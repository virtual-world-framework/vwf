<!DOCTYPE html>

<html>

  <head>

    <title>Virtual World Framework</title>

    <script type="text/javascript" src="qunit.js"></script>

    <script type="text/javascript" src="../lib/jquery-1.7.1.js"></script>
    <script type="text/javascript" src="../lib/async.js"></script>

    <script type="text/javascript" src="../lib/crypto.js"></script>
    <script type="text/javascript" src="../lib/md5.js"></script>

    <script type="text/javascript" src="../lib/alea.js"></script>
    <script type="text/javascript" src="../lib/mash.js"></script>

    <script type="text/javascript" src="../lib/vwf.js"></script>

    <script type="text/javascript" src="../lib/require.js"></script>

    <script type="text/javascript">

      require( {

        baseUrl: "../lib"

      }, [

        "domReady",
        "utility.js",

        "vwf/configuration",
        "vwf/kernel/model",
        "vwf/model/javascript",
        "vwf/model/object",
        "vwf/model/stage/log",
        "vwf/kernel/view",
        "vwf/view/document",
        "vwf/utility",
        "logger",

      ], function( ready, testUtility, configuration ) {

        // Test node replication.

        ready( function() {

          vwf.initialize(

            // Models

            [
              "vwf/model/javascript", 
              /* scriptModel */         // scriptModel will go here
              /* sceneModel */          // sceneModel will go here
              "vwf/model/object",
            ],

            // Views

            [
              "vwf/view/document"
            ]

          );

          // Insert the test-specific `scriptModel` and `sceneModel` drivers.
          // 
          // These drivers implement a specific set of properties for testing propagation and change
          // flags for properties delegated to other properties and properties handled by drivers
          // above the default model/object property store.
          // 
          //   - ps is a value property handled by model/test/scene
          //   - po is a value property handled by model/object
          //   - qs delegates as a string value to qs handled by model/test/scene
          //   - qo delegates as a string value to qo handled by model/object
          //   - rs/ro delegate to ss/so which delegate to ts/to in model/test/script
          //   - us/uo delegate to vs/vo which delegate back to us/uo in model/test/script
          // 
          //         ▾    ▾    ▾    ▾    ▾    ▾    ▾    ▾    ▾    ▾    ▾    ▾    ▾    ▾    
          // script: ▾    qs   rs ▸ ss ▸ ▾    us ▸ vs   ▾    qo   ro ▸ so ▸ ▾    uo ▸ vo   
          //         ▾    ▾    ◦    ◦    ▾    ◦  ◺ ◦    ▾    ▾    ◦    ◦    ▾    ◦  ◺ ◦    
          //  scene: ps   qs   ◦    ◦    ts   us   ◦    ▾    ▾    ◦    ◦    ▾    ▾    ◦    
          //         ◦    ◦    ◦    ◦    ◦    ◦    ◦    ▾    ▾    ◦    ◦    ▾    ▾    ◦    
          // object: ◦    ◦    ◦    ◦    ◦    ◦    ◦    po   qo   ◦    ◦    to   uo   ◦    
          // 
          // Key: ▾ ▸ : propagation path; ◦ : should not reach

          vwf.models.splice( 1, 0,
            scriptModel().create( vwf.models.kernel, [], {}, [] ),
            sceneModel().create( vwf.models.kernel, [], {}, [] )
          );

          // URI component to be used as a prototype. The state of a URI component can be expressed
          // as a patch to the URI's descriptor.

          var prototype = {

            // The descriptor, and a data URI referencing it.

            uri: testUtility.dataURIFromDescriptor( {
              properties: {
                p: { // numbers externally, strings internally
                  set: "this.p = value.toString()", // number to string
                  get: "return parseInt( this.p )", // string to number
                },
              }
            } ),

            // ID of the constructed component.

            id: undefined, // fill in once created

            // Function to apply a change.

            change: function( state ) {
              vwf.execute( this.id, "this.p = " + state );
            },

            // Function to calculate the expected getNode() state after a given change.

            state: function( state ) {
              if ( state ) { // modified state
                return {
                  patches: this.uri, // patches the component
                  properties: {
                    p: state.toString(), // property "p" changed
                  },
                };
              } else { // default state
                return this.uri; // component (no changes)
              }
            },

          };

          asyncTest( "URI component", function() {

            vwf.createNode( prototype.uri, function( id ) {
              prototype.id = id;

              deepEqual( vwf.getNode( id ), prototype.state(), "unmodified prototype is prototype URI" );

              prototype.change( 1 );
              deepEqual( vwf.getNode( id ), prototype.state( 1 ), "modified prototype is patched with changes" );

              prototype.change( 2 );
              deepEqual( vwf.getNode( id ), prototype.state( 2 ), "prototype modified again" );

              vwf.setNode( id, prototype.state( 1 ), function( id ) {

                deepEqual( vwf.getNode( id ), prototype.state( 1 ), "modified prototype restored" );

                // vwf.setNode( id, prototype.state() );  TODO: support property deletes
                // deepEqual( vwf.getNode( id ), prototype.state(), "unmodified prototype restored" );

                var state1 = prototype.state( 1 );

                vwf.deleteNode( id );

                vwf.createNode( state1, function( id ) {
                  prototype.id = id;

                  deepEqual( vwf.getNode( id ), state1, "modified prototype regenerated" );

                  vwf.deleteNode( id );

                  start();

                } );

              } );

            } );

          } );

          // Descriptor component deriving from the prototype. The state of a descriptor component
          // must be fully specified since there is no underlying URI to patch.

          var node = {

            // The descriptor.

            descriptor: {
              extends: prototype.uri,
            },

            // ID of the constructed component.

            id: undefined, // fill in once created

            // Function to apply a change.

            change: function( state ) {
              vwf.execute( this.id, "this.p = " + state );
            },

            // Function to calculate the expected getNode() state after a given change.

            state: function( state ) {
              if ( state ) { // modified state
                return {
                  id: this.id,
                  extends: prototype.uri,
                  sequence: 0,
                  random: randomState( undefined, this.id ),
                  properties: {
                    p: state.toString(), // property "p" from prototype set in node
                  },
                };
              } else { // default state
                return {
                  id: this.id,
                  extends: prototype.uri,
                  sequence: 0,
                  random: randomState( undefined, this.id ),
                };
              }
            },

          };

          asyncTest( "Descriptor component deriving from URI component", function() {

            vwf.createNode( node.descriptor, function( id ) {
              node.id = id;

              deepEqual( vwf.getNode( id ), node.state(), "unmodified node" );

              node.change( 1 );
              deepEqual( vwf.getNode( id ), node.state( 1 ), "modified node shows changes" );

              node.change( 2 );
              deepEqual( vwf.getNode( id ), node.state( 2 ), "node modified again" );

              vwf.setNode( id, node.state( 1 ), function( id ) {

                deepEqual( vwf.getNode( id ), node.state( 1 ), "modified node restored" );

                // vwf.setNode( id, node.state() );  TODO: support property deletes
                // deepEqual( vwf.getNode( id ), node.state(), "unmodified node restored" );

                var state1 = node.state( 1 );

                vwf.deleteNode( vwf.prototype( id ) );
                vwf.deleteNode( id );

                vwf.createNode( state1, function( id ) {
                  node.id = id;

                  deepEqual( vwf.getNode( id ), state1, "modified node regenerated" );

                  vwf.deleteNode( vwf.prototype( id ) );
                  vwf.deleteNode( id );

                  start();

                } );

              } );

            } );

          } );

          // URI component with a child.

          var prototypeWithChild = {

            // The descriptor, and a data URI referencing it.

            uri: testUtility.dataURIFromDescriptor( {
              properties: {
                p: {
                  set: "this.p = value.toString()",
                  get: "return parseInt( this.p )",
                },
              },
              children: {
                c: {
                  properties: {
                    p: null,
                  },
                },
              },
            } ),

            // ID of the constructed component.

            id: undefined, // fill in once created

            // Function to apply a change.

            change: function( state ) {
              vwf.execute( this.id, "this.c.p = " + state );
            },

            // Function to calculate the expected getNode() state after a given change.

            state: function( state ) {
              if ( state ) {
                return { // modified state
                  patches: this.uri,
                  children: {
                    c: {
                      patches: vwf.execute( this.id, "this.c.id" ),
                      properties: {
                        p: state,
                      },
                    },
                  },
                };
              } else { // default state
                return this.uri;
              }
            },

          };

          asyncTest( "URI component with child", function() {

            vwf.createNode( prototypeWithChild.uri, function( id ) {
              prototypeWithChild.id = id;

              deepEqual( vwf.getNode( id ), prototypeWithChild.state(), "unmodified prototype is prototype URI" );

              prototypeWithChild.change( 1 );
              deepEqual( vwf.getNode( id ), prototypeWithChild.state( 1 ), "modified prototype is patched with changes" );

              prototypeWithChild.change( 2 );
              deepEqual( vwf.getNode( id ), prototypeWithChild.state( 2 ), "prototype modified again" );

              vwf.setNode( id, prototypeWithChild.state( 1 ), function( id ) {

                deepEqual( vwf.getNode( id ), prototypeWithChild.state( 1 ), "modified prototype restored" );

                // vwf.setNode( id, prototypeWithChild.state() );  TODO: support property deletes
                // deepEqual( vwf.getNode( id ), prototypeWithChild.state(), "unmodified prototype restored" );

                var state1 = prototypeWithChild.state( 1 );

                vwf.deleteNode( vwf.execute( id, "this.c.id" ) );
                vwf.deleteNode( id );

                vwf.createNode( state1, function( id ) {
                  prototypeWithChild.id = id;

                  deepEqual( vwf.getNode( id ), state1, "modified prototype regenerated" );

                  vwf.deleteNode( vwf.execute( id, "this.c.id" ) );
                  vwf.deleteNode( id );

                  start();

                } );

              } );

            } );

          } );

          // URI component that creates a child in its initializer.

          var prototypeWithInitializerChild = {

            // The descriptor, and a data URI referencing it.

            uri: testUtility.dataURIFromDescriptor( {
              scripts: [
                "this.initialize = function() { " +
                  "this.children.create( 'c', { " +
                    "properties: { " +
                      "p: null, " +
                    "}, " +
                  "} ); " +
                "}"
              ]
            } ),

            // ID of the constructed component.

            id: undefined, // fill in once created

            // Function to apply a change.

            change: function( state ) {
              vwf.execute( this.id, "this.c.p = " + state );
            },

            // Function to calculate the expected getNode() state after a given change.

            state: function( state ) {
              if ( state ) {
                return { // modified state
                  patches: this.uri,
                  children: {
                    c: {
                      patches: vwf.execute( this.id, "this.c.id" ),
                      properties: {
                        p: state,
                      },
                    },
                  },
                };
              } else { // default state
                return this.uri;
              }

            },

          };

          asyncTest( "URI component with initializer child", function() {

            vwf.createNode( prototypeWithInitializerChild.uri, function( id ) {
              prototypeWithInitializerChild.id = id;

              deepEqual( vwf.getNode( id ), prototypeWithInitializerChild.state(), "unmodified prototype is prototype URI" );

              prototypeWithInitializerChild.change( 1 );
              deepEqual( vwf.getNode( id ), prototypeWithInitializerChild.state( 1 ), "modified prototype is patched with changes" );

              prototypeWithInitializerChild.change( 2 );
              deepEqual( vwf.getNode( id ), prototypeWithInitializerChild.state( 2 ), "prototype modified again" );

              vwf.setNode( id, prototypeWithInitializerChild.state( 1 ), function( id ) {

                deepEqual( vwf.getNode( id ), prototypeWithInitializerChild.state( 1 ), "modified prototype restored" );

                // vwf.setNode( id, prototypeWithInitializerChild.state() );  TODO: support property deletes
                // deepEqual( vwf.getNode( id ), prototypeWithInitializerChild.state(), "unmodified prototype restored" );

                var state1 = prototypeWithInitializerChild.state( 1 );

                vwf.deleteNode( vwf.execute( id, "this.c.id" ) );
                vwf.deleteNode( id );

                vwf.createNode( state1, function( id ) {
                  prototypeWithInitializerChild.id = id;

                  deepEqual( vwf.getNode( id ), state1, "modified prototype regenerated" );

                  vwf.deleteNode( vwf.execute( id, "this.c.id" ) );
                  vwf.deleteNode( id );

                  start();

                } );

              } );

            } );

          } );

          // Descriptor component deriving from a URI component that creates a child in its
          // initializer.

          var nodeWithPrototypeInitializerChild = {

            // The descriptor, and a data URI referencing it.

            descriptor: {
              extends: prototypeWithInitializerChild.uri,
            },

            // ID of the constructed component.

            id: undefined, // fill in once created

            // Function to apply a change.

            change: function( state ) {
              vwf.execute( this.id, "this.c.p = " + state );
            },

            // Function to calculate the expected getNode() state after a given change.

            state: function( state ) {

              var childID = vwf.execute( this.id, "this.c.id" );

              var nodeRandomState = randomState( undefined, this.id );
              var childRandomState = randomState( nodeRandomState, childID );

              return {
                id: this.id,
                extends: prototypeWithInitializerChild.uri,
                sequence: 1, // one child
                random: nodeRandomState,
                children: {
                  c: { // child always fully specified since createNode() outside of initialize()
                    id: childID,
                    sequence: 0,
                    random: childRandomState,
                    properties: {
                      p: state ? state : null,
                    },
                  },
                },
              };

            },

          };

          asyncTest( "Descriptor component deriving from URI component with initializer child", function() {

            vwf.createNode( nodeWithPrototypeInitializerChild.descriptor, function( id ) {
              nodeWithPrototypeInitializerChild.id = id;

              deepEqual( vwf.getNode( id ), nodeWithPrototypeInitializerChild.state(), "unmodified node" );

              nodeWithPrototypeInitializerChild.change( 1 );
              deepEqual( vwf.getNode( id ), nodeWithPrototypeInitializerChild.state( 1 ), "modified node" );

              nodeWithPrototypeInitializerChild.change( 2 );
              deepEqual( vwf.getNode( id ), nodeWithPrototypeInitializerChild.state( 2 ), "node modified again" );

              vwf.setNode( id, nodeWithPrototypeInitializerChild.state( 1 ), function( id ) {

                deepEqual( vwf.getNode( id ), nodeWithPrototypeInitializerChild.state( 1 ), "modified node restored" );

                vwf.setNode( id, nodeWithPrototypeInitializerChild.state(), function( id ) {

                  deepEqual( vwf.getNode( id ), nodeWithPrototypeInitializerChild.state(), "unmodified node restored" );

                  var state1 = nodeWithPrototypeInitializerChild.state( 1 );

                  vwf.deleteNode( vwf.execute( vwf.prototype( id ), "this.c.id" ) );
                  vwf.deleteNode( vwf.prototype( id ) );

                  vwf.deleteNode( vwf.execute( id, "this.c.id" ) );
                  vwf.deleteNode( id );

                  vwf.createNode( state1, function( id ) {
                    nodeWithPrototypeInitializerChild.id = id;

                    deepEqual( vwf.getNode( id ), state1, "modified node regenerated" );

                    vwf.deleteNode( vwf.execute( vwf.prototype( id ), "this.c.id" ) );
                    vwf.deleteNode( vwf.prototype( id ) );

                    vwf.deleteNode( vwf.execute( id, "this.c.id" ) );
                    vwf.deleteNode( id );

                    start();

                  } );

                } );

              } );

            } );

          } );

          // Change flags for properties handled by model/object and by a driver above model/object.

          asyncTest( "Property changes", function() {

            vwf.createNode( testUtility.dataURIFromDescriptor( {

              children: {

                alpha: {
                  properties: {
                    po: 0,
                    ps: 0,
                  }
                },

                beta: {
                  properties: {
                    po: 0,
                    ps: 0,
                  }
                },

              }

            } ), function( id ) {

              // Change the properties.

              vwf.execute( id, "this.alpha.po = 1" ); // handled by model/object; should mark alpha changed
              vwf.execute( id, "this.beta.ps = 1" );  // handled by model/test/scene; should mark beta changed

              // Verify the children and property changes are present in the replication state.

              deepEqual( vwf.getNode( id ), {
                patches: id,
                children: {
                  alpha: {
                    patches: vwf.execute( id, "this.alpha.id" ),
                    properties: {
                      po: 1,
                    }
                  },
                  beta: {
                    patches: vwf.execute( id, "this.beta.id" ),
                    properties: {
                      ps: 1,
                    }
                  },
              } }, "property changes handled by model/object and by model/test/scene detected" );

              // Clean up and continue.

              vwf.deleteNode( id );

              start();

            } );

          } );

          // == Helper functions ===================================================================

          // A driver representing a script engine. No values are stored here, but some properties
          // delegate to other properties.

          function scriptModel() {

            return require( "vwf/model" ).load( { id: "vwf/model/test/script" }, {

              creatingProperty: function( nodeID, propertyName, propertyValue ) {

                if ( propertyValue !== undefined ) {
                  return this.settingProperty( nodeID, propertyName, propertyValue );
                }

              },

              initializingProperty: function( nodeID, propertyName, propertyValue ) {

                if ( propertyValue !== undefined ) {
                  return this.settingProperty( nodeID, propertyName, propertyValue );
                }

              },

              settingProperty: function( nodeID, propertyName, propertyValue ) {

                switch ( propertyName ) {

                  case "qo": this.kernel.setProperty( nodeID, "qo", propertyValue.toString() ); return propertyValue;
                  case "qs": this.kernel.setProperty( nodeID, "qs", propertyValue.toString() ); return propertyValue;

                  case "ro": this.kernel.setProperty( nodeID, "so", propertyValue - 1 ); return propertyValue;
                  case "rs": this.kernel.setProperty( nodeID, "ss", propertyValue - 1 ); return propertyValue;

                  case "so": this.kernel.setProperty( nodeID, "to", propertyValue.toString() ); return propertyValue;
                  case "ss": this.kernel.setProperty( nodeID, "ts", propertyValue.toString() ); return propertyValue;

                  case "uo": this.kernel.setProperty( nodeID, "vo", propertyValue - 1 ); return propertyValue;
                  case "us": this.kernel.setProperty( nodeID, "vs", propertyValue - 1 ); return propertyValue;

                  case "vo": this.kernel.setProperty( nodeID, "uo", propertyValue.toString() ); return propertyValue;
                  case "vs": this.kernel.setProperty( nodeID, "us", propertyValue.toString() ); return propertyValue;

                }

              },

              gettingProperty: function( nodeID, propertyName, propertyValue ) {

                switch ( propertyName ) {

                  case "qo": return parseInt( this.kernel.getProperty( nodeID, "qo" ) );
                  case "qs": return parseInt( this.kernel.getProperty( nodeID, "qs" ) );

                  case "ro": return this.kernel.getProperty( nodeID, "so" ) + 1;
                  case "rs": return this.kernel.getProperty( nodeID, "ss" ) + 1;

                  case "so": return parseInt( this.kernel.getProperty( nodeID, "to" ) );
                  case "ss": return parseInt( this.kernel.getProperty( nodeID, "ts" ) );

                  case "uo": return this.kernel.getProperty( nodeID, "vo" ) + 1;
                  case "us": return this.kernel.getProperty( nodeID, "vs" ) + 1;

                  case "vo": return parseInt( this.kernel.getProperty( nodeID, "uo" ) );
                  case "vs": return parseInt( this.kernel.getProperty( nodeID, "us" ) );

                }

              },

            } );

          }

          // A driver representing a scene manager or other engine that stores some properties.
          // Properties handled here won't reach the model/object driver.

          function sceneModel() {

            return require( "vwf/model" ).load( { id: "vwf/model/test/scene" }, {

              creatingProperty: function( nodeID, propertyName, propertyValue ) {
                  return this.initializingProperty( nodeID, propertyName, propertyValue );
              },

              initializingProperty: function( nodeID, propertyName, propertyValue ) {
                  return this.settingProperty( nodeID, propertyName, propertyValue );
              },

              settingProperty: function( nodeID, propertyName, propertyValue ) {

                switch ( propertyName ) {

                  case "ps": case "qs": case "ts": case "us":
                    return this.state[ nodeID + '-' + propertyName ] = propertyValue;

                }

              },

              gettingProperty: function( nodeID, propertyName, propertyValue ) {

                switch ( propertyName ) {

                  case "ps": case "qs": case "ts": case "us":
                    return this.state[ nodeID + '-' + propertyName ];

                }

              },

            } );

          }

          // Generate the random state object given a parent's state and a node ID. If the node
          // doesn't have a parent, use the global random seed. This mimics the prng initialization
          // in model/object#creatingNode.

          function randomState( parentState, childID ) {

            return new Alea(
              parentState ? JSON.stringify( parentState ) : configuration.active["random-seed"],
              childID
            ).state;

          }

        } );

      } );

    </script>

    <link rel="stylesheet" type="text/css" href="qunit.css" />

  </head>

  <body>

    <h1 id="qunit-header">Virtual World Framework</h1>
    <h2 id="qunit-banner"></h2>
    <div id="qunit-testrunner-toolbar"></div>
    <h2 id="qunit-userAgent"></h2>
    <ol id="qunit-tests"></ol>

    <div id="qunit-fixture">test markup, will be hidden</div>

  </body>

</html>
