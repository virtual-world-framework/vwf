(function () {
/**
 * almond 0.0.3 Copyright (c) 2011, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
/*jslint strict: false, plusplus: false */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {

    var defined = {},
        waiting = {},
        aps = [].slice,
        main, req;

    if (typeof define === "function") {
        //If a define is already in play via another AMD loader,
        //do not overwrite.
        return;
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that "directory" and not name of the baseName's
                //module. For instance, baseName of "one/two/three", maps to
                //"one/two/three.js", but we want the directory, "one/two" for
                //this normalization.
                baseName = baseName.split("/");
                baseName = baseName.slice(0, baseName.length - 1);

                name = baseName.concat(name.split("/"));

                //start trimDots
                var i, part;
                for (i = 0; (part = name[i]); i++) {
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            }
        }
        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (waiting.hasOwnProperty(name)) {
            var args = waiting[name];
            delete waiting[name];
            main.apply(undef, args);
        }
        return defined[name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    function makeMap(name, relName) {
        var prefix, plugin,
            index = name.indexOf('!');

        if (index !== -1) {
            prefix = normalize(name.slice(0, index), relName);
            name = name.slice(index + 1);
            plugin = callDep(prefix);

            //Normalize according
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            p: plugin
        };
    }

    main = function (name, deps, callback, relName) {
        var args = [],
            usingExports,
            cjsModule, depName, i, ret, map;

        //Use name if no relName
        if (!relName) {
            relName = name;
        }

        //Call the callback to define the module, if necessary.
        if (typeof callback === 'function') {

            //Default to require, exports, module if no deps if
            //the factory arg has any arguments specified.
            if (!deps.length && callback.length) {
                deps = ['require', 'exports', 'module'];
            }

            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            for (i = 0; i < deps.length; i++) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = makeRequire(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = defined[name] = {};
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = {
                        id: name,
                        uri: '',
                        exports: defined[name]
                    };
                } else if (defined.hasOwnProperty(depName) || waiting.hasOwnProperty(depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw name + ' missing ' + depName;
                }
            }

            ret = callback.apply(defined[name], args);

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef) {
                    defined[name] = cjsModule.exports;
                } else if (!usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = req = function (deps, callback, relName, forceSync) {
        if (typeof deps === "string") {

            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            //Drop the config stuff on the ground.
            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = arguments[2];
            } else {
                deps = [];
            }
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 15);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function () {
        return req;
    };

    /**
     * Export require as a global, but only if it does not already exist.
     */
    if (!require) {
        require = req;
    }

    define = function (name, deps, callback) {

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (define.unordered) {
            waiting[name] = [name, deps, callback];
        } else {
            main(name, deps, callback);
        }
    };

    define.amd = {
        jQuery: true
    };
}());

define("../../ThirdParty/almond.js", function(){});

/*global define*/
define('Core/Cartesian2',[],function() {
    

    /**
     * A 2D Cartesian point.
     * <br/>
     * If either <code>x</code> or <code>y</code> is undefined, then the corresponding
     * component will be initialized to 0.0.
     *
     * @name Cartesian2
     * @constructor
     *
     * @param {Number} x The x-coordinate for the Cartesian type.
     * @param {Number} y The y-coordinate for the Cartesian type.
     *
     * @see Cartesian3
     * @see Cartesian4
     */
      function Cartesian2(x, y) {

        /**
         * DOC_TBA
         *
         * @type Number
         *
         * @see Cartesian2.y
         */
        this.x = (typeof x !== "undefined") ? x : 0.0;

        /**
         * DOC_TBA
         *
         * @type Number
         *
         * @see Cartesian2.x
         */
        this.y = (typeof y !== "undefined") ? y : 0.0;
    }

    /**
     * Returns a duplicate of a Cartesian2.
     *
     * @param {Cartesian2} cartesian The cartesian to clone.
     * @return {Cartesian2} A new Cartesian2 instance.
     */
    Cartesian2.clone = function(cartesian) {
        return new Cartesian2(cartesian.x, cartesian.y);
    };

    /**
     * Creates a Cartesian2 instance initialized to (0, 0).
     *
     * @memberof Cartesian2
     * @return {Cartesian2} A new Cartesian2 instance.
     */
    Cartesian2.getZero = function() {
        return new Cartesian2(0, 0);
    };

    /**
     * Creates a Cartesian2 instance initialized to (1, 0).
     *
     * @memberof Cartesian2
     * @return {Cartesian2} A new Cartesian2 instance.
     */
    Cartesian2.getUnitX = function() {
        return new Cartesian2(1, 0);
    };

    /**
     * Creates a Cartesian2 instance initialized to (0, 1).
     *
     * @memberof Cartesian2
     * @return {Cartesian2} A new Cartesian2 instance.
     */
    Cartesian2.getUnitY = function() {
        return new Cartesian2(0, 1);
    };

    /**
     * Returns the Cartesian's squared magnitude (length).
     *
     * @memberof Cartesian2
     * @return {Number} The squared magnitude.
     */
    Cartesian2.prototype.magnitudeSquared = function() {
        return this.x * this.x + this.y * this.y;
    };

    /**
     * Returns the Cartesian's magnitude (length).
     *
     * @memberof Cartesian2
     * @return {Number} The magnitude.
     */
    Cartesian2.prototype.magnitude = function() {
        return Math.sqrt(this.magnitudeSquared());
    };

    /**
     * Returns this Cartesian normalized.
     *
     * @memberof Cartesian2
     * @return {Cartesian2} The normalized Cartesian.
     */
    Cartesian2.prototype.normalize = function() {
        var magnitude = this.magnitude();
        return new Cartesian2(this.x / magnitude, this.y / magnitude);
    };

    /**
     * Returns the dot (scalar) product of two Cartesians.
     *
     * @memberof Cartesian2
     * @param {Cartesian2} other The Cartesian to dot with this.
     * @return {Number} The dot product.
     */
    Cartesian2.prototype.dot = function(other) {
        return this.x * other.x + this.y * other.y;
    };

    /**
     * Returns the componentwise sum of two Cartesians.
     *
     * @memberof Cartesian2
     * @param {Cartesian2} other The Cartesian to sum with this.
     * @return {Cartesian2} The sum of this and other.
     */
    Cartesian2.prototype.add = function(other) {
        return new Cartesian2(this.x + other.x, this.y + other.y);
    };

    /**
     * Returns the componentwise difference of two Cartesians.
     *
     * @memberof Cartesian2
     * @param {Cartesian2} other The Cartesian to subtract from this.
     * @return {Cartesian2} The difference of this and other.
     */
    Cartesian2.prototype.subtract = function(other) {
        return new Cartesian2(this.x - other.x, this.y - other.y);
    };

    /**
     * Returns this Cartesian scaled by a scalar.
     *
     * @memberof Cartesian2
     * @param {Number} scalar The scalar that is multiplied with this.
     * @return {Cartesian2} The scaled Cartesian.
     */
    Cartesian2.prototype.multiplyWithScalar = function(scalar) {
        return new Cartesian2(this.x * scalar, this.y * scalar);
    };

    /**
     * Returns this Cartesian divided by a scalar.
     *
     * @memberof Cartesian2
     * @param {Number} scalar The scalar to use for division.
     * @return {Cartesian2} This Cartesian after division.
     */
    Cartesian2.prototype.divideByScalar = function(scalar) {
        return new Cartesian2(this.x / scalar, this.y / scalar);
    };

    /**
     * Returns this Cartesian negated.
     *
     * @memberof Cartesian2
     * @return {Cartesian2} This Cartesian negated.
     */
    Cartesian2.prototype.negate = function() {
        return new Cartesian2(-this.x, -this.y);
    };

    /**
     * Returns a version of this Cartesian containing the absolute value of each component.
     *
     * @memberof Cartesian2
     * @return {Cartesian2} The absolute value of this Cartesian.
     */
    Cartesian2.prototype.abs = function() {
        return new Cartesian2(Math.abs(this.x), Math.abs(this.y));
    };

    /**
     * Returns a duplicate of a Cartesian2 instance.
     *
     * @memberof Cartesian2
     * @return {Cartesian2} A new copy of the Cartesian2 instance received as an argument.
     */
    Cartesian2.prototype.clone = function() {
        return new Cartesian2(this.x, this.y);
    };

    /**
     * Returns true if this Cartesian equals <code>other</code> componentwise.
     *
     * @memberof Cartesian2
     * @param {Cartesian2} other The Cartesian to compare for equality.
     * @return {Boolean} <code>true</code> if the Cartesians are equal componentwise; otherwise, <code>false</code>.
     */
    Cartesian2.prototype.equals = function(other) {
        return (this.x === other.x) && (this.y === other.y);
    };

    /**
     * Returns <code>true</code> if this Cartesian equals other componentwise
     * within the specified epsilon.
     *
     * @memberof Cartesian2
     *
     * @param {Cartesian2} other The Cartesian to compare for equality.
     * @param {Number} [epsilon=0.0] The epsilon to use for equality testing.
     *
     * @return {Boolean} <code>true</code> if the Cartesians are equal within the specified epsilon; otherwise, <code>false</code>.
     */
    Cartesian2.prototype.equalsEpsilon = function(other, epsilon) {
        epsilon = epsilon || 0.0;
        return (Math.abs(this.x - other.x) <= epsilon) && (Math.abs(this.y - other.y) <= epsilon);
    };

    /**
     * Returns a string representing this instance in the format (x, y).
     *
     * @memberof Cartesian2
     * @return {String} A string representing this instance.
     */
    Cartesian2.prototype.toString = function() {
        return "(" + this.x + ", " + this.y + ")";
    };

    return Cartesian2;
});

/*global define*/
define('Core/Cartesian3',['./Cartesian2'], function(Cartesian2) {
    

    /**
     * A 3D Cartesian point.
     * <br/>
     * If either <code>x</code>, <code>y</code>, or <code>z</code> is undefined, then the corresponding
     * component will be initialized to 0.0.
     *
     * @name Cartesian3
     * @constructor
     *
     * @param {Number} x The x-coordinate for the Cartesian type.
     * @param {Number} y The y-coordinate for the Cartesian type.
     * @param {Number} z The z-coordinate for the Cartesian type.
     *
     * @see Cartesian2
     * @see Cartesian4
     */
    function Cartesian3(x, y, z) {
       /**
         * DOC_TBA
         *
         * @type Number
         *
         * @see Cartesian3.y
         * @see Cartesian3.z
         */
        this.x = (typeof x !== "undefined") ? x : 0.0;

        /**
         * DOC_TBA
         *
         * @type Number
         *
         * @see Cartesian3.x
         * @see Cartesian3.z
         */
        this.y = (typeof y !== "undefined") ? y : 0.0;

        /**
         * DOC_TBA
         *
         * @type Number
         *
         * @see Cartesian3.x
         * @see Cartesian3.y
         */
        this.z = (typeof z !== "undefined") ? z : 0.0;
    }

    /**
     * Returns a duplicate of a Cartesian3.
     *
     * @param {Cartesian3} cartesian The cartesian to clone.
     * @return {Cartesian3} A new Cartesian3 instance.
     */
    Cartesian3.clone = function(cartesian) {
        return new Cartesian3(cartesian.x, cartesian.y, cartesian.z);
    };

    /**
     * Creates a Cartesian3 instance initialized to (0, 0, 0).
     *
     * @memberof Cartesian3
     * @return {Cartesian3} A new Cartesian3 instance.
     */
    Cartesian3.getZero = function() {
        return new Cartesian3(0, 0, 0);
    };

    /**
     * Creates a Cartesian3 instance initialized to (1, 0, 0).
     *
     * @memberof Cartesian3v
     * @return {Cartesian3} A new Cartesian3 instance.
     */
    Cartesian3.getUnitX = function() {
        return new Cartesian3(1, 0, 0);
    };

    /**
     * Creates a Cartesian3 instance initialized to (0, 1, 0).
     *
     * @memberof Cartesian3
     * @return {Cartesian3} A new Cartesian3 instance.
     */
    Cartesian3.getUnitY = function() {
        return new Cartesian3(0, 1, 0);
    };

    /**
     * Creates a Cartesian3 instance initialized to (0, 0, 1).
     *
     * @memberof Cartesian3
     * @return {Cartesian3} A new Cartesian3 instance.
     */
    Cartesian3.getUnitZ = function() {
        return new Cartesian3(0, 0, 1);
    };

    /**
     * Returns a new array, where each {@link Cartesian3}
     * element is flattened, that is, replaced with separate x, y,
     * and z elements.
     *
     * @memberof Cartesian3
     *
     * @param {Array} positions The array of Cartesian points to flatten.
     *
     * @return {Array} The flattened array.
     */
    Cartesian3.flatten = function(positions) {
        var flat = [];
        for ( var i = 0; i < positions.length; ++i) {
            flat.push(positions[i].x);
            flat.push(positions[i].y);
            flat.push(positions[i].z);
        }

        return flat;
    };

    /**
     * Returns the Cartesian's x and y components as a Cartesian2.
     *
     * @memberof Cartesian3
     * @return {Cartesian2} The Cartesian's x and y components.
     * @see Cartesian2
     */
    Cartesian3.prototype.getXY = function() {
        return new Cartesian2(this.x, this.y);
    };

    /**
     * Returns the Cartesian's squared magnitude (length).
     *
     * @memberof Cartesian3
     * @return {Number} The squared magnitude.
     */
    Cartesian3.prototype.magnitudeSquared = function() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
    };

    /**
     * Returns the Cartesian's magnitude (length).
     *
     * @memberof Cartesian3
     * @return {Number} The magnitude.
     */
    Cartesian3.prototype.magnitude = function() {
        return Math.sqrt(this.magnitudeSquared());
    };

    /**
     * Returns this Cartesian normalized.
     *
     * @memberof Cartesian3
     * @return {Cartesian3} The normalized Cartesian.
     */
    Cartesian3.prototype.normalize = function() {
        var magnitude = this.magnitude();
        return new Cartesian3(this.x / magnitude, this.y / magnitude, this.z / magnitude);
    };

    /**
     * Returns the cross (outer) product of two Cartesians.
     *
     * <p>
     * v.cross(u) is v x u.
     * </p>
     *
     * @memberof Cartesian3
     * @param {Cartesian3} other The Cartesian to cross with this.
     * @return {Cartesian3} The cross product.
     */
    Cartesian3.prototype.cross = function(other) {
        return new Cartesian3(
                this.y * other.z - this.z * other.y,
                this.z * other.x - this.x * other.z,
                this.x * other.y - this.y * other.x);
    };

    /**
     * Returns the dot (scalar) product of two Cartesians.
     *
     * @memberof Cartesian3
     * @param {Cartesian3} other The Cartesian to dot with this.
     * @return {Number} The dot product.
     */
    Cartesian3.prototype.dot = function(other) {
        return this.x * other.x + this.y * other.y + this.z * other.z;
    };

    /**
     * Returns the componentwise sum of two Cartesians.
     *
     * @memberof Cartesian3
     * @param {Cartesian3} other The Cartesian to sum with this.
     * @return {Cartesian3} The sum of this and other.
     */
    Cartesian3.prototype.add = function(other) {
        return new Cartesian3(this.x + other.x, this.y + other.y, this.z + other.z);
    };

    /**
     * Returns the componentwise difference of two Cartesians.
     *
     * @memberof Cartesian3
     * @param {Cartesian3} other The Cartesian to subtract from this.
     * @return {Cartesian3} The difference of this and other.
     */
    Cartesian3.prototype.subtract = function(other) {
        return new Cartesian3(this.x - other.x, this.y - other.y, this.z - other.z);
    };

    /**
     * Returns this Cartesian scaled by a scalar.
     *
     * @memberof Cartesian3
     * @param {Number} scalar The scalar that is multiplied with this.
     * @return {Cartesian3} The scaled Cartesian.
     */
    Cartesian3.prototype.multiplyWithScalar = function(scalar) {
        return new Cartesian3(this.x * scalar, this.y * scalar, this.z * scalar);
    };

    /**
     * Returns this Cartesian scaled by another Cartesian componentwise.
     *
     * @memberof Cartesian3
     * @param {Cartesian3} Cartesian The Cartesian that is multiplied with this componentwise.
     * @return {Cartesian3} The scaled Cartesian.
     */
    Cartesian3.prototype.multiplyComponents = function(Cartesian) {
        return new Cartesian3(this.x * Cartesian.x, this.y * Cartesian.y, this.z * Cartesian.z);
    };

    /**
     * Returns this Cartesian divided by a scalar.
     *
     * @memberof Cartesian3
     * @param {Number} scalar The scalar to use for division.
     * @return {Cartesian3} This Cartesian after division.
     */
    Cartesian3.prototype.divideByScalar = function(scalar) {
        return new Cartesian3(this.x / scalar, this.y / scalar, this.z / scalar);
    };

    /**
     * Returns the value of the maximum component.
     *
     * @memberof Cartesian3
     * @return {Number} The value of the maximum component.
     */
    Cartesian3.prototype.getMaximumComponent = function() {
        return Math.max(this.x, this.y, this.z);
    };

    /**
     * Returns the value of the minimum component.
     *
     * @memberof Cartesian3
     * @return {Number} The value of the minimum component.
     */
    Cartesian3.prototype.getMinimumComponent = function() {
        return Math.min(this.x, this.y, this.z);
    };

    /**
     * Returns a unit Cartesian representing the most orthogonal axis to this Cartesian.
     *
     * @memberof Cartesian3
     * @return {Cartesian3} The axis most orthogonal to this Cartesian.
     */
    Cartesian3.prototype.mostOrthogonalAxis = function() {
        var x = Math.abs(this.x);
        var y = Math.abs(this.y);
        var z = Math.abs(this.z);

        if ((x < y) && (x < z)) {
            return Cartesian3.getUnitX();
        } else if ((y < x) && (y < z)) {
            return Cartesian3.getUnitY();
        } else {
            return Cartesian3.getUnitZ();
        }
    };

    /**
     * Returns the angle, in radians, between this Cartesian and the Cartesian passed in.
     *
     * @memberof Cartesian3
     * @param {Cartesian3} scalar The Cartesian used to compute the angle.
     * @return {Number} The angle between the two Cartesians.
     */
    Cartesian3.prototype.angleBetween = function(Cartesian) {
        var c = Cartesian3.clone(Cartesian);
        return Math.acos(this.normalize().dot(c.normalize()));
    };

    /**
     * Rotates this Cartesian counterclockwise around around the specified axis by the specified degrees.
     *
     * @memberof Cartesian3
     * @param {Cartesian3} axis The axis to rotate around.
     * @param {Number} theta The angle, in radians, to rotate around.
     * @return {Cartesian3} The rotated Cartesian.
     */
    Cartesian3.prototype.rotateAroundAxis = function(axis, theta) {
        var x = this.x;
        var y = this.y;
        var z = this.z;

        var u = axis.x;
        var v = axis.y;
        var w = axis.z;

        var cosTheta = Math.cos(theta);
        var sinTheta = Math.sin(theta);

        var a = Cartesian3.clone(axis);
        var ms = a.magnitudeSquared();
        var m = Math.sqrt(ms);

        return new Cartesian3(
            ((u * (u * x + v * y + w * z)) +
            (((x * (v * v + w * w)) - (u * (v * y + w * z))) * cosTheta) +
            (m * ((-w * y) + (v * z)) * sinTheta)) / ms,

            ((v * (u * x + v * y + w * z)) +
            (((y * (u * u + w * w)) - (v * (u * x + w * z))) * cosTheta) +
            (m * ((w * x) - (u * z)) * sinTheta)) / ms,

            ((w * (u * x + v * y + w * z)) +
            (((z * (u * u + v * v)) - (w * (u * x + v * y))) * cosTheta) +
            (m * (-(v * x) + (u * y)) * sinTheta)) / ms);
    };

    /**
     * Returns this Cartesian negated.
     *
     * @memberof Cartesian3
     * @return {Cartesian3} This Cartesian negated.
     */
    Cartesian3.prototype.negate = function() {
        return new Cartesian3(-this.x, -this.y, -this.z);
    };

    /**
     * Returns a version of this Cartesian containing the absolute value of each component.
     *
     * @memberof Cartesian3
     * @return {Cartesian3} The absolute value of this Cartesian.
     */
    Cartesian3.prototype.abs = function() {
        return new Cartesian3(Math.abs(this.x), Math.abs(this.y), Math.abs(this.z));
    };

    /**
     * Returns the linear interpolation between this Cartesian and another Cartesian at value t.
     *
     * @memberof Cartesian3
     * @param {Cartesian} Cartesian The value to interpolate with this.
     * @param {Number} t A value in [0, 1] used to interpolate the two Cartesians.
     * @returns {Cartesian} The interpolated Cartesian at t.
     */
    Cartesian3.prototype.lerp = function(Cartesian, t) {
        var c = new Cartesian3(Cartesian.x, Cartesian.y, Cartesian.z);
        return this.multiplyWithScalar(1.0 - t).add(c.multiplyWithScalar(t));
    };

    /**
     * Returns a duplicate of a Cartesian3 instance.
     *
     * @memberof Cartesian3
     * @return {Cartesian3} A new copy of the Cartesian3 instance received as an argument.
     */
    Cartesian3.prototype.clone = function() {
        return new Cartesian3(this.x, this.y, this.z);
    };

    /**
     * Returns true if this Cartesian equals other componentwise.
     *
     * @memberof Cartesian3
     * @param {Cartesian3} other The Cartesian to compare for equality.
     * @return {Boolean} <code>true</code> if the Cartesians are equal componentwise; otherwise, <code>false</code>.
     */
    Cartesian3.prototype.equals = function(other) {
        return (this.x === other.x) && (this.y === other.y) && (this.z === other.z);
    };

    /**
     * Returns <code>true</code> if this Cartesian equals other componentwise within the specified epsilon.
     *
     * @memberof Cartesian3
     *
     * @param {Cartesian3} other The Cartesian to compare for equality.
     * @param {Number} [epsilon=0.0] The epsilon to use for equality testing.
     *
     * @return {Boolean} <code>true</code> if the Cartesians are equal within the specified epsilon; otherwise, <code>false</code>.
     */
    Cartesian3.prototype.equalsEpsilon = function(other, epsilon) {
        epsilon = epsilon || 0.0;
        return (Math.abs(this.x - other.x) <= epsilon) &&
               (Math.abs(this.y - other.y) <= epsilon) &&
               (Math.abs(this.z - other.z) <= epsilon);
    };

    /**
     * Returns a string representing this instance in the format (x, y, z).
     *
     * @memberof Cartesian3
     * @return {String} A string representing this instance.
     */
    Cartesian3.prototype.toString = function() {
        return "(" + this.x + ", " + this.y + ", " + this.z + ")";
    };

    return Cartesian3;
});

/*global define*/
define('Core/Cartesian4',[
        './Cartesian2',
        './Cartesian3'
    ], function(
        Cartesian2,
        Cartesian3) {
    

    /**
     * A 4D Cartesian point.
     * <p>
     * When called with no arguments, the Cartesian is initialized to (0, 0, 0, 0).
     * When called with one numeric argument, f, the Cartesian is initialized to (f, f, f, f).
     * When called with one Cartesian3 argument, v, and one numeric argument, w, the Cartesian is initialized to (v.x, v.y, v.z, w).
     * When called with one Cartesian2 argument, v, and two numeric arguments, z and w, the Cartesian is initialized to (v.x, v.y, z, w).
     * When called with four numeric arguments; x, y, z, and w; the Cartesian is initialized to (x, y, z, w).
     * </p>
     *
     * @name Cartesian4
     * @constructor
     *
     * @param {Number} x The x-coordinate for the Cartesian type.
     * @param {Number} y The y-coordinate for the Cartesian type.
     * @param {Number} z The z-coordinate for the Cartesian type.
     * @param {Number} w The w-coordinate for the Cartesian type.
     *
     * @see Cartesian2
     * @see Cartesian3
     */
    function Cartesian4(x, y, z, w) {

        /**
         * DOC_TBA
         *
         * @type Number
         *
         * @see Cartesian4.y
         * @see Cartesian4.z
         * @see Cartesian4.w
         */
        this.x = (typeof x !== "undefined") ? x : 0.0;

        /**
         * DOC_TBA
         *
         * @type Number
         *
         * @see Cartesian4.x
         * @see Cartesian4.z
         * @see Cartesian4.w
         */
        this.y = (typeof y !== "undefined") ? y : 0.0;

        /**
         * DOC_TBA
         *
         * @type Number
         *
         * @see Cartesian4.x
         * @see Cartesian4.y
         * @see Cartesian4.w
         */
        this.z = (typeof z !== "undefined") ? z : 0.0;

        /**
         * DOC_TBA
         *
         * @type Number
         *
         * @see Cartesian4.x
         * @see Cartesian4.y
         * @see Cartesian4.z
         */
        this.w = (typeof w !== "undefined") ? w : 0.0;
    }

    /**
     * Returns a duplicate of a Cartesian4.
     *
     * @param {Cartesian4} cartesian The cartesian to clone.
     * @return {Cartesian4} A new Cartesian4 instance.
     */
    Cartesian4.clone = function(cartesian) {
        return new Cartesian4(cartesian.x, cartesian.y, cartesian.z, cartesian.w);
    };

    /**
     * Creates a Cartesian4 instance initialized to (0, 0, 0, 0).
     *
     * @memberof Cartesian4
     * @return {Cartesian4} A new Cartesian4 instance.
     */
    Cartesian4.getZero = function() {
        return new Cartesian4(0, 0, 0, 0);
    };

    /**
     * Creates a Cartesian4 instance initialized to (1, 0, 0, 0).
     *
     * @memberof Cartesian4
     * @return {Cartesian4} A new Cartesian4 instance.
     */
    Cartesian4.getUnitX = function() {
        return new Cartesian4(1, 0, 0, 0);
    };

    /**
     * Creates a Cartesian4 instance initialized to (0, 1, 0, 0).
     *
     * @memberof Cartesian4
     * @return {Cartesian4} A new Cartesian4 instance.
     */
    Cartesian4.getUnitY = function() {
        return new Cartesian4(0, 1, 0, 0);
    };

    /**
     * Creates a Cartesian4 instance initialized to (0, 0, 1, 0).
     *
     * @memberof Cartesian4
     * @return {Cartesian4} A new Cartesian4 instance.
     */
    Cartesian4.getUnitZ = function() {
        return new Cartesian4(0, 0, 1, 0);
    };

    /**
     * Creates a Cartesian4 instance initialized to (0, 0, 0, 1).
     *
     * @memberof Cartesian4
     * @return {Cartesian4} A new Cartesian4 instance.
     */
    Cartesian4.getUnitW = function() {
        return new Cartesian4(0, 0, 0, 1);
    };

    /**
     * Returns the Cartesian's x and y components as a Cartesian2.
     *
     * @memberof Cartesian4
     * @return {Cartesian2} The Cartesian's x and y components.
     * @see Cartesian2
     */
    Cartesian4.prototype.getXY = function() {
        return new Cartesian2(this.x, this.y);
    };

    /**
     * Returns the Cartesian's x, y, and z components as a Cartesian3.
     *
     * @memberof Cartesian4
     * @return {Cartesian3} The Cartesian's x, y, and z components.
     * @see Cartesian2
     */
    Cartesian4.prototype.getXYZ = function() {
        return new Cartesian3(this.x, this.y, this.z);
    };

    /**
     * Returns the Cartesian's squared magnitude (length).
     *
     * @memberof Cartesian4
     * @return {Number} The squared magnitude.
     */
    Cartesian4.prototype.magnitudeSquared = function() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    };

    /**
     * Returns the Cartesian's magnitude (length).
     *
     * @memberof Cartesian4
     * @return {Number} The magnitude.
     */
    Cartesian4.prototype.magnitude = function() {
        return Math.sqrt(this.magnitudeSquared());
    };

    /**
     * Returns this Cartesian normalized.
     *
     * @memberof Cartesian4
     * @return {Cartesian4} The normalized Cartesian.
     */
    Cartesian4.prototype.normalize = function() {
        var magnitude = this.magnitude();
        return new Cartesian4(this.x / magnitude, this.y / magnitude, this.z / magnitude, this.w / magnitude);
    };

    /**
     * Returns the dot (scalar) product of two Cartesians.
     *
     * @memberof Cartesian4
     * @param {Cartesian4} other The Cartesian to dot with this.
     * @return {Number} The dot product.
     */
    Cartesian4.prototype.dot = function(other) {
        return this.x * other.x + this.y * other.y + this.z * other.z + this.w * other.w;
    };

    /**
     * Returns the componentwise sum of two Cartesians.
     *
     * @memberof Cartesian4
     * @param {Cartesian4} other The Cartesian to sum with this.
     * @return {Cartesian4} The sum of this and other.
     */
    Cartesian4.prototype.add = function(other) {
        return new Cartesian4(this.x + other.x, this.y + other.y, this.z + other.z, this.w + other.w);
    };

    /**
     * Returns the componentwise difference of two Cartesians.
     *
     * @memberof Cartesian4
     * @param {Cartesian4} other The Cartesian to subtract from this.
     * @return {Cartesian4} The difference of this and other.
     */
    Cartesian4.prototype.subtract = function(other) {
        return new Cartesian4(this.x - other.x, this.y - other.y, this.z - other.z, this.w - other.w);
    };

    /**
     * Returns this Cartesian scaled by a scalar.
     *
     * @memberof Cartesian4
     * @param {Number} scalar The scalar that is multiplied with this.
     * @return {Cartesian4} The scaled Cartesian.
     */
    Cartesian4.prototype.multiplyWithScalar = function(scalar) {
        return new Cartesian4(this.x * scalar, this.y * scalar, this.z * scalar, this.w * scalar);
    };

    /**
     * Returns this Cartesian scaled by another Cartesian componentwise.
     *
     * @memberof Cartesian4
     * @param {Cartesian4} Cartesian The Cartesian that is multiplied with this componentwise.
     * @return {Cartesian4} The scaled Cartesian.
     */
    Cartesian4.prototype.multiplyComponents = function(Cartesian) {
        return new Cartesian4(this.x * Cartesian.x, this.y * Cartesian.y, this.z * Cartesian.z, this.w * Cartesian.w);
    };

    /**
     * Returns this Cartesian divided by a scalar.
     *
     * @memberof Cartesian4
     * @param {Number} scalar The scalar to use for division.
     * @return {Cartesian4} This Cartesian after division.
     */
    Cartesian4.prototype.divideByScalar = function(scalar) {
        return new Cartesian4(this.x / scalar, this.y / scalar, this.z / scalar, this.w / scalar);
    };

    /**
     * Returns the value of the maximum component.
     *
     * @memberof Cartesian4
     * @return {Number} The value of the maximum component.
     */
    Cartesian4.prototype.getMaximumComponent = function() {
        return Math.max(this.x, this.y, this.z, this.w);
    };

    /**
     * Returns the value of the minimum component.
     *
     * @memberof Cartesian4
     * @return {Number} The value of the minimum component.
     */
    Cartesian4.prototype.getMinimumComponent = function() {
        return Math.min(this.x, this.y, this.z, this.w);
    };

    /**
     * Returns a unit Cartesian representing the most orthogonal axis to this Cartesian.
     *
     * @memberof Cartesian4
     * @return {Cartesian4} The axis most orthogonal to this Cartesian.
     */
    Cartesian4.prototype.mostOrthogonalAxis = function() {
        var x = Math.abs(this.x);
        var y = Math.abs(this.y);
        var z = Math.abs(this.z);
        var w = Math.abs(this.w);

        if ((x < y) && (x < z) && (x < w)) {
            return Cartesian4.getUnitX();
        } else if ((y < x) && (y < z) && (y < w)) {
            return Cartesian4.getUnitY();
        } else if ((z < x) && (z < y) && (z < w)) {
            return Cartesian4.getUnitZ();
        } else {
            return Cartesian4.getUnitW();
        }
    };

    /**
     * Returns this Cartesian negated.
     *
     * @memberof Cartesian4
     * @return {Cartesian4} This Cartesian negated.
     */
    Cartesian4.prototype.negate = function() {
        return new Cartesian4(-this.x, -this.y, -this.z, -this.w);
    };

    /**
     * Returns a version of this Cartesian containing the absolute value of each component.
     *
     * @memberof Cartesian4
     * @return {Cartesian4} The absolute value of this Cartesian.
     */
    Cartesian4.prototype.abs = function() {
        return new Cartesian4(Math.abs(this.x), Math.abs(this.y), Math.abs(this.z), Math.abs(this.w));
    };

    /**
     * Returns a duplicate of a Cartesian4 instance.
     *
     * @memberof Cartesian4
     * @return {Cartesian4} A new copy of the Cartesian4 instance received as an argument.
     */
    Cartesian4.prototype.clone = function() {
        return new Cartesian4(this.x, this.y, this.z, this.w);
    };

    /**
     * Returns true if this Cartesian equals other componentwise.
     *
     * @memberof Cartesian4
     * @param {Cartesian4} other The Cartesian to compare for equality.
     * @return {Boolean} <code>true</code> if the Cartesians are equal componentwise; otherwise, <code>false</code>.
     */
    Cartesian4.prototype.equals = function(other) {
        return (this.x === other.x) &&
               (this.y === other.y) &&
               (this.z === other.z) &&
               (this.w === other.w);
    };

    /**
     * Returns <code>true</code> if this Cartesian equals other componentwise within the specified epsilon.
     *
     * @memberof Cartesian4
     *
     * @param {Cartesian4} other The Cartesian to compare for equality.
     * @param {Number} [epsilon=0.0] The epsilon to use for equality testing.
     *
     * @return {Boolean} <code>true</code> if the Cartesians are equal within the specified epsilon; otherwise, <code>false</code>.
     */
    Cartesian4.prototype.equalsEpsilon = function(other, epsilon) {
        epsilon = epsilon || 0.0;
        return (Math.abs(this.x - other.x) <= epsilon) &&
               (Math.abs(this.y - other.y) <= epsilon) &&
               (Math.abs(this.z - other.z) <= epsilon) &&
               (Math.abs(this.w - other.w) <= epsilon);
    };

    /**
     * Returns a string representing this instance in the format (x, y, z, w).
     *
     * @memberof Cartesian4
     * @return {String} A string representing this instance.
     */
    Cartesian4.prototype.toString = function() {
        return "(" + this.x + ", " + this.y + ", " + this.z + ", " + this.w + ")";
    };

    return Cartesian4;
});

/*global define*/
define('Core/Cartographic2',[],function() {
    

    /**
     * A position defined by longitude and latitude; height is assumed to be zero.
     * <p>
     * When called with no arguments, the position is initialized to (0.0, 0.0).
     * When called with one Cartographic3 argument, p, the position is initialized to (p.longitude, g.latitude); p.height is ignored.
     * When called with two numeric arguments, longitude and latitude, the position is initialized to (longitude, latitude).
     * </p>
     *
     * @name Cartographic2
     * @constructor
     * @see Cartographic3
     */
    function Cartographic2() {
        var longitude = 0.0;
        var latitude = 0.0;

        if (arguments.length === 1) {
            longitude = arguments[0].longitude;
            latitude = arguments[0].latitude;
        } else if (arguments.length > 1) {
            longitude = arguments[0];
            latitude = arguments[1];
        }

        /**
         * DOC_TBA
         *
         * @type Number
         *
         * @see Cartographic2#latitude
         */
        this.longitude = longitude;

        /**
         * DOC_TBA
         *
         * @type Number
         *
         * @see Cartographic2#longitude
         */
        this.latitude = latitude;
    }

    /**
     * Creates a Cartographic2 instance initialized to (0.0, 0.0).
     *
     * @memberof Cartographic2
     * @return {Cartographic2} A new Cartographic2 instance.
     */
    Cartographic2.getZero = function() {
        return new Cartographic2(0.0, 0.0);
    };

    /**
     * Returns a duplicate of a Cartographic2 instance.
     *
     * @memberof Cartographic2
     * @return {Cartographic2} A new copy of the Cartographic2 instance received as an argument.
     */
    Cartographic2.prototype.clone = function() {
        return new Cartographic2(this.longitude, this.latitude);
    };

    /**
     * Returns <code>true</code> if this instance equals other.
     *
     * @memberof Cartographic2
     * 
     * @param {Cartographic2} other The cartographic position to compare for equality.
     *
     * @return {Boolean} <code>true</code> if the positions are equal; otherwise, false.
     */
    Cartographic2.prototype.equals = function(other) {
        return (this.longitude === other.longitude) && (this.latitude === other.latitude);
    };

    /**
     * Returns <code>true</code> if this instance equals other within the specified epsilon.
     *
     * @memberof Cartographic2
     * 
     * @param {Cartographic2} other The cartographic position to compare for equality.
     * @param {Number} [epsilon=0.0] The epsilon to use for equality testing.
     *
     * @return {Boolean} <code>true</code> if the position are equal within the specified epsilon; otherwise, <code>false</code>.
     */
    Cartographic2.prototype.equalsEpsilon = function(other, epsilon) {
        epsilon = epsilon || 0.0;
        return (Math.abs(this.longitude - other.longitude) <= epsilon) && (Math.abs(this.latitude - other.latitude) <= epsilon);
    };

    /**
     * Returns a string representing this instance in the format (longitude, latitude).
     *
     * @memberof Cartographic2
     * @return {String} Returns a string representing this instance.
     */
    Cartographic2.prototype.toString = function() {
        return "(" + this.longitude + ", " + this.latitude + ")";
    };

    return Cartographic2;
});

/*global define*/
define('Core/Cartographic3',[],function() {
    

    /**
     * A position defined by longitude, latitude, and height.
     * <p>
     * When called with no arguments, the position is initialized to (0.0, 0.0, 0.0).
     * When called with one Cartographic2 argument, p, the position is initialized to (p.longitude, g.latitude, 0.0).
     * When called with two numeric arguments, longitude and latitude, the position is initialized to (longitude, latitude, 0.0).
     * When called with two numeric arguments; longitude, latitude, and height; the position is initialized to (longitude, latitude, height).
     * </p>
     *
     * @name Cartographic3
     * @constructor
     *
     * @see Cartographic2
     */
    function Cartographic3() {
        var longitude = 0.0;
        var latitude = 0.0;
        var height = 0.0;

        if (arguments.length === 1) {
            longitude = arguments[0].longitude;
            latitude = arguments[0].latitude;
        } else if (arguments.length === 2) {
            longitude = arguments[0];
            latitude = arguments[1];
        } else if (arguments.length > 2) {
            longitude = arguments[0];
            latitude = arguments[1];
            height = arguments[2];
        }

        /**
         * DOC_TBA
         *
         * @type Number
         *
         * @see Cartographic2#latitude
         */
        this.longitude = longitude;

        /**
         * DOC_TBA
         *
         * @type Number
         *
         * @see Cartographic2#longitude
         */
        this.latitude = latitude;

        /**
         * DOC_TBA
         *
         * @type Number
         */
        this.height = height;
    }

    /**
     * Creates a Cartographic3 instance initialized to (0.0, 0.0, 0.0).
     *
     * @memberof Cartographic3
     * @return {Cartographic3} A new Cartographic3 instance.
     */
    Cartographic3.getZero = function() {
        return new Cartographic3(0.0, 0.0, 0.0);
    };

    /**
     * Returns a duplicate of a Cartographic3 instance.
     *
     * @memberof Cartographic3
     * @return {Cartographic3} A new copy of the Cartographic3 instance received as an argument.
     */
    Cartographic3.prototype.clone = function() {
        return new Cartographic3(this.longitude, this.latitude, this.height);
    };

    /**
     * Returns <code>true</code> if this instance equals other.
     *
     * @memberof Cartographic3
     * 
     * @param {Cartographic3} other The cartographic position to compare for equality.
     *
     * @return {Boolean} <code>true</code> if the positions are equal; otherwise, false.
     */
    Cartographic3.prototype.equals = function(other) {
        return (this.longitude === other.longitude) && (this.latitude === other.latitude) && (this.height === other.height);
    };

    /**
     * Returns <code>true</code> if this instance equals other within the specified epsilon.
     *
     * @memberof Cartographic3
     * 
     * @param {Cartographic3} other The cartographic position to compare for equality.
     * @param {Number} [epsilon=0.0] The epsilon to use for equality testing.
     *
     * @return {Boolean} <code>true</code> if the position are equal within the specified epsilon; otherwise, <code>false</code>.
     */
    Cartographic3.prototype.equalsEpsilon = function(other, epsilon) {
        epsilon = epsilon || 0.0;
        return (Math.abs(this.longitude - other.longitude) <= epsilon) && 
               (Math.abs(this.latitude - other.latitude) <= epsilon) &&
               (Math.abs(this.height - other.height) <= epsilon);
    };

    /**
     * Returns a string representing this instance in the format (longitude, latitude, height).
     *
     * @memberof Cartographic3
     * 
     * @return {String} Returns a string representing this instance.
     */
    Cartographic3.prototype.toString = function() {
        return "(" + this.longitude + ", " + this.latitude + ", " + this.height + ")";
    };

    return Cartographic3;
});

/*global define*/
define('Core/DeveloperError',[],function() {
    

    /**
     * Constructs an exception object that is thrown due to a developer error, e.g., invalid argument,
     * argument out of range, etc.  This exception should only be thrown during development;
     * it usually indicates a bug in the calling code.  This exception should never be
     * caught; instead the calling code should strive not to generate it.
     * <br /><br />
     * On the other hand, a {@link RuntimeError} indicates an exception that may
     * be thrown at runtime, e.g., out of memory, that the calling code should be prepared
     * to catch.
     *
     * @name DeveloperError
     *
     * @param {String} [message=undefined] The error message for this exception.
     * @param {String} [parameter=undefined] The name of the function argument that caused the exception.
     *
     * @see RuntimeError
     * @constructor
     */
    function DeveloperError(message, parameter) {
        /**
         * "DeveloperError" indicating that this exception was thrown due to a developer error.
         *
         * @constant
         * @type String
         */
        this.name = "DeveloperError";

        /**
         * The explanation for why this exception was thrown.
         *
         * @type String
         */
        this.message = message;

        /**
         * The name of the function argument that caused this exception.
         *
         * @type String
         */
        this.parameter = parameter;
    }

    return DeveloperError;
});

/*global define*/
define('Core/AxisAlignedBoundingRectangle',[
        './DeveloperError',
        './Cartesian2'
    ], function(
        DeveloperError,
        Cartesian2) {
    

    /**
     * DOC_TBA
     *
     * @name AxisAlignedBoundingRectangle
     *
     * @exception {DeveloperError} <code>positions</code> is required.
     *
     * @constructor
     */
    function AxisAlignedBoundingRectangle(positions) {
        if (!positions) {
            throw new DeveloperError("positions is required.", "positions");
        }

        this.minimum = undefined;
        this.maximum = undefined;
        this.center = undefined;

        var length = positions.length;
        if (length > 0) {
            var minimumX = positions[0].x;
            var minimumY = positions[0].y;

            var maximumX = positions[0].x;
            var maximumY = positions[0].y;

            for ( var i = 1; i < length; i++) {
                var p = positions[i];
                var x = p.x;
                var y = p.y;

                if (x < minimumX) {
                    minimumX = x;
                }

                if (x > maximumX) {
                    maximumX = x;
                }

                if (y < minimumY) {
                    minimumY = y;
                }

                if (y > maximumY) {
                    maximumY = y;
                }
            }

            var min = new Cartesian2(minimumX, minimumY);
            var max = new Cartesian2(maximumX, maximumY);

            /**
             * DOC_TBA
             *
             * @type Cartesian2
             */
            this.minimum = min;

            /**
             * DOC_TBA
             *
             * @type Cartesian2
             */
            this.maximum = max;

            /**
             * DOC_TBA
             *
             * @type Cartesian2
             */
            this.center = (min.add(max)).multiplyWithScalar(0.5);
        }
    }

    return AxisAlignedBoundingRectangle;
});

/*global define*/
define('Core/Enumeration',[],function() {
    

    /**
     * Constructs an enumeration that contains both a numeric value and a name.
     * This is used so the name of the enumeration is available in the debugger.
     * <br /><br />
     * When comparing enumeration using exact equality, use their {@link Enumeration.value}
     * property.
     * <br /><br />
     * <code>
     * if (left.value === right.value) { <br/>
     * &nbsp;&nbsp;&nbsp;&nbsp;// ... <br/>
     * }
     * </code>
     *
     * @param {Number} [value=undefined] The numeric value of the enumeration.
     * @param {String} [name=undefined] The name of the enumeration for debugging purposes.
     * @param {Object} [properties=undefined] An object containing extra properties to be added to the enumeration.
     *
     * @name Enumeration
     * @constructor
     * @example
     * // Create an object with two enumerations.
     * var filter = {
     *     NEAREST : new Enumeration(0x2600, "NEAREST"),
     *     LINEAR : new Enumeration(0x2601, "LINEAR")
     * };
     */
    function Enumeration(value, name, properties) {
        /**
         * The numeric value of the enumeration.
         * @type Number
         */
        this.value = value;

        /**
         * The name of the enumeration for debugging purposes.
         * @type String
         */
        this.name = name;

        if (typeof properties !== 'undefined') {
            for ( var propertyName in properties) {
                if (properties.hasOwnProperty(propertyName)) {
                    this[propertyName] = properties[propertyName];
                }
            }
        }
    }

    /**
     * Returns the numeric value of the enumeration.
     *
     * @memberof Enumeration
     *
     * @return {Number} The numeric value of the enumeration.
     */
    Enumeration.prototype.valueOf = function() {
        return this.value;
    };

    /**
     * Returns the name of the enumeration for debugging purposes.
     *
     * @memberof Enumeration
     *
     * @return {String} The name of the enumeration for debugging purposes.
     */
    Enumeration.prototype.toString = function() {
        return this.name;
    };

    return Enumeration;
});
/*global define*/
define('Core/ComponentDatatype',['./Enumeration'], function(Enumeration) {
    
    /*global Int8Array,Uint8Array,Int16Array,Uint16Array,Float32Array*/

    // Earlier versions of IE do not support typed arrays, and as a result,
    // using them below will cause the setup function itself to fail, causing
    // the page to abort load, and preventing us from prompting to install
    // Chrome Frame.  To avoid this, bail out early and return a dummy object,
    // since we won't be able to create a WebGL context anyway.
    if (typeof Int8Array === 'undefined') {
        return {};
    }

    /**
     * DOC_TBA
     *
     * @name ComponentDatatype
     * @enumeration
     */
    var ComponentDatatype = {};

    /**
     * DOC_TBA
     *
     * @constant
     * @type {Enumeration}
     * @memberOf ComponentDatatype
     */
    ComponentDatatype.BYTE = new Enumeration(0x1400, "BYTE"); // BYTE
    ComponentDatatype.BYTE.sizeInBytes = Int8Array.BYTES_PER_ELEMENT;
    ComponentDatatype.BYTE.toTypedArray = function(values) {
        return new Int8Array(values);
    };

    ComponentDatatype.BYTE.createArrayBufferView = function(buffer, byteOffset) {
        return new Int8Array(buffer, byteOffset);
    };

    /**
     * DOC_TBA
     *
     * @constant
     * @type {Enumeration}
     * @memberOf ComponentDatatype
     */
    ComponentDatatype.UNSIGNED_BYTE = new Enumeration(0x1401, "UNSIGNED_BYTE"); // UNSIGNED_BYTE
    ComponentDatatype.UNSIGNED_BYTE.sizeInBytes = Uint8Array.BYTES_PER_ELEMENT;
    ComponentDatatype.UNSIGNED_BYTE.toTypedArray = function(values) {
        return new Uint8Array(values);
    };

    ComponentDatatype.UNSIGNED_BYTE.createArrayBufferView = function(buffer, byteOffset) {
        return new Uint8Array(buffer, byteOffset);
    };

    /**
     * DOC_TBA
     *
     * @constant
     * @type {Enumeration}
     * @memberOf ComponentDatatype
     */
    ComponentDatatype.SHORT = new Enumeration(0x1402, "SHORT"); // SHORT
    ComponentDatatype.SHORT.sizeInBytes = Int16Array.BYTES_PER_ELEMENT;
    ComponentDatatype.SHORT.toTypedArray = function(values) {
        return new Int16Array(values);
    };

    ComponentDatatype.SHORT.createArrayBufferView = function(buffer, byteOffset) {
        return new Int16Array(buffer, byteOffset);
    };

    /**
     * DOC_TBA
     *
     * @constant
     * @type {Enumeration}
     * @memberOf ComponentDatatype
     */
    ComponentDatatype.UNSIGNED_SHORT = new Enumeration(0x1403, "UNSIGNED_SHORT"); // UNSIGNED_SHORT
    ComponentDatatype.UNSIGNED_SHORT.sizeInBytes = Uint16Array.BYTES_PER_ELEMENT;
    ComponentDatatype.UNSIGNED_SHORT.toTypedArray = function(values) {
        return new Uint16Array(values);
    };

    ComponentDatatype.UNSIGNED_SHORT.createArrayBufferView = function(buffer, byteOffset) {
        return new Uint16Array(buffer, byteOffset);
    };

    /**
     * DOC_TBA
     *
     * @constant
     * @type {Enumeration}
     * @memberOf ComponentDatatype
     */
    ComponentDatatype.FLOAT = new Enumeration(0x1406, "FLOAT"); // FLOAT
    ComponentDatatype.FLOAT.sizeInBytes = Float32Array.BYTES_PER_ELEMENT;
    ComponentDatatype.FLOAT.toTypedArray = function(values) {
        return new Float32Array(values);
    };

    ComponentDatatype.FLOAT.createArrayBufferView = function(buffer, byteOffset) {
        return new Float32Array(buffer, byteOffset);
    };

    return ComponentDatatype;
});

/*global define*/
define('Core/EventModifier',['./Enumeration'], function(Enumeration) {
    

    /**
     * This enumerated type is for representing keyboard modifiers. These are keys
     * that are held down in addition to other event types.
     *
     * @exports EventModifier
     */
    var EventModifier = {
        /**
         * Represents the shift key being held down.
         *
         * @constant
         * @type {Enumeration}
         */
        SHIFT : new Enumeration(0, "SHIFT"),

        /**
         * Represents the control key being held down.
         *
         * @constant
         * @type {Enumeration}
         */
        CTRL : new Enumeration(1, "CTRL"),

        /**
         * Represents the alt key being held down.
         *
         * @constant
         * @type {Enumeration}
         */
        ALT : new Enumeration(2, "ALT")
    };

    return EventModifier;
});
/*global define*/
define('Core/FAR',[],function() {
    

    /**
     * DOC_TBA
     *
     * Distance from the Sun to Pluto in meters.
     */
    var FAR = 5906376272000.0;

    return FAR;
});
/*global define*/
define('Core/IndexDatatype',['./Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports IndexDatatype
     */
    var IndexDatatype = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        UNSIGNED_BYTE : new Enumeration(0x1401, "unsignedByte"), // UNSIGNED_BYTE
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        UNSIGNED_SHORT : new Enumeration(0x1403, "unsignedShort") // UNSIGNED_SHORT
    };

    return IndexDatatype;
});

/*global define*/
define('Core/Intersect',['./Enumeration'], function(Enumeration) {
    

    /**
     * This enumerated type is used in determining where, relative to the frustum, an
     * object is located. The object can either be fully contained within the frustum (INSIDE),
     * partially inside the frustum and partially outside (INTERSECTING), or somwhere entirely
     * outside of the frustum's 6 planes (OUTSIDE).
     *
     * @exports Intersect
     */
    var Intersect = {
        /**
         * Represents that an object is not contained within the frustum.
         *
         * @constant
         * @type {Enumeration}
         */
        OUTSIDE : new Enumeration(-1, "OUTSIDE"),

        /**
         * Represents that an object intersects one of the frustum's planes.
         *
         * @constant
         * @type {Enumeration}
         */
        INTERSECTING : new Enumeration(0, "INTERSECTING"),

        /**
         * Represents that an object is fully within the frustum.
         *
         * @constant
         * @type {Enumeration}
         */
        INSIDE : new Enumeration(1, "INSIDE")
    };

    return Intersect;
});

/*global define*/
define('Core/AxisAlignedBoundingBox',[
        './DeveloperError',
        './Cartesian3',
        './Intersect'
    ], function(
        DeveloperError,
        Cartesian3,
        Intersect) {
    

    /**
     * Creates an instance of an AxisAlignedBoundingBox. The box is determined by finding the points spaced the
     * furthest apart on the x-, y-, and z-axes.
     *
     * @name AxisAlignedBoundingBox
     *
     * @param {Array} positions List of points that the bounding box will enclose.  Each point must have a <code>x</code>, <code>y</code>, and <code>z</code> properties.
     *
     * @exception {DeveloperError} <code>positions</code> is required.
     *
     * @constructor
     * @immutable
     *
     * @example
     * // Compute an axis aligned bounding box enclosing two points.
     * var box = new AxisAlignedBoundingBox(
     *     [new Cartesian3(2, 0, 0), new Cartesian3(-2, 0, 0)]);
     */
    function AxisAlignedBoundingBox(positions) {
        if (!positions) {
            throw new DeveloperError("positions is required.", "positions");
        }

        var length = positions.length;
        if (length !== 0) {
            var minimumX = positions[0].x;
            var minimumY = positions[0].y;
            var minimumZ = positions[0].z;

            var maximumX = positions[0].x;
            var maximumY = positions[0].y;
            var maximumZ = positions[0].z;

            for ( var i = 1; i < length; i++) {
                var p = positions[i];
                var x = p.x;
                var y = p.y;
                var z = p.z;

                if (x < minimumX) {
                    minimumX = x;
                }

                if (x > maximumX) {
                    maximumX = x;
                }

                if (y < minimumY) {
                    minimumY = y;
                }

                if (y > maximumY) {
                    maximumY = y;
                }

                if (z < minimumZ) {
                    minimumZ = z;
                }

                if (z > maximumZ) {
                    maximumZ = z;
                }
            }

            var min = new Cartesian3(minimumX, minimumY, minimumZ);
            var max = new Cartesian3(maximumX, maximumY, maximumZ);

            /**
             * The minimum point defining the bounding box.
             *
             * @type {Cartesian3}
             */
            this.minimum = min;

            /**
             * The maximum point defining the bounding box.
             *
             * @type {Cartesian3}
             */
            this.maximum = max;

            /**
             * The center point of the bounding box.
             *
             * @type {Cartesian3}
             */
            this.center = (min.add(max)).multiplyWithScalar(0.5);
        } else {
            this.minimum = undefined;
            this.maximum = undefined;
            this.center = undefined;
        }
    }

    /**
     * DOC_TBA
     * @memberof AxisAlignedBoundingBox
     */
    AxisAlignedBoundingBox.planeAABBIntersect = function(box, plane) {
        var max = box.maximum;
        var min = box.minimum;
        var center = max.add(min).divideByScalar(2);
        var h = max.subtract(min).divideByScalar(2); //The positive half diagonal
        var e = h.x * Math.abs(plane.x) + h.y * Math.abs(plane.y) + h.z * Math.abs(plane.z);
        var s = center.dot(plane.getXYZ()) + plane.w; //signed distance from center
        if (s - e > 0) {
            return Intersect.INSIDE;
        }

        if (s + e < 0) {
            //Not in front because normals point inwards
            return Intersect.OUTSIDE;
        }

        return Intersect.INTERSECTING;
    };

    return AxisAlignedBoundingBox;
});

/*global define*/
define('Core/BoundingSphere',[
        './DeveloperError',
        './Cartesian3',
        './Intersect'
    ], function(
        DeveloperError,
        Cartesian3,
        Intersect) {
    

    /**
     * Computes a tight-fitting bounding sphere enclosing a list of 3D Cartesian points.
     * <br /><br />
     *
     * <p>
     * When called with a list of {Cartesian3} elements as the only argument, the bounding
     * sphere is computed by running two algorithms, a naive algorithm and Ritter's algorithm. The
     * smaller of the two spheres is used to ensure a tight fit.
     * <br />
     * When called with the first argument as a {Cartesian3} instance and the second argument as a {Number},
     * then a bounding sphere is constructed using the first point as its center and the second argument
     * as its radius.
     * </p>
     *
     * @name BoundingSphere
     *
     * @param {Array} positions List of points that the bounding sphere will enclose.  Each point must have a <code>x</code>, <code>y</code>, and <code>z</code> properties.
     * @param {Number} radius An optional parameter, only to be supplied if <code>positions</code> contains a single point.
     *
     * @exception {DeveloperError} <code>positions</code> is required.
     *
     * @see AxisAlignedBoundingBox
     * @see <a href="http://blogs.agi.com/insight3d/index.php/2008/02/04/a-bounding/">Bounding Sphere computation article</a>
     *
     * @constructor
     * @immutable
     *
     * @example
     * // Compute a bounding sphere enclosing two points.
     * var sphere = new BoundingSphere([new Cartesian3(-2, 0, 0),
     *     new Cartesian3(2, 0, 0)]);
     * @example
     * // Compute the same bounding sphere using a center point and a radius.
     * var sphere = new BoundingSphere(new Cartesian3(0, 0, 0), 2);
     */
    function BoundingSphere(positions, radius) {
        if (!positions) {
            throw new DeveloperError("positions is required.", "positions");
        }

        if ((arguments.length === 2) && (typeof arguments[1] === 'number')) {
            /**
             * The center point of the sphere.
             *
             * @type {Cartesian3}
             */
            this.center = arguments[0].clone();
            /**
             * The radius of the sphere.
             *
             * @type {Number}
             */
            this.radius = arguments[1];
        } else {
            var x = positions[0].x;
            var y = positions[0].y;
            var z = positions[0].z;

            var xMin = new Cartesian3(x, y, z);
            var yMin = new Cartesian3(x, y, z);
            var zMin = new Cartesian3(x, y, z);

            var xMax = new Cartesian3(x, y, z);
            var yMax = new Cartesian3(x, y, z);
            var zMax = new Cartesian3(x, y, z);

            var currentPos;
            var numPositions = positions.length;
            for ( var i = 0; i < numPositions; i++) {
                currentPos = positions[i];
                x = currentPos.x;
                y = currentPos.y;
                z = currentPos.z;

                // Store points containing the the smallest and largest componenets
                if (x < xMin.x) {
                    xMin = currentPos;
                }

                if (x > xMax.x) {
                    xMax = currentPos;
                }

                if (y < yMin.y) {
                    yMin = currentPos;
                }

                if (y > yMax.y) {
                    yMax = currentPos;
                }

                if (z < zMin.z) {
                    zMin = currentPos;
                }

                if (z > zMax.z) {
                    zMax = currentPos;
                }
            }

            // Compute x-, y-, and z-spans (Squared distances b/n each component's min. and max.).
            var xSpan = (xMax.subtract(xMin)).magnitudeSquared();
            var ySpan = (yMax.subtract(yMin)).magnitudeSquared();
            var zSpan = (zMax.subtract(zMin)).magnitudeSquared();

            // Set the diameter endpoints to the largest span.
            var diameter1 = xMin;
            var diameter2 = xMax;
            var maxSpan = xSpan;
            if (ySpan > maxSpan) {
                maxSpan = ySpan;
                diameter1 = yMin;
                diameter2 = yMax;
            }
            if (zSpan > maxSpan) {
                maxSpan = zSpan;
                diameter1 = zMin;
                diameter2 = zMax;
            }

            // Calculate the center of the initial sphere found by Ritter's algorithm
            var ritterCenter = new Cartesian3(
                    (diameter1.x + diameter2.x) * 0.5,
                    (diameter1.y + diameter2.y) * 0.5,
                    (diameter1.z + diameter2.z) * 0.5);

            // Calculate the radius of the initial sphere found by Ritter's algorithm
            var radiusSquared = (diameter2.subtract(ritterCenter)).magnitudeSquared();
            var ritterRadius = Math.sqrt(radiusSquared);

            // Find the center of the sphere found using the Naive method.
            var minBoxPt = new Cartesian3(xMin.x, yMin.y, zMin.z);
            var maxBoxPt = new Cartesian3(xMax.x, yMax.y, zMax.z);
            var naiveCenter = (minBoxPt.add(maxBoxPt)).multiplyWithScalar(0.5);

            // Begin 2nd pass to find naive radius and modify the ritter sphere.
            var naiveRadius = 0;
            for (i = 0; i < numPositions; i++) {
                currentPos = positions[i];

                // Find the furthest point from the naive center to calculate the naive radius.
                var r = (currentPos.subtract(naiveCenter)).magnitude();
                if (r > naiveRadius) {
                    naiveRadius = r;
                }

                // Make adjustments to the Ritter Sphere to include all points.
                var oldCenterToPointSquared = (currentPos.subtract(ritterCenter)).magnitudeSquared();
                if (oldCenterToPointSquared > radiusSquared) {
                    var oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);
                    // Calculate new radius to include the point that lies outside
                    ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;
                    radiusSquared = ritterRadius * ritterRadius;
                    // Calculate center of new Ritter sphere
                    var oldToNew = oldCenterToPoint - ritterRadius;
                    ritterCenter = new Cartesian3(
                            (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) / oldCenterToPoint,
                            (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) / oldCenterToPoint,
                            (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) / oldCenterToPoint);
                }
            }

            if (ritterRadius < naiveRadius) {
                this.center = ritterCenter;
                this.radius = ritterRadius;
            } else {
                this.center = naiveCenter;
                this.radius = naiveRadius;
            }
        }
    }

    /**
     * DOC_TBA
     * @memberof BoundingSphere
     */
    BoundingSphere.prototype.clone = function() {
        return new BoundingSphere(this.center, this.radius);
    };

    /**
     * DOC_TBA
     * @memberof BoundingSphere
     */
    BoundingSphere.planeSphereIntersect = function(sphere, plane) {
        var center = sphere.center;
        var radius = sphere.radius;
        var distanceToPlane = plane.getXYZ().dot(center) + plane.w;

        if (distanceToPlane < -radius) {
            //center point is OUTSIDE of frustum
            return Intersect.OUTSIDE;
        } else if (distanceToPlane < radius) {
            //center point is within frustum, but radius extends beyond it; partial overlap
            return Intersect.INTERSECTING;
        }
        return Intersect.INSIDE;
    };

    return BoundingSphere;
});

/*global define*/
define('Core/Jobs',[],function() {
    
    /*global Image*/

    // TODO:  Need tests for this when interface is solid.

    /**
     * Jobs for use with {@link <a href="https://github.com/chriso/chain.js">chain.js</a>}.
     * Jobs can be used to asynchronously download resources, such as images, and create 
     * function dependencies, e.g., download these images asynchronously, and create a texture for
     * each when the download completes.
     * @exports Jobs
     * @see <a href="https://github.com/chriso/chain.js">chain.js</a>
     */
    var Jobs = {
        /**
         * Creates a function to asynchronously download an image for use with {@link <a href="https://github.com/chriso/chain.js">chain.js</a>}.
         * This allows multiple images to be downloaded in parallel, and other functions to depend on the download as shown in the example below.
         * <br /><br />
         * When a download completes, the image object is available to functions later in the chain via <code>this.images[url]</code>.
         * 
         * @param {String} url The url of the image relative the document, i.e., the host html file.
         * 
         * @returns {Object} A function to asynchronously download the image for use with chain.js.
         * 
         * @see <a href="https://github.com/chriso/chain.js">chain.js</a>
         * 
         * @example
         * // Asynchronously download two images, then create textures.
         * run(     
         *     Jobs.downloadImage("diffuse.jpg"),
         *     Jobs.downloadImage("specular.jpg")).thenRun(
         * function() {
         *     var diffuseTexture = context.createTexture2D({ 
         *          source      : this.images["diffuse.jpg"],
         *          pixelFormat : PixelFormat.RGB 
         *      });
         *     var specularTexture = context.createTexture2D({ 
         *          source      : this.images["specular.jpg"],
         *          pixelFormat : PixelFormat.RGB 
         *      });
         *     // ...
         * });
         */
        downloadImage : function(url) {
            return function(next) {
                var image = new Image();

                this.images = this.images || {};
                this.images[url] = image;

                image.onload = function() {
                    next();
                };
                image.src = url;
            };
        }
    };
    
    return Jobs;
});
/*global define*/
define('Core/LeapSecond',[
        'require',
        './DeveloperError'
    ], function(
        require,
        DeveloperError) {
    

    var JulianDate = function(a, b, c) {
        //because of the circular reference between JulianDate and TimeStandard,
        //we need to require JulianDate later and replace our reference
        JulianDate = require('./JulianDate');
        return new JulianDate(a, b, c);
    };

    /**
     * Describes a single leap second, which is constructed from a {@link JulianDate} and a
     * numerical offset representing the number of seconds between the TAI and UTC time standards.
     *
     * @name LeapSecond
     * @constructor
     *
     * @param {JulianDate} date A Julian date representing the time of the leap second.
     * Additionally, this parameter may be a {String} containing the date of the leap second
     * (in the format used to construct a Javascript Date object).
     * @param {Number} totalTaiOffsetFromUtc The cumulative difference, in seconds, between the TAI and
     * UTC standards at the time of this leap second.
     *
     * @exception {DeveloperError} <code>date</code> is required.
     * @exception {DeveloperError} <code>offset</code> is required.
     *
     * @see JulianDate
     * @see TimeStandard
     *
     * @example
     * // Example 1. Construct a LeapSecond using a JulianDate
     * var date = new Date("January 1, 1990 00:00:00 UTC");
     * var leapSecond = new LeapSecond(new JulianDate(date), 25.0);
     * var offset = leapSecond.offset;    // 25.0
     *
     * //////////////////////////////////////////////////////////////////
     *
     * // Example 2. Construct a LeapSecond using a date string
     * var date = "January 1, 1990 00:00:00 UTC";
     * var leapSecond = new LeapSecond(date, 25.0);
     */
    function LeapSecond(date, offset) {
        var julianDate;
        var totalTaiOffsetFromUtc;

        if (!date) {
            throw new DeveloperError("date is required.");
        }
        if (typeof offset === 'undefined') {
            throw new DeveloperError("offset is required.");
        }

        if (typeof date === 'object') {
            julianDate = date;
            totalTaiOffsetFromUtc = offset;
        } else if (typeof date === 'string') {
            julianDate = new JulianDate(new Date(date));
            totalTaiOffsetFromUtc = offset;
        }

        /*
         * The Julian date at which this leap second occurs.
         *
         * @type {JulianDate}
         */
        this.julianDate = julianDate;
        /*
         * The cumulative number of seconds between the UTC and TAI time standards at the time
         * of this leap second.
         *
         * @type {Number}
         */
        this.offset = totalTaiOffsetFromUtc;
    }

    /**
     * Sets the list of currently known leap seconds from user provided data.
     *
     * @memberof LeapSecond
     *
     * @param {Object} data An array of the form:
     *                          [
     *                            {
     *                              date   : xxx,
     *                              offset : xxx
     *                            },
     *                            ...
     *                          ]
     * <code>date</code> should be a String representing the
     * time of the leap second (in the format used to construct a Javascript Date object), and <code>offset</code>
     * should be a number representing the difference, in seconds, between the TAI and UTC standards at the
     * time of this leap second.
     *
     * @exception {DeveloperError} <code>data</code> is required.
     *
     * @see LeapSecond.getLeapSeconds
     *
     * @example
     * // Set the list of leap seconds using user defined data.
     * var data = [
     *     {
     *          date: "January 1, 1972 00:00:00 UTC",
     *          offset: 10.0
     *     },
     *     {
     *          date: "July 1, 1972 00:00:00 UTC",
     *          offset: 11.0
     *     }
     * ];
     * LeapSecond.setLeapSeconds(data);
     * var leapSeconds = LeapSecond.getLeapSeconds();  // An array of two LeapSeconds.
     */
    LeapSecond.setLeapSeconds = function(data) {
        if (!data) {
            throw new DeveloperError("data is required.", "data");
        }

        LeapSecond._leapSeconds = [];
        var numObjects = data.length;
        for ( var i = 0; i < numObjects; i++) {
            LeapSecond._leapSeconds.push(new LeapSecond(data[i].date, data[i].offset));
        }
        LeapSecond._leapSeconds.sort(LeapSecond.compareLeapSecondDate);
    };

    /**
     * Returns a list of leap seconds. If {@link LeapSecond.setLeapSeconds} has not yet been called,
     * then a list of leap seconds that was available when this library was released is returned.
     *
     * @memberof LeapSecond
     *
     * @return {Array} A list of {@link LeapSecond} objects.
     *
     * @see LeapSecond.setLeapSeconds
     */
    LeapSecond.getLeapSeconds = function() {
        if (!LeapSecond._leapSeconds) {
            LeapSecond._leapSeconds =
                [
                     new LeapSecond("January 1, 1972 00:00:00 UTC", 10),
                     new LeapSecond("July 1, 1972 00:00:00 UTC", 11),
                     new LeapSecond("January 1, 1973 00:00:00 UTC", 12),
                     new LeapSecond("January 1, 1974 00:00:00 UTC", 13),
                     new LeapSecond("January 1, 1975 00:00:00 UTC", 14),
                     new LeapSecond("January 1, 1976 00:00:00 UTC", 15),
                     new LeapSecond("January 1, 1977 00:00:00 UTC", 16),
                     new LeapSecond("January 1, 1978 00:00:00 UTC", 17),
                     new LeapSecond("January 1, 1979 00:00:00 UTC", 18),
                     new LeapSecond("January 1, 1980 00:00:00 UTC", 19),
                     new LeapSecond("July 1, 1981 00:00:00 UTC", 20),
                     new LeapSecond("July 1, 1982 00:00:00 UTC", 21),
                     new LeapSecond("July 1, 1983 00:00:00 UTC", 22),
                     new LeapSecond("July 1, 1985 00:00:00 UTC", 23),
                     new LeapSecond("January 1, 1988 00:00:00 UTC", 24),
                     new LeapSecond("January 1, 1990 00:00:00 UTC", 25),
                     new LeapSecond("January 1, 1991 00:00:00 UTC", 26),
                     new LeapSecond("July 1, 1992 00:00:00 UTC", 27),
                     new LeapSecond("July 1, 1993 00:00:00 UTC", 28),
                     new LeapSecond("July 1, 1994 00:00:00 UTC", 29),
                     new LeapSecond("January 1, 1996 00:00:00 UTC", 30),
                     new LeapSecond("July 1, 1997 00:00:00 UTC", 31),
                     new LeapSecond("January 1, 1999 00:00:00 UTC", 32),
                     new LeapSecond("January 1, 2006 00:00:00 UTC", 33),
                     new LeapSecond("January 1, 2009 00:00:00 UTC", 34)
                 ];
        }
        return LeapSecond._leapSeconds;
    };

    /**
     * Checks whether two leap seconds are equivalent to each other.
     *
     * @memberof LeapSecond
     *
     * @param {LeapSecond} other The leap second to compare against.
     *
     * @return {Boolean} <code>true</code> if the leap seconds are equal; otherwise, <code>false</code>.
     *
     * @example
     * var date = new Date("January 1, 1990 00:00:00 UTC");
     * var leapSecond1 = new LeapSecond(new JulianDate(date), 25.0);
     * var leapSecond2 = new LeapSecond(new JulianDate(date), 25.0);
     * leapSecond1.equals(leapSecond2);     // true
     */
    LeapSecond.prototype.equals = function(other) {
        return this.julianDate.equals(other.julianDate) && (this.offset === other.offset);
    };

    /**
     * Given two leap seconds, determines which comes before the other by comparing
     * their respective Julian dates.
     *
     * @memberof LeapSecond
     *
     * @param {LeapSecond} leapSecond1 The first leap second to be compared.
     * @param {LeapSecond} leapSecond2 The second leap second to be compared.
     *
     * @return {Number} A negative value if the first leap second is earlier than the second,
     *                  a positive value if the first leap second is later than the second, or
     *                  zero if the two leap seconds are equal (ignoring their offsets).
     *
     * @see JulianDate#isBefore
     * @see JulianDate#isAfter
     *
     * @example
     * var date = new Date("January 1, 2006 00:00:00 UTC");
     * var leapSecond1 = new LeapSecond(new JulianDate(date), 33.0);
     * var leapSecond2 = new LeapSecond(new JulianDate(date), 34.0);
     * LeapSecond.compareLeapSecondDate(leapSecond1, leapSecond2);    // returns 0
     */
    LeapSecond.compareLeapSecondDate = function(leapSecond1, leapSecond2) {
        var julianDayNum1 = leapSecond1.julianDate.getJulianDayNumber();
        var julianDayNum2 = leapSecond2.julianDate.getJulianDayNumber();
        if (julianDayNum1 !== julianDayNum2) {
            return julianDayNum1 < julianDayNum2 ? -1 : 1;
        }
        var secondsOfDay1 = leapSecond1.julianDate.getSecondsOfDay();
        var secondsOfDay2 = leapSecond2.julianDate.getSecondsOfDay();
        if (secondsOfDay1 !== secondsOfDay2) {
            return secondsOfDay1 < secondsOfDay2 ? -1 : 1;
        }
        return 0;
    };

    return LeapSecond;
});
/*global define*/
define('Core/Math',[
        './Cartesian2',
        './Cartesian3',
        './Cartographic2',
        './Cartographic3'
    ],
    function(
        Cartesian2,
        Cartesian3,
        Cartographic2,
        Cartographic3) {
    

    /**
     * @exports CesiumMath
     * Math functions.
     */
    var CesiumMath = {};

    /**
     * 0.1
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON1 = 0.1;

    /**
     * 0.01
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON2 = 0.01;

    /**
     * 0.001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON3 = 0.001;

    /**
     * 0.0001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON4 = 0.0001;

    /**
     * 0.00001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON5 = 0.00001;

    /**
     * 0.000001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON6 = 0.000001;

    /**
     * 0.0000001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON7 = 0.0000001;

    /**
     * 0.00000001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON8 = 0.00000001;

    /**
     * 0.000000001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON9 = 0.000000001;

    /**
     * 0.0000000001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON10 = 0.0000000001;

    /**
     * 0.00000000001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON11 = 0.00000000001;

    /**
     * 0.000000000001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON12 = 0.000000000001;

    /**
     * 0.0000000000001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON13 = 0.0000000000001;

    /**
     * 0.00000000000001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON14 = 0.00000000000001;

    /**
     * 0.000000000000001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON15 = 0.000000000000001;

    /**
     * 0.0000000000000001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON16 = 0.0000000000000001;

    /**
     * 0.00000000000000001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON17 = 0.00000000000000001;

    /**
     * 0.000000000000000001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON18 = 0.000000000000000001;

    /**
     * 0.0000000000000000001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON19 = 0.0000000000000000001;

    /**
     * 0.00000000000000000001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON20 = 0.00000000000000000001;

    /**
     * 3.986004418e14
     * @constant
     * @type Number
     */
    CesiumMath.GRAVITATIONALPARAMETER = 3.986004418e14;

    /**
     * Returns the sign of the value; 1 if the value is positive, -1 if the value is
     * negative, or 0 if the value is 0.
     *
     * @param {Number} value The value to return the sign of.
     *
     * @return {Number} The sign of value.
     */
    CesiumMath.sign = function(value) {
        if (value > 0) {
            return 1;
        } else if (value < 0) {
            return -1;
        }

        return 0;
    };

    /**
     * DOC_TBA
     */
    CesiumMath.angleBetween = function(vector1, vector2) {
        var v1 = new Cartesian3(vector1.x, vector1.y, vector1.z);
        var v2 = new Cartesian3(vector2.x, vector2.y, vector2.z);

        var magnitude1 = v1.magnitude();
        var magnitude2 = v2.magnitude();

        if ((magnitude1 < CesiumMath.EPSILON12) || (magnitude2 < CesiumMath.EPSILON12)) {
            return 0.0;
        }

        var cross = v1.cross(v2);
        var sinTheta = cross.magnitude();
        var cosTheta = v1.dot(v2);

        return Math.abs(Math.atan2(sinTheta, cosTheta));
    };

    /**
     * Returns the hyperbolic sine of a {@code Number}.
     * The hyperbolic sine of <em>value</em> is defined to be
     * (<em>e<sup>x</sup>&nbsp;-&nbsp;e<sup>-x</sup></em>)/2.0
     * where <i>e</i> is Euler's number, approximately 2.71828183.
     *
     * <p>Special cases:
     *   <ul>
     *     <li>If the argument is NaN, then the result is NaN.</li>
     *
     *     <li>If the argument is infinite, then the result is an infinity
     *     with the same sign as the argument.</li>
     *
     *     <li>If the argument is zero, then the result is a zero with the
     *     same sign as the argument.</li>
     *   </ul>
     *</p>
     *
     * @param value The number whose hyperbolic sine is to be returned.
     *
     * @return The hyperbolic sine of {@code value}.
     *
     */
    CesiumMath.sinh = function(value) {
        var part1 = Math.pow(Math.E, value);
        var part2 = Math.pow(Math.E, -1.0 * value);

        return (part1 - part2) * 0.5;
    };

    /**
     * Returns the hyperbolic cosine of a {@code Number}.
     * The hyperbolic cosine of <strong>value</strong> is defined to be
     * (<em>e<sup>x</sup>&nbsp;+&nbsp;e<sup>-x</sup></em>)/2.0
     * where <i>e</i> is Euler's number, approximately 2.71828183.
     *
     * <p>Special cases:
     *   <ul>
     *     <li>If the argument is NaN, then the result is NaN.</li>
     *
     *     <li>If the argument is infinite, then the result is positive infinity.</li>
     *
     *     <li>If the argument is zero, then the result is {@code 1.0}.</li>
     *   </ul>
     *</p>
     *
     * @param value The number whose hyperbolic cosine is to be returned.
     *
     * @return The hyperbolic cosine of {@code value}.
     */
    CesiumMath.cosh = function(value) {
        var part1 = Math.pow(Math.E, value);
        var part2 = Math.pow(Math.E, -1.0 * value);

        return (part1 + part2) * 0.5;
    };

    /**
     * DOC_TBA
     */
    CesiumMath.lerp = function(p, q, time) {
        return ((1.0 - time) * p) + (time * q);
    };

    /**
     * 1/pi
     *
     * @constant
     * @type {Number}
     * @see agi_pi
     */
    CesiumMath.PI = Math.PI;

    /**
     * 1/pi
     *
     * @constant
     * @type {Number}
     * @see agi_oneOverPi
     */
    CesiumMath.ONE_OVER_PI = 1.0 / Math.PI;

    /**
     * pi/2
     *
     * @constant
     * @type {Number}
     * @see agi_piOverTwo
     */
    CesiumMath.PI_OVER_TWO = Math.PI * 0.5;

    /**
     * pi/3
     * <br /><br />
     *
     * @constant
     * @type {Number}
     * @see agi_piOverThree
     */
    CesiumMath.PI_OVER_THREE = Math.PI / 3.0;

    /**
     * pi/4
     *
     * @constant
     * @type {Number}
     * @see agi_piOverFour
     */
    CesiumMath.PI_OVER_FOUR = Math.PI / 4.0;

    /**
     * pi/6
     *
     * @constant
     * @type {Number}
     * @see agi_piOverSix
     */
    CesiumMath.PI_OVER_SIX = Math.PI / 6.0;

    /**
     * 3pi/2
     *
     * @constant
     * @type {Number}
     * @see agi_threePiOver2
     */
    CesiumMath.THREE_PI_OVER_TWO = (3.0 * Math.PI) * 0.5;

    /**
     * 2pi
     *
     * @constant
     * @type {Number}
     * @see agi_twoPi
     */
    CesiumMath.TWO_PI = 2.0 * Math.PI;

    /**
     * 1/2pi
     *
     * @constant
     * @type {Number}
     * @see agi_oneOverTwoPi
     */
    CesiumMath.ONE_OVER_TWO_PI = 1.0 / (2.0 * Math.PI);

    /**
     * The number of radians in a degree.
     *
     * @constant
     * @type {Number}
     * @see agi_radiansPerDegree
     */
    CesiumMath.RADIANS_PER_DEGREE = Math.PI / 180.0;

    /**
     * The number of degrees in a radian.
     *
     * @constant
     * @type {Number}
     * @see agi_degreesPerRadian
     */
    CesiumMath.DEGREES_PER_RADIAN = 180.0 / Math.PI;

    /**
     * Converts degrees to radians.
     * @param {Number} degrees The angle to convert in degrees.
     * @return {Number} The corresponding angle in radians.
     */
    CesiumMath.toRadians = function(degrees) {
        return degrees * CesiumMath.RADIANS_PER_DEGREE;
    };

    /**
     * Converts the longitude and latitude of a {@link Cartographic3} from degrees to radians.  The height is not changed.
     * @param {Cartographic3} cartographic The cartographic position to convert in degrees.
     * @return {Cartographic3} The corresponding cartographic position with longitude and latitude in radians.
     */
    CesiumMath.cartographic3ToRadians = function(cartographic) {
        return new Cartographic3(
                CesiumMath.toRadians(cartographic.longitude),
                CesiumMath.toRadians(cartographic.latitude),
                cartographic.height);
    };

    /**
     * Converts the longitude and latitude of a {@link Cartographic2} from degrees to radians.
     * @param {Cartographic2} cartographic The cartographic position to convert in degrees.
     * @return {Cartographic2} The corresponding cartographic position in radians.
     */
    CesiumMath.cartographic2ToRadians = function(cartographic) {
        return new Cartographic2(
                CesiumMath.toRadians(cartographic.longitude),
                CesiumMath.toRadians(cartographic.latitude));
    };

    /**
     * Converts radians to degrees.
     * @param {Number} radians The angle to convert in radians.
     * @return {Number} The corresponding angle in degrees.
     */
    CesiumMath.toDegrees = function(radians) {
        return radians * CesiumMath.DEGREES_PER_RADIAN;
    };

    /**
     * Converts the longitude and latitude of a {@link Cartographic3} from radians to degrees.  The height is not changed.
     * @param {Cartographic3} cartographic The cartographic position to convert in radians.
     * @return {Cartographic3} The corresponding cartographic position with longitude and latitude in degrees.
     */
    CesiumMath.cartographic3ToDegrees = function(cartographic) {
        return new Cartographic3(
                CesiumMath.toDegrees(cartographic.longitude),
                CesiumMath.toDegrees(cartographic.latitude),
                cartographic.height);
    };

    /**
     * Converts the longitude and latitude of a {@link Cartographic2} from radians to degrees.
     * @param {Cartographic2} cartographic The cartographic position to convert in radians.
     * @return {Cartographic2} The corresponding cartographic position in degrees.
     */
    CesiumMath.cartographic2ToDegrees = function(cartographic) {
        return new Cartographic2(
                CesiumMath.toDegrees(cartographic.longitude),
                CesiumMath.toDegrees(cartographic.latitude));
    };

    /**
     * Converts a longitude value, in radians, to the range [<code>-Math.PI</code>, <code>Math.PI</code>).
     *
     * @param {Number} angle The longitude value, in radians, to convert to the range [<code>-Math.PI</code>, <code>Math.PI</code>).
     *
     * @return {Number} The equivalent longitude value in the range [<code>-Math.PI</code>, <code>Math.PI</code>).
     *
     * @example
     * // Convert 270 degrees to -90 degrees longitude
     * var longitude = CesiumMath.convertLongitudeRange(CesiumMath.toRadians(270.0));
     */
    CesiumMath.convertLongitudeRange = function(angle) {
        var twoPi = CesiumMath.TWO_PI;

        var simplified = angle - Math.floor(angle / twoPi) * twoPi;
        if (simplified < -Math.PI) {
            simplified += twoPi;
        } else if (simplified >= Math.PI) {
            simplified -= twoPi;
        }
        return simplified;
    };

    /**
     * Alters the value of input x such that <code>-CesiumMath.PI</code> <= x <= <code>CesiumMath.PI</code>
     * @param {Number} angle in radians
     * @return {Number} The angle in the range ()<code>-CesiumMath.PI</code>, <code>CesiumMath.PI</code>).
    */
    CesiumMath.negativePiToPi = function(x){
        var epsilon10 = CesiumMath.EPSILON10;
        var pi = CesiumMath.PI;
        var two_pi = CesiumMath.TWO_PI;
        while(x < -(pi+ epsilon10)){
            x += two_pi;
        }
        if(x < -pi){
            x = -pi;
        }
        while(x > pi + epsilon10){
            x-=two_pi;
        }
        if(x > pi){
            x = pi;
        }
        return x;
    };

    /**
     * DOC_TBA
     */
    CesiumMath.equalsEpsilon = function(left, right, epsilon) {
        epsilon = epsilon || 0.0;
        return Math.abs(left - right) <= epsilon;
    };

    return CesiumMath;
});

/*global define*/
define('Core/Ellipsoid',[
        './DeveloperError',
        './Math',
        './Cartesian3',
        './Cartographic2',
        './Cartographic3'
    ], function(
        DeveloperError,
        CesiumMath,
        Cartesian3,
        Cartographic2,
        Cartographic3) {
    

    /**
     * DOC_TBA
     * @name Ellipsoid
     *
     * @param {Cartesian3} radii The ellipsoid's radius in the x, y, and z ds.
     *
     * @constructor
     * @immutable
     *
     * @exception {DeveloperError} One argument is required.
     * @exception {DeveloperError} All radii components must be greater than or equal to zero.
     */
    function Ellipsoid() {
        if (arguments.length === 0) {
            throw new DeveloperError("One argument is required.");
        }

        if (arguments[0].x < 0 || arguments[0].y < 0 || arguments[0].z < 0) {
            throw new DeveloperError("All radii components must be greater than or equal to zero.", "radii");
        }

        var radii = Cartesian3.clone(arguments[0]);
        var x = radii.x;
        var y = radii.y;
        var z = radii.z;

        this._radii = radii;
        this._radiiSquared = new Cartesian3(
                x * x,
                y * y,
                z * z);
        this._radiiToTheFourth = new Cartesian3(
                x * x * x * x,
                y * y * y * y,
                z * z * z * z);
        this._oneOverRadii = new Cartesian3(
                1.0 / x,
                1.0 / y,
                1.0 / z);
        this._oneOverRadiiSquared = new Cartesian3(
                1.0 / (x * x),
                1.0 / (y * y),
                1.0 / (z * z));
    }

    /**
     * DOC_TBA
     *
     * @memberof Ellipsoid
     *
     * @return {Ellipsoid} DOC_TBA
     *
     * @see agi_getWgs84EllipsoidEC
     */
    Ellipsoid.getWgs84 = function() {
        return new Ellipsoid(new Cartesian3(6378137.0, 6378137.0, 6356752.314245));
    };

    /**
     * DOC_TBA
     *
     * @memberof Ellipsoid
     *
     * @return {Ellipsoid} DOC_TBA
     */
    Ellipsoid.getScaledWgs84 = function() {
        return new Ellipsoid(new Cartesian3(1.0, 1.0, 6356752.314245 / 6378137.0));
    };

    /**
     * DOC_TBA
     *
     * @memberof Ellipsoid
     *
     * @return {Ellipsoid} DOC_TBA
     */
    Ellipsoid.getUnitSphere = function() {
        return new Ellipsoid(new Cartesian3(1.0, 1.0, 1.0));
    };

    /**
     * DOC_TBA
     *
     * @memberof Ellipsoid
     *
     * @return {Cartesian3} DOC_TBA
     */
    Ellipsoid.prototype.getRadii = function() {
        return this._radii;
    };

    /**
     * DOC_TBA
     *
     * @memberof Ellipsoid
     *
     * @return {Cartesian3} DOC_TBA
     */
    Ellipsoid.prototype.getRadiiSquared = function() {
        return this._radiiSquared;
    };

    /**
     * DOC_TBA
     *
     * @memberof Ellipsoid
     *
     * @return {Cartesian3} DOC_TBA
     */
    Ellipsoid.prototype.getRadiiToTheFourth = function() {
        return this._radiiToTheFourth;
    };

    /**
     * DOC_TBA
     *
     * @memberof Ellipsoid
     *
     * @return {Cartesian3} DOC_TBA
     */
    Ellipsoid.prototype.getOneOverRadii = function() {
        return this._oneOverRadii;
    };

    /**
     * DOC_TBA
     *
     * @memberof Ellipsoid
     *
     * @return {Cartesian3} DOC_TBA
     */
    Ellipsoid.prototype.getOneOverRadiiSquared = function() {
        return this._oneOverRadiiSquared;
    };

    /**
     * DOC_TBA
     *
     * @memberof Ellipsoid
     *
     * @return {Number} DOC_TBA
     */
    Ellipsoid.prototype.getMinimumRadius = function() {
        var radii = this.getRadii();
        return Math.min(radii.x, Math.min(radii.y, radii.z));
    };

    /**
     * DOC_TBA
     *
     * @memberof Ellipsoid
     *
     * @return {Number} DOC_TBA
     */
    Ellipsoid.prototype.getMaximumRadius = function() {
        var radii = this.getRadii();
        return Math.max(radii.x, Math.max(radii.y, radii.z));
    };

    /**
     * DOC_TBA
     *
     * @memberof Ellipsoid
     *
     * @param {Cartesian3} positionOnEllipsoid DOC_TBA
     *
     * @return {Cartesian3} DOC_TBA
     */
    Ellipsoid.geocentricSurfaceNormal = function(positionOnEllipsoid) {
        var position = Cartesian3.clone(positionOnEllipsoid);
        return position.normalize();
    };

    /**
     * DOC_TBA
     *
     * @memberof Ellipsoid
     *
     * @param {Cartesian3} positionOnEllipsoid DOC_TBA
     *
     * @return {Cartesian3} DOC_TBA
     */
    Ellipsoid.prototype.geodeticSurfaceNormal = function(positionOnEllipsoid) {
        var position = Cartesian3.clone(positionOnEllipsoid);
        return (position.multiplyComponents(this.getOneOverRadiiSquared())).normalize();
    };

    /**
     * DOC_TBA
     *
     * @memberof Ellipsoid
     *
     * @param {Cartographic3} position DOC_TBA
     * @return {Cartesian3} DOC_TBA
     */
    Ellipsoid.prototype.geodeticSurfaceNormalc = function(position) {
        var cosLatitude = Math.cos(position.latitude);

        return new Cartesian3(
                cosLatitude * Math.cos(position.longitude),
                cosLatitude * Math.sin(position.longitude),
                Math.sin(position.latitude));
    };

    /**
     * DOC_TBA
     *
     * @memberof Ellipsoid
     *
     * @param {Cartographic3} position DOC_TBA  (or Cartographic2)
     * @return {Cartesian3} DOC_TBA
     */
    Ellipsoid.prototype.toCartesian = function(position) {
        var n = this.geodeticSurfaceNormalc(position);
        var k = this.getRadiiSquared().multiplyComponents(n);
        var gamma = Math.sqrt((k.x * n.x) + (k.y * n.y) + (k.z * n.z));

        var rSurface = k.divideByScalar(gamma);
        return rSurface.add(n.multiplyWithScalar(position.height || 0.0));
    };

    /**
     * DOC_TBA
     *
     * @memberof Ellipsoid
     *
     * Input is array of Cartographic3 or Cartographic2.
     */
    Ellipsoid.prototype.toCartesians = function(positions) {
        if (positions) {
            var cartesians = [];

            var length = positions.length;
            for ( var i = 0; i < length; ++i) {
                cartesians.push(this.toCartesian(positions[i]));
            }

            return cartesians;
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof Ellipsoid
     *
     * @param position Input is Cartographic3 or Cartographic2.
     */
    Ellipsoid.prototype.cartographicDegreesToCartesian = function(position) {
        if (position) {
            var cartographic = new Cartographic3(
                    CesiumMath.toRadians(position.longitude),
                    CesiumMath.toRadians(position.latitude),
                    position.height || 0.0);
            return this.toCartesian(cartographic);
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof Ellipsoid
     *
     * @param positions Input is array of Cartographic3 or Cartographic2.
     */
    Ellipsoid.prototype.cartographicDegreesToCartesians = function(positions) {
        if (positions) {
            var cartesians = [];

            var length = positions.length;
            for ( var i = 0; i < length; ++i) {
                var cartographic = positions[i];

                cartesians.push(this.toCartesian(
                        new Cartographic3(
                                CesiumMath.toRadians(cartographic.longitude),
                                CesiumMath.toRadians(cartographic.latitude),
                                cartographic.height || 0.0)));
            }

            return cartesians;
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof Ellipsoid
     *
     * @param {Cartesian3} positionOnSurface DOC_TBA
     * @return {Cartographic2} DOC_TBA
     */
    Ellipsoid.prototype.toCartographic2 = function(positionOnSurface) {
        var p = Cartesian3.clone(positionOnSurface);
        var n = this.geodeticSurfaceNormal(p);
        return new Cartographic2(
                Math.atan2(n.y, n.x),
                Math.asin(n.z / n.magnitude()));
    };

    /**
     * DOC_TBA
     *
     * @memberof Ellipsoid
     *
     * @param {Cartesian3} position DOC_TBA
     * @return {Cartographic3} DOC_TBA
     */
    Ellipsoid.prototype.toCartographic3 = function(position) {
        var pos = Cartesian3.clone(position);
        var p = this.scaleToGeodeticSurface(pos);
        var h = position.subtract(p);
        var height = CesiumMath.sign(h.dot(pos)) * h.magnitude();
        var c = this.toCartographic2(p);
        return new Cartographic3(c.longitude, c.latitude, height);
    };

    /**
     * DOC_TBA
     *
     * @memberof Ellipsoid
     */
    Ellipsoid.prototype.toCartographic3s = function(positions) {
        if (positions) {
            var cartographics = [];

            var length = positions.length;
            for ( var i = 0; i < length; ++i) {
                cartographics.push(this.toCartographic3(positions[i]));
            }

            return cartographics;
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof Ellipsoid
     *
     * @param {Cartesian3} position DOC_TBA
     * @return {Cartesian3} DOC_TBA
     */
    Ellipsoid.prototype.scaleToGeodeticSurface = function(position) {
        var pos = Cartesian3.clone(position);
        var positionX = position.x;
        var positionY = position.y;
        var positionZ = position.z;

        var oneOverRadiiSquared = this.getOneOverRadiiSquared();
        var oneOverRadiiSquaredX = oneOverRadiiSquared.x;
        var oneOverRadiiSquaredY = oneOverRadiiSquared.y;
        var oneOverRadiiSquaredZ = oneOverRadiiSquared.z;

        var radiiSquared = this.getRadiiSquared();
        var radiiSquaredX = radiiSquared.x;
        var radiiSquaredY = radiiSquared.y;
        var radiiSquaredZ = radiiSquared.z;

        var radiiToTheFourth = this.getRadiiToTheFourth();
        var radiiToTheFourthX = radiiToTheFourth.x;
        var radiiToTheFourthY = radiiToTheFourth.y;
        var radiiToTheFourthZ = radiiToTheFourth.z;

        var beta = 1.0 / Math.sqrt(
                (positionX * positionX) * oneOverRadiiSquaredX +
                (positionY * positionY) * oneOverRadiiSquaredY +
                (positionZ * positionZ) * oneOverRadiiSquaredZ);
        var n = new Cartesian3(
                beta * positionX * oneOverRadiiSquaredX,
                beta * positionY * oneOverRadiiSquaredY,
                beta * positionZ * oneOverRadiiSquaredZ).magnitude();
        var alpha = (1.0 - beta) * (pos.magnitude() / n);

        var x2 = positionX * positionX;
        var y2 = positionY * positionY;
        var z2 = positionZ * positionZ;

        var da = 0.0;
        var db = 0.0;
        var dc = 0.0;

        var s = 0.0;
        var dSdA = 1.0;

        do {
            alpha -= (s / dSdA);

            da = 1.0 + (alpha * oneOverRadiiSquaredX);
            db = 1.0 + (alpha * oneOverRadiiSquaredY);
            dc = 1.0 + (alpha * oneOverRadiiSquaredZ);

            var da2 = da * da;
            var db2 = db * db;
            var dc2 = dc * dc;

            var da3 = da * da2;
            var db3 = db * db2;
            var dc3 = dc * dc2;

            s = x2 / (radiiSquaredX * da2) +
                y2 / (radiiSquaredY * db2) +
                z2 / (radiiSquaredZ * dc2) - 1.0;

            dSdA = -2.0 *
                    (x2 / (radiiToTheFourthX * da3) +
                     y2 / (radiiToTheFourthY * db3) +
                     z2 / (radiiToTheFourthZ * dc3));
        } while (Math.abs(s) > CesiumMath.EPSILON10);

        return new Cartesian3(
                positionX / da,
                positionY / db,
                positionZ / dc);
    };

    /**
     * DOC_TBA
     *
     * @memberof Ellipsoid
     *
     * @param {Cartesian3} position DOC_TBA
     * @return {Cartesian3} DOC_TBA
     */
    Ellipsoid.prototype.scaleToGeocentricSurface = function(position) {
        var pos = Cartesian3.clone(position);
        var positionX = position.x;
        var positionY = position.y;
        var positionZ = position.z;
        var oneOverRadiiSquared = this.getOneOverRadiiSquared();

        var beta = 1.0 / Math.sqrt(
                (positionX * positionX) * oneOverRadiiSquared.x +
                (positionY * positionY) * oneOverRadiiSquared.y +
                (positionZ * positionZ) * oneOverRadiiSquared.z);

        return pos.multiplyWithScalar(beta);
    };

    /**
     * Returns <code>true</code> if this ellipsoid equals <code>other</code>, meaning their radii are equal.
     *
     * @memberof Ellipsoid
     *
     * @param {Ellipsoid} other The Ellipsoid to compare for equality.
     *
     * @return {Boolean} <code>true</code> if the ellipsoids are equal; otherwise, <code>false</code>.
     */
    Ellipsoid.prototype.equals = function(other) {
        return this._radii.equals(other._radii);
    };

    return Ellipsoid;
});

/*global define*/
define('Core/EquidistantCylindricalProjection',[
        './Math',
        './Cartesian3',
        './Ellipsoid'
    ], function(
        CesiumMath,
        Cartesian3,
        Ellipsoid) {
    

    /**
     * DOC_TBA
     * @name EquidistantCylindricalProjection
     * @constructor
     *
     * @immutable
     */
    function EquidistantCylindricalProjection(ellipsoid) {
        ellipsoid = ellipsoid || Ellipsoid.getWgs84();

        var radii = ellipsoid.getRadii();

        this._ellipsoid = ellipsoid;
        this._halfEquatorCircumference = Math.PI * (Math.max(radii.x, radii.y));
        this._quarterPolarCircumference = 0.5 * Math.PI * radii.z;
    }

    /*
     * DOC_TBA
     * @memberof EquidistantCylindricalProjection
     */
    EquidistantCylindricalProjection.prototype.getEllipsoid = function() {
        return this._ellipsoid;
    };

    /*
     * DOC_TBA
     * @memberof EquidistantCylindricalProjection
     */
    EquidistantCylindricalProjection.prototype.project = function(cartographic) {
        // Scale to [-1, 1]
        var lon = cartographic.longitude / Math.PI;
        var lat = cartographic.latitude / CesiumMath.PI_OVER_TWO;

        // Actually this is the special case of equidistant cylindrical called the plate carree
        return new Cartesian3(lon * this._halfEquatorCircumference, lat * this._quarterPolarCircumference, cartographic.height);
    };

    return EquidistantCylindricalProjection;
});

/*global define*/
define('Core/IntersectionTests',[
        './DeveloperError',
        './Math',
        './Cartesian3'
    ],
    function(
        DeveloperError,
        CesiumMath,
        Cartesian3) {
    

    /**
     * DOC_TBA
     *
     * @exports IntersectionTests
     */
    var IntersectionTests = {
        /**
         * DOC_TBA
         *
         * @param {Cartesian3} rayOrigin DOC_TBA
         * @param {Cartesian3} rayDirection DOC_TBA
         * @param {Cartesian3} planeNormal DOC_TBA
         * @param {Number} planeD DOC_TBA
         *
         * @exception {DeveloperError} rayOrigin is required.
         * @exception {DeveloperError} rayDirection is required.
         * @exception {DeveloperError} planeNormal is required.
         * @exception {DeveloperError} planeD is required.
         */
        rayPlane : function(rayOrigin, rayDirection, planeNormal, planeD) {
            if (!rayOrigin) {
                throw new DeveloperError("rayOrigin is required.", "rayOrigin");
            }

            if (!rayDirection) {
                throw new DeveloperError("rayDirection is required.", "rayDirection");
            }

            if (!planeNormal) {
                throw new DeveloperError("planeNormal is required.", "planeNormal");
            }

            if (!planeD) {
                throw new DeveloperError("planeD is required.", "planeD");
            }

            var origin = Cartesian3.clone(rayOrigin);
            var direction = Cartesian3.clone(rayDirection);
            var normal = Cartesian3.clone(planeNormal);

            var denominator = normal.dot(direction);

            if (Math.abs(denominator) < CesiumMath.EPSILON15) {
                // Ray is parallel to plane.  The ray may be in the polygon's plane.
                return undefined;
            }

            var t = (-planeD - normal.dot(origin)) / denominator;

            if (t < 0) {
                return undefined;
            }

            return origin.add(direction.multiplyWithScalar(t));
        },

        rayEllipsoid : function(rayOrigin, rayDirection, ellipsoid) {
            if (!rayOrigin) {
                throw new DeveloperError("rayOrigin is required.", "rayOrigin");
            }

            if (!rayDirection) {
                throw new DeveloperError("rayDirection is required.", "rayDirection");
            }

            if (!ellipsoid) {
                throw new DeveloperError("ellipsoid is required.", "ellipsoid");
            }

            var inverseRadii = ellipsoid.getOneOverRadii();
            var q = inverseRadii.multiplyComponents(rayOrigin);
            var w = inverseRadii.multiplyComponents(rayDirection);

            var q2 = q.magnitudeSquared();
            var qw = q.dot(w);

            var difference, w2, product, discriminant, temp;

            if (q2 > 1.0) {
                // Outside ellipsoid.
                if (qw >= 0.0) {
                    // Looking outward or tangent (0 intersections).
                    return undefined;
                }

                // qw < 0.0.
                var qw2 = qw * qw;
                difference = q2 - 1.0; // Positively valued.
                w2 = w.magnitudeSquared();
                product = w2 * difference;

                if (qw2 < product) {
                    // Imaginary roots (0 intersections).
                    return undefined;
                } else if (qw2 > product) {
                    // Distinct roots (2 intersections).
                    discriminant = qw * qw - product;
                    temp = -qw + Math.sqrt(discriminant); // Avoid cancellation.
                    var root0 = temp / w2;
                    var root1 = difference / temp;
                    if (root0 < root1) {
                        return {
                            start : root0,
                            stop : root1
                        };
                    }

                    return {
                        start : root1,
                        stop : root0
                    };
                } else {
                    // qw2 == product.  Repeated roots (2 intersections).
                    var root = Math.sqrt(difference / w2);
                    return {
                        start : root,
                        stop : root
                    };
                }

            } else if (q2 < 1.0) {
                // Inside ellipsoid (2 intersections).
                difference = q2 - 1.0; // Negatively valued.
                w2 = w.magnitudeSquared();
                product = w2 * difference; // Negatively valued.
                if (qw < 0.0) {
                    // Looking inward.
                    discriminant = qw * qw - product;
                    temp = qw - Math.sqrt(discriminant); // Avoid cancellation.  Negatively valued.
                    return {
                        start : 0.0,
                        stop : difference / temp
                    };
                } else if (qw > 0.0) {
                    // Looking outward.
                    discriminant = qw * qw - product;
                    temp = qw + Math.sqrt(discriminant); // Avoid cancellation. Positively valued.
                    return {
                        start : 0.0,
                        stop : temp / w2
                    };
                } else {
                    // qw == 0.0 // Looking tangent.
                    temp = Math.sqrt(-product);
                    return {
                        start : 0.0,
                        stop : temp / w2
                    };
                }
            } else {
                // q2 == 1.0. On ellipsoid.
                if (qw < 0.0) {
                    // Looking inward.
                    w2 = w.magnitudeSquared();
                    return {
                        start : 0.0,
                        stop : -qw / w2
                    };
                }

                // qw >= 0.0.  Looking outward or tangent.
                return undefined;
            }
        }
    };

    return IntersectionTests;
});

/*global define*/
define('Core/Matrix2',[
        './DeveloperError',
        './Cartesian2'
    ],
    function(
        DeveloperError,
        Cartesian2) {
    

    var numberOfElements = 4;

    /**
     * A 2x2 matrix, stored internally in column-major order.
     *
     * <p>
     * When called with no arguments, the matrix elements are initialized to all zeros.
     * When called with one numeric argument, f, the columns are initialized to [f, 0] [0, f].  Hence new Matrix2(1) creates the identity matrix.
     * When called with four numeric arguments which define the matrix elements in row-major order; column0Row0, column1Row0, column0Row1, and column1Row1; the matrix is initialized to [column0Row0, column0Row1] [column1Row0, column1Row1].
     * </p>
     *
     * @name Matrix2
     * @constructor
     * @immutable
     *
     * @see Matrix3
     * @see Matrix4
     */
    function Matrix2() {
        var values = this.values = []; // Column-major
        values.length = numberOfElements;

        if (arguments.length === 0) {
            for ( var i = 0; i < numberOfElements; ++i) {
                values[i] = 0;
            }
        } else if (arguments.length < numberOfElements) {
            values[0] = arguments[0];
            values[1] = 0;

            values[2] = 0;
            values[3] = arguments[0];
        } else if (arguments.length >= numberOfElements) {

            values[0] = arguments[0]; // Column 0, Row 0
            values[1] = arguments[2]; // Column 1, Row 0

            values[2] = arguments[1]; // Column 0, Row 0
            values[3] = arguments[3]; // Column 1, Row 1
        }
    }

    /**
     * Returns the element at column 0, row 0.
     *
     * @memberof Matrix2
     * @return {Number} The element at column 0, row 0.
     */
    Matrix2.prototype.getColumn0Row0 = function() {
        return this.values[0];
    };

    /**
     * Returns the element at column 0, row 1.
     *
     * @memberof Matrix2
     * @return {Number} The element at column 0, row 1.
     */
    Matrix2.prototype.getColumn0Row1 = function() {
        return this.values[1];
    };

    /**
     * Returns the element at column 1, row 0.
     *
     * @memberof Matrix2
     * @return {Number} The element at column 1, row 0.
     */
    Matrix2.prototype.getColumn1Row0 = function() {
        return this.values[2];
    };

    /**
     * Returns the element at column 1, row 1.
     *
     * @memberof Matrix2
     * @return {Number} The element at column 1, row 1.
     */
    Matrix2.prototype.getColumn1Row1 = function() {
        return this.values[3];
    };

    /**
     * Returns the element at the zero-based, column-major index.
     *
     * @memberof Matrix2
     * @return {Number} The element at the zero-based, column-major index.
     * @exception {DeveloperError} Index must be between 0 and 3.
     */
    Matrix2.prototype.getColumnMajorValue = function(index) {
        if (index < 0 || index > 3) {
            throw new DeveloperError("Index must be between 0 and 3.", "index");
        }

        return this.values[index];
    };

    /**
     * Creates a 2x2 uniform scale matrix.
     *
     * @memberof Matrix2
     *
     * @param {Number} scale The uniform scale in the x and y directions.
     *
     * @see Matrix2.createNonUniformScale
     *
     * @example
     * var m = Matrix2.createScale(2.0);
     * var v = m.multiplyWithVector(new Cartesian2(1.0, 1.0));
     * // v is (2.0, 2.0)
     */
    Matrix2.createScale = function(scale) {
        if (scale) {
            return new Matrix2(
                    scale, 0.0,
                    0.0,   scale);
        }

        return new Matrix2();
    };

    /**
     * Creates a 2x2 non-uniform scale matrix.
     *
     * @memberof Matrix2
     *
     * @param {Cartesian3} scale The non-uniform scale in the x and y directions.
     *
     * @see Matrix2.createScale
     *
     * @example
     * var m = Matrix2.createNonUniformScale(new Cartesian2(1.0, 2.0));
     * var v = m.multiplyWithVector(new Cartesian2(1.0, 1.0));
     * // v is (1.0, 2.0)
     */
    Matrix2.createNonUniformScale = function(scale) {
        if (scale) {
            return new Matrix2(
                    scale.x, 0.0,
                    0.0,     scale.y);
        }

        return new Matrix2();
    };

    /**
     * Returns a copy of the first, i.e. left, column of this matrix.
     *
     * @memberof Matrix2
     *
     * @return {Cartesian2} The first column of this matrix.
     *
     * @see Matrix2#setColumn0
     *
     * @example
     * var m = Matrix2.getIdentity();
     * var c = m.getColumn0(); // (x, y) == (1.0, 0.0)
     */
    Matrix2.prototype.getColumn0 = function() {
        var values = this.values;
        return new Cartesian2(values[0], values[1]);
    };

    /**
     * Sets the first, i.e. left, column of this matrix.
     *
     * @memberof Matrix2
     *
     * @param {Cartesian2} column The first column of this matrix.
     *
     * @see Matrix2#getColumn0
     *
     * @example
     * // Column will be (1.0, 2.0)
     * m.setColumn0(new Cartesian2(1.0, 2.0));
     */
    Matrix2.prototype.setColumn0 = function(column) {
        var values = this.values;
        values[0] = column.x;
        values[1] = column.y;
    };

    /**
     * Returns a copy of the second, i.e. right, column of this matrix.
     *
     * @memberof Matrix2
     *
     * @return {Cartesian2} The second column of this matrix.
     *
     * @see Matrix2#setColumn1
     *
     * @example
     * var m = Matrix2.getIdentity();
     * var c = m.getColumn1(); // (x, y) == (0.0, 1.0)
     */
    Matrix2.prototype.getColumn1 = function() {
        var values = this.values;
        return new Cartesian2(values[2], values[3]);
    };

    /**
     * Sets the second, i.e. right, column of this matrix.
     *
     * @memberof Matrix2
     *
     * @param {Cartesian2} column The second column of this matrix.
     *
     * @see Matrix2#getColumn1
     *
     * @example
     * // Column will be (1.0, 2.0)
     * m.setColumn1(new Cartesian2(1.0, 2.0));
     */
    Matrix2.prototype.setColumn1 = function(column) {
        var values = this.values;
        values[2] = column.x;
        values[3] = column.y;
    };

    /**
     * Returns a copy of the first, i.e. top, row of this matrix.
     *
     * @memberof Matrix2
     *
     * @return {Cartesian2} The first row of this matrix.
     *
     * @see Matrix2#setRow0
     *
     * @example
     * var m = Matrix2.getIdentity();
     * var c = m.getRow0(); // (x, y) == (1.0, 0.0)
     */
    Matrix2.prototype.getRow0 = function() {
        var values = this.values;
        return new Cartesian2(values[0], values[2]);
    };

    /**
     * Sets the first, i.e. top, row of this matrix.
     *
     * @memberof Matrix2
     *
     * @param {Cartesian2} row The first row of this matrix.
     *
     * @see Matrix2#getRow0
     *
     * @example
     * // Row will be (1.0, 2.0)
     * m.setRow0(new Cartesian2(1.0, 2.0));
     */
    Matrix2.prototype.setRow0 = function(row) {
        var values = this.values;
        values[0] = row.x;
        values[2] = row.y;
    };

    /**
     * Returns a copy of the second, i.e. bottom, row of this matrix.
     *
     * @memberof Matrix2
     *
     * @return {Cartesian2} The second row of this matrix.
     *
     * @see Matrix2#setRow1
     *
     * @example
     * var m = Matrix2.getIdentity();
     * var c = m.getRow1(); // (x, y) == (0.0, 1.0)
     */
    Matrix2.prototype.getRow1 = function() {
        var values = this.values;
        return new Cartesian2(values[1], values[3]);
    };

    /**
     * Sets the second, i.e. bottom, row of this matrix.
     *
     * @memberof Matrix2
     *
     * @param {Cartesian2} row The second row of this matrix.
     *
     * @see Matrix2#getRow1
     *
     * @example
     * // Row will be (1.0, 2.0)
     * m.setRow1(new Cartesian2(1.0, 2.0));
     */
    Matrix2.prototype.setRow1 = function(row) {
        var values = this.values;
        values[1] = row.x;
        values[3] = row.y;
    };

    /**
     * DOC_TBA
     *
     * @memberof Matrix2
     *
     * @exception {DeveloperError} columnMajorValues must have 4 elements.
     */
    Matrix2.createFromColumnMajorArray = function(columnMajorValues) {
        if (columnMajorValues) {
            if (columnMajorValues.length === numberOfElements) {
                return new Matrix2(
                        columnMajorValues[0], columnMajorValues[2],
                        columnMajorValues[1], columnMajorValues[3]);
            }

            throw new DeveloperError("columnMajorValues must have 4 elements.", "columnMajorValues");
        }
        return new Matrix2();
    };

    /**
     * Creates a Matrix2 instance initialized to the identity matrix.
     *
     * @memberof Matrix2
     *
     * @return {Matrix2} A new Matrix2 instance initialized to the identity matrix.
     */
    Matrix2.getIdentity = function() {
        return new Matrix2(1);
    };

    /**
     * Returns 4, the number of elements in a Matrix2.
     *
     * @memberof Matrix2
     *
     * @return {Number} 4.
     */
    Matrix2.getNumberOfElements = function() {
        return numberOfElements;
    };

    /**
     * Returns the transpose of this matrix.
     *
     * @memberof Matrix2
     *
     * @return {Matrix2} The transpose of this matrix.
     */
    Matrix2.prototype.transpose = function() {
        return new Matrix2(
                this.getColumn0Row0(), this.getColumn0Row1(),
                this.getColumn1Row0(), this.getColumn1Row1());
    };

    /**
     * Returns a duplicate of a Matrix3 instance.
     *
     * @memberof Matrix2
     *
     * @return {Matrix2} A new copy of the Matrix3 instance.
     */
    Matrix2.prototype.clone = function() {
        return new Matrix2(
                this.getColumn0Row0(), this.getColumn1Row0(),
                this.getColumn0Row1(), this.getColumn1Row1());
    };

    /**
     * Returns <code>true</code> if this matrix equals other element-wise.
     *
     * @memberof Matrix2
     * @param {Matrix2} other The matrix to compare for equality.
     * @return {Boolean} <code>true</code> if the matrices are equal element-wise; otherwise, <code>false</code>.
     */
    Matrix2.prototype.equals = function(other) {
        for ( var i = 0; i < numberOfElements; ++i) {
            if (this.getColumnMajorValue(i) !== other.getColumnMajorValue(i)) {
                return false;
            }
        }
        return true;
    };

    /**
     * Returns <code>true</code> if this matrix equals other element-wise within the specified epsilon.
     *
     * @memberof Matrix2
     *
     * @param {Matrix2} other The matrix to compare for equality.
     * @param {Number} [epsilon=0.0] The epsilon to use for equality testing.
     *
     * @return {Boolean} <code>true</code> if the matrices are equal element-wise within the specified epsilon; otherwise, <code>false</code>.
     */
    Matrix2.prototype.equalsEpsilon = function(other, epsilon) {
        epsilon = epsilon || 0.0;
        for ( var i = 0; i < numberOfElements; ++i) {
            if (Math.abs(this.getColumnMajorValue(i) - other.getColumnMajorValue(i)) > epsilon) {
                return false;
            }
        }
        return true;
    };

    /**
     * Returns a string representing this instance with one line per row in the matrix.
     *
     * @memberof Matrix2
     *
     * @return {String} Returns a string representing this instance.
     */
    Matrix2.prototype.toString = function() {
        return "(" + this.getColumn0Row0() + ", " + this.getColumn1Row0() + ")\n" +
               "(" + this.getColumn0Row1() + ", " + this.getColumn1Row1() + ")";
    };

    return Matrix2;
});

/*global define*/
define('Core/Matrix3',[
        './DeveloperError',
        './Cartesian3'
    ],
    function(
        DeveloperError,
        Cartesian3) {
    

    var numberOfElements = 9;

    /**
     * A 3x3 matrix, stored internally in column-major order.
     *
     * <p>
     * When called with no arguments, the matrix elements are initialized to all zeros.
     * When called with one numeric argument, f, the columns are initialized to [f, 0, 0] [0, f, 0] [0, 0, f].  Hence new Matrix3(1) creates the identity matrix.
     * When called with nine numeric arguments in row-major order, these arguments define the elements of the matrix.
     * </p>
     *
     * @name Matrix3
     * @constructor
     * @immutable
     *
     * @see Matrix3.createFromColumnMajorArray
     * @see Matrix2
     * @see Matrix4
     * @see Quaternion
     */
    function Matrix3() {
        var values = this.values = []; // Column-major
        values.length = numberOfElements;

        if (arguments.length === 0) {
            for ( var i = 0; i < numberOfElements; ++i) {
                values[i] = 0;
            }
        } else if (arguments.length < numberOfElements) {
            values[0] = arguments[0];
            values[1] = 0;
            values[2] = 0;

            values[3] = 0;
            values[4] = arguments[0];
            values[5] = 0;

            values[6] = 0;
            values[7] = 0;
            values[8] = arguments[0];
        } else if (arguments.length >= 9) {
            values[0] = arguments[0]; // Column 0, Row 0
            values[1] = arguments[3]; // Column 0, Row 1
            values[2] = arguments[6]; // Column 0, Row 2

            values[3] = arguments[1]; // Column 1, Row 0
            values[4] = arguments[4]; // Column 1, Row 1
            values[5] = arguments[7]; // Column 1, Row 2

            values[6] = arguments[2]; // Column 2, Row 0
            values[7] = arguments[5]; // Column 2, Row 1
            values[8] = arguments[8]; // Column 2, Row 2
        }
    }

    /**
     * Returns the element at column 0, row 0.
     *
     * @memberof Matrix3
     * @return {Number} The element at column 0, row 0.
     */
    Matrix3.prototype.getColumn0Row0 = function() {
        return this.values[0];
    };

    /**
     * Returns the element at column 0, row 1.
     *
     * @memberof Matrix3
     * @return {Number} The element at column 0, row 1.
     */
    Matrix3.prototype.getColumn0Row1 = function() {
        return this.values[1];
    };

    /**
     * Returns the element at column 0, row 2.
     *
     * @memberof Matrix3
     * @return {Number} The element at column 0, row 2.
     */
    Matrix3.prototype.getColumn0Row2 = function() {
        return this.values[2];
    };

    /**
     * Returns the element at column 1, row 0.
     *
     * @memberof Matrix3
     * @return {Number} The element at column 1, row 0.
     */
    Matrix3.prototype.getColumn1Row0 = function() {
        return this.values[3];
    };

    /**
     * Returns the element at column 1, row 1.
     *
     * @memberof Matrix3
     * @return {Number} The element at column 1, row 1.
     */
    Matrix3.prototype.getColumn1Row1 = function() {
        return this.values[4];
    };

    /**
     * Returns the element at column 1, row 2.
     *
     * @memberof Matrix3
     * @return {Number} The element at column 1, row 2.
     */
    Matrix3.prototype.getColumn1Row2 = function() {
        return this.values[5];
    };

    /**
     * Returns the element at column 2, row 0.
     *
     * @memberof Matrix3
     * @return {Number} The element at column 2, row 0.
     */
    Matrix3.prototype.getColumn2Row0 = function() {
        return this.values[6];
    };

    /**
     * Returns the element at column 2, row 1.
     *
     * @memberof Matrix3
     * @return {Number} The element at column 2, row 1.
     */
    Matrix3.prototype.getColumn2Row1 = function() {
        return this.values[7];
    };

    /**
     * Returns the element at column 2, row 1.
     *
     * @memberof Matrix3
     * @return {Number} The element at column 2, row 1.
     */
    Matrix3.prototype.getColumn2Row2 = function() {
        return this.values[8];
    };

    /**
     * Returns the element at the zero-based, column-major index.
     *
     * @memberof Matrix3
     * @return {Number} The element at the zero-based, column-major index.
     * @exception {DeveloperError} Index must be between 0 and 8.
     */
    Matrix3.prototype.getColumnMajorValue = function(index) {
        if (index < 0 || index > 8) {
            throw new DeveloperError("Index must be between 0 and 8.", "index");
        }

        return this.values[index];
    };

    /**
     * Creates a 3x3 uniform scale matrix.
     *
     * @memberof Matrix3
     *
     * @param {Number} scale The uniform scale in the x, y, and z directions.
     *
     * @see Matrix3.createNonUniformScale
     *
     * @example
     * var m = Matrix3.createScale(2.0);
     * var v = m.multiplyWithVector(new Cartesian3(1.0, 1.0, 1.0));
     * // v is (2.0, 2.0, 2.0)
     */
    Matrix3.createScale = function(scale) {
        if (scale) {
            return new Matrix3(
                    scale, 0.0,   0.0,
                    0.0,   scale, 0.0,
                    0.0,   0.0,   scale);
        }

        return new Matrix3();
    };

    /**
     * Creates a 3x3 non-uniform scale matrix.
     *
     * @memberof Matrix3
     *
     * @param {Cartesian3} scale The non-uniform scale in the x, y, and z directions.
     *
     * @see Matrix3.createScale
     *
     * @example
     * var m = Matrix3.createNonUniformScale(new Cartesian3(1.0, 2.0, 3.0));
     * var v = m.multiplyWithVector(new Cartesian3(1.0, 1.0, 1.0));
     * // v is (1.0, 2.0, 3.0)
     */
    Matrix3.createNonUniformScale = function(scale) {
        if (scale) {
            return new Matrix3(
                    scale.x, 0.0,     0.0,
                    0.0,     scale.y, 0.0,
                    0.0,     0.0,     scale.z);
        }

        return new Matrix3();
    };

    /**
     * Returns a copy of the first, i.e. leftmost, column of this matrix.
     *
     * @memberof Matrix3
     *
     * @return {Cartesian3} The first column of this matrix.
     *
     * @see Matrix3#setColumn0
     *
     * @example
     * var m = Matrix3.getIdentity();
     * var c = m.getColumn0(); // (x, y, z) == (1.0, 0.0, 0.0)
     */
    Matrix3.prototype.getColumn0 = function() {
        var values = this.values;
        return new Cartesian3(values[0], values[1], values[2]);
    };

    /**
     * Sets the first, i.e. leftmost, column of this matrix.
     *
     * @memberof Matrix3
     *
     * @param {Cartesian3} column The first column of this matrix.
     *
     * @see Matrix3#getColumn0
     *
     * @example
     * // Column will be (1.0, 2.0, 3.0)
     * m.setColumn0(new Cartesian3(1.0, 2.0, 3.0));
     */
    Matrix3.prototype.setColumn0 = function(column) {
        var values = this.values;
        values[0] = column.x;
        values[1] = column.y;
        values[2] = column.z;
    };

    /**
     * Returns a copy of the second column of this matrix.
     *
     * @memberof Matrix3
     *
     * @return {Cartesian3} The second column of this matrix.
     *
     * @see Matrix3#setColumn1
     *
     * @example
     * var m = Matrix3.getIdentity();
     * var c = m.getColumn1(); // (x, y, z) == (0.0, 1.0, 0.0)
     */
    Matrix3.prototype.getColumn1 = function() {
        var values = this.values;
        return new Cartesian3(values[3], values[4], values[5]);
    };

    /**
     * Sets the second column of this matrix.
     *
     * @memberof Matrix3
     *
     * @param {Cartesian3} column The second column of this matrix.
     *
     * @see Matrix3#getColumn1
     *
     * @example
     * // Column will be (1.0, 2.0, 3.0)
     * m.setColumn1(new Cartesian3(1.0, 2.0, 3.0));
     */
    Matrix3.prototype.setColumn1 = function(column) {
        var values = this.values;
        values[3] = column.x;
        values[4] = column.y;
        values[5] = column.z;
    };

    /**
     * Returns a copy of the third, i.e. rightmost, column of this matrix.
     *
     * @memberof Matrix3
     *
     * @return {Cartesian3} The third column of this matrix.
     *
     * @see Matrix3#setColumn2
     *
     * @example
     * var m = Matrix3.getIdentity();
     * var c = m.getColumn2(); // (x, y, z) == (0.0, 0.0, 1.0)
     */
    Matrix3.prototype.getColumn2 = function() {
        var values = this.values;
        return new Cartesian3(values[6], values[7], values[8]);
    };

    /**
     * Sets the third, i.e. rightmost, column of this matrix.
     *
     * @memberof Matrix3
     *
     * @param {Cartesian3} column The third column of this matrix.
     *
     * @see Matrix3#getColumn2
     *
     * @example
     * // Column will be (1.0, 2.0, 3.0)
     * m.setColumn1(new Cartesian3(1.0, 2.0, 3.0));
     */
    Matrix3.prototype.setColumn2 = function(column) {
        var values = this.values;
        values[6] = column.x;
        values[7] = column.y;
        values[8] = column.z;
    };

    /**
     * Returns a copy of the first, i.e. top, row of this matrix.
     *
     * @memberof Matrix3
     *
     * @return {Cartesian3} The first row of this matrix.
     *
     * @see Matrix3#setRow0
     *
     * @example
     * var m = Matrix3.getIdentity();
     * var c = m.getRow0(); // (x, y, z) == (1.0, 0.0, 0.0)
     */
    Matrix3.prototype.getRow0 = function() {
        var values = this.values;
        return new Cartesian3(values[0], values[3], values[6]);
    };

    /**
     * Sets the first, i.e. top, row of this matrix.
     *
     * @memberof Matrix3
     *
     * @param {Cartesian3} row The first row of this matrix.
     *
     * @see Matrix3#getRow0
     *
     * @example
     * // Row will be (1.0, 2.0, 3.0)
     * m.setRow0(new Cartesian3(1.0, 2.0, 3.0));
     */
    Matrix3.prototype.setRow0 = function(row) {
        var values = this.values;
        values[0] = row.x;
        values[3] = row.y;
        values[6] = row.z;
    };

    /**
     * Returns a copy of the second, e.g. middle, row of this matrix.
     *
     * @memberof Matrix3
     *
     * @return {Cartesian3} The second row of this matrix.
     *
     * @see Matrix3#setRow1
     *
     * @example
     * var m = Matrix3.getIdentity();
     * var c = m.getRow1(); // (x, y, z) == (0.0, 1.0, 0.0)
     */
    Matrix3.prototype.getRow1 = function() {
        var values = this.values;
        return new Cartesian3(values[1], values[4], values[7]);
    };

    /**
     * Sets the second, i.e. middle, row of this matrix.
     *
     * @memberof Matrix3
     *
     * @param {Cartesian3} row The second row of this matrix.
     *
     * @see Matrix3#getRow1
     *
     * @example
     * // Row will be (1.0, 2.0, 3.0)
     * m.setRow1(new Cartesian3(1.0, 2.0, 3.0));
     */
    Matrix3.prototype.setRow1 = function(row) {
        var values = this.values;
        values[1] = row.x;
        values[4] = row.y;
        values[7] = row.z;
    };

    /**
     * Returns a copy of the third, i.e. bottom, row of this matrix.
     *
     * @memberof Matrix3
     *
     * @return {Cartesian3} The third row of this matrix.
     *
     * @see Matrix3#setRow2
     *
     * @example
     * var m = Matrix3.getIdentity();
     * var c = m.getRow2(); // (x, y, z) == (0.0, 0.0, 1.0)
     */
    Matrix3.prototype.getRow2 = function() {
        var values = this.values;
        return new Cartesian3(values[2], values[5], values[8]);
    };

    /**
     * Sets the third, i.e. bottom, row of this matrix.
     *
     * @memberof Matrix3
     *
     * @param {Cartesian3} row The third row of this matrix.
     *
     * @see Matrix3#getRow2
     *
     * @example
     * // Row will be (1.0, 2.0, 3.0)
     * m.setRow2(new Cartesian3(1.0, 2.0, 3.0));
     */
    Matrix3.prototype.setRow2 = function(row) {
        var values = this.values;
        values[2] = row.x;
        values[5] = row.y;
        values[8] = row.z;
    };

    /**
     * DOC_TBA
     *
     * @memberof Matrix3
     *
     * @exception {DeveloperError} columnMajorValues must have 9 elements.
     */
    Matrix3.createFromColumnMajorArray = function(columnMajorValues) {
        if (columnMajorValues) {
            if (columnMajorValues.length === numberOfElements) {
                return new Matrix3(
                        columnMajorValues[0], columnMajorValues[3], columnMajorValues[6],
                        columnMajorValues[1], columnMajorValues[4], columnMajorValues[7],
                        columnMajorValues[2], columnMajorValues[5], columnMajorValues[8]);
            }

            throw new DeveloperError("columnMajorValues must have 9 elements.", "columnMajorValues");
        }
        return new Matrix3();
    };

    /**
     * Creates a Matrix3 instance initialized to the identity matrix.
     *
     * @memberof Matrix3
     *
     * @return {Matrix3} A new Matrix3 instance initialized to the identity matrix.
     */
    Matrix3.getIdentity = function() {
        return new Matrix3(1);
    };

    /**
     * Returns 9, the number of elements in a Matrix3.
     *
     * @memberof Matrix3
     *
     * @return {Number} 9.
     */
    Matrix3.getNumberOfElements = function() {
        return numberOfElements;
    };

    /**
     * Returns the transpose of this matrix.
     *
     * @memberof Matrix3
     *
     * @return {Matrix3} The transpose of this matrix.
     */
    Matrix3.prototype.transpose = function() {
        return new Matrix3(
                this.getColumn0Row0(), this.getColumn0Row1(), this.getColumn0Row2(),
                this.getColumn1Row0(), this.getColumn1Row1(), this.getColumn1Row2(),
                this.getColumn2Row0(), this.getColumn2Row1(), this.getColumn2Row2());
    };

    /**
     * Multiplies a vector by this matrix, that is, v' = Mv, where M is this, v is the vector argument, and v' is returned.
     *
     * @memberof Matrix3
     * @param {Cartesian3} vector The vector that is multiplied with this.
     * @return {Cartesian3} The transformed vector.
     */
    Matrix3.prototype.multiplyWithVector = function(vector) {
        var vX = vector.x;
        var vY = vector.y;
        var vZ = vector.z;

        var x = this.getColumnMajorValue(0) * vX +
                this.getColumnMajorValue(3) * vY +
                this.getColumnMajorValue(6) * vZ;

        var y = this.getColumnMajorValue(1) * vX +
                this.getColumnMajorValue(4) * vY +
                this.getColumnMajorValue(7) * vZ;

        var z = this.getColumnMajorValue(2) * vX +
                this.getColumnMajorValue(5) * vY +
                this.getColumnMajorValue(8) * vZ;

        return new Cartesian3(x, y, z);
    };

    /**
     * Multiplies a matrix by this matrix.
     *
     * @memberof Matrix3
     * @param {Matrix3} matrix The matrix that is on the right hand side of the multiplication.
     * @return {Matrix3} The multipled matrix.
     */
    Matrix3.prototype.multiplyWithMatrix = function(matrix) {
        var col0row0 =
            this.getColumnMajorValue(0) * matrix.getColumnMajorValue(0) +
            this.getColumnMajorValue(3) * matrix.getColumnMajorValue(1) +
            this.getColumnMajorValue(6) * matrix.getColumnMajorValue(2);
        var col0row1 =
            this.getColumnMajorValue(1) * matrix.getColumnMajorValue(0) +
            this.getColumnMajorValue(4) * matrix.getColumnMajorValue(1) +
            this.getColumnMajorValue(7) * matrix.getColumnMajorValue(2);
        var col0row2 =
            this.getColumnMajorValue(2) * matrix.getColumnMajorValue(0) +
            this.getColumnMajorValue(5) * matrix.getColumnMajorValue(1) +
            this.getColumnMajorValue(8) * matrix.getColumnMajorValue(2);

        var col1row0 =
            this.getColumnMajorValue(0) * matrix.getColumnMajorValue(3) +
            this.getColumnMajorValue(3) * matrix.getColumnMajorValue(4) +
            this.getColumnMajorValue(6) * matrix.getColumnMajorValue(5);
        var col1row1 =
            this.getColumnMajorValue(1) * matrix.getColumnMajorValue(3) +
            this.getColumnMajorValue(4) * matrix.getColumnMajorValue(4) +
            this.getColumnMajorValue(7) * matrix.getColumnMajorValue(5);
        var col1row2 =
            this.getColumnMajorValue(2) * matrix.getColumnMajorValue(3) +
            this.getColumnMajorValue(5) * matrix.getColumnMajorValue(4) +
            this.getColumnMajorValue(8) * matrix.getColumnMajorValue(5);

        var col2row0 =
            this.getColumnMajorValue(0) * matrix.getColumnMajorValue(6) +
            this.getColumnMajorValue(3) * matrix.getColumnMajorValue(7) +
            this.getColumnMajorValue(6) * matrix.getColumnMajorValue(8);
        var col2row1 =
            this.getColumnMajorValue(1) * matrix.getColumnMajorValue(6) +
            this.getColumnMajorValue(4) * matrix.getColumnMajorValue(7) +
            this.getColumnMajorValue(6) * matrix.getColumnMajorValue(8);
        var col2row2 =
            this.getColumnMajorValue(2) * matrix.getColumnMajorValue(6) +
            this.getColumnMajorValue(5) * matrix.getColumnMajorValue(7) +
            this.getColumnMajorValue(8) * matrix.getColumnMajorValue(8);

        return new Matrix3(
                col0row0, col1row0, col2row0,
                col0row1, col1row1, col2row1,
                col0row2, col1row2, col2row2);
    };

    /**
     * Returns a copy of this matrix with each element negated.
     *
     * @memberof Matrix3
     *
     * @return {Matrix3} A copy of this matrix with each element negated.
     */
    Matrix3.prototype.negate = function() {
        return new Matrix3(
                -this.getColumn0Row0(), -this.getColumn1Row0(), -this.getColumn2Row0(),
                -this.getColumn0Row1(), -this.getColumn1Row1(), -this.getColumn2Row1(),
                -this.getColumn0Row2(), -this.getColumn1Row2(), -this.getColumn2Row2());
    };

    /**
     * Returns a duplicate of a Matrix3 instance.
     *
     * @memberof Matrix3
     *
     * @return {Matrix3} A new copy of the Matrix3 instance.
     */
    Matrix3.prototype.clone = function() {
        return new Matrix3(
                this.getColumn0Row0(), this.getColumn1Row0(), this.getColumn2Row0(),
                this.getColumn0Row1(), this.getColumn1Row1(), this.getColumn2Row1(),
                this.getColumn0Row2(), this.getColumn1Row2(), this.getColumn2Row2());
    };

    /**
     * Returns <code>true</code> if this matrix equals other element-wise.
     *
     * @memberof Matrix3
     * @param {Matrix3} other The matrix to compare for equality.
     * @return {Boolean} <code>true</code> if the matrices are equal element-wise; otherwise, <code>false</code>.
     */
    Matrix3.prototype.equals = function(other) {
        for ( var i = 0; i < numberOfElements; ++i) {
            if (this.getColumnMajorValue(i) !== other.getColumnMajorValue(i)) {
                return false;
            }
        }
        return true;
    };

    /**
     * Returns <code>true</code> if this matrix equals other element-wise within the specified epsilon.
     *
     * @param {Matrix3} other The matrix to compare for equality.
     * @param {Number} [epsilon=0.0] The epsilon to use for equality testing.
     * @return {Boolean} <code>true</code> if the matrices are equal element-wise within the specified epsilon; otherwise, <code>false</code>.
     */
    Matrix3.prototype.equalsEpsilon = function(other, epsilon) {
        epsilon = epsilon || 0.0;
        for ( var i = 0; i < numberOfElements; ++i) {
            if (Math.abs(this.getColumnMajorValue(i) - other.getColumnMajorValue(i)) > epsilon) {
                return false;
            }
        }
        return true;
    };

    /**
     * Returns a string representing this instance with one line per row in the matrix.
     *
     * @memberof Matrix3
     *
     * @return {String} Returns a string representing this instance.
     */
    Matrix3.prototype.toString = function() {
        return "(" + this.getColumn0Row0() + ", " + this.getColumn1Row0() + ", " + this.getColumn2Row0() + ")\n" +
               "(" + this.getColumn0Row1() + ", " + this.getColumn1Row1() + ", " + this.getColumn2Row1() + ")\n" +
               "(" + this.getColumn0Row2() + ", " + this.getColumn1Row2() + ", " + this.getColumn2Row2() + ")";
    };

    /**
     * Returns a matrix that rotates a vector <code>theta</code> radians around the z-axis.
     *
     * @memberof Matrix3
     *
     * @param {Number} theta The rotation angle, in radians.
     *
     * @returns {Matrix3} The rotation matrix.
     *
     * @see Matrix3.rotationAroundY
     * @see Matrix3.rotationAroundX
     */
    Matrix3.rotationAroundZ = function(theta) {
        var c = Math.cos(theta);
        var s = Math.sin(theta);
        return new Matrix3(
                  c,  -s, 0.0,
                  s,   c, 0.0,
                0.0, 0.0, 1.0);
    };

    /**
     * Returns a matrix that rotates a vector <code>theta</code> radians around the y-axis.
     *
     * @memberof Matrix3
     *
     * @param {Number} theta The rotation angle, in radians.
     *
     * @returns {Matrix3} The rotation matrix.
     *
     * @see Matrix3.rotationAroundZ
     * @see Matrix3.rotationAroundX
     */
    Matrix3.rotationAroundY = function(theta) {
        var c = Math.cos(theta);
        var s = Math.sin(theta);
        return new Matrix3(
                  c, 0.0,   s,
                0.0, 1.0, 0.0,
                 -s, 0.0,   c);
    };

    /**
     * Returns a matrix that rotates a vector <code>theta</code> radians around the x-axis.
     *
     * @param {Number} theta The rotation angle, in radians.
     *
     * @returns {Matrix3} The rotation matrix.
     *
     * @see Matrix3.rotationAroundZ
     * @see Matrix3.rotationAroundY
     */
    Matrix3.rotationAroundX = function(theta) {
        var c = Math.cos(theta);
        var s = Math.sin(theta);
        return new Matrix3(
                1.0, 0.0, 0.0,
                0.0,   c,  -s,
                0.0,   s,   c);
    };

    /**
     * Returns a matrix that rotates a vector <code>theta</code> radians around <code>axis</code>.
     *
     * @memberof Matrix3
     *
     * @param {Cartesian3} axis The axis to rotate around.
     * @param {Number} theta The rotation angle, in radians.
     *
     * @returns {Matrix3} The rotation matrix.
     *
     * @see Quaternion.fromAxisAngle
     */
    Matrix3.fromAxisAngle = function(axis, theta) {
        var a = Cartesian3.clone(axis);
        var nAxis = a.normalize();

        var cosTheta = Math.cos(theta);
        var sinTheta = Math.sin(theta);
        var oneMinusCosTheta = 1.0 - cosTheta;

        var xy = nAxis.x * nAxis.y;
        var xz = nAxis.x * nAxis.z;
        var yz = nAxis.y * nAxis.z;

        var m00 = cosTheta + oneMinusCosTheta * nAxis.x * nAxis.x;
        var m01 = oneMinusCosTheta * xy + nAxis.z * sinTheta;
        var m02 = oneMinusCosTheta * xz - nAxis.y * sinTheta;

        var m10 = oneMinusCosTheta * xy - nAxis.z * sinTheta;
        var m11 = cosTheta + oneMinusCosTheta * nAxis.y * nAxis.y;
        var m12 = oneMinusCosTheta * yz + nAxis.x * sinTheta;

        var m20 = oneMinusCosTheta * xz + nAxis.y * sinTheta;
        var m21 = oneMinusCosTheta * yz - nAxis.x * sinTheta;
        var m22 = cosTheta + oneMinusCosTheta * nAxis.z * nAxis.z;

        return new Matrix3(
                m00, m10, m20,
                m01, m11, m21,
                m02, m12, m22);
    };

    return Matrix3;
});

/*global define*/
define('Core/MercatorProjection',[
        './Math',
        './Cartesian3',
        './Ellipsoid'
    ], function(
        CesiumMath,
        Cartesian3,
        Ellipsoid) {
    

    /**
     * @name MercatorProjection
     *
     * @constructor
     *
     * @immutable
     */
    function MercatorProjection(ellipsoid) {
        ellipsoid = ellipsoid || Ellipsoid.getWgs84();

        var radii = ellipsoid.getRadii();

        this._ellipsoid = ellipsoid;
        this._halfEquatorCircumference = Math.PI * (Math.max(radii.x, radii.y));
        this._quarterPolarCircumference = 0.5 * Math.PI * radii.z;
    }

    /*
     * DOC_TBA
     * @memberof MercatorProjection
     */
    MercatorProjection.prototype.getEllipsoid = function() {
        return this._ellipsoid;
    };

    /**
     * DOC_TBA
     * @memberof MercatorProjection
     */
    MercatorProjection.prototype.project = function(cartographic) {
        // Scale to [-1, 1]
        var lon = cartographic.longitude / Math.PI;
        var lat = cartographic.latitude / CesiumMath.PI_OVER_TWO;

        // TODO: Deal with latitude outside ~(-85, 85) degrees
        return new Cartesian3(lon * this._halfEquatorCircumference, Math.log((1.0 + Math.sin(lat)) / Math.cos(lat)) * this._quarterPolarCircumference, cartographic.height);
    };

    return MercatorProjection;
});
/*global define*/
define('Core/MouseEventType',['./Enumeration'], function(Enumeration) {
    

    /**
     * This enumerated type is for classifying mouse events: down, up, click, double click, move and move while a button is held down.
     *
     * @exports MouseEventType
     */
    var MouseEventType = {
        /**
         * Represents a mouse left button down event.
         *
         * @constant
         * @type {Enumeration}
         */
        LEFT_DOWN : new Enumeration(0, "LEFT_DOWN"),

        /**
         * Represents a mouse left button up event.
         *
         * @constant
         * @type {Enumeration}
         */
        LEFT_UP : new Enumeration(1, "LEFT_UP"),

        /**
         * Represents a mouse left click event.
         *
         * @constant
         * @type {Enumeration}
         */
        LEFT_CLICK : new Enumeration(2, "LEFT_CLICK"),

        /**
         * Represents a mouse left double click event.
         *
         * @constant
         * @type {Enumeration}
         */
        LEFT_DOUBLE_CLICK : new Enumeration(3, "LEFT_DOUBLE_CLICK"),

        /**
         * Represents a mouse left button down event.
         *
         * @constant
         * @type {Enumeration}
         */
        RIGHT_DOWN : new Enumeration(5, "RIGHT_DOWN"),

        /**
         * Represents a mouse right button up event.
         *
         * @constant
         * @type {Enumeration}
         */
        RIGHT_UP : new Enumeration(6, "RIGHT_UP"),

        /**
         * Represents a mouse right click event.
         *
         * @constant
         * @type {Enumeration}
         */
        RIGHT_CLICK : new Enumeration(7, "RIGHT_CLICK"),

        /**
         * Represents a mouse right double click event.
         *
         * @constant
         * @type {Enumeration}
         */
        RIGHT_DOUBLE_CLICK : new Enumeration(8, "RIGHT_DOUBLE_CLICK"),

        /**
         * Represents a mouse middle button down event.
         *
         * @constant
         * @type {Enumeration}
         */
        MIDDLE_DOWN : new Enumeration(10, "MIDDLE_DOWN"),

        /**
         * Represents a mouse middle button up event.
         *
         * @constant
         * @type {Enumeration}
         */
        MIDDLE_UP : new Enumeration(11, "MIDDLE_UP"),

        /**
         * Represents a mouse middle click event.
         *
         * @constant
         * @type {Enumeration}
         */
        MIDDLE_CLICK : new Enumeration(12, "MIDDLE_CLICK"),

        /**
         * Represents a mouse middle double click event.
         *
         * @constant
         * @type {Enumeration}
         */
        MIDDLE_DOUBLE_CLICK : new Enumeration(13, "MIDDLE_DOUBLE_CLICK"),

        /**
         * Represents a mouse move event.
         *
         * @constant
         * @type {Enumeration}
         */
        MOVE : new Enumeration(15, "MOVE"),

        /**
         * Represents a mouse wheel event.
         *
         * @constant
         * @type {Enumeration}
         */
        WHEEL : new Enumeration(16, "WHEEL")
    };

    return MouseEventType;
});
/*global define*/
define('Core/PolylinePipeline',['./Cartographic3'], function(Cartographic3) {
    

    /**
     * DOC_TBA
     *
     * @exports PolylinePipeline
     */
    var PolylinePipeline = {
        /*
         * DOC_TBA
         */
        wrapLongitude : function(ellipsoid, positions) {
            var segments = [];

            if (positions && (positions.length > 0)) {
                var length = positions.length;

                var currentSegment = [{
                    cartesian : positions[0].clone(),
                    cartographic : ellipsoid.toCartographic3(positions[0]),
                    index : 0
                }];

                var prev = currentSegment[0].cartographic;

                for ( var i = 1; i < length; ++i) {
                    var cur = ellipsoid.toCartographic3(positions[i]);

                    if (Math.abs(prev.longitude - cur.longitude) > Math.PI) {
                        var interpolatedLongitude = prev.longitude < 0.0 ? -Math.PI : Math.PI;
                        var longitude = cur.longitude + (2.0 * interpolatedLongitude);
                        var ratio = (interpolatedLongitude - prev.longitude) / (longitude - prev.longitude);
                        var interpolatedLatitude = prev.latitude + (cur.latitude - prev.latitude) * ratio;
                        var interpolatedHeight = prev.height + (cur.height - prev.height) * ratio;

                        currentSegment.push({
                            cartesian : ellipsoid.toCartesian(new Cartographic3(interpolatedLongitude, interpolatedLatitude, interpolatedHeight)),
                            cartographic : new Cartographic3(interpolatedLongitude, interpolatedLatitude, interpolatedHeight),
                            index : i
                        });
                        segments.push(currentSegment);

                        currentSegment = [];
                        currentSegment.push({
                            cartesian : ellipsoid.toCartesian(new Cartographic3(-interpolatedLongitude, interpolatedLatitude, interpolatedHeight)),
                            cartographic : new Cartographic3(-interpolatedLongitude, interpolatedLatitude, interpolatedHeight),
                            index : i
                        });
                    }

                    currentSegment.push({
                        cartesian : positions[i].clone(),
                        cartographic : ellipsoid.toCartographic3(positions[i]),
                        index : i
                    });

                    prev = cur.clone();
                }

                if (currentSegment.length > 1) {
                    segments.push(currentSegment);
                }
            }

            return segments;
        }
    };

    return PolylinePipeline;
});
/*global define*/
define('Core/PrimitiveType',['./Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports PrimitiveType
     */
    var PrimitiveType = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        POINTS : new Enumeration(0x0000, "points"), // POINTS
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        LINES : new Enumeration(0x0001, "lines"), // LINES
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        LINE_LOOP : new Enumeration(0x0002, "lineLoop"), // LINE_LOOP
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        LINE_STRIP : new Enumeration(0x0003, "lineStrip"), // LINE_STRIP
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        TRIANGLES : new Enumeration(0x0004, "triangles"), // TRIANGLES
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        TRIANGLE_STRIP : new Enumeration(0x0005, "triangleStrip"), // TRIANGLE_STRIP
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        TRIANGLE_FAN : new Enumeration(0x0006, "trangleFan") // TRIANGLE_FAN
    };

    return PrimitiveType;
});

/*global define*/
define('Core/BoxTessellator',[
        './DeveloperError',
        './Cartesian3',
        './ComponentDatatype',
        './PrimitiveType'
    ], function(
        DeveloperError,
        Cartesian3,
        ComponentDatatype,
        PrimitiveType) {
    

    /**
     * DOC_TBA
     *
     * @exports BoxTessellator
     *
     * @see CubeMapEllipsoidTessellator
     * @see PlaneTessellator
     */
    var BoxTessellator = {
        /**
         * DOC_TBA
         *
         * @exception {DeveloperError} All dimensions' components must be greater than or equal to zero.
         */
        compute : function(template) {
            template = template || {};
            var minimumCorner;
            var maximumCorner;

            if (template.minimumCorner && template.maximumCorner) {
                minimumCorner = template.minimumCorner;
                maximumCorner = template.maximumCorner;
            } else {
                var dimensions = template.dimensions || new Cartesian3(1.0, 1.0, 1.0);

                if (dimensions.x < 0 || dimensions.y < 0 || dimensions.z < 0) {
                    throw new DeveloperError("All dimensions components must be greater than or equal to zero.");
                }

                var corner = dimensions.multiplyWithScalar(0.5);
                minimumCorner = corner.negate();
                maximumCorner = corner;
            }

            var mesh = {};
            mesh.attributes = {};
            mesh.indexLists = [];

            // 8 corner points.
            mesh.attributes.position = {
                componentDatatype : ComponentDatatype.FLOAT,
                componentsPerAttribute : 3,
                values : [
                          minimumCorner.x, minimumCorner.y, minimumCorner.z,
                          maximumCorner.x, minimumCorner.y, minimumCorner.z,
                          maximumCorner.x, maximumCorner.y, minimumCorner.z,
                          minimumCorner.x, maximumCorner.y, minimumCorner.z,
                          minimumCorner.x, minimumCorner.y, maximumCorner.z,
                          maximumCorner.x, minimumCorner.y, maximumCorner.z,
                          maximumCorner.x, maximumCorner.y, maximumCorner.z,
                          minimumCorner.x, maximumCorner.y, maximumCorner.z
                      ]
            };

            // 12 triangles:  6 faces, 2 triangles each.
            mesh.indexLists.push({
                primitiveType : PrimitiveType.TRIANGLES,
                values : [
                          4, 5, 6, // Top: plane z = corner.Z
                          4, 6, 7,
                          1, 0, 3, // Bottom: plane z = -corner.Z
                          1, 3, 2,
                          1, 6, 5, // Side: plane x = corner.X
                          1, 2, 6,
                          2, 3, 7, // Side: plane y = corner.Y
                          2, 7, 6,
                          3, 0, 4, // Side: plane x = -corner.X
                          3, 4, 7,
                          0, 1, 5, // Side: plane y = -corner.Y
                          0, 5, 4
                      ]
            });

            return mesh;
        }
    };

    return BoxTessellator;
});
/*global define*/
define('Core/CubeMapEllipsoidTessellator',[
        './DeveloperError',
        './Cartesian3',
        './ComponentDatatype',
        './PrimitiveType'
    ], function(
        DeveloperError,
        Cartesian3,
        ComponentDatatype,
        PrimitiveType) {
    

    /**
     * DOC_TBA
     *
     * @exports CubeMapEllipsoidTessellator
     *
     * @see BoxTessellator
     */
    var CubeMapEllipsoidTessellator = {};

    /**
     * DOC_TBA
     *
     * @param {Ellipsoid} ellipsoid DOC_TBA.
     * @param {Number} numberOfPartitions DOC_TBA.
     * @param {String} attributeName DOC_TBA.
     *
     * @exception {DeveloperError} numberOfPartitions must be greater than zero.
     */
    CubeMapEllipsoidTessellator.compute = function(ellipsoid, numberOfPartitions, attributeName) {
        if (numberOfPartitions <= 0) {
            throw new DeveloperError("numberOfPartitions must be greater than zero.", "numberOfPartitions");
        }

        attributeName = attributeName || "position";

        var positions = [];
        var indices = [];

        function addEdgePositions(i0, i1) {
            var indices = [];
            indices[0] = i0;
            indices[2 + (numberOfPartitions - 1) - 1] = i1;

            var origin = positions[i0];
            var direction = positions[i1].subtract(positions[i0]);

            for ( var i = 1; i < numberOfPartitions; ++i) {
                var delta = i / numberOfPartitions;

                indices[i] = positions.length;
                positions.push(origin.add(direction.multiplyWithScalar(delta)));
            }

            return indices;
        }

        function addFaceTriangles(leftBottomToTop, bottomLeftToRight, rightBottomToTop, topLeftToRight) {
            var origin = positions[bottomLeftToRight[0]];
            var x = positions[bottomLeftToRight[bottomLeftToRight.length - 1]].subtract(origin);
            var y = positions[topLeftToRight[0]].subtract(origin);

            var bottomIndicesBuffer = [];
            var topIndicesBuffer = [];

            var bottomIndices = bottomLeftToRight;
            var topIndices = topIndicesBuffer;

            for ( var j = 1; j <= numberOfPartitions; ++j) {
                if (j !== numberOfPartitions) {
                    if (j !== 1) {
                        //
                        // This copy could be avoided by ping ponging buffers.
                        //
                        bottomIndicesBuffer = topIndicesBuffer.slice(0);
                        bottomIndices = bottomIndicesBuffer;
                    }

                    topIndicesBuffer[0] = leftBottomToTop[j];
                    topIndicesBuffer[numberOfPartitions] = rightBottomToTop[j];

                    var deltaY = j / numberOfPartitions;
                    var offsetY = y.multiplyWithScalar(deltaY);

                    for ( var i = 1; i < numberOfPartitions; ++i) {
                        var deltaX = i / numberOfPartitions;
                        var offsetX = x.multiplyWithScalar(deltaX);

                        topIndicesBuffer[i] = positions.length;
                        positions.push(origin.add(offsetX).add(offsetY));
                    }
                } else {
                    if (j !== 1) {
                        bottomIndices = topIndicesBuffer;
                    }
                    topIndices = topLeftToRight;
                }

                for ( var k = 0; k < numberOfPartitions; ++k) {
                    indices.push(bottomIndices[k]);
                    indices.push(bottomIndices[k + 1]);
                    indices.push(topIndices[k + 1]);

                    indices.push(bottomIndices[k]);
                    indices.push(topIndices[k + 1]);
                    indices.push(topIndices[k]);
                }
            }
        }

        //
        // Initial cube.  In the plane, z = -1:
        //
        //                   +y
        //                    |
        //             Q2     * p3     Q1
        //                  / | \
        //              p0 *--+--* p2   +x
        //                  \ | /
        //             Q3     * p1     Q4
        //                    |
        //
        // Similarly, p4 to p7 are in the plane z = 1.
        //
        positions.push(new Cartesian3(-1, 0, -1));
        positions.push(new Cartesian3(0, -1, -1));
        positions.push(new Cartesian3(1, 0, -1));
        positions.push(new Cartesian3(0, 1, -1));
        positions.push(new Cartesian3(-1, 0, 1));
        positions.push(new Cartesian3(0, -1, 1));
        positions.push(new Cartesian3(1, 0, 1));
        positions.push(new Cartesian3(0, 1, 1));

        //
        // Edges
        //
        // 0 -> 1, 1 -> 2, 2 -> 3, 3 -> 0.  Plane z = -1
        // 4 -> 5, 5 -> 6, 6 -> 7, 7 -> 4.  Plane z = 1
        // 0 -> 4, 1 -> 5, 2 -> 6, 3 -> 7.  From plane z = -1 to plane z - 1
        //
        var edge0to1 = addEdgePositions(0, 1);
        var edge1to2 = addEdgePositions(1, 2);
        var edge2to3 = addEdgePositions(2, 3);
        var edge3to0 = addEdgePositions(3, 0);

        var edge4to5 = addEdgePositions(4, 5);
        var edge5to6 = addEdgePositions(5, 6);
        var edge6to7 = addEdgePositions(6, 7);
        var edge7to4 = addEdgePositions(7, 4);

        var edge0to4 = addEdgePositions(0, 4);
        var edge1to5 = addEdgePositions(1, 5);
        var edge2to6 = addEdgePositions(2, 6);
        var edge3to7 = addEdgePositions(3, 7);

        addFaceTriangles(edge0to4, edge0to1, edge1to5, edge4to5); // Q3 Face
        addFaceTriangles(edge1to5, edge1to2, edge2to6, edge5to6); // Q4 Face
        addFaceTriangles(edge2to6, edge2to3, edge3to7, edge6to7); // Q1 Face
        addFaceTriangles(edge3to7, edge3to0, edge0to4, edge7to4); // Q2 Face
        addFaceTriangles(edge7to4.slice(0).reverse(), edge4to5, edge5to6, edge6to7.slice(0).reverse()); // Plane z = 1
        addFaceTriangles(edge1to2, edge0to1.slice(0).reverse(), edge3to0.slice(0).reverse(), edge2to3); // Plane z = -1

        // Expand cube into ellipsoid.
        var radii = ellipsoid.getRadii();
        for ( var i = 0; i < positions.length; ++i) {
            positions[i] = positions[i].normalize().multiplyComponents(radii);
        }

        var mesh = {};
        mesh.attributes = {};
        mesh.indexLists = [];

        mesh.attributes[attributeName] = {
            componentDatatype : ComponentDatatype.FLOAT,
            componentsPerAttribute : 3,
            values : Cartesian3.flatten(positions)
        };

        mesh.indexLists.push({
            primitiveType : PrimitiveType.TRIANGLES,
            values : indices
        });

        return mesh;
    };

    return CubeMapEllipsoidTessellator;
});
/*global define*/
define('Core/ExtentTessellator',[
        './DeveloperError',
        './Math',
        './Ellipsoid',
        './Cartesian3',
        './Cartographic3',
        './ComponentDatatype',
        './PrimitiveType'
    ], function(
        DeveloperError,
        CesiumMath,
        Ellipsoid,
        Cartesian3,
        Cartographic3,
        ComponentDatatype,
        PrimitiveType) {
    

    /**
     * Contains class functions to create a mesh or vertex array from a cartographic extent.
     *
     * @exports ExtentTessellator
     *
     * @see CubeMapEllipsoidTessellator
     * @see BoxTessellator
     * @see PlaneTessellator
     */
    var ExtentTessellator = {};

    ExtentTessellator._validateExtent = function(extent) {
        if (!extent ||
            typeof extent.north === "undefined" ||
            typeof extent.south === "undefined" ||
            typeof extent.west === "undefined" ||
            typeof extent.east === "undefined") {
            throw new DeveloperError("extent is required and must have north, south, east and west attributes.", "extent");
        }

        if (extent.north < -CesiumMath.PI_OVER_TWO || extent.north > CesiumMath.PI_OVER_TWO) {
            throw new DeveloperError("extent.north must be in the interval [-Pi/2, Pi/2].", "extent.north");
        }

        if (extent.south < -CesiumMath.PI_OVER_TWO || extent.south > CesiumMath.PI_OVER_TWO) {
            throw new DeveloperError("extent.south must be in the interval [-Pi/2, Pi/2].", "extent.south");
        }

        if (extent.north < extent.south) {
            throw new DeveloperError("extent.north must be greater than extent.south.", "extent");
        }

        if (extent.west < -CesiumMath.PI || extent.west > CesiumMath.PI) {
            throw new DeveloperError("extent.west must be in the interval [-Pi, Pi].", "extent.west");
        }

        if (extent.east < -CesiumMath.PI || extent.east > CesiumMath.PI) {
            throw new DeveloperError("extent.east must be in the interval [-Pi, Pi].", "extent.east");
        }

        if (extent.west > extent.east) {
            throw new DeveloperError("extent.west must be greater than extent.east.", "extent");
        }
    };

    ExtentTessellator._computeVertices = function(description) {
        var desc = description || {};

        var extent = desc.extent;
        var boundExtent = desc.boundaryExtent;
        var ellipsoid = desc.ellipsoid;
        var granularity = desc.granularity;
        var altitude = desc.altitude;
        var genTexCoords = desc.generateTextureCoords;
        var interleave = desc.interleave;
        var relativeToCenter = desc.relativeToCenter;

        var vertices = desc.vertices;
        var texCoords = desc.texCoords;
        var indices = desc.indices;

        // for computing texture coordinates
        var lonScalar = 1.0 / (extent.east - extent.west);
        var latScalar = 1.0 / (extent.north - extent.south);

        var i;
        var j;
        var rows = 0;
        var cols = 0;

        for (i = boundExtent.north;; i = i - granularity) {
            if (i < boundExtent.south) {
                i = boundExtent.south;
            }

            cols = 0;
            for (j = boundExtent.west;; j = j + granularity) {
                if (j > boundExtent.east) {
                    j = boundExtent.east;
                }

                var cartPosition = new Cartographic3(j, i, altitude);
                var position = ellipsoid.toCartesian(cartPosition).subtract(relativeToCenter);
                vertices.push(position.x, position.y, position.z);

                if (genTexCoords) {
                    var u = (cartPosition.longitude - extent.west) * lonScalar;
                    var v = (cartPosition.latitude - extent.south) * latScalar;
                    if (interleave) {
                        vertices.push(u, v);
                    } else {
                        texCoords.push(u, v);
                    }
                }

                ++cols;

                if (j === boundExtent.east) {
                    break;
                }
            }
            ++rows;

            if (i === boundExtent.south) {
                break;
            }
        }

        var index = 0;
        for (i = 0; i < rows - 1; ++i) {
            for (j = 0; j < cols - 1; ++j) {
                var upperLeft = index;
                var lowerLeft = upperLeft + cols;
                var lowerRight = lowerLeft + 1;
                var upperRight = upperLeft + 1;

                indices.push(upperLeft, lowerLeft, upperRight);
                indices.push(upperRight, lowerLeft, lowerRight);

                ++index;
            }
            ++index;
        }
    };

    /**
     * Creates a mesh from a cartographic extent.
     *
     * @param {Ellipsoid} description.ellipsoid The ellipsoid on which the extent lies. Defaults to a WGS84 ellipsoid.
     * @param {Object} description.extent A cartographic extent with north, south, east and west properties in radians.
     * @param {Number} description.granularity The distance, in radians, between each latitude and longitude.
     * Determines the number of positions in the buffer. Defaults to 0.1.
     * @param {Number} description.altitude The height from the surface of the ellipsoid. Defaults to 0.
     * @param {Boolean} description.generateTextureCoords A truthy value will cause texture coordinates to be generated.
     * @param {Cartesian3} description.relativetoCenter If this parameter is provided, the positions will be
     * computed as <code>worldPosition.subtract(relativeToCenter)</code>. Defaults to (0, 0, 0).
     *
     * @exception {DeveloperError} <code>description.extent</code> is required and must have north, south, east and west attributes.
     * @exception {DeveloperError} <code>description.extent.north</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].
     * @exception {DeveloperError} <code>description.extent.south</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].
     * @exception {DeveloperError} <code>description.extent.east</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].
     * @exception {DeveloperError} <code>description.extent.west</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].
     * @exception {DeveloperError} <code>description.extent.north</code> must be greater than <code>extent.south</code>.
     * @exception {DeveloperError} <code>description.extent.east</code> must be greater than <code>extent.west</code>.
     * @exception {DeveloperError} <code>description.context</code> is required.
     *
     * @return {Object} A mesh containing attributes for positions, possibly texture coordinates and indices
     * from the extent for creating a vertex array.
     *
     * @see Context#createVertexArrayFromMesh
     * @see MeshFilters#createAttributeIndices
     * @see MeshFilters#toWireframeInPlace
     *
     * @example
     * // Create a vertex array for rendering a wireframe extent.
     * var mesh = ExtentTessellator.compute({
     *     ellipsoid : Ellipsoid.getWgs84(),
     *     extent : {
     *         north : CesiumMath.toRadians(42.0),
     *         south : CesiumMath.toRadians(39.0),
     *         east : CesiumMath.toRadians(-74.0),
     *         west : CesiumMath.toRadians(-80.0)
     *     },
     *     granularity : 0.01,
     *     altitude : 10000.0
     * });
     * mesh = MeshFilters.toWireframeInPlace(mesh);
     * var va = context.createVertexArrayFromMesh({
     *     mesh             : mesh,
     *     attributeIndices : MeshFilters.createAttributeIndices(mesh)
     * });
     */
    ExtentTessellator.compute = function(description) {
        var desc = description || {};

        ExtentTessellator._validateExtent(desc.extent);

        desc.ellipsoid = desc.ellipsoid || Ellipsoid.getWgs84();
        desc.granularity = (desc.granularity && desc.granularity > 0.0) ? desc.granularity : 0.1;
        desc.altitude = (desc.altitude && desc.altitude > 0.0) ? desc.altitude : 0.0;
        desc.relativeToCenter = (desc.relativeToCenter) ? Cartesian3.clone(desc.relativeToCenter) : Cartesian3.getZero();
        desc.boundaryWidth = desc.boundaryWidth || 0; // NOTE: may want to expose in the future.
        desc.interleave = false;
        desc.positionName = desc.positionName || "position";
        desc.textureCoordName = desc.textureCoordName || "textureCoordinates";

        var vertices = [];
        var indices = [];
        var texCoords = [];

        desc.vertices = vertices;
        desc.texCoords = texCoords;
        desc.indices = indices;
        desc.boundaryExtent = {
            north : desc.extent.north + desc.granularity * desc.boundaryWidth,
            south : desc.extent.south - desc.granularity * desc.boundaryWidth,
            west : desc.extent.west - desc.granularity * desc.boundaryWidth,
            east : desc.extent.east + desc.granularity * desc.boundaryWidth
        };

        ExtentTessellator._computeVertices(desc);

        var mesh = {};
        mesh.attributes = {};
        mesh.indexLists = [];

        mesh.attributes[desc.positionName] = {
            componentDatatype : ComponentDatatype.FLOAT,
            componentsPerAttribute : 3,
            values : vertices
        };

        if (desc.generateTextureCoords) {
            mesh.attributes[desc.textureCoordName] = {
                componentDatatype : ComponentDatatype.FLOAT,
                componentsPerAttribute : 2,
                values : texCoords
            };
        }

        mesh.indexLists.push({
            primitiveType : PrimitiveType.TRIANGLES,
            values : indices
        });

        return mesh;
    };

    /**
     * Creates arrays of vertex attributes and indices from a cartographic extent.
     *
     * @param {Ellipsoid} description.ellipsoid The ellipsoid on which the extent lies. Defaults to a WGS84 ellipsoid.
     * @param {Object} description.extent A cartographic extent with north, south, east and west properties in radians.
     * @param {Number} description.granularity The distance, in radians, between each latitude and longitude.
     * Determines the number of positions in the buffer. Defaults to 0.1.
     * @param {Number} description.altitude The height from the surface of the ellipsoid. Defaults to 0.
     * @param {Boolean} description.generateTextureCoords A truthy value will cause texture coordinates to be generated.
     * @param {Boolean} description.interleave If both this parameter and <code>generateTextureCoords</code> are truthy,
     * the positions and texture coordinates will be interleaved in a single buffer.
     * @param {Object} description.attributeIndices An object with possibly two numeric attributes, <code>position</code>
     * and <code>textureCoordinates</code>, used to index the shader attributes of the same names.
     * <code>position</code> defaults to 0 and <code>textureCoordinates</code> defaults to 1.
     * @param {Cartesian3} description.relativetoCenter If this parameter is provided, the positions will be
     * computed as <code>worldPosition.subtract(relativeToCenter)</code>. Defaults to (0, 0, 0).
     *
     * @exception {DeveloperError} <code>description.extent</code> is required and must have north, south, east and west attributes.
     * @exception {DeveloperError} <code>description.extent.north</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].
     * @exception {DeveloperError} <code>description.extent.south</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].
     * @exception {DeveloperError} <code>description.extent.east</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].
     * @exception {DeveloperError} <code>description.extent.west</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].
     * @exception {DeveloperError} <code>description.extent.north</code> must be greater than <code>extent.south</code>.     *
     * @exception {DeveloperError} <code>description.extent.east</code> must be greater than <code>extent.west</code>.
     *
     * @return {Object} An object with flattened arrays for vertex attributes and indices.
     *
     * @example
     * // Example 1:
     * // Create a vertex array for a solid extent, with separate positions and texture coordinates.
     * var buffers = ExtentTessellator.computeBuffers({
     *     ellipsoid : ellipsoid,
     *     extent : extent,
     *     generateTextureCoords : true
     * });
     *
     * var datatype = ComponentDatatype.FLOAT;
     * var usage = BufferUsage.STATIC_DRAW;
     * var positionBuffer = context.createVertexBuffer(datatype.toTypedArray(buffers.positions), usage);
     * var texCoordBuffer = context.createVertexBuffer(datatype.toTypedArray(buffers.textureCoords), usage);
     * attributes = [{
     *         index : attributeIndices.position,
     *         vertexBuffer : positionBuffer,
     *         componentDatatype : datatype,
     *         componentsPerAttribute : 3
     *     }, {
     *         index : attributeIndices.textureCoordinates,
     *         vertexBuffer : texCoordBuffer,
     *         componentDatatype : datatype,
     *         componentsPerAttribute : 2
     *     }];
     * var indexBuffer = context.createIndexBuffer(new Uint16Array(buffers.indices), usage, IndexDatatype.UNSIGNED_SHORT);
     * var va = context.createVertexArray(attributes, indexBuffer);
     *
     * @example
     * // Example 2:
     * // Create a vertex array for a solid extent, with interleaved positions and texture coordinates.
     * var buffers = ExtentTessellator.computeBuffers({
     *     ellipsoid : ellipsoid,
     *     extent : extent,
     *     generateTextureCoords : true,
     *     interleave : true
     * });
     *
     * var datatype = ComponentDatatype.FLOAT;
     * var usage = BufferUsage.STATIC_DRAW;
     * var typedArray = datatype.toTypedArray(buffers.vertices);
     * var buffer = context.createVertexBuffer(typedArray, usage);
     * var stride = 5 * datatype.sizeInBytes;
     * var attributes = [{
     *         index : attributeIndices.position3D,
     *         vertexBuffer : buffer,
     *         componentDatatype : datatype,
     *         componentsPerAttribute : 3,
     *         normalize : false,
     *         offsetInBytes : 0,
     *         strideInBytes : stride
     *     }, {
     *         index : attributeIndices.textureCoordinates,
     *         vertexBuffer : buffer,
     *         componentDatatype : datatype,
     *         componentsPerAttribute : 2,
     *         normalize : false,
     *         offsetInBytes : 3 * datatype.sizeInBytes,
     *         strideInBytes : stride
     *     }];
     * var indexBuffer = context.createIndexBuffer(new Uint16Array(buffers.indices), usage, IndexDatatype.UNSIGNED_SHORT);
     * var vacontext.createVertexArray(attributes, indexBuffer);
     *
     */
    ExtentTessellator.computeBuffers = function(description) {
        var desc = description || {};

        ExtentTessellator._validateExtent(desc.extent);

        desc.ellipsoid = desc.ellipsoid || Ellipsoid.getWgs84();
        desc.granularity = (typeof desc.granularity !== "undefined" && desc.granularity > 0.0) ? desc.granularity : 0.1;
        desc.altitude = (typeof desc.altitude !== "undefined" && desc.altitude > 0.0) ? desc.altitude : 0.0;
        desc.relativeToCenter = (desc.relativeToCenter) ? Cartesian3.clone(desc.relativeToCenter) : Cartesian3.getZero();
        desc.boundaryWidth = desc.boundaryWidth || 0; // NOTE: may want to expose in the future.

        desc.vertices = [];
        desc.texCoords = [];
        desc.indices = [];
        desc.boundaryExtent = {
            north : desc.extent.north + desc.granularity * desc.boundaryWidth,
            south : desc.extent.south - desc.granularity * desc.boundaryWidth,
            west : desc.extent.west - desc.granularity * desc.boundaryWidth,
            east : desc.extent.east + desc.granularity * desc.boundaryWidth
        };

        ExtentTessellator._computeVertices(desc);

        var result = {};
        if (desc.interleave) {
            result.vertices = desc.vertices;
        } else {
            result.positions = desc.vertices;
            if (desc.generateTextureCoords) {
                result.textureCoords = desc.texCoords;
            }
        }

        result.indices = desc.indices;
        return result;
    };

    return ExtentTessellator;
});

/*global define*/
define('Core/PlaneTessellator',[
        './DeveloperError',
        './Cartesian2',
        './PrimitiveType'
    ], function(
        DeveloperError,
        Cartesian2,
        PrimitiveType) {
    

    /**
     * DOC_TBA
     *
     * @exports PlaneTessellator
     *
     * @see CubeMapEllipsoidTessellator
     * @see BoxTessellator
     */
    var PlaneTessellator = {
        /**
         * DOC_TBA
         *
         * @exception {DeveloperError} Resolution must be greater than one in both the x and y directions.
         */
        compute : function(template) {
            template = template || {};
            var resolution = template.resolution || new Cartesian2(2, 2);
            var onInterpolation = template.onInterpolation; // Can be undefined

            if (resolution.x <= 1 || resolution.y <= 1) {
                throw new DeveloperError("Resolution must be greater than one in both the x and y directions.");
            }

            var i;
            var j;

            // To allow computing custom attributes, e.g., texture coordinates, etc.
            if (onInterpolation) {
                for (j = 0; j < resolution.y; ++j) {
                    var yTime = j / (resolution.y - 1);

                    for (i = 0; i < resolution.x; ++i) {
                        var xTime = i / (resolution.x - 1);
                        onInterpolation(new Cartesian2(xTime, yTime));
                    }
                }
            }

            var indices = [];

            // Counterclockwise winding order
            for (j = 0; j < resolution.y - 1; ++j) {
                var row = j * resolution.x;
                var aboveRow = (j + 1) * resolution.x;

                for (i = 0; i < resolution.x - 1; ++i) {
                    indices.push(row + i, row + i + 1, aboveRow + i + 1);
                    indices.push(row + i, aboveRow + i + 1, aboveRow + i);
                }
            }

            return {
                attributes : {},
                indexLists : [{
                    primitiveType : PrimitiveType.TRIANGLES,
                    values : indices
                }]
            };
        }
    };

    return PlaneTessellator;
});
/*global define*/
define('Core/Quaternion',[
        './Math',
        './Cartesian3',
        './Cartesian4',
        './Matrix3'
    ], function(
        CesiumMath,
        Cartesian3,
        Cartesian4,
        Matrix3) {
    

    /**
     * DOC_TBA
     *
     * @name Quaternion
     *
     * @constructor
     *
     * @param {Number} x The x-component of the Quaternion.
     * @param {Number} y The y-component of the Quaternion.
     * @param {Number} z The z-component of the Quaternion.
     * @param {Number} w The w-component of the Quaternion.
     *
     * @see Matrix3
     */
    function Quaternion(x, y, z, w) {

        /**
         * The x coordinate.
         *
         * @type Number
         *
         * @see Quaternion.y
         * @see Quaternion.z
         * @see Quaternion.w
         */
        this.x = (typeof x !== "undefined") ? x : 0.0;

        /**
         * The y coordinate.
         *
         * @type Number
         *
         * @see Quaternion.x
         * @see Quaternion.z
         * @see Quaternion.w
         */
        this.y = (typeof y !== "undefined") ? y : 0.0;

        /**
         * The z coordinate.
         *
         * @type Number
         *
         * @see Quaternion.x
         * @see Quaternion.y
         * @see Quaternion.w
         */
        this.z = (typeof z !== "undefined") ? z : 0.0;

        /**
         * The w coordinate.
         *
         * @type Number
         *
         * @see Quaternion.x
         * @see Quaternion.y
         * @see Quaternion.z
         */
        this.w = (typeof w !== "undefined") ? w : 0.0;
    }

    /**
     * Returns a duplicate of a Quaternion.
     *
     * @param {Quaternion} quaternion The Quaternion to clone.
     * @return {Quaternion} A new Quaternion instance.
     */
    Quaternion.clone = function(quaternion) {
        return new Quaternion(quaternion.x, quaternion.y, quaternion.z, quaternion.w);
    };

    /**
     * Creates a quaternion initialized to <code>(0.0, 0.0, 0.0, 0.0)</code>.
     *
     * @memberof Quaternion
     *
     * @return {Quaternion} A new quaternion initialized to <code>(0.0, 0.0, 0.0, 0.0)</code>.
     */
    Quaternion.getZero = function() {
        return new Quaternion(0.0, 0.0, 0.0, 0.0);
    };

    /**
     * Creates a quaternion initialized to <code>(0.0, 0.0, 0.0, 1.0)</code>.
     *
     * @memberof Quaternion
     *
     * @return {Quaternion} A new quaternion initialized to <code>(0.0, 0.0, 0.0, 1.0)</code>.
     */
    Quaternion.getIdentity = function() {
        return new Quaternion(0.0, 0.0, 0.0, 1.0);
    };

    /**
     * Returns the conjugate of this quaternion.
     *
     * @memberof Quaternion
     *
     * @return {Quaternion} The conjugate of this quaternion.
     */
    Quaternion.prototype.conjugate = function() {
        return new Quaternion(-this.x, -this.y, -this.z, this.w);
    };

    /**
     * Returns the quaternion's norm squared.
     *
     * @memberof Quaternion
     *
     * @return {Number} The norm squared.
     *
     * @see Quaternion#norm
     */
    Quaternion.prototype.normSquared = function() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    };

    /**
     * Returns the quaternion's norm.
     *
     * @memberof Quaternion
     *
     * @return {Number} The norm.
     *
     * @see Quaternion#normSquared
     */
    Quaternion.prototype.norm = function() {
        return Math.sqrt(this.normSquared());
    };

    /**
     * Returns this quaternion normalized.
     *
     * @memberof Quaternion
     *
     * @returns {Quaternion} This quaternion normalized.
     */
    Quaternion.prototype.normalize = function() {
        var inverseMagnitude = 1.0 / this.norm();
        return new Quaternion(
                this.x * inverseMagnitude,
                this.y * inverseMagnitude,
                this.z * inverseMagnitude,
                this.w * inverseMagnitude);
    };

    /**
     * Returns the inverse of this quaternion.
     *
     * @memberof Quaternion
     *
     * @return {Quaternion} The inverse.
     */
    Quaternion.prototype.inverse = function() {
        return this.conjugate().multiplyWithScalar(1.0 / this.normSquared());
    };

    /**
     * Returns the componentwise sum of two quaternions, <code>this</code> + <code>other</code>.
     *
     * @memberof Quaternion
     *
     * @param {Quaternion} other The quaternion to sum with <code>this</code>.
     *
     * @return {Quaternion} The componentwise sum of two quaternions, <code>this</code> + <code>other</code>.
     *
     * @see Quaternion#subtract
     */
    Quaternion.prototype.add = function(other) {
        return new Quaternion(this.x + other.x, this.y + other.y, this.z + other.z, this.w + other.w);
    };

    /**
     * Returns the componentwise difference of two quaternions, <code>this</code> - <code>other</code>.
     *
     * @memberof Quaternion
     *
     * @param {Quaternion} other The quaternion to subtract from </code>this</code>.
     *
     * @return {Quaternion} The componentwise difference of two quaternions, <code>this</code> - <code>other</code>.
     *
     * @see Quaternion#add
     */
    Quaternion.prototype.subtract = function(other) {
        return new Quaternion(this.x - other.x, this.y - other.y, this.z - other.z, this.w - other.w);
    };

    /**
     * Returns this quaternion negated.
     *
     * @memberof Quaternion
     *
     * @return {Quaternion} This quaternion negated.
     */
    Quaternion.prototype.negate = function() {
        return new Quaternion(-this.x, -this.y, -this.z, -this.w);
    };

    /**
     * Returns the dot (scalar) product of two quaternions, <code>this</code> dot <code>other</code>.
     *
     * @memberof Quaternion
     *
     * @param {Quaternion} other The quaternion to dot with <code>this</code>.
     *
     * @return {Number} The dot (scalar) product of two quaternions, <code>this</code> dot <code>other</code>.
     *
     * @see Quaternion#multiply
     */
    Quaternion.prototype.dot = function(other) {
        return this.x * other.x + this.y * other.y + this.z * other.z + this.w * other.w;
    };

    /**
     * Returns the product two quaternions, <code>this</code> and <code>other</code>.
     *
     * @memberof Quaternion
     *
     * @param {Quaternion} other The quaternion to multiply with <code>this</code>.
     *
     * @return {Quaternion} The product two quaternions, <code>this</code> and <code>other</code>.
     *
     * @see Quaternion#dot
     */
    Quaternion.prototype.multiply = function(other) {
        return new Quaternion(
                this.y * other.z - this.z * other.y + this.x * other.w + this.w * other.x,
                this.z * other.x - this.x * other.z + this.y * other.w + this.w * other.y,
                this.x * other.y - this.y * other.x + this.z * other.w + this.w * other.z,
                this.w * other.w - this.x * other.x - this.y * other.y - this.z * other.z);
    };

    /**
     * Returns this quaternion scaled by a scalar.
     *
     * @memberof Quaternion
     *
     * @param {Number} scalar The scalar that is multiplied with <code>this</code>.
     *
     * @return {Quaternion} This quaternion scaled by a scalar.
     *
     * @see Quaternion#divideByScalar
     */
    Quaternion.prototype.multiplyWithScalar = function(scalar) {
        return new Quaternion(this.x * scalar, this.y * scalar, this.z * scalar, this.w * scalar);
    };

    /**
     * Returns this quaternion divided by a scalar.
     *
     * @memberof Quaternion
     *
     * @param {Number} scalar The scalar to use for division.
     *
     * @return {Quaternion} This quaternion divided by a scalar.
     *
     * @see Quaternion#multiplyWithScalar
     */
    Quaternion.prototype.divideByScalar = function(scalar) {
        return new Quaternion(this.x / scalar, this.y / scalar, this.z / scalar, this.w / scalar);
    };

    /**
     * Applies the rotation represented by this quaternion to a 4D Cartesian.
     *
     * @memberof Quaternion
     *
     * @param {Cartesian4} cartesian The cartesian to rotate.
     *
     * @return {Cartesian4} The rotated cartesian.
     */
    Quaternion.prototype.rotate = function(cartesian) {
        var c = new Cartesian4.clone(cartesian);
        var result = this.multiply(c).multiply(this.conjugate());
        return new Cartesian4(result.x, result.y, result.z, result.w);
    };

    /**
     * Returns the axis of rotation if this is a unit quaternion that represents a rotation.
     *
     * @memberof Quaternion
     *
     * @return {Cartesian3} The axis of rotation.
     *
     * @see Quaternion#getAngle
     * @see Quaternion.fromAxisAngle
     */
    Quaternion.prototype.getAxis = function() {
        if (Math.abs(this.w - 1.0) < CesiumMath.EPSILON6) {
            return Cartesian3.getZero();
        }

        var scalar = 1.0 / Math.sqrt(1.0 - (this.w * this.w));
        return new Cartesian3(this.x * scalar, this.y * scalar, this.z * scalar);
    };

    /**
     * Returns the angle of rotation if this is a unit quaternion that represents a rotation.
     *
     * @memberof Quaternion
     *
     * @return {Number} The angle of rotation.
     *
     * @see Quaternion#getAxis
     * @see Quaternion.fromAxisAngle
     */
    Quaternion.prototype.getAngle = function() {
        if (Math.abs(this.w - 1.0) < CesiumMath.EPSILON6) {
            return 0.0;
        }

        return 2.0 * Math.acos(this.w);
    };

    /**
     * Returns the 3x3 rotation matrix from this quaternion.
     *
     * @memberof Quaternion
     *
     * @return {Matrix3} The 3x3 rotation matrix from this quaternion.
     *
     * @see Quaternion.fromRotationMatrix
     */
    Quaternion.prototype.toRotationMatrix = function() {
        var x2 = this.x * this.x;
        var xy = this.x * this.y;
        var xz = this.x * this.z;
        var xw = this.x * this.w;
        var y2 = this.y * this.y;
        var yz = this.y * this.z;
        var yw = this.y * this.w;
        var z2 = this.z * this.z;
        var zw = this.z * this.w;
        var w2 = this.w * this.w;

        var m00 = x2 - y2 - z2 + w2;
        var m01 = 2.0 * (xy + zw);
        var m02 = 2.0 * (xz - yw);

        var m10 = 2.0 * (xy - zw);
        var m11 = -x2 + y2 - z2 + w2;
        var m12 = 2.0 * (yz + xw);

        var m20 = 2.0 * (xz + yw);
        var m21 = 2.0 * (yz - xw);
        var m22 = -x2 - y2 + z2 + w2;

        return new Matrix3(
                m00, m10, m20,
                m01, m11, m21,
                m02, m12, m22);
    };

    /**
     * Computes the linear interpolation between <code>this</code> and another quaternion.
     *
     * @memberof Quaternion
     *
     * @param {Number} t The normalized amount, in the range <code>[0,1]>/code>, between the two quaternions.
     * @param {Quaternion} q The ending Quaternion.
     *
     * @return {Quaternion} The interpolated quaternion between <code>this</code> and <code>q</code>, at <code>t</code>.
     */
    Quaternion.prototype.lerp = function(t, q) {
        var quaternion = Quaternion.clone(q);
        return this.multiplyWithScalar(1.0 - t).add(quaternion.multiplyWithScalar(t));
    };

    /**
     * Computes the spherical linear interpolation between <code>this</code> and another quaternion.
     *
     * @memberof Quaternion
     *
     * @param {Number} t The normalized amount, in the range <code>[0,1]</code>, between the two quaternions.
     * @param {Quaternion} q The ending quaternion.
     *
     * @return {Quaternion} The interpolated quaternion between <code>this</code> and <code>q</code>, at <code>t</code>.
     */
    Quaternion.prototype.slerp = function(t, q) {
        var quaternion = Quaternion.clone(q);
        var dot = this.dot(quaternion);

        // The angle between this must be acute. Since q and -q represent
        // the same rotation, negate q to get the acute angle.
        var r = quaternion;
        if (dot < 0.0) {
            dot = -dot;
            r = quaternion.negate();
        }

        // dot > 0, as the dot product approaches 1, the angle between the
        // quaternions vanishes. use linear interpolation.
        if (1.0 - dot < CesiumMath.EPSILON6) {
            return this.lerp(t, r);
        }

        var theta = Math.acos(dot);
        var scaledP = this.multiplyWithScalar(Math.sin((1 - t) * theta));
        var scaledR = r.multiplyWithScalar(Math.sin(t * theta));
        var sum = scaledP.add(scaledR);
        var result = sum.multiplyWithScalar(1.0 / Math.sin(theta));

        return result;
    };

    /**
     * Computes the logarithm of this quaternion.
     *
     * @memberof Quaternion
     *
     * @return {Cartesian3} The result of the logarithm.
     */
    Quaternion.prototype.log = function() {
        var theta = Math.acos(this.w);
        var thetaOverSinTheta = 0.0;
        if (theta > CesiumMath.EPSILON6) {
            thetaOverSinTheta = theta / Math.sin(theta);
        }

        return new Cartesian3(this.x * thetaOverSinTheta, this.y * thetaOverSinTheta, this.z * thetaOverSinTheta);
    };

    /**
     * Raises this quaternion to the <code>t</code> power.
     *
     * @memberof Quaternion
     *
     * @param {Number} t The degree of this quaternion to compute.
     *
     * @return {Quaternion} This quaternion raised to the <code>t</code> power.
     */
    Quaternion.prototype.power = function(t) {
        return Quaternion.exp(this.log().multiplyWithScalar(t));
    };

    /**
     * Returns a copy of this quaternion.
     *
     * @memberof Quaternion
     *
     * @return {Quaternion} A copy of this quaternion.
     */
    Quaternion.prototype.clone = function() {
        return new Quaternion(this.x, this.y, this.z, this.w);
    };

    /**
     * Returns <code>true</code> if this quaternion equals <code>other</code>, componentwise.
     *
     * @param {Quaternion} other The quaternion to test for equality.
     *
     * @return {Boolean} <code>true</code> if the quaternions are equal componentwise; otherwise, <code>false</code>.
     */
    Quaternion.prototype.equals = function(other) {
        return (this.x === other.x) &&
               (this.y === other.y) &&
               (this.z === other.z) &&
               (this.w === other.w);
    };

    /**
     * Returns <code>true</code> if this quaternion equals <code>other</code>, componentwise, within the specified epsilon.
     *
     * @memberof Quaternion
     *
     * @param {Quaternion} other The quaternion to test for equality.
     * @param {Number} [epsilon=0.0] The epsilon to use for equality testing.
     *
     * @return {Boolean} <code>true</code> if the quaternions are equal within the specified epsilon; otherwise, <code>false</code>.
     */
    Quaternion.prototype.equalsEpsilon = function(other, epsilon) {
        epsilon = epsilon || 0.0;
        return (Math.abs(this.x - other.x) <= epsilon) &&
               (Math.abs(this.y - other.y) <= epsilon) &&
               (Math.abs(this.z - other.z) <= epsilon) &&
               (Math.abs(this.w - other.w) <= epsilon);
    };

    /**
     * Returns a string representing this quaternion in the format (x, y, z, w).
     *
     * @memberof Quaternion
     *
     * @return {String} A string representing this Quaternion.
     */
    Quaternion.prototype.toString = function() {
        return "(" + this.x + ", " + this.y + ", " + this.z + ", " + this.w + ")";
    };

    /**
     * Creates a quaternion representing a rotation around an axis.
     *
     * @memberof Quaternion
     *
     * @param {Cartesian3} axis The axis of rotation.
     * @param {Number} angle The angle in degrees to rotate around the axis.
     *
     * @return {Quaternion} The quaternion representing the rotation.
     *
     * @see Quaternion#getAxis
     * @see Quaternion#getAngle
     * @see Matrix3.fromAxisAngle
     */
    Quaternion.fromAxisAngle = function(axis, angle) {
        var a = Cartesian3.clone(axis);
        var halfAngle = angle / 2.0;
        var s = Math.sin(halfAngle);
        var c = Math.cos(halfAngle);
        var nAxis = a.normalize();

        return new Quaternion(nAxis.x * s, nAxis.y * s, nAxis.z * s, c);
    };

    /**
     * Creates a Quaternion from a 3x3 rotation matrix.
     *
     * @memberof Quaternion
     *
     * @param {Matrix3} matrix The rotation matrix.
     *
     * @return {Quaternion} The quaternion representing the rotation.
     *
     * @see Quaternion#toRotationMatrix
     */
    Quaternion.fromRotationMatrix = function(matrix) {
        var x = 0;
        var y = 0;
        var z = 0;
        var w = 0;

        var m00 = matrix.getColumn0Row0();
        var m11 = matrix.getColumn1Row1();
        var m22 = matrix.getColumn2Row2();

        var factor = m00 * m11 * m22;

        var type = 0;
        if (m00 > factor) {
            type = 1;
            factor = m00;
        }

        if (m11 > factor) {
            type = 2;
            factor = m11;
        }

        if (m22 > factor) {
            type = 3;
            factor = m22;
        }

        if (type === 1) {
            x = 0.5 * Math.sqrt(1.0 + m00 - m11 - m22);
            factor = 1.0 / (4.0 * x);

            w = factor * (matrix.getColumn2Row1() - matrix.getColumn1Row2());

            if (w < 0.0) {
                w = -w;
                factor = -factor;
            }

            y = factor * (matrix.getColumn1Row0() + matrix.getColumn0Row1());
            z = factor * (matrix.getColumn2Row0() + matrix.getColumn0Row2());
        } else if (type === 2) {
            y = 0.5 * Math.sqrt(1.0 - m00 + m11 - m22);
            factor = 1.0 / (4.0 * y);

            w = factor * (matrix.getColumn0Row2() - matrix.getColumn2Row0());

            if (w < 0) {
                w = -w;
                factor = -factor;
            }

            x = factor * (matrix.getColumn1Row0() + matrix.getColumn0Row1());
            z = factor * (matrix.getColumn2Row1() + matrix.getColumn1Row2());
        } else if (type === 3) {
            z = 0.5 * Math.sqrt(1.0 - m00 - m11 + m22);
            factor = 1.0 / (4.0 * z);

            w = factor * (matrix.getColumn1Row0() - matrix.getColumn0Row1());

            if (w < 0) {
                w = -w;
                factor = -factor;
            }

            x = factor * (matrix.getColumn2Row0() + matrix.getColumn0Row2());
            y = factor * (matrix.getColumn2Row1() + matrix.getColumn1Row2());
        } else {
            w = 0.5 * Math.sqrt(1.0 + factor);
            factor = 1.0 / (4.0 * w);

            x = factor * (matrix.getColumn2Row1() - matrix.getColumn1Row2());
            y = factor * (matrix.getColumn0Row2() - matrix.getColumn2Row0());
            z = factor * (matrix.getColumn1Row0() - matrix.getColumn0Row1());
        }

        return new Quaternion(x, y, z, w);
    };

    /**
     * Computes the exponential of a Quaternion.
     *
     * @memberof Quaternion
     *
     * @param {Cartesian3} cartesian The cartesian power.
     *
     * @return {Quaternion} The Quaternion representing the exponential.
     */
    Quaternion.exp = function(cartesian) {
        var c = Cartesian3.clone(cartesian);
        var theta = c.magnitude();
        var sinThetaOverTheta = 0.0;
        if (theta > CesiumMath.EPSILON6) {
            sinThetaOverTheta = Math.sin(theta) / theta;
        }

        return new Quaternion(
                cartesian.x * sinThetaOverTheta,
                cartesian.y * sinThetaOverTheta,
                cartesian.z * sinThetaOverTheta,
                Math.cos(theta));
    };

   return Quaternion;
});

/*global define*/
define('Core/Rectangle',[],function() {
    

    /**
     * DOC_TBA
     * 
     * @name Rectangle
     * 
     * @param {Number} [x=0.0] The x coordinate of the rectangle.
     * @param {Number} [y=0.0] The y coordinate of the rectangle.
     * @param {Number} [width=0.0] The width of the rectangle.
     * @param {Number} [height=0.0] The height of the rectangle.
     *
     * @constructor
     */
    function Rectangle(x, y, width, height) {
        /**
         * The x coordinate of the rectangle
         *
         * @type Number
         *
         * @see Rectangle.y
         */
        this.x = x || 0.0;

        /**
         * The y coordinate of the rectangle
         *
         * @type Number
         *
         * @see Rectangle.x
         */
        this.y = y || 0.0;

        /**
         * The width of the rectangle
         *
         * @type Number
         *
         * @see Rectangle.height
         */
        this.width = width || 0.0;

        /**
         * The height of the rectangle
         *
         * @type Number
         *
         * @see Rectangle.width
         */
        this.height = height || 0.0;
    }

    /**
     * Returns a copy of this rectangle.
     *
     * @memberof Rectangle
     * 
     * @return {Rectangle} A copy of this rectangle.
     */
    Rectangle.prototype.clone = function() {
        return new Rectangle(this.x, this.y, this.width, this.height);
    };

    /**
     * Returns <code>true</code> if this rectangle equals <code>other</code>, property for property.
     *
     * @memberof Rectangle
     * 
     * @param {Rectangle} other The rectangle to compare for equality.
     *
     * @return {Boolean} <code>true</code> if the rectangles are equal; otherwise, <code>false</code>.
     */
    Rectangle.prototype.equals = function(other) {
        return (this.x === other.x) && 
               (this.y === other.y) && 
               (this.width === other.width) && 
               (this.height === other.height);
    };

    /**
     * Returns <code>true</code> if this rectangle equals <code>other</code>, property for property, within the specified epsilon.
     *
     * @memberof Rectangle
     * 
     * @param {Rectangle} other The rectangle to compare for equality.
     * @param {Number} [epsilon=0.0] The epsilon to use for equality testing.
     *
     * @return {Boolean} <code>true</code> if the rectangles are equal within the specified epsilon; otherwise, <code>false</code>.
     */
    Rectangle.prototype.equalsEpsilon = function(other, epsilon) {
        epsilon = epsilon || 0.0;
        return (Math.abs(this.x - other.x) <= epsilon) && 
               (Math.abs(this.y - other.y) <= epsilon) &&
               (Math.abs(this.width - other.width) <= epsilon) && 
               (Math.abs(this.height - other.height) <= epsilon);
    };

    /**
     * Returns a string representing this rectangle in the format (x, y, width, height).
     *
     * @memberof Rectangle
     * 
     * @return {String} A string representing this rectangle.
     */
    Rectangle.prototype.toString = function() {
        return "(" + this.x + ", " + this.y + ", " + this.width + ", " + this.height + ")";
    };

    /**
     * DOC_TBA
     * @memberof Rectangle
     */
    Rectangle.rectangleRectangleIntersect = function(rect1, rect2) {
        return !(rect1.x > rect2.x + rect2.width || 
                 rect1.x + rect1.width < rect2.x || 
                 rect1.y + rect1.height < rect2.y || 
                 rect1.y > rect2.y + rect2.height);
    };

    return Rectangle;
});

/*global define*/
define('Core/RuntimeError',[],function() {
    

    /**
     * Constructs an exception object that is thrown due to an error that can occur at runtime, e.g.,
     * out of memory, could not compile shader, etc.  If a function may throw this
     * exception, the calling code should be prepared to catch it.
     * <br /><br />
     * On the other hand, a {@link DeveloperError} indicates an exception due
     * to a developer error, e.g., invalid argument, that usually indicates a bug in the
     * calling code.
     *
     * @name RuntimeError
     *
     * @param {String} [message=undefined] The error message for this exception.
     *
     * @see DeveloperError
     * @constructor
     */
    function RuntimeError(message) {
        /**
         * "RuntimeError" indicating that this exception was thrown due to a runtime error.
         *
         * @constant
         * @type String
         */
        this.name = "RuntimeError";

        /**
         * The explanation for why this exception was thrown.
         *
         * @type String
         */
        this.message = message;
    }

    return RuntimeError;
});

/*global define*/
define('Core/Matrix4',[
        './DeveloperError',
        './RuntimeError',
        './Math',
        './Cartesian3',
        './Cartesian4',
        './Matrix3'
    ],
    function(
        DeveloperError,
        RuntimeError,
        CesiumMath,
        Cartesian3,
        Cartesian4,
        Matrix3) {
    

    var numberOfElements = 16;

    /**
     * A 4x4 matrix, stored internally in column-major order.
     *
     * <p>
     * When called with no arguments, the matrix elements are initialized to all zeros.
     * When called with one numeric argument, f, the columns are initialized to [f, 0, 0, 0] [0, f, 0, 0] [0, 0, f, 0] [0, 0, 0, f].  Hence new Matrix4(1) creates the identity matrix.
     * When called with two arguments; one Matrix3, rotation, and one Vector3, translation; the matrix is initialized to a 4x4 transformation matrix composed of a 3x3 rotation matrix in the upper left and a 3D translation in the upper right.  The bottom row is [0, 0, 0, 1].
     * When called with sixteen numeric arguments in row-major order, these arguments define the elements of the matrix.
     * </p>
     *
     * @name Matrix4
     * @constructor
     * @immutable
     *
     * @see Matrix4.createFromColumnMajorArray
     * @see Matrix2
     * @see Matrix3
     */
    function Matrix4() {
        var values = this.values = []; // Column-major
        values.length = numberOfElements;

        if (arguments.length === 0) {
            for ( var i = 0; i < numberOfElements; ++i) {
                values[i] = 0;
            }
        } else if (arguments.length === 1) {
            values[0] = arguments[0];
            values[1] = 0;
            values[2] = 0;
            values[3] = 0;

            values[4] = 0;
            values[5] = arguments[0];
            values[6] = 0;
            values[7] = 0;

            values[8] = 0;
            values[9] = 0;
            values[10] = arguments[0];
            values[11] = 0;

            values[12] = 0;
            values[13] = 0;
            values[14] = 0;
            values[15] = arguments[0];
        } else if (arguments.length < numberOfElements) {
            var rotation = arguments[0];
            var translation = arguments[1];

            values[0] = rotation.getColumn0Row0();
            values[1] = rotation.getColumn0Row1();
            values[2] = rotation.getColumn0Row2();
            values[3] = 0;

            values[4] = rotation.getColumn1Row0();
            values[5] = rotation.getColumn1Row1();
            values[6] = rotation.getColumn1Row2();
            values[7] = 0;

            values[8] = rotation.getColumn2Row0();
            values[9] = rotation.getColumn2Row1();
            values[10] = rotation.getColumn2Row2();
            values[11] = 0;

            values[12] = translation.x;
            values[13] = translation.y;
            values[14] = translation.z;
            values[15] = 1;
        } else if (arguments.length >= numberOfElements) {
            values[0] = arguments[0];  // Column 0, Row 0
            values[1] = arguments[4];  // Column 0, Row 1
            values[2] = arguments[8];  // Column 0, Row 2
            values[3] = arguments[12]; // Column 0, Row 3

            values[4] = arguments[1];  // Column 1, Row 0
            values[5] = arguments[5];  // Column 1, Row 1
            values[6] = arguments[9];  // Column 1, Row 2
            values[7] = arguments[13]; // Column 1, Row 3

            values[8] = arguments[2];  // Column 2, Row 0
            values[9] = arguments[6];  // Column 2, Row 1
            values[10] = arguments[10];// Column 2, Row 2
            values[11] = arguments[14];// Column 2, Row 3

            values[12] = arguments[3]; // Column 3, Row 0
            values[13] = arguments[7]; // Column 3, Row 1
            values[14] = arguments[11];// Column 3, Row 2
            values[15] = arguments[15];// Column 3, Row 3
        }
    }

    /**
     * Returns the element at column 0, row 0.
     *
     * @memberof Matrix4
     *
     * @return {Number} The element at column 0, row 0.
     */
    Matrix4.prototype.getColumn0Row0 = function() {
        return this.values[0];
    };

    /**
     * Returns the element at column 0, row 1.
     *
     * @memberof Matrix4
     *
     * @return {Number} The element at column 0, row 1.
     */
    Matrix4.prototype.getColumn0Row1 = function() {
        return this.values[1];
    };

    /**
     * Returns the element at column 0, row 2.
     *
     * @memberof Matrix4
     *
     * @return {Number} The element at column 0, row 2.
     */
    Matrix4.prototype.getColumn0Row2 = function() {
        return this.values[2];
    };

    /**
     * Returns the element at column 0, row 3.
     *
     * @memberof Matrix4
     *
     * @return {Number} The element at column 0, row 3.
     */
    Matrix4.prototype.getColumn0Row3 = function() {
        return this.values[3];
    };

    /**
     * Returns the element at column 1, row 0.
     *
     * @memberof Matrix4
     *
     * @return {Number} The element at column 1, row 0.
     */
    Matrix4.prototype.getColumn1Row0 = function() {
        return this.values[4];
    };

    /**
     * Returns the element at column 1, row 1.
     *
     * @memberof Matrix4
     *
     * @return {Number} The element at column 1, row 1.
     */
    Matrix4.prototype.getColumn1Row1 = function() {
        return this.values[5];
    };

    /**
     * Returns the element at column 1, row 2.
     *
     * @memberof Matrix4
     *
     * @return {Number} The element at column 1, row 2.
     */
    Matrix4.prototype.getColumn1Row2 = function() {
        return this.values[6];
    };

    /**
     * Returns the element at column 1, row 3.
     *
     * @memberof Matrix4
     *
     * @return {Number} The element at column 1, row 3.
     */
    Matrix4.prototype.getColumn1Row3 = function() {
        return this.values[7];
    };

    /**
     * Returns the element at column 2, row 0.
     *
     * @memberof Matrix4
     *
     * @return {Number} The element at column 2, row 0.
     */
    Matrix4.prototype.getColumn2Row0 = function() {
        return this.values[8];
    };

    /**
     * Returns the element at column 2, row 1.
     *
     * @memberof Matrix4
     *
     * @return {Number} The element at column 2, row 1.
     */
    Matrix4.prototype.getColumn2Row1 = function() {
        return this.values[9];
    };

    /**
     * Returns the element at column 2, row 2.
     *
     * @memberof Matrix4
     *
     * @return {Number} The element at column 2, row 2.
     */
    Matrix4.prototype.getColumn2Row2 = function() {
        return this.values[10];
    };

    /**
     * Returns the element at column 2, row 3.
     *
     * @memberof Matrix4
     *
     * @return {Number} The element at column 2, row 3.
     */
    Matrix4.prototype.getColumn2Row3 = function() {
        return this.values[11];
    };

    /**
     * Returns the element at column 3, row 0.
     *
     * @memberof Matrix4
     *
     * @return {Number} The element at column 3, row 0.
     */
    Matrix4.prototype.getColumn3Row0 = function() {
        return this.values[12];
    };

    /**
     * Returns the element at column 3, row 1.
     *
     * @memberof Matrix4
     *
     * @return {Number} The element at column 3, row 1.
     */
    Matrix4.prototype.getColumn3Row1 = function() {
        return this.values[13];
    };

    /**
     * Returns the element at column 3, row 2.
     *
     * @memberof Matrix4
     *
     * @return {Number} The element at column 3, row 2.
     */
    Matrix4.prototype.getColumn3Row2 = function() {
        return this.values[14];
    };

    /**
     * Returns the element at column 3, row 3.
     *
     * @memberof Matrix4
     *
     * @return {Number} The element at column 3, row 3.
     */
    Matrix4.prototype.getColumn3Row3 = function() {
        return this.values[15];
    };

    /**
     * Returns the element at the zero-based, column-major index.
     *
     * @memberof Matrix4
     * @return {Number} The element at the zero-based, column-major index.
     * @exception {DeveloperError} Index must be between 0 and 15.
     */
    Matrix4.prototype.getColumnMajorValue = function(index) {
        if (index < 0 || index > 15) {
            throw new DeveloperError("Index must be between 0 and 15.", "index");
        }

        return this.values[index];
    };

    /**
     * Returns a copy of the first, i.e. leftmost, column of this matrix.
     *
     * @memberof Matrix4
     *
     * @return {Cartesian4} The first column of this matrix.
     *
     * @see Matrix4#setColumn0
     *
     * @example
     * var m = Matrix4.getIdentity();
     * var c = m.getColumn0(); // (x, y, z, w) == (1.0, 0.0, 0.0, 0.0)
     */
    Matrix4.prototype.getColumn0 = function() {
        var values = this.values;
        return new Cartesian4(values[0], values[1], values[2], values[3]);
    };

    /**
     * Sets the first, i.e. leftmost, column of this matrix.
     *
     * @memberof Matrix4
     *
     * @param {Cartesian4} column The first column of this matrix.
     *
     * @see Matrix4#getColumn0
     *
     * @example
     * // Column will be (1.0, 2.0, 3.0, 4.0)
     * m.setColumn0(new Cartesian4(1.0, 2.0, 3.0, 4.0));
     */
    Matrix4.prototype.setColumn0 = function(column) {
        var values = this.values;
        values[0] = column.x;
        values[1] = column.y;
        values[2] = column.z;
        values[3] = column.w;
    };

    /**
     * Returns a copy of the second column of this matrix.
     *
     * @memberof Matrix4
     *
     * @return {Cartesian4} The second column of this matrix.
     *
     * @see Matrix4#setColumn1
     *
     * @example
     * var m = Matrix4.getIdentity();
     * var c = m.getColumn1(); // (x, y, z, w) == (0.0, 1.0, 0.0, 0.0)
     */
    Matrix4.prototype.getColumn1 = function() {
        var values = this.values;
        return new Cartesian4(values[4], values[5], values[6], values[7]);
    };

    /**
     * Sets the second column of this matrix.
     *
     * @memberof Matrix4
     *
     * @param {Cartesian4} column The second column of this matrix.
     *
     * @see Matrix4#getColumn1
     *
     * @example
     * // Column will be (1.0, 2.0, 3.0, 4.0)
     * m.setColumn1(new Cartesian4(1.0, 2.0, 3.0, 4.0));
     */
    Matrix4.prototype.setColumn1 = function(column) {
        var values = this.values;
        values[4] = column.x;
        values[5] = column.y;
        values[6] = column.z;
        values[7] = column.w;
    };

    /**
     * Returns a copy of the third column of this matrix.
     *
     * @memberof Matrix4
     *
     * @return {Cartesian4} The third column of this matrix.
     *
     * @see Matrix4#setColumn2
     *
     * @example
     * var m = Matrix4.getIdentity();
     * var c = m.getColumn2(); // (x, y, z, w) == (0.0, 0.0, 1.0, 0.0)
     */
    Matrix4.prototype.getColumn2 = function() {
        var values = this.values;
        return new Cartesian4(values[8], values[9], values[10], values[11]);
    };

    /**
     * Sets the third column of this matrix.
     *
     * @memberof Matrix4
     *
     * @param {Cartesian4} column The third column of this matrix.
     *
     * @see Matrix4#getColumn2
     *
     * @example
     * // Column will be (1.0, 2.0, 3.0, 4.0)
     * m.setColumn2(new Cartesian4(1.0, 2.0, 3.0, 4.0));
     */
    Matrix4.prototype.setColumn2 = function(column) {
        var values = this.values;
        values[8] = column.x;
        values[9] = column.y;
        values[10] = column.z;
        values[11] = column.w;
    };

    /**
     * Returns a copy of the fourth, i.e. rightmost, column of this matrix.
     *
     * @memberof Matrix4
     *
     * @return {Cartesian4} The fourth column of this matrix.
     *
     * @see Matrix4#setColumn3
     *
     * @example
     * var m = Matrix4.getIdentity();
     * var c = m.getColumn3(); // (x, y, z, w) == (0.0, 0.0, 0.0, 1.0)
     */
    Matrix4.prototype.getColumn3 = function() {
        var values = this.values;
        return new Cartesian4(values[12], values[13], values[14], values[15]);
    };

    /**
     * Sets the fourth, i.e. rightmost, column of this matrix.
     *
     * @memberof Matrix4
     *
     * @param {Cartesian4} column The fourth column of this matrix.
     *
     * @see Matrix4#getColumn3
     *
     * @example
     * // Column will be (1.0, 2.0, 3.0, 4.0)
     * m.setColumn3(new Cartesian4(1.0, 2.0, 3.0, 4.0));
     */
    Matrix4.prototype.setColumn3 = function(column) {
        var values = this.values;
        values[12] = column.x;
        values[13] = column.y;
        values[14] = column.z;
        values[15] = column.w;
    };

    /**
     * Returns a copy of the first, i.e. top, row of this matrix.
     *
     * @memberof Matrix4
     *
     * @return {Cartesian4} The first row of this matrix.
     *
     * @see Matrix4#setRow0
     *
     * @example
     * var m = Matrix4.getIdentity();
     * var c = m.getRow0(); // (x, y, z, w) == (1.0, 0.0, 0.0, 0.0)
     */
    Matrix4.prototype.getRow0 = function() {
        var values = this.values;
        return new Cartesian4(values[0], values[4], values[8], values[12]);
    };

    /**
     * Sets the first, i.e. top, row of this matrix.
     *
     * @memberof Matrix4
     *
     * @param {Cartesian4} row The first row of this matrix.
     *
     * @see Matrix4#getRow0
     *
     * @example
     * // Row will be (1.0, 2.0, 3.0, 4.0)
     * m.setRow0(new Cartesian4(1.0, 2.0, 3.0, 4.0));
     */
    Matrix4.prototype.setRow0 = function(row) {
        var values = this.values;
        values[0] = row.x;
        values[4] = row.y;
        values[8] = row.z;
        values[12] = row.w;
    };

    /**
     * Returns a copy of the second, from the top, row of this matrix.
     *
     * @memberof Matrix4
     *
     * @return {Cartesian4} The second row of this matrix.
     *
     * @see Matrix4#setRow1
     *
     * @example
     * var m = Matrix4.getIdentity();
     * var c = m.getRow1(); // (x, y, z, w) == (0.0, 1.0, 0.0, 0.0)
     */
    Matrix4.prototype.getRow1 = function() {
        var values = this.values;
        return new Cartesian4(values[1], values[5], values[9], values[13]);
    };

    /**
     * Sets the second, from the top, row of this matrix.
     *
     * @memberof Matrix4
     *
     * @param {Cartesian4} row The second row of this matrix.
     *
     * @see Matrix4#getRow1
     *
     * @example
     * // Row will be (1.0, 2.0, 3.0, 4.0)
     * m.setRow1(new Cartesian4(1.0, 2.0, 3.0, 4.0));
     */
    Matrix4.prototype.setRow1 = function(row) {
        var values = this.values;
        values[1] = row.x;
        values[5] = row.y;
        values[9] = row.z;
        values[13] = row.w;
    };

    /**
     * Returns a copy of the third, from the top, row of this matrix.
     *
     * @memberof Matrix4
     *
     * @return {Cartesian4} The third row of this matrix.
     *
     * @see Matrix4#setRow2
     *
     * @example
     * var m = Matrix4.getIdentity();
     * var c = m.getRow2(); // (x, y, z, w) == (0.0, 0.0, 1.0, 0.0)
     */
    Matrix4.prototype.getRow2 = function() {
        var values = this.values;
        return new Cartesian4(values[2], values[6], values[10], values[14]);
    };

    /**
     * Sets the third, from the top, row of this matrix.
     *
     * @memberof Matrix4
     *
     * @param {Cartesian4} row The third row of this matrix.
     *
     * @see Matrix4#getRow2
     *
     * @example
     * // Row will be (1.0, 2.0, 3.0, 4.0)
     * m.setRow2(new Cartesian4(1.0, 2.0, 3.0, 4.0));
     */
    Matrix4.prototype.setRow2 = function(row) {
        var values = this.values;
        values[2] = row.x;
        values[6] = row.y;
        values[10] = row.z;
        values[14] = row.w;
    };

    /**
     * Returns a copy of the fourth, i.e. bottom, row of this matrix.
     *
     * @memberof Matrix4
     *
     * @return {Cartesian4} The fourth row of this matrix.
     *
     * @see Matrix4#setRow3
     *
     * @example
     * var m = Matrix4.getIdentity();
     * var c = m.getRow3(); // (x, y, z, w) == (0.0, 0.0, 0.0, 1.0)
     */
    Matrix4.prototype.getRow3 = function() {
        var values = this.values;
        return new Cartesian4(values[3], values[7], values[11], values[15]);
    };

    /**
     * Sets the fourth, i.e. bottom, row of this matrix.
     *
     * @memberof Matrix4
     *
     * @param {Cartesian4} row The fourth row of this matrix.
     *
     * @see Matrix4#getRow3
     *
     * @example
     * // Row will be (1.0, 2.0, 3.0, 4.0)
     * m.setRow3(new Cartesian4(1.0, 2.0, 3.0, 4.0));
     */
    Matrix4.prototype.setRow3 = function(row) {
        var values = this.values;
        values[3] = row.x;
        values[7] = row.y;
        values[11] = row.z;
        values[15] = row.w;
    };

    /**
     * DOC_TBA
     *
     * @memberof Matrix4
     *
     * @exception {DeveloperError} columnMajorValues must have 16 elements.
     */
    Matrix4.createFromColumnMajorArray = function(columnMajorValues) {
        if (columnMajorValues) {
            if (columnMajorValues.length === numberOfElements) {
                return new Matrix4(
                        columnMajorValues[0], columnMajorValues[4], columnMajorValues[8],  columnMajorValues[12],
                        columnMajorValues[1], columnMajorValues[5], columnMajorValues[9],  columnMajorValues[13],
                        columnMajorValues[2], columnMajorValues[6], columnMajorValues[10], columnMajorValues[14],
                        columnMajorValues[3], columnMajorValues[7], columnMajorValues[11], columnMajorValues[15]);
            }

            throw new DeveloperError("columnMajorValues must have 16 elements.", "columnMajorValues");
        }

        return new Matrix4();
    };

    /**
     * Creates a 4x4 uniform scale matrix.
     *
     * @memberof Matrix4
     *
     * @param {Number} scale The uniform scale in the x, y, and z directions.
     *
     * @see Matrix4.createNonUniformScale
     *
     * @example
     * var m = Matrix4.createScale(2.0);
     * var v = m.multiplyWithVector(new Cartesian4(1.0, 1.0, 1.0, 1.0));
     * // v is (2.0, 2.0, 2.0, 1.0)
     */
    Matrix4.createScale = function(scale) {
        if (scale) {
            return new Matrix4(
                 scale, 0.0,   0.0,   0.0,
                 0.0,   scale, 0.0,   0.0,
                 0.0,   0.0,   scale, 0.0,
                 0.0,   0.0,   0.0,   1.0);
        }

        return new Matrix4();
    };

    /**
     * Creates a 4x4 non-uniform scale matrix.
     *
     * @memberof Matrix4
     *
     * @param {Cartesian3} scale The non-uniform scale in the x, y, and z directions.
     *
     * @see Matrix4.createScale
     *
     * @example
     * var m = Matrix4.createNonUniformScale(new Cartesian3(1.0, 2.0, 3.0));
     * var v = m.multiplyWithVector(new Cartesian4(1.0, 1.0, 1.0, 1.0));
     * // v is (1.0, 2.0, 3.0, 1.0)
     */
    Matrix4.createNonUniformScale = function(scale) {
        if (scale) {
            return new Matrix4(
                 scale.x, 0.0,     0.0,     0.0,
                 0.0,     scale.y, 0.0,     0.0,
                 0.0,     0.0,     scale.z, 0.0,
                 0.0,     0.0,     0.0,     1.0);
        }

        return new Matrix4();
    };

    /**
     * DOC_TBA
     *
     * @memberof Matrix4
     */
    Matrix4.createTranslation = function(translation) {
        if (translation) {
            return new Matrix4(
                     1.0, 0.0, 0.0, translation.x,
                     0.0, 1.0, 0.0, translation.y,
                     0.0, 0.0, 1.0, translation.z,
                     0.0, 0.0, 0.0, 1.0);
        }

        return new Matrix4();
    };

    /**
     * Creates a Matrix4 representing a perspective transformation matrix.
     *
     * @memberof Matrix4
     *
     * @param {Number} fovy The field of view in radians.
     * @param {Number} aspect The aspect ratio.
     * @param {Number} zNear The distance to the near plane.
     * @param {Number} zFar The distance to the far plane.
     *
     * @return {Matrix4} The perspective transformation matrix.
     *
     * @exception {DeveloperError} fovy must be in [0, PI).
     * @exception {DeveloperError} aspect must be greater than zero.
     * @exception {DeveloperError} zNear must be greater than zero.
     * @exception {DeveloperError} zFar must be greater than zero.
     *
     * @see Matrix4.createPerspectiveOffCenter
     * @see Matrix4.createInfinitePerspectiveOffCenter
     * @see Matrix4.createOrthographicOffCenter
     */
    Matrix4.createPerspectiveFieldOfView = function(fovy, aspect, zNear, zFar) {
        if (fovy <= 0.0 || fovy > Math.PI) {
            throw new DeveloperError("fovy must be in [0, PI).", "fovy");
        }

        if (aspect <= 0.0) {
            throw new DeveloperError("aspect must be greater than zero.", "aspect");
        }

        if (zNear <= 0.0) {
            throw new DeveloperError("zNear must be greater than zero.", "zNear");
        }

        if (zFar <= 0.0) {
            throw new DeveloperError("zFar must be greater than zero.", "zFar");
        }

        var bottom = Math.tan(fovy * 0.5);
        var f = 1.0 / bottom;

        return new Matrix4(
            f / aspect, 0.0,                             0.0, 0.0,
            0.0,          f,                             0.0, 0.0,
            0.0,        0.0, (zFar + zNear) / (zNear - zFar), (2.0 * zFar * zNear) / (zNear - zFar),
            0.0,        0.0,                            -1.0, 0.0);
    };

    /**
     * DOC_TBA
     *
     * @memberof Matrix4
     *
     * @see Matrix4.createPerspectiveFieldOfView
     * @see Matrix4.createInfinitePerspectiveOffCenter
     * @see Matrix4.createOrthographicOffCenter
     */
    Matrix4.createPerspectiveOffCenter = function(left, right, bottom, top, zNear, zFar) {
        var l = left;
        var r = right;
        var b = bottom;
        var t = top;
        var n = zNear;
        var f = zFar;
        return new Matrix4(
            2.0 * n / (r - l), 0.0,               (r + l) / (r - l),  0.0,
            0.0,               2.0 * n / (t - b), (t + b) / (t - b),  0.0,
            0.0,               0.0,              -(f + n) / (f - n), -2.0 * f * n / (f - n),
            0.0,               0.0,              -1.0,                0.0);
    };

    /**
     * DOC_TBA
     *
     * @memberof Matrix4
     *
     * @see Matrix4.createPerspectiveFieldOfView
     * @see Matrix4.createPerspectiveOffCenter
     * @see Matrix4.createOrthographicOffCenter
     */
    Matrix4.createInfinitePerspectiveOffCenter = function(left, right, bottom, top, zNear) {
        var l = left;
        var r = right;
        var b = bottom;
        var t = top;
        var n = zNear;
        return new Matrix4(
            2.0 * n / (r - l), 0.0,               (r + l) / (r - l),  0.0,
            0.0,               2.0 * n / (t - b), (t + b) / (t - b),  0.0,
            0.0,               0.0,              -1.0,               -2.0 * n,
            0.0,               0.0,              -1.0,                0.0);
    };

    /**
     * Creates a Matrix4 representing an orthographic transformation matrix.
     *
     * @memberof Matrix4
     *
     * @param {Number} left
     * @param {Number} right
     * @param {Number} bottom
     * @param {Number} top
     * @param {Number} zNear The distance to the near plane.
     * @param {Number} zFar The distance to the far plane.
     *
     * @return {Matrix4} The orthographic transformation matrix.
     *
     * @see Matrix4.createPerspectiveFieldOfView
     * @see Matrix4.createPerspectiveOffCenter
     * @see Matrix4.createInfinitePerspectiveOffCenter
     */
    Matrix4.createOrthographicOffCenter = function(left, right, bottom, top, zNear, zFar) {
        var a = 1.0 / (right - left);
        var b = 1.0 / (top - bottom);
        var c = 1.0 / (zFar - zNear);

        var tx = -(right + left) * a;
        var ty = -(top + bottom) * b;
        var tz = -(zFar + zNear) * c;

        return new Matrix4(
           2.0 * a, 0.0,      0.0,     tx,
           0.0,     2.0 * b,  0.0,     ty,
           0.0,     0.0,     -2.0 * c, tz,
           0.0,     0.0,      0.0,     1.0);
    };

    /**
     * Creates a matrix that transforms from normalized device coordinates to window coordinates.
     *
     * @memberof Matrix4
     *
     * @param {Object}[viewport = { x : 0.0, y : 0.0, width : 0.0, height : 0.0 }] The viewport's corners as shown in Example 1.
     * @param {Number}[nearDepthRange = 0.0] The near plane distance in window coordinates.
     * @param {Number}[farDepthRange = 1.0] The far plane distance in window coordinates.
     *
     * @return {Matrix4} The viewport transformation matrix.
     *
     * @see agi_viewportTransformation
     * @see Context#getViewport
     *
     * @example
     * // Example 1.  Create viewport transformation using an explicit viewport and depth range.
     * var m = Matrix4.createViewportTransformation({
     *     x : 0.0,
     *     y : 0.0,
     *     width : 1024.0,
     *     height : 768.0
     * }, 0.0, 1.0);
     *
     * // Example 2.  Create viewport transformation using the context's viewport.
     * var m = Matrix4.createViewportTransformation(context.getViewport());
     */
    Matrix4.createViewportTransformation = function(viewport, nearDepthRange, farDepthRange) {
        var v = viewport || {};
        v.x = v.x || 0.0;
        v.y = v.y || 0.0;
        v.width = v.width || 0.0;
        v.height = v.height || 0.0;
        nearDepthRange = nearDepthRange || 0.0;
        farDepthRange = (typeof farDepthRange === "undefined") ? 1.0 : farDepthRange;

        var halfWidth = v.width * 0.5;
        var halfHeight = v.height * 0.5;
        var halfDepth = (farDepthRange - nearDepthRange) * 0.5;

        return new Matrix4(
            halfWidth, 0.0,        0.0,       v.x + halfWidth,
            0.0,       halfHeight, 0.0,       v.y + halfHeight,
            0.0,       0.0,        halfDepth, nearDepthRange + halfDepth,
            0.0,       0.0,        0.0,       1.0);
    };

    /**
     * Creates a Matrix4 representing a view matrix.
     *
     * @memberof Matrix4
     *
     * @param {Cartesian3} eye The position of the viewer.
     * @param {Cartesian3} target The point that the viewer is looking at.
     * @param {Cartesian3} up The up vector, i.e., how the viewer is tilted.
     *
     * @return {Matrix4} The view vector.
     */
    Matrix4.createLookAt = function(eye, target, up) {
        var t = Cartesian3.clone(target);
        var f = t.subtract(eye).normalize();
        var s = f.cross(up).normalize();
        var u = s.cross(f).normalize();

        var rotation = new Matrix4(
            s.x,  s.y,  s.z, 0.0,
            u.x,  u.y,  u.z, 0.0,
           -f.x, -f.y, -f.z, 0.0,
            0.0,  0.0,  0.0, 1.0);
        var translation = new Matrix4(
            1.0, 0.0, 0.0, -eye.x,
            0.0, 1.0, 0.0, -eye.y,
            0.0, 0.0, 1.0, -eye.z,
            0.0, 0.0, 0.0, 1.0);
        return rotation.multiplyWithMatrix(translation);
    };

    /**
     * Creates a Matrix4 instance initialized to the identity matrix.
     *
     * @memberof Matrix4
     *
     * @return {Matrix4} A new Matrix4 instance initialized to the identity matrix.
     */
    Matrix4.getIdentity = function() {
        return new Matrix4(1);
    };

    /**
     * Returns 16, the number of elements in a Matrix4.
     *
     * @memberof Matrix4
     *
     * @return {Number} 16.
     */
    Matrix4.getNumberOfElements = function() {
        return numberOfElements;
    };

    /**
     * Returns the upper left 3x3 rotation matrix, assuming the matrix is a affine transformation matrix.
     *
     * @memberof Matrix4
     *
     * @return {Matrix3} The upper left 3x3 matrix from this 4x4 matrix.
     */
    Matrix4.prototype.getRotation = function() {
        return new Matrix3(
                this.getColumn0Row0(), this.getColumn1Row0(), this.getColumn2Row0(),
                this.getColumn0Row1(), this.getColumn1Row1(), this.getColumn2Row1(),
                this.getColumn0Row2(), this.getColumn1Row2(), this.getColumn2Row2());
    };

    /**
     * Returns the transpose of the upper left 3x3 rotation matrix, assuming the matrix is a affine transformation matrix.
     *
     * @memberof Matrix4
     *
     * @return {Matrix3} The transpose of the upper left 3x3 matrix from this 4x4 matrix.
     */
    Matrix4.prototype.getRotationTranspose = function() {
        return new Matrix3(
                this.getColumn0Row0(), this.getColumn0Row1(), this.getColumn0Row2(),
                this.getColumn1Row0(), this.getColumn1Row1(), this.getColumn1Row2(),
                this.getColumn2Row0(), this.getColumn2Row1(), this.getColumn2Row2());
    };

    /**
     * Returns the 3D translation portion of this matrix in the upper right, assuming the matrix is a affine transformation matrix.
     *
     * @memberof Matrix4
     *
     * @return {Cartesian3} The first three rows of the rightmost column of this 4x4 matrix.
     */
    Matrix4.prototype.getTranslation = function() {
        return new Cartesian3(this.getColumn3Row0(), this.getColumn3Row1(), this.getColumn3Row2());
    };

    /**
     * Computes and returns the inverse of this matrix, assuming it is
     * an affine transformation matrix, where the upper left 3x3 elements
     * are a rotation matrix, and the upper three elements in the fourth
     * column are the translation.  The bottom row is assumed to be [0, 0, 0, 1].
     * <p>
     * This method is faster than computing the inverse for a general 4x4
     * matrix using {@link #inverse}.
     * </ p>
     * <p>
     * The matrix is not verified to be in the proper form.
     * </ p>
     *
     * @memberof Matrix4
     *
     * @return {Matrix4} The inverse of this affine transformation matrix.
     */
    Matrix4.prototype.inverseTransformation = function() {
        // r = rotaton, rT = r^-1
        var rT = this.getRotationTranspose();

        // T = translation, rTT = (-rT)(T)
        var rTT = rT.negate().multiplyWithVector(this.getTranslation());

        // [ rT, rTT ]
        // [  0,  1  ]
        return new Matrix4(
                rT.getColumn0Row0(), rT.getColumn1Row0(), rT.getColumn2Row0(), rTT.x,
                rT.getColumn0Row1(), rT.getColumn1Row1(), rT.getColumn2Row1(), rTT.y,
                rT.getColumn0Row2(), rT.getColumn1Row2(), rT.getColumn2Row2(), rTT.z,
                0, 0, 0, 1);
    };

    /**
     * Computes and returns the inverse of this general 4x4 matrix.
     * <p>
     * The matrix is inverted using Cramer's Rule.  If the determinant
     * is zero, the matrix can not be inverted, and an exception is thrown.
     * </ p>
     * <p>
     * If the matrix is an affine transformation matrix, it is more efficient
     * to invert it with {@link #inverseTransformation}.
     * </ p>
     *
     * @memberof Matrix4
     *
     * @return {Matrix4} The inverse of this matrix.
     * @exception {RuntimeError} This matrix is not invertible because its determinate is zero.
     */
    Matrix4.prototype.inverse = function() {
        //
        // Ported from:
        //   ftp://download.intel.com/design/PentiumIII/sml/24504301.pdf
        //

        var dst = [];
        var tmp = [];
        var src = [];
        var det;

        // transpose matrix
        for ( var i = 0; i < 4; ++i) {
            src[i] = this.getColumnMajorValue(i * 4);
            src[i + 4] = this.getColumnMajorValue(i * 4 + 1);
            src[i + 8] = this.getColumnMajorValue(i * 4 + 2);
            src[i + 12] = this.getColumnMajorValue(i * 4 + 3);
        }

        // calculate pairs for first 8 elements (cofactors)
        tmp[0]  = src[10] * src[15];
        tmp[1]  = src[11] * src[14];
        tmp[2]  = src[9]  * src[15];
        tmp[3]  = src[11] * src[13];
        tmp[4]  = src[9]  * src[14];
        tmp[5]  = src[10] * src[13];
        tmp[6]  = src[8]  * src[15];
        tmp[7]  = src[11] * src[12];
        tmp[8]  = src[8]  * src[14];
        tmp[9]  = src[10] * src[12];
        tmp[10] = src[8]  * src[13];
        tmp[11] = src[9]  * src[12];

        // calculate first 8 elements (cofactors)
        dst[0]  = tmp[0] * src[5] + tmp[3] * src[6] + tmp[4]  * src[7];
        dst[0] -= tmp[1] * src[5] + tmp[2] * src[6] + tmp[5]  * src[7];
        dst[1]  = tmp[1] * src[4] + tmp[6] * src[6] + tmp[9]  * src[7];
        dst[1] -= tmp[0] * src[4] + tmp[7] * src[6] + tmp[8]  * src[7];
        dst[2]  = tmp[2] * src[4] + tmp[7] * src[5] + tmp[10] * src[7];
        dst[2] -= tmp[3] * src[4] + tmp[6] * src[5] + tmp[11] * src[7];
        dst[3]  = tmp[5] * src[4] + tmp[8] * src[5] + tmp[11] * src[6];
        dst[3] -= tmp[4] * src[4] + tmp[9] * src[5] + tmp[10] * src[6];
        dst[4]  = tmp[1] * src[1] + tmp[2] * src[2] + tmp[5]  * src[3];
        dst[4] -= tmp[0] * src[1] + tmp[3] * src[2] + tmp[4]  * src[3];
        dst[5]  = tmp[0] * src[0] + tmp[7] * src[2] + tmp[8]  * src[3];
        dst[5] -= tmp[1] * src[0] + tmp[6] * src[2] + tmp[9]  * src[3];
        dst[6]  = tmp[3] * src[0] + tmp[6] * src[1] + tmp[11] * src[3];
        dst[6] -= tmp[2] * src[0] + tmp[7] * src[1] + tmp[10] * src[3];
        dst[7]  = tmp[4] * src[0] + tmp[9] * src[1] + tmp[10] * src[2];
        dst[7] -= tmp[5] * src[0] + tmp[8] * src[1] + tmp[11] * src[2];

        // calculate pairs for second 8 elements (cofactors)
        tmp[0]  = src[2] * src[7];
        tmp[1]  = src[3] * src[6];
        tmp[2]  = src[1] * src[7];
        tmp[3]  = src[3] * src[5];
        tmp[4]  = src[1] * src[6];
        tmp[5]  = src[2] * src[5];
        tmp[6]  = src[0] * src[7];
        tmp[7]  = src[3] * src[4];
        tmp[8]  = src[0] * src[6];
        tmp[9]  = src[2] * src[4];
        tmp[10] = src[0] * src[5];
        tmp[11] = src[1] * src[4];

        // calculate second 8 elements (cofactors)
        dst[8]   = tmp[0]  * src[13] + tmp[3]  * src[14] + tmp[4]  * src[15];
        dst[8]  -= tmp[1]  * src[13] + tmp[2]  * src[14] + tmp[5]  * src[15];
        dst[9]   = tmp[1]  * src[12] + tmp[6]  * src[14] + tmp[9]  * src[15];
        dst[9]  -= tmp[0]  * src[12] + tmp[7]  * src[14] + tmp[8]  * src[15];
        dst[10]  = tmp[2]  * src[12] + tmp[7]  * src[13] + tmp[10] * src[15];
        dst[10] -= tmp[3]  * src[12] + tmp[6]  * src[13] + tmp[11] * src[15];
        dst[11]  = tmp[5]  * src[12] + tmp[8]  * src[13] + tmp[11] * src[14];
        dst[11] -= tmp[4]  * src[12] + tmp[9]  * src[13] + tmp[10] * src[14];
        dst[12]  = tmp[2]  * src[10] + tmp[5]  * src[11] + tmp[1]  * src[9];
        dst[12] -= tmp[4]  * src[11] + tmp[0]  * src[9]  + tmp[3]  * src[10];
        dst[13]  = tmp[8]  * src[11] + tmp[0]  * src[8]  + tmp[7]  * src[10];
        dst[13] -= tmp[6]  * src[10] + tmp[9]  * src[11] + tmp[1]  * src[8];
        dst[14]  = tmp[6]  * src[9]  + tmp[11] * src[11] + tmp[3]  * src[8];
        dst[14] -= tmp[10] * src[11] + tmp[2]  * src[8]  + tmp[7]  * src[9];
        dst[15]  = tmp[10] * src[10] + tmp[4]  * src[8]  + tmp[9]  * src[9];
        dst[15] -= tmp[8]  * src[9]  + tmp[11] * src[10] + tmp[5]  * src[8];

        // calculate determinant
        det = src[0] * dst[0] + src[1] * dst[1] + src[2] * dst[2] + src[3] * dst[3];

        if (Math.abs(det) < CesiumMath.EPSILON20) {
            throw new RuntimeError("This matrix is not invertible because its determinate is zero.");
        }

        // calculate matrix inverse
        det = 1.0 / det;
        for ( var j = 0; j < 16; ++j) {
            dst[j] *= det;
        }

        return new Matrix4(
                dst[0], dst[4], dst[8],  dst[12],
                dst[1], dst[5], dst[9],  dst[13],
                dst[2], dst[6], dst[10], dst[14],
                dst[3], dst[7], dst[11], dst[15]);
    };

    /**
     * Returns the transpose of this matrix.
     *
     * @memberof Matrix4
     *
     * @return {Matrix4} The transpose of this matrix.
     */
    Matrix4.prototype.transpose = function() {
        return new Matrix4(
                this.getColumn0Row0(), this.getColumn0Row1(), this.getColumn0Row2(), this.getColumn0Row3(),
                this.getColumn1Row0(), this.getColumn1Row1(), this.getColumn1Row2(), this.getColumn1Row3(),
                this.getColumn2Row0(), this.getColumn2Row1(), this.getColumn2Row2(), this.getColumn2Row3(),
                this.getColumn3Row0(), this.getColumn3Row1(), this.getColumn3Row2(), this.getColumn3Row3());
    };

    /**
     * Multiplies a vector by this matrix, that is, v' = Mv, where M is this, v is the vector argument, and v' is returned.
     *
     * @memberof Matrix4
     *
     * @param {Cartesian4} vector The vector that is multiplied with this.
     * @return {Cartesian4} The transformed vector.
     */
    Matrix4.prototype.multiplyWithVector = function(vector) {
        var vX = vector.x;
        var vY = vector.y;
        var vZ = vector.z;
        var vW = vector.w;

        var x =
            this.getColumnMajorValue(0)  * vX +
            this.getColumnMajorValue(4)  * vY +
            this.getColumnMajorValue(8)  * vZ +
            this.getColumnMajorValue(12) * vW;

        var y =
            this.getColumnMajorValue(1)  * vX +
            this.getColumnMajorValue(5)  * vY +
            this.getColumnMajorValue(9)  * vZ +
            this.getColumnMajorValue(13) * vW;

        var z =
            this.getColumnMajorValue(2)  * vX +
            this.getColumnMajorValue(6)  * vY +
            this.getColumnMajorValue(10) * vZ +
            this.getColumnMajorValue(14) * vW;

        var w =
            this.getColumnMajorValue(3)  * vX +
            this.getColumnMajorValue(7)  * vY +
            this.getColumnMajorValue(11) * vZ +
            this.getColumnMajorValue(15) * vW;

        return new Cartesian4(x, y, z, w);
    };

    /**
     * Multiplies a matrix by this matrix.
     *
     * @memberof Matrix4
     *
     * @param {Matrix4} matrix The matrix that is on the right hand side of the multiplication.
     * @return {Matrix4} The multipled matrix.
     */
    Matrix4.prototype.multiplyWithMatrix = function(matrix) {
        var l = this.values;
        var r = matrix.values;

        var col0row0 =
            l[0]  * r[0] +
            l[4]  * r[1] +
            l[8]  * r[2] +
            l[12] * r[3];
        var col0row1 =
            l[1]  * r[0] +
            l[5]  * r[1] +
            l[9]  * r[2] +
            l[13] * r[3];
        var col0row2 =
            l[2]  * r[0] +
            l[6]  * r[1] +
            l[10] * r[2] +
            l[14] * r[3];
        var col0row3 =
            l[3]  * r[0] +
            l[7]  * r[1] +
            l[11] * r[2] +
            l[15] * r[3];

        var col1row0 =
            l[0]  * r[4] +
            l[4]  * r[5] +
            l[8]  * r[6] +
            l[12] * r[7];
        var col1row1 =
            l[1]  * r[4] +
            l[5]  * r[5] +
            l[9]  * r[6] +
            l[13] * r[7];
        var col1row2 =
            l[2]  * r[4] +
            l[6]  * r[5] +
            l[10] * r[6] +
            l[14] * r[7];
        var col1row3 =
            l[3]  * r[4] +
            l[7]  * r[5] +
            l[11] * r[6] +
            l[15] * r[7];

        var col2row0 =
            l[0]  * r[8]  +
            l[4]  * r[9]  +
            l[8]  * r[10] +
            l[12] * r[11];
        var col2row1 =
            l[1]  * r[8]  +
            l[5]  * r[9]  +
            l[9]  * r[10] +
            l[13] * r[11];
        var col2row2 =
            l[2]  * r[8]  +
            l[6]  * r[9]  +
            l[10] * r[10] +
            l[14] * r[11];
        var col2row3 =
            l[3]  * r[8]  +
            l[7]  * r[9]  +
            l[11] * r[10] +
            l[15] * r[11];

        var col3row0 =
            l[0]  * r[12] +
            l[4]  * r[13] +
            l[8]  * r[14] +
            l[12] * r[15];
        var col3row1 =
            l[1]  * r[12] +
            l[5]  * r[13] +
            l[9]  * r[14] +
            l[13] * r[15];
        var col3row2 =
            l[2]  * r[12] +
            l[6]  * r[13] +
            l[10] * r[14] +
            l[14] * r[15];
        var col3row3 =
            l[3]  * r[12] +
            l[7]  * r[13] +
            l[11] * r[14] +
            l[15] * r[15];

        return new Matrix4(
                col0row0, col1row0, col2row0, col3row0,
                col0row1, col1row1, col2row1, col3row1,
                col0row2, col1row2, col2row2, col3row2,
                col0row3, col1row3, col2row3, col3row3);
    };

    /**
     * Returns a copy of this matrix with each element negated.
     *
     * @memberof Matrix4
     *
     * @return {Matrix4} A copy of this matrix with each element negated.
     */
    Matrix4.prototype.negate = function() {
        return new Matrix4(
                -this.getColumn0Row0(), -this.getColumn1Row0(), -this.getColumn2Row0(), -this.getColumn3Row0(),
                -this.getColumn0Row1(), -this.getColumn1Row1(), -this.getColumn2Row1(), -this.getColumn3Row1(),
                -this.getColumn0Row2(), -this.getColumn1Row2(), -this.getColumn2Row2(), -this.getColumn3Row2(),
                -this.getColumn0Row3(), -this.getColumn1Row3(), -this.getColumn2Row3(), -this.getColumn3Row3());
    };

    /**
     * Returns a duplicate of a Matrix4 instance.
     *
     * @memberof Matrix4
     *
     * @return {Matrix4} A new copy of the Matrix4 instance.
     */
    Matrix4.prototype.clone = function() {
        return new Matrix4(
                this.getColumn0Row0(), this.getColumn1Row0(), this.getColumn2Row0(), this.getColumn3Row0(),
                this.getColumn0Row1(), this.getColumn1Row1(), this.getColumn2Row1(), this.getColumn3Row1(),
                this.getColumn0Row2(), this.getColumn1Row2(), this.getColumn2Row2(), this.getColumn3Row2(),
                this.getColumn0Row3(), this.getColumn1Row3(), this.getColumn2Row3(), this.getColumn3Row3());
    };

    /**
     * Returns <code>true</code> if this matrix equals other element-wise.
     *
     * @memberof Matrix4
     *
     * @param {Matrix4} other The matrix to compare for equality.
     *
     * @return {Boolean} <code>true</code> if the matrices are equal element-wise; otherwise, <code>false</code>.
     */
    Matrix4.prototype.equals = function(other) {
        for ( var i = 0; i < numberOfElements; ++i) {
            if (this.getColumnMajorValue(i) !== other.getColumnMajorValue(i)) {
                return false;
            }
        }
        return true;
    };

    /**
     * Returns <code>true</code> if this matrix equals other element-wise within the specified epsilon.
     *
     * @memberof Matrix4
     *
     * @param {Matrix4} other The matrix to compare for equality.
     * @param {Number} [epsilon=0.0] The epsilon to use for equality testing.
     *
     * @return {Boolean} <code>true</code> if the matrices are equal element-wise within the specified epsilon; otherwise, <code>false</code>.
     */
    Matrix4.prototype.equalsEpsilon = function(other, epsilon) {
        epsilon = epsilon || 0.0;
        for ( var i = 0; i < numberOfElements; ++i) {
            if (Math.abs(this.getColumnMajorValue(i) - other.getColumnMajorValue(i)) > epsilon) {
                return false;
            }
        }
        return true;
    };

    /**
     * Returns a string representing this instance with one line per row in the matrix.
     *
     * @memberof Matrix4
     *
     * @return {String} Returns a string representing this instance.
     */
    Matrix4.prototype.toString = function() {
        return "(" + this.getColumn0Row0() + ", " + this.getColumn1Row0() + ", " + this.getColumn2Row0() + ", " + this.getColumn3Row0() + ")\n" +
               "(" + this.getColumn0Row1() + ", " + this.getColumn1Row1() + ", " + this.getColumn2Row1() + ", " + this.getColumn3Row1() + ")\n" +
               "(" + this.getColumn0Row2() + ", " + this.getColumn1Row2() + ", " + this.getColumn2Row2() + ", " + this.getColumn3Row2() + ")\n" +
               "(" + this.getColumn0Row3() + ", " + this.getColumn1Row3() + ", " + this.getColumn2Row3() + ", " + this.getColumn3Row3() + ")";
    };

    return Matrix4;
});

/*global define*/
define('Core/TimeConstants',[],function() {
    

    /**
     * Constants for time conversions like those done by {@link JulianDate}.
     *
     * @exports TimeConstants
     *
     * @see JulianDate
     */
    var TimeConstants = {
        /**
         * The number of seconds in one millisecond: <code>0.001</code>
         * @constant
         * @type {Number}
         */
        SECONDS_PER_MILLISECOND : 0.001,

        /**
         * The number of seconds in one minute: <code>60</code>.
         * @constant
         * @type {Number}
         */
        SECONDS_PER_MINUTE : 60.0,

        /**
         * The number of minutes in one hour: <code>60</code>.
         * @constant
         * @type {Number}
         */
        MINUTES_PER_HOUR : 60.0,

        /**
         * The number of hours in one day: <code>24</code>.
         * @constant
         * @type {Number}
         */
        HOURS_PER_DAY : 24.0,

        /**
         * The number of seconds in one hour: <code>3600</code>.
         * @constant
         * @type {Number}
         */
        SECONDS_PER_HOUR : 3600.0,

        /**
         * The number of minutes in one day: <code>1440</code>.
         * @constant
         * @type {Number}
         */
        MINUTES_PER_DAY : 1440.0,

        /**
         * The number of seconds in one day, ignoring leap seconds: <code>86400</code>.
         * @constant
         * @type {Number}
         */
        SECONDS_PER_DAY : 86400.0,

        /**
         * The number of days in one Julian century: <code>36525</code>.
         * @constant
         * @type {Number}
         */
        DAYS_PER_JULIAN_CENTURY : 36525.0,

        /**
         * One trillionth of a second.
         * @constant
         * @type {Number}
         */
        PICOSECOND : 0.000000001,

        /**
         * DOC_TBA
         * @constant
         * @type {Number}
         */
        MODIFIED_JULIAN_DATE_DIFFERENCE : 2400000.5
    };

    return TimeConstants;
});
/*global define*/
define('Core/Tipsify',['./DeveloperError'], function(DeveloperError) {
    

    /**
     * Encapsulates an algorithm to optimize triangles for the post
     * vertex-shader cache.  This is based on the 2007 SIGGRAPH paper
     * "Fast Triangle Reordering for Vertex Locality and Reduced Overdraw."
     * The runtime is linear but several passes are made.
     *
     * @exports Tipsify
     *
     * @see <a href="http://gfx.cs.princeton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf">
     * Fast Triangle Reordering for Vertex Locality and Reduced Overdraw</a>
     * by Sander, Nehab, and Barczak
     */
    var Tipsify = {};

    /**
     * Calculates the average cache miss ratio (ACMR) for a given set of indices.
     *
     * @param {Array} indices Lists triads of numbers corresponding to the indices of the vertices
     *                        in the vertex buffer that define the mesh's triangles.
     * @param {Number} maximumIndex The maximum value of the elements in <code>indices</code>.
     * @param {Number} cacheSize The number of vertices that can be stored in the cache at any one time.
     *
     * @exception {DeveloperError} indices is required.
     * @exception {DeveloperError} indices length must be a multiple of three.
     * @exception {DeveloperError} maximumIndex must be greater than zero.
     * @exception {DeveloperError} cacheSize must be greater than two.
     *
     * @return {Number} The average cache miss ratio (ACMR).
     *
     * @example
     * var indices = [0, 1, 2, 3, 4, 5];
     * var maxIndex = 5;
     * var cacheSize = 3;
     * var acmr = Tipsify.calculateACMR(indices, maxIndex, cacheSize);
     */
    Tipsify.calculateACMR = function(indices, maximumIndex, cacheSize) {
        if (!indices) {
            throw new DeveloperError("indices is required.", "indices");
        }

        var numIndices = indices.length;

        if ((numIndices < 3) || (numIndices % 3 !== 0)) {
            throw new DeveloperError("indices length must be a multiple of three.", "indices");
        }
        if (maximumIndex <= 0) {
            throw new DeveloperError("maximumIndex must be greater than zero.", "maximumIndex");
        }
        if (cacheSize < 3) {
            throw new DeveloperError("cacheSize must be greater than two.", "cachSize");
        }

        // Vertex time stamps
        var vertexTimeStamps = [];
        for ( var i = 0; i < maximumIndex + 1; i++) {
            vertexTimeStamps[i] = 0;
        }

        // Cache processing
        var s = cacheSize + 1;
        for ( var j = 0; j < numIndices; ++j) {
            if ((s - vertexTimeStamps[indices[j]]) > cacheSize) {
                vertexTimeStamps[indices[j]] = s;
                ++s;
            }
        }

        return (s - cacheSize + 1) / (numIndices / 3);
    };

    /**
     * Optimizes triangles for the post-vertex shader cache.
     *
     * @param {Array} indices Lists triads of numbers corresponding to the indices of the vertices
     *                        in the vertex buffer that define the mesh's triangles.
     * @param {Number} maximumIndex The maximum value of the elements in <code>indices</code>.
     * @param {Number} cacheSize The number of vertices that can be stored in the cache at any one time.
     *
     * @exception {DeveloperError} indices is required.
     * @exception {DeveloperError} indices length must be a multiple of three.
     * @exception {DeveloperError} maximumIndex must be greater than zero.
     * @exception {DeveloperError} cacheSize must be greater than two.
     *
     * @return {Array} A list of the input indices in an optimized order.
     *
     * @example
     * var indices = [0, 1, 2, 3, 4, 5];
     * var maxIndex = 5;
     * var cacheSize = 3;
     * var reorderedIndices = Tipsify.tipsify(indices, maxIndex, cacheSize);
     */
    Tipsify.tipsify = function(indices, maximumIndex, cacheSize) {
        var cursor;

        function skipDeadEnd(vertices, deadEnd, indices, maximumIndexPlusOne) {
            while (deadEnd.length >= 1) {
                // while the stack is not empty
                var d = deadEnd[deadEnd.length - 1]; // top of the stack
                deadEnd.splice(deadEnd.length - 1, 1); // pop the stack

                if (vertices[d].numLiveTriangles > 0) {
                    return d;
                }
            }

            while (cursor < maximumIndexPlusOne) {
                if (vertices[cursor].numLiveTriangles > 0) {
                    ++cursor;
                    return cursor - 1;
                }
                ++cursor;
            }
            return -1;
        }

        function getNextVertex(indices, cacheSize, oneRing, vertices, s, deadEnd, maximumIndexPlusOne) {
            var n = -1;
            var p;
            var m = -1;
            var itOneRing = 0;
            while (itOneRing < oneRing.length) {
                var index = oneRing[itOneRing];
                if (vertices[index].numLiveTriangles) {
                    p = 0;
                    if ((s - vertices[index].timeStamp + (2 * vertices[index].numLiveTriangles)) <= cacheSize) {
                        p = s - vertices[index].timeStamp;
                    }
                    if ((p > m) || (m === -1)) {
                        m = p;
                        n = index;
                    }
                }
                ++itOneRing;
            }
            if (n === -1) {
                return skipDeadEnd(vertices, deadEnd, indices, maximumIndexPlusOne);
            }
            return n;
        }

        if (!indices) {
            throw new DeveloperError("indices is required.", "indices");
        }
        var numIndices = indices.length;

        if ((numIndices < 3) || (numIndices % 3 !== 0)) {
            throw new DeveloperError("indices length must be a multiple of three.", "indices");
        }
        if (maximumIndex <= 0) {
            throw new DeveloperError("maximumIndex must be greater than zero.", "maximumIndex");
        }
        if (cacheSize < 3) {
            throw new DeveloperError("cacheSize must be greater than two.", "cachSize");
        }

        // Determine maximum index
        var maximumIndexPlusOne = 0;
        var currentIndex = 0;
        var intoIndices = indices[currentIndex];
        var endIndex = numIndices;
        if (maximumIndex !== -1) {
            maximumIndexPlusOne = maximumIndex + 1;
        } else {
            while (currentIndex < endIndex) {
                if (intoIndices > maximumIndexPlusOne) {
                    maximumIndexPlusOne = intoIndices;
                }
                ++currentIndex;
                intoIndices = indices[currentIndex];
            }
            if (maximumIndexPlusOne === -1) {
                return 0;
            }
            ++maximumIndexPlusOne;
        }

        // Vertices
        var vertices = [];
        for ( var i = 0; i < maximumIndexPlusOne; i++) {
            vertices[i] = {
                numLiveTriangles : 0,
                timeStamp : 0,
                vertexTriangles : []
            };
        }
        currentIndex = 0;
        var triangle = 0;
        while (currentIndex < endIndex) {
            (vertices[indices[currentIndex]]).vertexTriangles.push(triangle);
            ++(vertices[indices[currentIndex]]).numLiveTriangles;
            (vertices[indices[currentIndex + 1]]).vertexTriangles.push(triangle);
            ++(vertices[indices[currentIndex + 1]]).numLiveTriangles;
            (vertices[indices[currentIndex + 2]]).vertexTriangles.push(triangle);
            ++(vertices[indices[currentIndex + 2]]).numLiveTriangles;
            ++triangle;
            currentIndex += 3;
        }

        // Starting index
        var f = 0;

        // Time Stamp
        var s = cacheSize + 1;
        cursor = 1;

        // Process
        var oneRing = [];
        var deadEnd = []; //Stack
        var vertex;
        var intoVertices;
        var currentOutputIndex = 0;
        var outputIndices = [];
        var numTriangles = numIndices / 3;
        var triangleEmitted = [];
        for (i = 0; i < numTriangles; i++) {
            triangleEmitted[i] = false;
        }
        var index;
        var limit;
        while (f !== -1) {
            oneRing = [];
            intoVertices = vertices[f];
            limit = intoVertices.vertexTriangles.length;
            for ( var k = 0; k < limit; ++k) {
                triangle = intoVertices.vertexTriangles[k];
                if (!triangleEmitted[triangle]) {
                    triangleEmitted[triangle] = true;
                    currentIndex = triangle + triangle + triangle;
                    for ( var j = 0; j < 3; ++j) {
                        // Set this index as a possible next index
                        index = indices[currentIndex];
                        oneRing.push(index);
                        deadEnd.push(index);

                        // Output index
                        outputIndices[currentOutputIndex] = index;
                        ++currentOutputIndex;

                        // Cache processing
                        vertex = vertices[index];
                        --vertex.numLiveTriangles;
                        if ((s - vertex.timeStamp) > cacheSize) {
                            vertex.timeStamp = s;
                            ++s;
                        }
                        ++currentIndex;
                    }
                }
            }
            f = getNextVertex(indices, cacheSize, oneRing, vertices, s, deadEnd, maximumIndexPlusOne);
        }

        return outputIndices;
    };

    return Tipsify;
});

/*global define*/
define('Core/MeshFilters',[
        './DeveloperError',
        './Cartesian3',
        './EquidistantCylindricalProjection',
        './ComponentDatatype',
        './PrimitiveType',
        './Tipsify'
    ], function(
        DeveloperError,
        Cartesian3,
        EquidistantCylindricalProjection,
        ComponentDatatype,
        PrimitiveType,
        Tipsify) {
    

    /**
     * DOC_TBA
     *
     * @exports MeshFilters
     *
     * @see Context#createVertexArrayFromMesh
     */
    var MeshFilters = {};

    /**
     * Converts a mesh's triangle indices to line indices.  Each list of indices in the mesh's <code>indexList</code> with
     * a primitive type of <code>triangles</code>, <code>triangleStrip</code>, or <code>trangleFan</code> is converted to a
     * list of indices with a primitive type of <code>lines</code>.  Lists of indices with other primitive types remain unchanged.
     * <br /><br />
     * The <code>mesh</code> argument should use the standard layout like the mesh returned by {@link BoxTessellator}.
     * <br /><br />
     * This filter is commonly used to create a wireframe mesh for visual debugging.
     *
     * @param {Object} mesh The mesh to filter, which is modified in place.
     *
     * @returns The modified <code>mesh</code> argument, with its triangle indices converted to lines.
     *
     * @see BoxTessellator
     *
     * @example
     * var mesh = BoxTessellator.compute();
     * mesh = MeshFilters.toWireframeInPlace(mesh);
     */
    MeshFilters.toWireframeInPlace = function(mesh) {
        function addTriangle(lines, i0, i1, i2) {
            lines.push(i0);
            lines.push(i1);

            lines.push(i1);
            lines.push(i2);

            lines.push(i2);
            lines.push(i0);
        }

        function trianglesToLines(triangles) {
            var lines = [];
            var count = triangles.length;
            for ( var i = 0; i < count; i += 3) {
                addTriangle(lines, triangles[i], triangles[i + 1], triangles[i + 2]);
            }

            return lines;
        }

        function triangleStripToLines(triangles) {
            var lines = [];
            var count = triangles.length;

            if (count >= 3) {
                addTriangle(lines, triangles[0], triangles[1], triangles[2]);

                for ( var i = 3; i < count; ++i) {
                    addTriangle(lines, triangles[i - 1], triangles[i], triangles[i - 2]);
                }
            }

            return lines;
        }

        function triangleFanToLines(triangles) {
            var lines = [];

            if (triangles.length > 0) {
                var base = triangles[0];
                var count = triangles.length - 1;
                for ( var i = 1; i < count; ++i) {
                    addTriangle(lines, base, triangles[i], triangles[i + 1]);
                }
            }

            return lines;
        }

        if (mesh) {
            var indexLists = mesh.indexLists;
            if (indexLists) {
                var count = indexLists.length;
                for ( var i = 0; i < count; ++i) {
                    var indices = indexLists[i];

                    switch (indices.primitiveType) {
                    case PrimitiveType.TRIANGLES:
                        indices.primitiveType = PrimitiveType.LINES;
                        indices.values = trianglesToLines(indices.values);
                        break;
                    case PrimitiveType.TRIANGLE_STRIP:
                        indices.primitiveType = PrimitiveType.LINES;
                        indices.values = triangleStripToLines(indices.values);
                        break;
                    case PrimitiveType.TRIANGLE_FAN:
                        indices.primitiveType = PrimitiveType.LINES;
                        indices.values = triangleFanToLines(indices.values);
                        break;
                    }
                }
            }
        }

        return mesh;
    };

    /**
     * DOC_TBA
     */
    MeshFilters.createAttributeIndices = function(mesh) {
        var indices = {};

        if (mesh) {
            var attributes = mesh.attributes;
            var j = 0;

            for ( var name in attributes) {
                if (attributes.hasOwnProperty(name)) {
                    indices[name] = j++;
                }
            }
        }

        return indices;
    };

    /**
     * DOC_TBA
     */
    MeshFilters.mapAttributeIndices = function(indices, map) {
        var mappedIndices = {};

        if (indices && map) {
            for ( var name in map) {
                if (map.hasOwnProperty(name)) {
                    mappedIndices[map[name]] = indices[name];
                }
            }
        }

        return mappedIndices;
    };

    MeshFilters._computeNumberOfAttributes = function(mesh) {
        var numberOfVertices = -1;
        for ( var property in mesh.attributes) {
            if (mesh.attributes.hasOwnProperty(property) && mesh.attributes[property].values) {
                var attribute = mesh.attributes[property];
                var num = attribute.values.length / attribute.componentsPerAttribute;
                if ((numberOfVertices !== num) && (numberOfVertices !== -1)) {
                    throw new DeveloperError("All mesh attribute lists must have the same number of attributes.");
                }
                numberOfVertices = num;
            }
        }

        return numberOfVertices;
    };

    /**
     * Reorders a mesh's indices to achieve better performance from the GPU's pre-vertex-shader cache.
     * Each list of indices in the mesh's <code>indexList</code> is reordered to keep the same index-vertex correspondence.
     * <br /><br />
     * The <code>mesh</code> argument should use the standard layout like the mesh returned by {@link BoxTessellator}.
     * <br /><br />

     * @param {Object} mesh The mesh to filter, which is modified in place.
     *
     * @exception {DeveloperError} All mesh attribute lists must have the same number of attributes.
     *
     * @returns The modified <code>mesh</code> argument, with its vertices and indices reordered for the GPU's pre-vertex-shader cache.
     *
     * @see MeshFilters.reorderForPostVertexCache
     *
     * @example
     * var mesh = CubeMapEllipsoidTessellator.compute(...);
     * mesh = MeshFilters.reorderForPreVertexCache(mesh);
     */
    MeshFilters.reorderForPreVertexCache = function(mesh) {
        if (mesh) {
            var numVertices = MeshFilters._computeNumberOfAttributes(mesh);

            var indexCrossReferenceOldToNew = [];
            for ( var i = 0; i < numVertices; i++) {
                indexCrossReferenceOldToNew[i] = -1;
            }

            //Construct cross reference and reorder indices
            var indexLists = mesh.indexLists;
            if (indexLists) {
                var count = indexLists.length;
                for ( var j = 0; j < count; ++j) {
                    var indicesIn = indexLists[j].values;
                    var numIndices = indicesIn.length;
                    var indicesOut = [];
                    var intoIndicesIn = 0;
                    var intoIndicesOut = 0;
                    var nextIndex = 0;
                    var tempIndex;
                    while (intoIndicesIn < numIndices) {
                        tempIndex = indexCrossReferenceOldToNew[indicesIn[intoIndicesIn]];
                        if (tempIndex !== -1) {
                            indicesOut[intoIndicesOut] = tempIndex;
                        } else {
                            tempIndex = indicesIn[intoIndicesIn];
                            if (tempIndex >= numVertices) {
                                throw new DeveloperError("Input indices contains a value greater than or equal to the number of vertices");
                            }
                            indexCrossReferenceOldToNew[tempIndex] = nextIndex;

                            indicesOut[intoIndicesOut] = nextIndex;
                            ++nextIndex;
                        }
                        ++intoIndicesIn;
                        ++intoIndicesOut;
                    }
                    indexLists[j].values = indicesOut;
                }
            }

            //Reorder Vertices
            var attributes = mesh.attributes;
            if (attributes) {
                for ( var property in attributes) {
                    if (attributes.hasOwnProperty(property) && attributes[property].values) {
                        var elementsIn = attributes[property].values;
                        var intoElementsIn = 0;
                        var numComponents = attributes[property].componentsPerAttribute;
                        var elementsOut = [];
                        while (intoElementsIn < numVertices) {
                            var temp = indexCrossReferenceOldToNew[intoElementsIn];
                            for (i = 0; i < numComponents; i++) {
                                elementsOut[numComponents * temp + i] = elementsIn[numComponents * intoElementsIn + i];
                            }
                            ++intoElementsIn;
                        }
                        attributes[property].values = elementsOut;
                    }
                }
            }
        }
        return mesh;
    };

    /**
     * Reorders a mesh's indices to achieve better performance from the GPU's post vertex-shader cache by using the Tipsify algorithm.
     * Each list of indices in the mesh's <code>indexList</code> is optimally reordered.
     * <br /><br />
     * The <code>mesh</code> argument should use the standard layout like the mesh returned by {@link BoxTessellator}.
     * <br /><br />

     * @param {Object} mesh The mesh to filter, which is modified in place.
     * @param {Number} [cacheCapacity=24] The number of vertices that can be held in the GPU's vertex cache.
     *
     * @exception {DeveloperError} Mesh's index list must be defined.
     * @exception {DeveloperError} Mesh's index lists' lengths must each be a multiple of three.
     * @exception {DeveloperError} Mesh's index list's maximum index value must be greater than zero.
     * @exception {DeveloperError} cacheCapacity must be greater than two.
     *
     * @returns The modified <code>mesh</code> argument, with its indices optimally reordered for the post-vertex-shader cache.
     *
     * @see MeshFilters.reorderForPreVertexCache
     * @see Tipsify
     * @see <a href="http://gfx.cs.princeton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf">
     * Fast Triangle Reordering for Vertex Locality and Reduced Overdraw</a>
     * by Sander, Nehab, and Barczak
     *
     * @example
     * var mesh = CubeMapEllipsoidTessellator.compute(...);
     * mesh = MeshFilters.reorderForPostVertexCache(mesh);
     */
    MeshFilters.reorderForPostVertexCache = function(mesh, cacheCapacity) {
        if (mesh) {
            var indexLists = mesh.indexLists;
            if (indexLists) {
                var count = indexLists.length;
                for ( var i = 0; i < count; i++) {
                    var indices = indexLists[i].values;
                    var numIndices = indices.length;
                    var maximumIndex = 0;
                    for ( var j = 0; j < numIndices; j++) {
                        if (indices[j] > maximumIndex) {
                            maximumIndex = indices[j];
                        }
                    }
                    indexLists[i].values = Tipsify.tipsify(indices, maximumIndex, cacheCapacity || 24);
                }
            }
        }
        return mesh;
    };

    MeshFilters._verifyTrianglesPrimitiveType = function(indexLists) {
        var length = indexLists.length;
        for ( var i = 0; i < length; ++i) {
            if (indexLists[i].primitiveType !== PrimitiveType.TRIANGLES) {
                throw new DeveloperError("The mesh's index-lists must have PrimitiveType equal to PrimitiveType.TRIANGLES.");
            }
        }
    };

    MeshFilters._copyAttributesDescriptions = function(attributes) {
        var newAttributes = {};

        for ( var attribute in attributes) {
            if (attributes.hasOwnProperty(attribute) && attributes[attribute].values) {
                var attr = attributes[attribute];
                newAttributes[attribute] = {
                    componentDatatype : attr.componentDatatype,
                    componentsPerAttribute : attr.componentsPerAttribute,
                    values : []
                };
            }
        }

        return newAttributes;
    };

    MeshFilters._copyVertex = function(destinationAttributes, sourceAttributes, index) {
        for ( var attribute in sourceAttributes) {
            if (sourceAttributes.hasOwnProperty(attribute) && sourceAttributes[attribute].values) {
                var attr = sourceAttributes[attribute];

                for ( var k = 0; k < attr.componentsPerAttribute; ++k) {
                    destinationAttributes[attribute].values.push(attr.values[(index * attr.componentsPerAttribute) + k]);
                }
            }
        }
    };

    /**
     * DOC_TBA.  Old mesh is not guaranteed to be copied.
     *
     * @exception {DeveloperError} The mesh's index-lists must have PrimitiveType equal to PrimitiveType.TRIANGLES.
     * @exception {DeveloperError} All mesh attribute lists must have the same number of attributes.
     */
    MeshFilters.fitToUnsignedShortIndices = function(mesh) {
        function createMesh(attributes, primitiveType, indices) {
            return {
                attributes : attributes,
                indexLists : [{
                    primitiveType : primitiveType,
                    values : indices
                }]
            };
        }

        var meshes = [];

        if (mesh) {
            MeshFilters._verifyTrianglesPrimitiveType(mesh.indexLists);

            var numberOfVertices = MeshFilters._computeNumberOfAttributes(mesh);

            // If there's an index list and more than 64K attributes, it is possible that
            // some indices are outside the range of unsigned short [0, 64K - 1]
            var sixtyFourK = 64 * 1024;
            var indexLists = mesh.indexLists;
            if (indexLists && (numberOfVertices > sixtyFourK)) {
                // PERFORMANCE_IDEA:  If an input mesh has more than one index-list.  This creates
                // at least one vertex-array per index-list.  A more sophisticated implementation
                // may create less vertex-arrays.
                var length = indexLists.length;
                for ( var i = 0; i < length; ++i) {
                    var oldToNewIndex = [];
                    var newIndices = [];
                    var currentIndex = 0;
                    var newAttributes = MeshFilters._copyAttributesDescriptions(mesh.attributes);

                    var originalIndices = indexLists[i].values;
                    var numberOfIndices = originalIndices.length;

                    for ( var j = 0; j < numberOfIndices; j += 3) {
                        // It would be easy to extend this inter-loop to support all primitive-types.

                        var x0 = originalIndices[j];
                        var x1 = originalIndices[j + 1];
                        var x2 = originalIndices[j + 2];

                        var i0 = oldToNewIndex[x0];
                        if (typeof i0 === "undefined") {
                            i0 = currentIndex++;
                            oldToNewIndex[x0] = i0;

                            MeshFilters._copyVertex(newAttributes, mesh.attributes, x0);
                        }

                        var i1 = oldToNewIndex[x1];
                        if (typeof i1 === "undefined") {
                            i1 = currentIndex++;
                            oldToNewIndex[x1] = i1;

                            MeshFilters._copyVertex(newAttributes, mesh.attributes, x1);
                        }

                        var i2 = oldToNewIndex[x2];
                        if (typeof i2 === "undefined") {
                            i2 = currentIndex++;
                            oldToNewIndex[x2] = i2;

                            MeshFilters._copyVertex(newAttributes, mesh.attributes, x2);
                        }

                        newIndices.push(i0);
                        newIndices.push(i1);
                        newIndices.push(i2);

                        if (currentIndex + 3 > sixtyFourK) {
                            meshes.push(createMesh(newAttributes, indexLists[i].primitiveType, newIndices));

                            // Reset for next vertex-array
                            oldToNewIndex = [];
                            newIndices = [];
                            currentIndex = 0;
                            newAttributes = MeshFilters._copyAttributesDescriptions(mesh.attributes);
                        }
                    }

                    if (newIndices.length !== 0) {
                        meshes.push(createMesh(newAttributes, indexLists[i].primitiveType, newIndices));
                    }
                }
            } else {
                // No need to split into multiple meshes
                meshes.push(mesh);
            }
        }

        return meshes;
    };

    ///////////////////////////////////////////////////////////////////////////

    /**
     * DOC_TBA
     */
    MeshFilters.projectTo2D = function(mesh, projection) {
        if (mesh && mesh.attributes && mesh.attributes.position) {
            projection = projection || new EquidistantCylindricalProjection();
            var ellipsoid = projection.getEllipsoid();

            // Project original positions to 2D.
            var wgs84Positions = mesh.attributes.position.values;
            var projectedPositions = [];

            for ( var i = 0; i < wgs84Positions.length; i += 3) {
                var lonLat = ellipsoid.toCartographic2(new Cartesian3(wgs84Positions[i], wgs84Positions[i + 1], wgs84Positions[i + 2]));
                var projectedLonLat = projection.project(lonLat);
                projectedPositions.push(projectedLonLat.x, projectedLonLat.y);
            }

            // Rename original positions to WGS84 Positions.
            mesh.attributes.position3D = mesh.attributes.position;

            // Replace original positions with 2D projected positions
            mesh.attributes.position2D = {
                componentDatatype : ComponentDatatype.FLOAT,
                componentsPerAttribute : 2,
                values : projectedPositions
            };
            delete mesh.attributes.position;
        }

        return mesh;
    };

    return MeshFilters;
});

/*global define*/
define('Core/TridiagonalSystemSolver',['./DeveloperError'], function(DeveloperError) {
    

    /**
     * Uses the Tridiagonal Matrix Algorithm, also known as the Thomas Algorithm, to solve
     * a system of linear equations where the coefficient matrix is a tridiagonal matrix.
     *
     * @exports TridiagonalSystemSolver
     */
    var TridiagonalSystemSolver = {};

    /**
     * Solves a tridiagonal system of linear equations.
     *
     * @param {Array} diagonal An array with length <code>n</code> that contains the diagonal of the coefficient matrix.
     * @param {Array} lower An array with length <code>n - 1</code> that contains the lower diagonal of the coefficient matrix.
     * @param {Array} upper An array with length <code>n - 1</code> that contains the upper diagonal of the coefficient matrix.
     * @param {Array} right An array of Cartesians with length <code>n</code> that is the right side of the system of equations.
     *
     * @exception {DeveloperError} The array lower is required.
     * @exception {DeveloperError} The array diagonal is required.
     * @exception {DeveloperError} The array upper is required.
     * @exception {DeveloperError} The array right is required.
     * @exception {DeveloperError} diagonal and right must have the same lengths.
     * @exception {DeveloperError} lower and upper must have the same lengths.
     * @exception {DeveloperError} lower and upper must be one less than the length of diagonal.
     *
     * @returns {Array} An array of Cartesians with length <code>n</code> that is the solution to the tridiagonal system of equations.
     *
     * @performance Linear time.
     *
     * @example
     * var lowerDiagonal = [1.0, 1.0, 1.0, 1.0];
     * var diagonal = [2.0, 4.0, 4.0, 4.0, 2.0];
     * var upperDiagonal = [1.0, 1.0, 1.0, 1.0];
     * var rightHandSide = [
     *     new Cartesian3(410757.0, -1595711.0, 1375302.0),
     *     new Cartesian3(-5986705.0, -2190640.0, 1099600.0),
     *     new Cartesian3(-12593180.0, 288588.0, -1755549.0),
     *     new Cartesian3(-5349898.0, 2457005.0, -2685438.0),
     *     new Cartesian3(845820.0, 1573488.0, -1205591.0)
     * ];
     *
     * var solution = TridiagonalSystemSolver.solve(lowerDiagonal, diagonal, upperDiagonal, rightHandSide);
     */
    TridiagonalSystemSolver.solve = function(lower, diagonal, upper, right) {
        if (!lower || !(lower instanceof Array)) {
            throw new DeveloperError("The array lower is required.", "lower");
        }

        if (!diagonal || !(diagonal instanceof Array)) {
            throw new DeveloperError("The array diagonal is required.", "diagonal");
        }

        if (!upper || !(upper instanceof Array)) {
            throw new DeveloperError("The array upper is required.", "upper");
        }

        if (!right || !(right instanceof Array)) {
            throw new DeveloperError("The array right is required.", "right");
        }

        if (diagonal.length !== right.length) {
            throw new DeveloperError("diagonal and right must have the same lengths.", "diagonal or right");
        }

        if (lower.length !== upper.length) {
            throw new DeveloperError("lower and upper must have the same lengths.", "lower or upper");
        } else if (lower.length !== diagonal.length - 1) {
            throw new DeveloperError("lower and upper must be one less than the length of diagonal.", "lower or upper");
        }

        var c = [], d = [], x = [];
        c.length = upper.length;
        d.length = x.length = right.length;

        c[0] = upper[0] / diagonal[0];
        d[0] = right[0].multiplyWithScalar(1.0 / diagonal[0]);

        var scalar, i = 1;
        for (; i < c.length; ++i) {
            scalar = 1.0 / (diagonal[i] - c[i - 1] * lower[i - 1]);
            c[i] = upper[i] * scalar;
            d[i] = right[i].subtract(d[i - 1].multiplyWithScalar(lower[i - 1]));
            d[i] = d[i].multiplyWithScalar(scalar);
        }

        scalar = 1.0 / (diagonal[i] - c[i - 1] * lower[i - 1]);
        d[i] = right[i].subtract(d[i - 1].multiplyWithScalar(lower[i - 1]));
        d[i] = d[i].multiplyWithScalar(scalar);

        x[x.length - 1] = d[d.length - 1];
        for (i = x.length - 2; i >= 0; --i) {
            x[i] = d[i].subtract(x[i + 1].multiplyWithScalar(c[i]));
        }

        return x;
    };

    return TridiagonalSystemSolver;
});

/*global define*/
define('Core/HermiteSpline',[
        './DeveloperError',
        './Matrix4',
        './Cartesian4',
        './TridiagonalSystemSolver'
    ],
    function(
        DeveloperError,
        Matrix4,
        Cartesian4,
        TridiagonalSystemSolver) {
    

    /**
     * A Hermite spline is a cubic interpolating spline. Positions, tangents, and times must be defined
     * for each control point. If no tangents are specified by the control points, the end and interior
     * tangents are generated, creating a natural cubic spline. If the only tangents specified are at
     * the end control points, the interior tangents will be generated as well, creating a clamped cubic
     * spline. Otherwise, it is assumed that each control point defines a tangent at that point.
     *
     * Natural and clamped cubic splines are in the class C<sup>2</sup>.
     *
     * @name HermiteSpline
     * @constructor
     *
     * @param {Array} controlPoints An array, of at least length 3, of objects with <code>point</code>,
     * <code>time</code>, and <code>tangent</code> properties.
     *
     * @exception {DeveloperError} controlPoints is required.
     * @exception {DeveloperError} controlPoints must be an array of at least length 3.
     *
     * @see CatmullRomSpline
     *
     * @example
     * // Example 1.
     * // Create a natural cubic spline above the earth from Philadelphia to Los Angeles.
     * var controlPoints = [
     *     {point: new Cartesian3(1235398.0, -4810983.0, 4146266.0), time: 0.0},
     *     {point: new Cartesian3(1372574.0, -5345182.0, 4606657.0), time: 1.5},
     *     {point: new Cartesian3(-757983.0, -5542796.0, 4514323.0), time: 3.0},
     *     {point: new Cartesian3(-2821260.0, -5248423.0, 4021290.0), time: 4.5},
     *     {point: new Cartesian3(-2539788.0, -4724797.0, 3620093.0), time: 6.0}
     * ];
     * var spline = new HermiteSpline(controlPoints);
     *
     * // Example 2.
     * // Create a Catmull-Rom spline above the earth from Philadelphia to Los Angeles.
     * var controlPoints = [
     *     {point: new Cartesian3(1235398.0, -4810983.0, 4146266.0), time: 0.0},
     *     {point: new Cartesian3(1372574.0, -5345182.0, 4606657.0), time: 1.5},
     *     {point: new Cartesian3(-757983.0, -5542796.0, 4514323.0), time: 3.0},
     *     {point: new Cartesian3(-2821260.0, -5248423.0, 4021290.0), time: 4.5},
     *     {point: new Cartesian3(-2539788.0, -4724797.0, 3620093.0), time: 6.0}
     * ];
     *
     * // Add tangents
     * controlPoints[0].tangent = new Cartesian3(1125196, -161816, 270551);
     * for (var i = 1; i < controlPoints.length - 1; ++i) {
     *     controlPoints[i].tangent = controlPoints[i + 1].point.subtract(controlPoints[i - 1].point).multiplyWithScalar(0.5);
     * }
     * controlPoints[controlPoints.length - 1].tangent = new Cartesian3(1165345, 112641, 47281);
     *
     * var spline = new HermiteSpline(controlPoints);
     */
    function HermiteSpline(controlPoints) {
        if (!controlPoints || !(controlPoints instanceof Array) || controlPoints.length < 3) {
            throw new DeveloperError("controlPoints is required. It must be an array with at least a length of 3.", "controlPoints");
        }

        this._points = controlPoints;

        this._lastTimeIndex = 0;

        if (!this._points[0].tangent || !this._points[this._points.length - 1].tangent) {
            this._generateNatural();
        } else if (this._points[0].tangent && !this._points[1].tangent && this._points[this._points.length - 1].tangent && !this._points[this._points.length - 2].tangent) {
            this._generateClamped();
        }
    }

    //TODO: Assign the matrix to _coefsMat when the build process takes into
    //      account dependencies between files.
    var _hermiteCoefficientMatrix = null;
    HermiteSpline.hermiteCoefficientMatrix = function() {
        if (!_hermiteCoefficientMatrix) {
            _hermiteCoefficientMatrix = new Matrix4(
                    2.0, -3.0,  0.0,  1.0,
                   -2.0,  3.0,  0.0,  0.0,
                    1.0, -2.0,  1.0,  0.0,
                    1.0, -1.0,  0.0,  0.0);
        }
        return _hermiteCoefficientMatrix;
    };

    HermiteSpline._findIndex = function(time, interpolator) {
        // Take advantage of temporal coherence by checking current, next and previous intervals
        // for containment of time.
        var i = interpolator._lastTimeIndex || 0;
        if (time >= interpolator._points[i].time) {
            if (i + 1 < interpolator._points.length && time < interpolator._points[i + 1].time) {
                return i;
            } else if (i + 2 < interpolator._points.length && time < interpolator._points[i + 2].time) {
                interpolator._lastTimeIndex = i + 1;
                return interpolator._lastTimeIndex;
            }
        } else if (i - 1 >= 0 && time >= interpolator._points[i - 1].time) {
            interpolator._lastTimeIndex = i - 1;
            return interpolator._lastTimeIndex;
        }

        // The above failed so do a linear search. For the use cases so far, the
        // length of the list is less than 10. In the future, if there is a bottle neck,
        // it might be here.
        for (i = 0; i < interpolator._points.length - 1; ++i) {
            if (time >= interpolator._points[i].time && time < interpolator._points[i + 1].time) {
                break;
            }
        }

        if (i === interpolator._points.length - 1) {
            i = interpolator._points.length - 2;
        }

        interpolator._lastTimeIndex = i;
        return interpolator._lastTimeIndex;
    };

    HermiteSpline.prototype._generateClamped = function() {
        var l = [], d = [], u = [], r = [];
        l.length = u.length = this._points.length - 1;
        d.length = r.length = this._points.length;

        var i;
        l[0] = d[0] = 1.0;
        u[0] = 0.0;
        r[0] = this._points[0].tangent;
        for (i = 1; i < l.length - 1; ++i) {
            l[i] = u[i] = 1.0;
            d[i] = 4.0;
            r[i] = this._points[i + 1].point.subtract(this._points[i - 1].point).multiplyWithScalar(3.0);
        }
        l[i] = 0.0;
        u[i] = 1.0;
        d[i] = 4.0;
        r[i] = this._points[i + 1].point.subtract(this._points[i - 1].point).multiplyWithScalar(3.0);
        d[i + 1] = 1.0;
        r[i + 1] = this._points[i + 1].tangent;

        var tangents = TridiagonalSystemSolver.solve(l, d, u, r);
        for (i = 0; i < this._points.length; ++i) {
            this._points[i].tangent = tangents[i];
        }
    };

    HermiteSpline.prototype._generateNatural = function() {
        var l = [], d = [], u = [], r = [];
        l.length = u.length = this._points.length - 1;
        d.length = r.length = this._points.length;

        var i;
        l[0] = u[0] = 1.0;
        d[0] = 2.0;
        r[0] = this._points[1].point.subtract(this._points[0].point).multiplyWithScalar(3.0);
        for (i = 1; i < l.length; ++i) {
            l[i] = u[i] = 1.0;
            d[i] = 4.0;
            r[i] = this._points[i + 1].point.subtract(this._points[i - 1].point).multiplyWithScalar(3.0);
        }
        d[i] = 2.0;
        r[i] = this._points[i].point.subtract(this._points[i - 1].point).multiplyWithScalar(3.0);

        var tangents = TridiagonalSystemSolver.solve(l, d, u, r);
        for (i = 0; i < this._points.length; ++i) {
            this._points[i].tangent = tangents[i];
        }
    };

    /**
     * Returns the array of control points.
     *
     * @memberof HermiteSpline
     * @return {Array} The array of control points.
     */
    HermiteSpline.prototype.getControlPoints = function() {
        return this._points;
    };

    /**
     * Evaluates the curve at a given time.
     *
     * @memberof HermiteSpline
     *
     * @param {Number} time The time at which to evaluate the curve.
     *
     * @exception {DeveloperError} time is required.
     * @exception {DeveloperError} time must be in the range <code>[a<sub>0</sub>, a<sub>n</sub>]</code>,
     * where <code>a<sub>0</sub></code> and <code>a<sub>n</sub></code> are the time properties of first and
     * last elements in the array given during construction, respectively.
     *
     * @return {Cartesian3} The point on the curve at the given <code>time</code>.
     *
     * @example
     * // spline above the earth from Philadelphia to Los Angeles
     * var controlPoints = [
     *     {point: new Cartesian3(1235398.0, -4810983.0, 4146266.0), time: 0.0},
     *     {point: new Cartesian3(1372574.0, -5345182.0, 4606657.0), time: 1.5},
     *     {point: new Cartesian3(-757983.0, -5542796.0, 4514323.0), time: 3.0},
     *     {point: new Cartesian3(-2821260.0, -5248423.0, 4021290.0), time: 4.5},
     *     {point: new Cartesian3(-2539788.0, -4724797.0, 3620093.0), time: 6.0}
     * ];
     * var spline = new HermiteSpline(controlPoints);
     *
     * // some position above Los Angeles
     * var position = spline.evaluate(5.0);
     */
    HermiteSpline.prototype.evaluate = function(time) {
        if (typeof time === "undefined") {
            throw new DeveloperError("time is required.", "time");
        }

        if (time < this._points[0].time || time > this._points[this._points.length - 1].time) {
            throw new DeveloperError("time is out of range.", "time");
        }

        var i = HermiteSpline._findIndex(time, this);
        var u = (time - this._points[i].time) / (this._points[i + 1].time - this._points[i].time);

        var timeVec = new Cartesian4(0.0, u * u, u, 1.0);
        timeVec.x = timeVec.y * u;

        var coefs = HermiteSpline.hermiteCoefficientMatrix().multiplyWithVector(timeVec);
        var p0 = this._points[i].point.multiplyWithScalar(coefs.x);
        var p1 = this._points[i + 1].point.multiplyWithScalar(coefs.y);
        var p2 = this._points[i].tangent.multiplyWithScalar(coefs.z);
        var p3 = this._points[i + 1].tangent.multiplyWithScalar(coefs.w);

        return p0.add(p1.add(p2.add(p3)));
    };

    return HermiteSpline;
});

/*global define*/
define('Core/CatmullRomSpline',[
        './DeveloperError',
        './Matrix4',
        './Cartesian3',
        './Cartesian4',
        './HermiteSpline'
    ],
    function(
        DeveloperError,
        Matrix4,
        Cartesian3,
        Cartesian4,
        HermiteSpline) {
    

    /**
     * A Catmull-Rom spline is a cubic spline where the tangent at control points,
     * except the first and last, are computed using the previous and next control points.
     * Catmull-Rom splines are in the class C<sup>1</sup>.
     *
     * @name CatmullRomSpline
     * @constructor
     *
     * @param {Array} controlPoints The array of control points. Each element of the array should be an object with <code>point</code> and <code>time</code> properties.
     * @param {Cartesian3} firstTangent The tangent of the curve at the first control point.
     * If the tangent is not given, it will be estimated.
     * @param {Cartesian3} lastTangent The tangent of the curve at the last control point.
     * If the tangent is not given, it will be estimated.
     *
     * @exception {DeveloperError} controlPoints is required.
     * @exception {DeveloperError} controlPoints must be an array of at least length 3.
     *
     * @see HermiteSpline
     *
     * @example
     * // spline above the earth from Philadelphia to Los Angeles
     * var controlPoints = [
     *     {point: new Cartesian3(1235398.0, -4810983.0, 4146266.0), time: 0.0},
     *     {point: new Cartesian3(1372574.0, -5345182.0, 4606657.0), time: 1.5},
     *     {point: new Cartesian3(-757983.0, -5542796.0, 4514323.0), time: 3.0},
     *     {point: new Cartesian3(-2821260.0, -5248423.0, 4021290.0), time: 4.5},
     *     {point: new Cartesian3(-2539788.0, -4724797.0, 3620093.0), time: 6.0}
     * ];
     * var spline = new CatmullRomSpline(controlPoints);
     */
    function CatmullRomSpline(controlPoints, firstTangent, lastTangent) {
        if (!controlPoints || !(controlPoints instanceof Array) || controlPoints.length < 3) {
            throw new DeveloperError("An array of objects with point and time properties, with a length of at least 3, is required.", "controlPoints");
        }

        this._points = controlPoints;
        this._lastTimeIndex = 0;

        if (firstTangent) {
            this._ti = Cartesian3.clone(firstTangent);
        } else {
            this._ti = controlPoints[1].point
                           .multiplyWithScalar(2.0)
                           .subtract(controlPoints[2].point)
                           .subtract(controlPoints[0].point)
                           .multiplyWithScalar(0.5);
        }

        if (firstTangent) {
            this._to = Cartesian3.clone(lastTangent);
        } else {
            var n = controlPoints.length - 1;
            this._to = controlPoints[n].point
                           .subtract(controlPoints[n - 1].point.multiplyWithScalar(2.0))
                           .add(controlPoints[n - 2].point)
                           .multiplyWithScalar(0.5);
        }
    }

    //TODO: Assign the matrix to _coefsMat when the build process takes into
    //      account dependencies between files.
    var _catmullRomCoefficientMatrix = null;
    CatmullRomSpline.catmullRomCoefficientMatrix = function() {
        if (!_catmullRomCoefficientMatrix) {
            _catmullRomCoefficientMatrix = new Matrix4(
                   -0.5,  1.0, -0.5,  0.0,
                    1.5, -2.5,  0.0,  1.0,
                   -1.5,  2.0,  0.5,  0.0,
                    0.5, -0.5,  0.0,  0.0);
        }
        return _catmullRomCoefficientMatrix;
    };

    /**
     * Returns the array of control points.
     *
     * @memberof CatmullRomSpline
     * @return {Array} The array of control points.
     */
    CatmullRomSpline.prototype.getControlPoints = function() {
        return this._points;
    };

    /**
     * Returns the tangent of the first control point.
     *
     * @memberof CatmullRomSpline
     *
     * @return {Cartesian3} The tangent of the first control point.
     *
     * @see CatmullRomSpline#getEndTangent
     */
    CatmullRomSpline.prototype.getStartTangent = function() {
        return this._ti;
    };

    /**
     * Returns the tangent of the last control point.
     *
     * @memberof CatmullRomSpline
     *
     * @return {Cartesian3} The tangent of the last control point.
     *
     * @see CatmullRomSpline#getStartTangent
     */
    CatmullRomSpline.prototype.getEndTangent = function() {
        return this._to;
    };

    /**
     * Evaluates the curve at a given time.
     *
     * @memberof CatmullRomSpline
     *
     * @param {Number} time The time at which to evaluate the curve.
     *
     * @exception {DeveloperError} time is required.
     * @exception {DeveloperError} time must be in the range <code>[a<sub>0</sub>, a<sub>n</sub>]</code>,
     * where <code>a<sub>0</sub></code> and <code>a<sub>n</sub></code> are the time properties of first and
     * last elements in the array given during construction, respectively.
     *
     * @return {Cartesian3} The point on the curve at the given <code>time</code>.
     *
     * @example
     * // spline above the earth from Philadelphia to Los Angeles
     * var controlPoints = [
     *     {point: new Cartesian3(1235398.0, -4810983.0, 4146266.0), time: 0.0},
     *     {point: new Cartesian3(1372574.0, -5345182.0, 4606657.0), time: 1.5},
     *     {point: new Cartesian3(-757983.0, -5542796.0, 4514323.0), time: 3.0},
     *     {point: new Cartesian3(-2821260.0, -5248423.0, 4021290.0), time: 4.5},
     *     {point: new Cartesian3(-2539788.0, -4724797.0, 3620093.0), time: 6.0}
     * ];
     * var spline = new CatmullRomSpline(controlPoints);
     *
     * // some position above Los Angeles
     * var position = spline.evaluate(5.0);
     */
    CatmullRomSpline.prototype.evaluate = function(time) {
        if (typeof time === "undefined") {
            throw new DeveloperError("time is required.", "time");
        }

        if (time < this._points[0].time || time > this._points[this._points.length - 1].time) {
            throw new DeveloperError("time is out of range.", "time");
        }

        var i = HermiteSpline._findIndex(time, this);
        var u = (time - this._points[i].time) / (this._points[i + 1].time - this._points[i].time);

        var timeVec = new Cartesian4(0.0, u * u, u, 1.0);
        timeVec.x = timeVec.y * u;

        var p0, p1, p2, p3, coefs;
        if (i === 0) {
            p0 = this._points[0].point;
            p1 = this._points[1].point;
            p2 = this._ti;
            p3 = this._points[2].point.subtract(p0).multiplyWithScalar(0.5);
            coefs = HermiteSpline.hermiteCoefficientMatrix().multiplyWithVector(timeVec);
        } else if (i === this._points.length - 2) {
            p0 = this._points[i].point;
            p1 = this._points[i + 1].point;
            p2 = p1.subtract(this._points[i - 1].point).multiplyWithScalar(0.5);
            p3 = this._to;
            coefs = HermiteSpline.hermiteCoefficientMatrix().multiplyWithVector(timeVec);
        } else {
            p0 = this._points[i - 1].point;
            p1 = this._points[i].point;
            p2 = this._points[i + 1].point;
            p3 = this._points[i + 2].point;
            coefs = CatmullRomSpline.catmullRomCoefficientMatrix().multiplyWithVector(timeVec);
        }
        p0 = p0.multiplyWithScalar(coefs.x);
        p1 = p1.multiplyWithScalar(coefs.y);
        p2 = p2.multiplyWithScalar(coefs.z);
        p3 = p3.multiplyWithScalar(coefs.w);

        return p0.add(p1.add(p2.add(p3)));
    };

    return CatmullRomSpline;
});

/*global define*/
define('Core/Visibility',['./Enumeration'], function(Enumeration) {
    

    /**
     * This enumerated type is used in determining to what extent an object, the occludee,
     * is visible during horizon culling. An occluder may fully block an occludee, in which case
     * it has no visibility, may partially block an occludee from view, or may not block it at all,
     * leading to full visibility.
     *
     * @exports Visibility
     */
    var Visibility = {
        /**
         * Represents that no part of an object is visible.
         *
         * @constant
         * @type {Enumeration}
         */
        NONE : new Enumeration(-1, "NONE"),
        /**
        * Represents that part, but not all, of an object is visible
        *
        * @constant
        * @type {Enumeration}
        */
        PARTIAL : new Enumeration(0, "PARTIAL"),
        /**
        * Represents that an object is visible in its entirety.
        *
        * @constant
        * @type {Enumeration}
        */
        FULL : new Enumeration(1, "FULL")
    };

    return Visibility;
});
/*global define*/
define('Core/Occluder',[
        './DeveloperError',
        './Math',
        './Cartesian3',
        './Visibility'
    ], function(
        DeveloperError,
        CesiumMath,
        Cartesian3,
        Visibility) {
    

    /**
     * Creates an Occluder derived from an object's position and radius, as well as the camera position.
     * The occluder can be used to determine wether or not other objects are visible or hidden behind the
     * visible horizon defined by the occluder and camera position.
     *
     * @name Occluder
     *
     * @param {BoundingSphere} occluderBS The bounding sphere surrounding the occluder.
     * @param {Cartesian3} cameraPosition The coordinate of the viewer/camera.
     *
     * @exception {DeveloperError} <code>occluderBS</code> is required.
     * @exception {DeveloperError} <code>cameraPosition</code> is required.
     *
     * @constructor
     *
     * @example
     * // Construct an occluder one unit away from the origin with a radius of one.
     * var cameraPosition = new Cartesian3.getZero();
     * var occluderBS = new BoundingSphere(new Cartesian3(0, 0, -1), 1);
     * var occluder = new Occluder(occluderBS, cameraPosition);
     */
    function Occluder(occluderBS, cameraPosition) {
        if (!occluderBS) {
            throw new DeveloperError("occluder bounding sphere is required.", "occluderPBS");
        }
        if (!cameraPosition) {
            throw new DeveloperError("camera position is required.", "cameraPosition");
        }

        var cameraPos = Cartesian3.clone(cameraPosition);
        var occluderPosition = occluderBS.center.clone();
        var occluderRadius = occluderBS.radius;

        var cameraToOccluderVec = occluderPosition.subtract(cameraPosition);
        var invCameraToOccluderDistance = cameraToOccluderVec.magnitudeSquared();
        var occluderRadiusSqrd = occluderRadius * occluderRadius;
        var horizonDistance;
        var horizonPlaneNormal;
        var horizonPlanePosition;
        if (invCameraToOccluderDistance > occluderRadiusSqrd) {
            horizonDistance = Math.sqrt(invCameraToOccluderDistance - occluderRadiusSqrd);
            invCameraToOccluderDistance = 1.0 / Math.sqrt(invCameraToOccluderDistance);
            horizonPlaneNormal = cameraToOccluderVec.multiplyWithScalar(invCameraToOccluderDistance);
            var nearPlaneDistance = horizonDistance * horizonDistance * invCameraToOccluderDistance;
            horizonPlanePosition = cameraPos.add(horizonPlaneNormal.multiplyWithScalar(nearPlaneDistance));
        } else {
            horizonDistance = Number.MAX_VALUE;
        }

        this._occluderPosition = occluderPosition;
        this._occluderRadius = occluderRadius;
        this._cameraPosition = cameraPos.clone();
        this._horizonDistance = horizonDistance;
        this._horizonPlaneNormal = horizonPlaneNormal;
        this._horizonPlanePosition = horizonPlanePosition;
    }

    /**
     * Returns the position of the occluder.
     *
     * @memberof Occluder
     *
     * @return {Cartesian3} The position of the occluder.
     */
    Occluder.prototype.getPosition = function() {
        return this._occluderPosition;
    };

    /**
     * Returns the radius of the occluder.
     *
     * @return {Number} The radius of the occluder.
     */
    Occluder.prototype.getRadius = function() {
        return this._occluderRadius;
    };

    /**
    * Determines whether or not an object, the <code>occludee</code>, is hidden from view by the occluder.
    *
    * @memberof Occluder
    *
    * @param {BoundingSphere} occludeeBS The bounding sphere surrounding the occludee object.
    *
    * @return {boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.
    *
    * @example
    * var cameraPosition = new Cartesian3(0, 0, 0);
    * var littleSphere = new BoundingSphere(new Cartesian3(0, 0, -1), 0.25);
    * var occluder = new Occluder(littleSphere, cameraPosition);
    * var bigSphere = new BoundingSphere(new Cartesian3(0, 0, -3), 1);
    * occluder.isVisible(bigSphere); //returns true
    *
    * @see Occluder#getVisibility
    */
    Occluder.prototype.isVisible = function(occludeeBS) {
        var occludeePosition = occludeeBS.center.clone();
        var occludeeRadius = occludeeBS.radius;

        if (this._horizonDistance !== Number.MAX_VALUE) {
            var tempVec = occludeePosition.subtract(this._occluderPosition);
            var temp = this._occluderRadius - occludeeRadius;
            temp = tempVec.magnitudeSquared() - (temp * temp);
            if (occludeeRadius < this._occluderRadius) {
                if (temp > 0.0) {
                    temp = Math.sqrt(temp) + this._horizonDistance;
                    tempVec = occludeePosition.subtract(this._cameraPosition);
                    return ((temp * temp) + (occludeeRadius * occludeeRadius)) > tempVec.magnitudeSquared();
                }
                return false;
            }

            // Prevent against the case where the occludee radius is larger than the occluder's; since this is
            // an uncommon case, the following code should rarely execute.
            if (temp > 0.0) {
                tempVec = occludeePosition.subtract(this._cameraPosition);
                var tempVecMagnitudeSquared = tempVec.magnitudeSquared();
                var occluderRadiusSquared = this._occluderRadius * this._occluderRadius;
                var occludeeRadiusSquared = occludeeRadius * occludeeRadius;
                if ((((this._horizonDistance * this._horizonDistance) + occluderRadiusSquared) * occludeeRadiusSquared) >
                    (tempVecMagnitudeSquared * occluderRadiusSquared)) {
                    // The occludee is close enough that the occluder cannot possible occlude the occludee
                    return true;
                }
                temp = Math.sqrt(temp) + this._horizonDistance;
                return ((temp * temp) + occludeeRadiusSquared) > tempVecMagnitudeSquared;
            }

            // The occludee completely encompasses the occluder
            return true;
        }

        return false;
    };

    /**
     * Determine to what extent an occludee is visible (not visible, partially visible,  or fully visible).
     *
     * @memberof Occluder
     *
     * @param {BoundingSphere} occludeeBS
     *
     * @return {Enumeration} Visibility.NONE if the occludee is not visible,
     *                       Visibility.PARTIAL if the occludee is partially visible, or
     *                       Visibility.FULL if the occludee is fully visible.
     * @example
     * var sphere1 = new BoundingSphere(new Cartesian3(0, 0, -1.5), 0.5);
     * var sphere2 = new BoundingSphere(new Cartesian3(0, 0, -2.5), 0.5);
     * var cameraPosition = new Cartesian3(0, 0, 0);
     * var occluder = new Occluder(sphere1, cameraPosition);
     * occluder.getVisibility(sphere2); //returns Visibility.NONE
     *
     * @see Occluder#isVisible
     */
    Occluder.prototype.getVisibility = function(occludeeBS) {
        // If the occludee radius is larger than the occluders, this will return that
        // the entire ocludee is visible, even though that may not be the case, though this should
        // not occur too often.
        var occludeePosition = occludeeBS.center.clone();
        var occludeeRadius = occludeeBS.radius;

        if (occludeeRadius > this._occluderRadius) {
            return Visibility.FULL;
        }

        if (this._horizonDistance !== Number.MAX_VALUE) {
            // The camera is outside the occluder
            var tempVec = occludeePosition.subtract(this._occluderPosition);
            var temp = this._occluderRadius - occludeeRadius;
            var occluderToOccludeeDistSqrd = tempVec.magnitudeSquared();
            temp = occluderToOccludeeDistSqrd - (temp * temp);
            if (temp > 0.0) {
                // The occludee is not completely inside the occluder
                // Check to see if the occluder completely hides the occludee
                temp = Math.sqrt(temp) + this._horizonDistance;
                tempVec = occludeePosition.subtract(this._cameraPosition);
                var cameraToOccludeeDistSqrd = tempVec.magnitudeSquared();
                if (((temp * temp) + (occludeeRadius * occludeeRadius)) < cameraToOccludeeDistSqrd) {
                    return Visibility.NONE;
                }

                // Check to see whether the occluder is fully or partially visible
                // when the occludee does not intersect the occluder
                temp = this._occluderRadius + occludeeRadius;
                temp = occluderToOccludeeDistSqrd - (temp * temp);
                if (temp > 0.0) {
                    // The occludee does not intersect the occluder.
                    temp = Math.sqrt(temp) + this._horizonDistance;
                    return (cameraToOccludeeDistSqrd < ((temp * temp)) + (occludeeRadius * occludeeRadius)) ? Visibility.FULL : Visibility.PARTIAL;
                }

                //Check to see if the occluder is fully or partially visible when the occludee DOES
                //intersect the occluder
                tempVec = occludeePosition.subtract(this._horizonPlanePosition);
                return (tempVec.dot(this._horizonPlaneNormal) > -occludeeRadius) ? Visibility.PARTIAL : Visibility.FULL;
            }
        }
        return Visibility.NONE;
    };

    /**
     * Computes a point that can be used as the occludee position to the visibility functions.
     * Use a radius of zero for the occludee radius.  Typically, a user computes a bounding sphere around
     * an object that is used for visibility; however it is also possible to compute a point that if
     * seen/not seen would also indicate if an object is visible/not visible.  This function is better
     * called for objects that do not move relative to the occluder and is large, such as a chunk of
     * terrain.  You are better off not calling this and using the object's bounding sphere for objects
     * such as a satellite or ground vehicle.
     *
     * @memberof Occluder
     *
     * @param {BoundingSphere} occluderBS The bounding sphere surrounding the occluder.
     * @param {Cartesian3} occludeePosition The point where the occludee (bounding sphere of radius 0) is located.
     * @param {Array} positions List of altitude points on the horizon near the surface of the occluder.
     *
     * @exception {DeveloperError} <code>positions</code> is a required, non-empty array.
     * @exception {DeveloperError} <code>occluderBS</code> is required.
     * @exception {DeveloperError} <code>occludeePosition</code> must have a value other than <code>occluderBS.center</code>.
     *
     * @return {Object} An object containing two attributes: <code>occludeePoint</code> and <code>valid</code>
     * which is a boolean value.
     *
     * @example
     * var cameraPosition = new Cartesian3(0, 0, 0);
     * var occluderBS = new BoundingSphere(new Cartesian3(0, 0, -8), 2);
     * var occluder = new Occluder(occluderBS, cameraPosition);
     * var positions = [new Cartesian3(-0.25, 0, -5.3), new Cartesian3(0.25, 0, -5.3)];
     * var tileOccluderSphere = new BoundingSphere(positions);
     * var occludeePosition = tileOccluderSphere.center;
     * var occludeePt = occluder.getOccludeePoint(occluderBS, occludeePosition, positions);
     *
     */
    Occluder.getOccludeePoint = function(occluderBS, occludeePosition, positions) {
        // Validate input data
        if (!occluderBS) {
            throw new DeveloperError("Argument occluderBS is required.", "occluderBS");
        }

        if (!positions) {
            throw new DeveloperError("Argument positions is required.", "positions");
        }

        if (positions.length === 0) {
            throw new DeveloperError("Argument positions must contain at least one element", "positions");
        }

        var occludeePos = Cartesian3.clone(occludeePosition);
        var occluderPosition = occluderBS.center.clone();
        var occluderRadius = occluderBS.radius;
        var numPositions = positions.length;

        if (occluderPosition.equals(occludeePosition)) {
            throw new DeveloperError("Argument occludeePosition must be different than argument occluderBS's center point", "occludeePosition");
        }

        var valid = true;

        // Compute a plane with a normal from the occluder to the occludee position.
        var occluderPlaneNormal = occludeePos.subtract(occluderPosition).normalize();
        var occluderPlaneD = -(occluderPlaneNormal.dot(occluderPosition));

        //For each position, determine the horizon intersection. Choose the position and intersection
        //that results in the greatest angle with the occcluder plane.
        var aRotationVector = Occluder._anyRotationVector(occluderPosition, occluderPlaneNormal, occluderPlaneD);
        var dot = Occluder._horizonToPlaneNormalDotProduct(occluderBS, occluderPlaneNormal, occluderPlaneD, aRotationVector, positions[0]);
        if (!dot) {
            //The position is inside the mimimum radius, which is invalid
            valid = false;
        }
        var tempDot;
        for ( var i = 1; i < numPositions; ++i) {
            tempDot = Occluder._horizonToPlaneNormalDotProduct(occluderBS, occluderPlaneNormal, occluderPlaneD, aRotationVector, positions[i]);
            if (!tempDot) {
                //The position is inside the minimum radius, which is invalid
                valid = false;
                break;
            }
            if (tempDot < dot) {
                dot = tempDot;
            }
        }
        //Verify that the dot is not near 90 degress
        if (dot < 0.00174532836589830883577820272085) {
            valid = false;
        }

        var distance = occluderRadius / dot;
        var occludeePoint = occluderPosition.add(occluderPlaneNormal.multiplyWithScalar(distance));
        return {
            occludeePoint : occludeePoint,
            valid : valid
        };
    };

    Occluder._anyRotationVector = function(occluderPosition, occluderPlaneNormal, occluderPlaneD) {
        var tempVec0 = occluderPlaneNormal.clone().abs();
        var majorAxis = tempVec0.x > tempVec0.y ? 0 : 1;
        if (((majorAxis === 0) && (tempVec0.z > tempVec0.x)) || ((majorAxis === 1) && (tempVec0.z > tempVec0.y))) {
            majorAxis = 2;
        }
        var tempVec1 = new Cartesian3();
        if (majorAxis === 0) {
            tempVec0.x = occluderPosition.x;
            tempVec0.y = occluderPosition.y + 1.0;
            tempVec0.z = occluderPosition.z + 1.0;
            tempVec1 = Cartesian3.getUnitX();
        } else if (majorAxis === 1) {
            tempVec0.x = occluderPosition.x + 1.0;
            tempVec0.y = occluderPosition.y;
            tempVec0.z = occluderPosition.z + 1.0;
            tempVec1 = Cartesian3.getUnitY();
        } else {
            tempVec0.x = occluderPosition.x + 1.0;
            tempVec0.y = occluderPosition.y + 1.0;
            tempVec0.z = occluderPosition.z;
            tempVec1 = Cartesian3.getUnitZ();
        }
        var u = ((occluderPlaneNormal.dot(tempVec0)) + occluderPlaneD) / -(occluderPlaneNormal.dot(tempVec1));
        return ((tempVec0.add(tempVec1.multiplyWithScalar(u))).subtract(occluderPosition)).normalize();
    };

    Occluder._rotationVector = function(occluderPosition, occluderPlaneNormal, occluderPlaneD, position, anyRotationVector) {
        //Determine the angle between the occluder plane normal and the position direction
        var positionDirection = position.subtract(occluderPosition);
        positionDirection = positionDirection.normalize();
        if (occluderPlaneNormal.dot(positionDirection) < 0.99999998476912904932780850903444) {
            var crossProduct = occluderPlaneNormal.cross(positionDirection);
            var length = crossProduct.magnitude();
            if (length > CesiumMath.EPSILON13) {
                return crossProduct.normalize();
            }
        }
        //The occluder plane normal and the position direction are colinear. Use any
        //vector in the occluder plane as the rotation vector
        return anyRotationVector;
    };

    Occluder._horizonToPlaneNormalDotProduct = function(occluderBS, occluderPlaneNormal, occluderPlaneD, anyRotationVector, position) {
        var occluderPosition = occluderBS.center.clone();
        var occluderRadius = occluderBS.radius;

        //Verify that the position is outside the occluder
        var positionToOccluder = occluderPosition.subtract(position);
        var occluderToPositionDistanceSquared = positionToOccluder.magnitudeSquared();
        var occluderRadiusSquared = occluderRadius * occluderRadius;
        if (occluderToPositionDistanceSquared < occluderRadiusSquared) {
            return false;
        }

        //Horizon parameters
        var horizonDistanceSquared = occluderToPositionDistanceSquared - occluderRadiusSquared;
        var horizonDistance = Math.sqrt(horizonDistanceSquared);
        var occluderToPositionDistance = Math.sqrt(occluderToPositionDistanceSquared);
        var invOccluderToPositionDistance = 1.0 / occluderToPositionDistance;
        var cosTheta = horizonDistance * invOccluderToPositionDistance;
        var horizonPlaneDistance = cosTheta * horizonDistance;
        positionToOccluder = positionToOccluder.normalize();
        var horizonPlanePosition = position.add(positionToOccluder.multiplyWithScalar(horizonPlaneDistance));
        var horizonCrossDistance = Math.sqrt(horizonDistanceSquared - (horizonPlaneDistance * horizonPlaneDistance));

        //Rotate the position to occluder vector 90 degrees
        var tempVec = this._rotationVector(occluderPosition, occluderPlaneNormal, occluderPlaneD, position, anyRotationVector);
        var horizonCrossDirection = new Cartesian3(
                (tempVec.x * tempVec.x * positionToOccluder.x) + ((tempVec.x * tempVec.y - tempVec.z) * positionToOccluder.y) + ((tempVec.x * tempVec.z + tempVec.y) * positionToOccluder.z),
                ((tempVec.x * tempVec.y + tempVec.z) * positionToOccluder.x) + (tempVec.y * tempVec.y * positionToOccluder.y) + ((tempVec.y * tempVec.z - tempVec.x) * positionToOccluder.z),
                ((tempVec.x * tempVec.z - tempVec.y) * positionToOccluder.x) + ((tempVec.y * tempVec.z + tempVec.x) * positionToOccluder.y) + (tempVec.z * tempVec.z * positionToOccluder.z));
        horizonCrossDirection = horizonCrossDirection.normalize();

        //Horizon positions
        var offset = horizonCrossDirection.multiplyWithScalar(horizonCrossDistance);
        tempVec = ((horizonPlanePosition.add(offset)).subtract(occluderPosition)).normalize();
        var dot0 = occluderPlaneNormal.dot(tempVec);
        tempVec = ((horizonPlanePosition.subtract(offset)).subtract(occluderPosition)).normalize();
        var dot1 = occluderPlaneNormal.dot(tempVec);
        return (dot0 < dot1) ? dot0 : dot1;
    };

    return Occluder;
});
/*global define*/
define('Core/WindingOrder',['./Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports WindingOrder
     */
    var WindingOrder = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        CLOCKWISE : new Enumeration(0x0900, "CLOCKWISE"), // GL_CW
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        COUNTER_CLOCKWISE : new Enumeration(0x0901, "COUNTER_CLOCKWISE") // GL_CCW
    };

    return WindingOrder;
});
/*global define*/
define('Core/binarySearch',['./DeveloperError'], function(DeveloperError) {
    

    /**
     * Finds an item in a sorted array.
     *
     * @param {Array} array The sorted array to search.
     * @param {Object} itemToFind The item to find in the array.
     *
     * @param {Function} comparator The function to use to compare the item to elements in the array.
     *        The first parameter passed to the comparator function is an item in the array, the
     *        second is <code>itemToFind</code>.  If the array item is less than <code>itemToFind</code>,
     *        the function should return a negative value.  If it is greater, the function should return
     *        a positive value.  If the items are equal, it should return 0.
     *
     * @return {Number} The index of <code>itemToFind</code> in the array, if it exists.  If <code>itemToFind</code>
     *        does not exist, the return value is a negative number which is the bitwise complement (~)
     *        of the index before which the itemToFind should be inserted in order to maintain the
     *        sorted order of the array.
     *
     * @exception {DeveloperError} <code>array</code> is required.
     * @exception {DeveloperError} <code>toFind</code> is required.
     * @exception {DeveloperError} <code>comparator</code> is required.
     * @exports binarySearch
     *
     * @example
     * // Create a comparator function to search through an array of numbers.
     * var comparator = function (a, b){
     *     return a - b;
     * };
     * var numbers = [0, 2, 4, 6, 8];
     * var index = binarySearch(numbers, 6, comparator); // 3
     */
    function binarySearch(array, itemToFind, comparator) {
        if (!array) {
            throw new DeveloperError("array is required.", "array");
        }
        if (!itemToFind) {
            throw new DeveloperError("itemToFind is required.", "itemToFind");
        }
        if (!comparator) {
            throw new DeveloperError("comparator is required.", "comparator");
        }

        var low = 0;
        var high = array.length - 1;
        var i;
        var comparison;

        while (low <= high) {
            i = ~~((low + high) / 2);
            comparison = comparator(array[i], itemToFind);
            if (comparison < 0) {
                low = i + 1;
                continue;
            }
            if (comparison > 0) {
                high = i - 1;
                continue;
            }
            return i;
        }
        return ~(high + 1);
    }

    return binarySearch;
});
/*global define*/
define('Core/TimeStandard',[
        'require',
        './DeveloperError',
        './binarySearch',
        './LeapSecond'
    ], function(
        require,
        DeveloperError,
        binarySearch,
        LeapSecond) {
    

    var JulianDate = function(a, b, c) {
        //because of the circular reference between JulianDate and TimeStandard,
        //we need to require JulianDate later and replace our reference
        JulianDate = require('./JulianDate');
        return new JulianDate(a, b, c);
    };

    /**
     * Provides a means for measuring time by specifying the rate at which time passes and/or
     * points in time. Note that for many operations, an arithmetically safe standard (such as TAI)
     * should be used in order to correctly compare times. Additionally, functions to convert between
     * time standards and other supplemental functions are provided.
     *
     * @exports TimeStandard
     *
     * @see JulianDate
     * @see LeapSecond
     */
    var TimeStandard = {
        /**
         * Represents the coordinated Universal Time (UTC) time standard.
         *
         * UTC is related to TAI according to the relationship
         * <code>UTC = TAI - deltaT</code> where <code>deltaT</code> is the number of leap
         * seconds which have been introduced as of the time in TAI.
         *
         */
        UTC : 0,

        /**
         * Represents the International Atomic Time (TAI) time standard.
         * TAI is the principal time standard to which the other time standards are related.
         */
        TAI : 1,

        /**
         * If the julian date is already in the UTC time standard, it is returned.
         *
         * @param {JulianDate} julianDate The date, in TAI time standard, to convert to the UTC time standard.
         *
         * @exception {DeveloperError} <code>julianDate</code> is required.
         * @exception {DeveloperError} <code>julianDate</code> is not in the TAI time standard.
         *
         * @return {JulianDate} A Julian date representing the input date in the UTC time standard.
         * @return {Boolean} <code>false</code> if the requested date is during the moment of a leap second.
         *
         * @performance Expected <code>O(log n)</code>, where <code>n</code> is the number of elements
         * in the list of existing leap seconds returned by {@link LeapSecond.getLeapSeconds}.
         *
         * @example
         * // Convert a date representing Jan. 1, 2000 12:00:00 TAI to UTC.
         * var julianDateTai = JulianDate.createJulianDate(2451545.0, TimeStandard.TAI);
         * var julianDateUtc = TimeStandard.convertTaiToUtc(julianDateTai);
         *
         */
        convertTaiToUtc : function(julianDate) {
            if (!julianDate) {
                throw new DeveloperError("julianDate is required.", "julianDate");
            }
            if (julianDate.getTimeStandard() === TimeStandard.UTC) {
                return julianDate;
            }
            if (julianDate.getTimeStandard() !== TimeStandard.TAI) {
                throw new DeveloperError("julianDate is not in the TAI time standard.", "julianDate");
            }

            // treat the request date as if it were UTC, and search for the most recent leap second.
            var toFind = new LeapSecond(julianDate, 0.0);
            var leapSeconds = LeapSecond.getLeapSeconds();
            var index = binarySearch(leapSeconds, toFind, LeapSecond.compareLeapSecondDate);
            if (index < 0) {
                index = ~index;
                --index;
            }
            var leapSecond;
            var newDate;
            // now we have the index of the most recent leap second that is after the requested date.
            if (index >= 0) {
                leapSecond = leapSeconds[index];
                var mostRecentOffset = leapSecond.offset;
                var leapSecondDate = leapSecond.julianDate;

                if (julianDate.getJulianDayNumber() === leapSecondDate.getJulianDayNumber()) {
                    // if the requested date is on the day of the leap second, we may have to adjust
                    var secondsSinceLeapSecond = julianDate.getSecondsOfDay() - leapSecondDate.getSecondsOfDay();
                    if (secondsSinceLeapSecond >= mostRecentOffset - 1 && secondsSinceLeapSecond < mostRecentOffset) {
                        // if the requested date is during the moment of a leap second, then we cannot convert to UTC
                        return false;
                    }

                    if (secondsSinceLeapSecond < mostRecentOffset) {
                        // The leap second we found is actually after the desired date, as a result of simply treating
                        // the TAI date as if it were UTC. So, use the previous leap second instead.
                        --index;
                    }
                }
                newDate = julianDate.addSeconds(-leapSeconds[index].offset);
            } else {
                newDate = julianDate.addSeconds(-leapSeconds[0].offset);
            }
            return new JulianDate(newDate.getJulianDayNumber(), newDate.getSecondsOfDay(), TimeStandard.UTC);
        },

        /**
         * If the julian date is already in the TAI time standard, it is returned.
         *
         * @param {JulianDate} julianDate The date, in the UTC time standard, to convert to the TAI time standard.
         *
         * @exception {DeveloperError} <code>julianDate</code> is required.
         * @exception {DeveloperError} <code>julianDate</code> is not in the UTC time standard.
         *
         * @return {JulianDate} A Julian date representing the input date in the TAI time standard.
         *
         * @example
         * var date = new Date("July 11, 2011 12:00:00 UTC");
         * var julianDateUtc = new JulianDate(date, TimeStandard.UTC);
         * var julianDateTai = TimeStandard.convertUtcToTai(julianDateUtc);
         */
        convertUtcToTai : function(julianDate) {
            if (!julianDate) {
                throw new DeveloperError("julianDate is required.", "julianDate");
            }
            if (julianDate.getTimeStandard() === TimeStandard.TAI) {
                return julianDate;
            }
            if (julianDate.getTimeStandard() !== TimeStandard.UTC) {
                throw new DeveloperError("julianDate is not in the UTC time standard.", "julianDate");
            }

            var newDate = julianDate.addSeconds(julianDate.getTaiMinusUtc());
            return new JulianDate(newDate.getJulianDayNumber(), newDate.getSecondsOfDay(), TimeStandard.TAI);
        }
    };

    return TimeStandard;
});
/*global define*/
define('Core/JulianDate',[
        './DeveloperError',
        './binarySearch',
        './TimeConstants',
        './LeapSecond',
        './TimeStandard'
    ],function(
        DeveloperError,
        binarySearch,
        TimeConstants,
        LeapSecond,
        TimeStandard) {
    

    function computeJulianDayNumber(month, day, year) {
        // Algorithm from page 604 of the Explanatory Supplement to the
        // Astronomical Almanac (Seidelmann 1992).
        month = month | 0;
        day = day | 0;
        year = year | 0;

        var a = ((month - 14) / 12) | 0;
        var b = (year + 4800 + a) | 0;

        return ((((1461 * b) / 4) | 0) + (((367 * (month - 2 - 12 * a)) / 12) | 0) - (((3 * ((b + 100) / 100)) / 4) | 0) + day - 32075) | 0;
    }

    function computeJulianSecondsOfDay(hour, minute, second, millisecond) {
        hour = hour | 0;
        minute = minute | 0;
        second = second | 0;
        millisecond = millisecond | 0;

        // JulianDates are noon-based
        hour = hour - 12;
        if (hour < 0) {
            hour += 24;
        }

        return second + ((hour * TimeConstants.SECONDS_PER_HOUR) + (minute * TimeConstants.SECONDS_PER_MINUTE) + (millisecond * TimeConstants.SECONDS_PER_MILLISECOND));
    }

    /**
     * Creates an immutable JulianDate instance from a Javascript Date object. Alternately, a JulianDate
     * may be constructed by passing a Julian day number and the number of seconds elapsed into that day
     * as arguments (along with an optional time standard).
     *
     * An astronomical Julian Date is the number of days since noon on January 1, -4712 (4713 BC).
     * For increased precision, this class stores the whole number part of the date and the seconds
     * part of the date in separate components.
     *
     * This type assumes that days always have TimeConstants.SECONDS_PER_DAY (86400.0) seconds.
     * When using a JulianDate with the (UTC) time standard, a day with a leap second actually
     * has 86401.0 seconds.  The end result is that JulianDate cannot represent the moment of a
     * leap second with the UTC time standard. However, it can represent the moment of a leap second in the
     * International Atomic Time standard {@link TimeStandard.TAI}.  Also, subtracting
     * two UTC dates that are on opposite sides of a leap second will correctly take the leap second into
     * account.
     * <br/>
     * While the Javascript Date object defaults to the system's local time zone, the Julian date is computed
     * using the UTC values.
     *
     * @name JulianDate
     * @constructor
     * @immutable
     *
     * @param {Date} [date] The Javascript Date object representing the time to be converted to a Julian date.
     * @param {TimeStandard} [timeStandard = TimeStandard.UTC] Indicates the time standard
     * in which this Julian date is represented.
     *
     * @see JulianDate.createJulianDate
     * @see TimeStandard
     * @see LeapSecond
     * @see <a href="http://www.w3schools.com/js/js_obj_date.asp">Javascript Date Object on w3schools</a>.
     * @see <a href="http://www.w3schools.com/jsref/jsref_obj_date.asp">Javascript Date Object Reference on w3schools</a>.
     *
     * @example
     * // Example 1. Construct a Julian date at the current time.
     * var jd = new JulianDate(); // Same as new JulianDate(new Date());
     * var julianDate = jd.getJulianDate();
     *
     * //////////////////////////////////////////////////////////////////
     *
     * // Example 2. Construct a Julian date specifying the UTC time standard
     * var date = new Date("January 1, 2011 12:00:00 EST");
     * var jd = new JulianDate(date, TimeStandard.UTC);
     *
     * //////////////////////////////////////////////////////////////////
     *
     * // Example 3. Construct a Julian date from a Julian day number and seconds of the day.
     * var julianDayNumber = 2448257;   // January 1, 1991
     * var secondsOfDay = 21600;        // 06:00:00
     * var jd = new JulianDate(julianDayNumber, secondsOfDay, TimeStandard.UTC);
     */
    function JulianDate(date) {
        var julianDayNumber;
        var julianSecondsOfDay;
        var timeStandard;

        date = date || new Date();

        if (typeof date === 'number') {
            julianDayNumber = arguments[0];
            julianSecondsOfDay = arguments[1];
            timeStandard = arguments[2];
        } else if (typeof date === 'object') {
            var month = date.getUTCMonth() + 1; // getUTCMonth returns a value 0-11.
            var day = date.getUTCDate();
            var year = date.getUTCFullYear();

            var hours = date.getUTCHours();
            var minutes = date.getUTCMinutes();
            var seconds = date.getUTCSeconds();
            var milliseconds = date.getUTCMilliseconds();

            julianDayNumber = computeJulianDayNumber(month, day, year);
            julianSecondsOfDay = computeJulianSecondsOfDay(hours, minutes, seconds, milliseconds);
            if (julianSecondsOfDay >= 43200.0) {
                julianDayNumber -= 1;
            }
            timeStandard = arguments[1];

            this._date = date;
        }

        // Normalize so that the number of seconds is >= 0 and < a day.
        var wholeDays = (julianSecondsOfDay / TimeConstants.SECONDS_PER_DAY) | 0;
        julianDayNumber += wholeDays;
        julianSecondsOfDay -= TimeConstants.SECONDS_PER_DAY * wholeDays;

        if (julianSecondsOfDay < 0) {
            julianDayNumber--;
            julianSecondsOfDay += TimeConstants.SECONDS_PER_DAY;
        }

        this._timeStandard = timeStandard || TimeStandard.UTC;
        this._julianDayNumber = julianDayNumber;
        this._secondsOfDay = julianSecondsOfDay;
    }

    /**
     * Creates an immutable JulianDate instance from a floating point number representing a Julian date.
     *
     * @memberof JulianDate
     *
     * @param {Number} date
     * @param {TimeStandard} [timeStandard = TimeStandard.UTC] Indicates the time standard
     * in which this Julian date is represented.
     *
     * @exception {DeveloperError} <code>date</code> is required.
     * @exception {DeveloperError} <code>date</code> must be non-negative.
     *
     * @see JulianDate
     * @see TimeStandard
     *
     * @example
     * // Construct a Julian date corresponding to January 1, 1991 06:00:00 UTC.
     * var julianDate = JulianDate.createJulianDate(2448257.75, TimeStandard.UTC);
     */
    JulianDate.createJulianDate = function(date, timeStandard) {
        if (typeof date === 'undefined' || date === null) {
            throw new DeveloperError("date is required.", "date");
        }

        if (date < 0) {
            throw new DeveloperError("Julian date must be non-negative", "date");
        }

        var julianDayNumber = date | 0;
        var secondsOfDay = (date - julianDayNumber) * TimeConstants.SECONDS_PER_DAY;
        return new JulianDate(julianDayNumber, secondsOfDay, timeStandard);
    };

    /**
     * Compares two {JulianDate} instances.
     *
     * @memberof JulianDate
     *
     * @param {JulianDate} a The first instance.
     * @param {JulianDate} b The second instance.
     * @return {Number} A negative value if a is less than b, a positive value if
     *                   a is greater than b, and zero if a and b are equal.
     */
    JulianDate.compare = function(a, b) {
        // If the days aren't even close, don't bother thinking about the time standard.
        var dayDifference = (a._julianDayNumber - b._julianDayNumber) | 0;
        if (dayDifference > 1 || dayDifference < -1) {
            return dayDifference;
        }

        if (a.getTimeStandard() !== TimeStandard.TAI) {
            a = TimeStandard.convertUtcToTai(a);
        }
        if (b.getTimeStandard() !== TimeStandard.TAI) {
            b = TimeStandard.convertUtcToTai(b);
        }

        if (dayDifference !== 0) {
            return dayDifference;
        }

        return a._secondsOfDay - b._secondsOfDay;
    };

    /**
     * Returns the time standard used to construct this JulianDate.
     *
     * @memberof JulianDate
     *
     * @return The property of {@Link TimeStandard} representing the correct time standard.
     *
     * @see TimeStandard
     */
    JulianDate.prototype.getTimeStandard = function() {
        return this._timeStandard;
    };

    /**
     * Returns the total number of whole and fractional days represented by this astronomical Julian date.
     *
     * @memberof JulianDate
     *
     * @return {Number} The Julian date as single floating point number.
     *
     * @see JulianDate#getJulianDayNumber
     * @see JulianDate#getJulianTimeFraction
     */
    JulianDate.prototype.getJulianDate = function() {
        if (!this._julianDate) {
            this._julianDate = this._julianDayNumber + (this._secondsOfDay / TimeConstants.SECONDS_PER_DAY);
        }
        return this._julianDate;
    };

    /**
     * Returns the whole number component of the Julian date.
     *
     * @memberof JulianDate
     *
     * @return {Number} A whole number representing the Julian day number.
     *
     * @see JulianDate#getJulianDate
     * @see JulianDate#getJulianTimeFraction
     */
    JulianDate.prototype.getJulianDayNumber = function() {
        return this._julianDayNumber;
    };

    /**
     * Returns the floating point component of the Julian date representing the time of day.
     *
     * @memberof JulianDate
     *
     * @return {Number} The floating point component of the Julian date representing the time of day.
     *
     * @see JulianDate#getJulianDate
     * @see JulianDate#getJulianDayNumber
     */
    JulianDate.prototype.getJulianTimeFraction = function() {
        if (!this._julianTimeFraction) {
            this._julianTimeFraction = this._secondsOfDay / TimeConstants.SECONDS_PER_DAY;
        }
        return this._julianTimeFraction;
    };

    /**
     * Return the number of seconds elapsed into the current Julian day (starting at noon).
     *
     * @memberof JulianDate
     *
     * @return {Number} The number of seconds elapsed into the current day.
     *
     * @see JulianDate#getJulianDayNumber
     */
    JulianDate.prototype.getSecondsOfDay = function() {
        return this._secondsOfDay;
    };

    /**
     * Returns a Javascript Date object equivalent to the Julian date
     * (accurate to the nearest second in the UTC time standard).
     *
     * @memberof JulianDate
     *
     * @return {Date} The Javascript Date equivalent to this Julian date.
     */
    JulianDate.prototype.getDate = function() {
        if (!this._date) {
            var julianDayNumber = this._julianDayNumber;
            var secondsOfDay = this._secondsOfDay;
            if (this._timeStandard === TimeStandard.TAI) {
                var julianDateTai = TimeStandard.convertTaiToUtc(this);
                julianDayNumber = julianDateTai._julianDayNumber;
                secondsOfDay = julianDateTai._secondsOfDay;
            }
            if (secondsOfDay >= 43200.0) {
                julianDayNumber += 1;
            }

            // Algorithm from page 604 of the Explanatory Supplement to the
            // Astronomical Almanac (Seidelmann 1992).
            var L = (julianDayNumber + 68569) | 0;
            var N = (4 * L / 146097) | 0;
            L = (L - (((146097 * N + 3) / 4) | 0)) | 0;
            var I = ((4000 * (L + 1)) / 1461001) | 0;
            L = (L - (((1461 * I) / 4) | 0) + 31) | 0;
            var J = ((80 * L) / 2447) | 0;
            var day = (L - (((2447 * J) / 80) | 0)) | 0;
            L = (J / 11) | 0;
            var month = (J + 2 - 12 * L) | 0;
            var year = (100 * (N - 49) + I + L) | 0;

            month--; // month field is zero-indexed

            var hours = (secondsOfDay / TimeConstants.SECONDS_PER_HOUR) | 0;
            var remainingSeconds = secondsOfDay - (hours * TimeConstants.SECONDS_PER_HOUR);
            var minutes = (remainingSeconds / TimeConstants.SECONDS_PER_MINUTE) | 0;
            remainingSeconds = remainingSeconds - (minutes * TimeConstants.SECONDS_PER_MINUTE);
            var seconds = remainingSeconds | 0;
            var milliseconds = ((remainingSeconds - seconds) / TimeConstants.SECONDS_PER_MILLISECOND) | 0;

            // JulianDates are noon-based
            hours += 12;
            if (hours > 23) {
                hours -= 24;
            }

            this._date = new Date(Date.UTC(year, month, day, hours, minutes, seconds, milliseconds));
        }
        return this._date;
    };

    /**
     * Computes the number of seconds that have elapsed from this Julian date to the <code>other</code>
     * Julian date, taking leap seconds into account.
     *
     * @memberof JulianDate
     *
     * @param {JulianDate} other The other Julian date, which is the end of the interval.
     *
     * @return {Number} The number of seconds that have elpased from this Julian date to the other Julian date.
     *
     * @see JulianDate#getMinutesDifference
     *
     * @example
     * var start = new JulianDate(new Date("July 4, 2011 12:00:00"));
     * var end = new JulianDate(new Date("July 5, 2011 12:01:00"));
     * var difference = start.getSecondsDifference(end);    // 86460.0 seconds
     */
    JulianDate.prototype.getSecondsDifference = function(other) {
        // If not already, convert the dates to the TAI standard, which is safe for arithmetic.
        var julianDate1 = this;
        var julianDate2 = other;
        if (julianDate1.getTimeStandard() !== TimeStandard.TAI) {
            julianDate1 = TimeStandard.convertUtcToTai(julianDate1);
        }
        if (julianDate2.getTimeStandard() !== TimeStandard.TAI) {
            julianDate2 = TimeStandard.convertUtcToTai(julianDate2);
        }

        var dayDifference = (julianDate2.getJulianDayNumber() - julianDate1.getJulianDayNumber()) * TimeConstants.SECONDS_PER_DAY;
        return (dayDifference + (julianDate2.getSecondsOfDay() - julianDate1.getSecondsOfDay()));
    };

    /**
     * Computes the number of minutes that have elapsed from this Julian date to the <code>other</code>
     * Julian date, taking leap seconds into account.
     *
     * @memberof JulianDate
     *
     * @param {JulianDate} other The other Julian date, which is the end of the interval.
     *
     * @return {Number} The number of seconds that have elpased from this Julian date to the other Julian date.
     *
     * @see JulianDate#getSecondsDifference
     *
     * @example
     * var start = new JulianDate(new Date("July 4, 2011 12:00:00"));
     * var end = new JulianDate(new Date("July 5, 2011 12:01:00"));
     * var difference = start.getMinutesDifference(end);    // 1441.0 minutes
     */
    JulianDate.prototype.getMinutesDifference = function(other) {
        // If not already, convert the dates to the TAI standard, which is safe for arithmetic.
        var julianDate1 = this;
        var julianDate2 = other;
        if (julianDate1.getTimeStandard() !== TimeStandard.TAI) {
            julianDate1 = TimeStandard.convertUtcToTai(julianDate1);
        }
        if (julianDate2.getTimeStandard() !== TimeStandard.TAI) {
            julianDate2 = TimeStandard.convertUtcToTai(julianDate2);
        }

        var dayDifference = (julianDate2.getJulianDayNumber() - julianDate1.getJulianDayNumber()) * TimeConstants.MINUTES_PER_DAY;
        var timeDifference = (julianDate2.getSecondsOfDay() - julianDate1.getSecondsOfDay()) / TimeConstants.SECONDS_PER_MINUTE;
        return (dayDifference + timeDifference);
    };

    /**
     * Returns the difference in seconds between the TAI and UTC time standards
     * for this Julian date.
     *
     * @memberof JulianDate
     *
     * @return {Number} The difference in seconds between the TAI and UTC time standards for this date.
     *
     * @performance Expected <code>O(log n)</code>, where <code>n</code> is the number of elements
     * in the list of existing leap seconds returned by {@link LeapSecond.getLeapSeconds}.
     *
     * @see LeapSecond
     * @see TimeStandard
     *
     * @example
     * var date = new Date("July 11, 2011 12:00:00 UTC");
     * var jd = new JulianDate(date, TimeStandard.TAI);
     * var difference = jd.getTaiMinusUtc();    // 34
     */
    JulianDate.prototype.getTaiMinusUtc = function() {
        // Start by assuming we're working with UTC. We'll check
        // later if we're off by one because we really have TAI.
        var toFind = new LeapSecond(this, 0.0);
        var leapSeconds = LeapSecond.getLeapSeconds();
        var index = binarySearch(leapSeconds, toFind, LeapSecond.compareLeapSecondDate);
        if (index < 0) {
            index = ~index;
            --index;
        }
        // Check if we're off by one because we're really working with TAI.
        // If the requested date minus the most recent previous leap second offset is less than the date
        // for the current leap second, then we haven't quite gotten to that leap second yet.
        if (this.getTimeStandard() === TimeStandard.TAI) {
            var lastDate;
            var indexOffset;
            if (index < 0 || index >= leapSeconds.length) {
                // Corresponds to a the Julian Date 0.0
                var beginning = new Date(Date.UTC(-4712, 0, -37, 12, 0, 0, 0));
                lastDate = new JulianDate(beginning, TimeStandard.UTC);
                indexOffset = 10.0;
            } else {
                lastDate = leapSeconds[index].julianDate;
                indexOffset = leapSeconds[index].offset;
            }
            var taiCutoff = new JulianDate(lastDate.getJulianDayNumber(), lastDate.getSecondsOfDay());
            taiCutoff = taiCutoff.addSeconds(indexOffset);
            if (this.isBefore(taiCutoff)) {
                --index;
            }
        }

        if (index < 0) {
            return 10.0;
        }
        return LeapSecond.getLeapSeconds()[index].offset;
    };

    /**
     * Returns a new Julian date representing a time <code>duration</code> seconds later
     * (or earlier in the case of a negative amount).
     *
     * @memberof JulianDate
     *
     * @param {Number} duration An integer number of seconds to add or subtract.
     *
     * @return {JulianDate} A new Julian date object
     *
     * @see JulianDate#addMinutes
     * @see JulianDate#addHours
     * @see JulianDate#addDays
     *
     * @example
     * var date = new Date();
     * date.setUTCFullYear(2011, 6, 4);     // July 4, 2011 @ 12:00:00 UTC
     * date.setUTCHours(12, 0, 00, 0);
     * var start = new JulianDate(date);
     * var end = start.addSeconds(95);      // July 4, 2011 @ 12:01:35 UTC
     */
    JulianDate.prototype.addSeconds = function(duration) {
        var newSecondsOfDay = this._secondsOfDay + duration;
        return new JulianDate(this._julianDayNumber, newSecondsOfDay, this._timeStandard);
    };

    /**
     * Returns a new Julian date representing a time <code>duration</code> minutes later
     * (or earlier in the case of a negative amount).
     *
     * @memberof JulianDate
     *
     * @param {Number} duration An integer number of minutes to add or subtract.
     *
     * @return {JulianDate} A new Julian date object
     *
     * @see JulianDate#addSeconds
     * @see JulianDate#addHours
     * @see JulianDate#addDays
     *
     * @example
     * var date = new Date();
     * date.setUTCFullYear(2011, 6, 4);     // July 4, 2011 @ 12:00 UTC
     * date.setUTCHours(12, 0, 0, 0);
     * var start = new JulianDate(date);
     * var end = start.addMinutes(65);      // July 4, 2011 @ 13:05 UTC
     */
    JulianDate.prototype.addMinutes = function(duration) {
        var newSecondsOfDay = this._secondsOfDay + (duration * TimeConstants.SECONDS_PER_MINUTE);
        return new JulianDate(this._julianDayNumber, newSecondsOfDay, this._timeStandard);
    };

    /**
     * Returns a new Julian date representing a time <code>duration</code> hours later
     * (or earlier in the case of a negative amount).
     *
     * @memberof JulianDate
     *
     * @param {Number} duration An integer number of hours to add or subtract.
     *
     * @return {JulianDate} A new Julian date object
     *
     * @see JulianDate#addSeconds
     * @see JulianDate#addMinutes
     * @see JulianDate#addDays
     *
     * @example
     * var date = new Date();
     * date.setUTCFullYear(2011, 6, 4);     // July 4, 2011 @ 12:00 UTC
     * date.setUTCHours(12, 0, 0, 0);
     * var start = new JulianDate(date);
     * var end = start.addHours(6);         // July 4, 2011 @ 18:00 UTC
     */
    JulianDate.prototype.addHours = function(duration) {
        var newSecondsOfDay = this._secondsOfDay + (duration * TimeConstants.SECONDS_PER_HOUR);
        return new JulianDate(this._julianDayNumber, newSecondsOfDay, this._timeStandard);
    };

    /**
     * Returns a new Julian date representing a time <code>duration</code> days later
     * (or earlier in the case of a negative amount).
     *
     * @memberof JulianDate
     *
     * @param {Number} duration An integer number of days to add or subtract.
     *
     * @return {JulianDate} A new Julian date object
     *
     * @see JulianDate#addSeconds
     * @see JulianDate#addMinutes
     * @see JulianDate#addHours
     *
     * @example
     * var date = new Date();
     * date.setUTCFullYear(2011, 6, 4);     // July 4, 2011 @ 12:00 UTC
     * date.setUTCHours(12, 0, 0, 0);
     * var start = new JulianDate(date);
     * var end = start.addDays(5);         // July 9, 2011 @ 12:00 UTC
     */
    JulianDate.prototype.addDays = function(duration) {
        var newJulianDayNumber = this._julianDayNumber + duration;
        return new JulianDate(newJulianDayNumber, this._secondsOfDay, this._timeStandard);
    };

    /**
     * Computes the fraction of the year corresponding to this Julian date. Leap years
     * are taken into account.
     *
     * @memberof JulianDate
     *
     * @return {Number} The fraction of the current year that has passed.
     *
     * @example
     * var date = new Date(2011, 0, 2); // January 2, 2011 @ 0:00
     * date.setUTCHours(0, 0, 0, 0);
     * var julianDate = new JulianDate(date);
     * var yearFraction = julianDate.toYearFraction(); //1.0/365.0
     */
    JulianDate.prototype.toYearFraction = function() {
        var commonYearCumulativeMonthTable = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
        var leapYearCumulativeMonthTable = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
        var dayInYear;
        var fractionOfDay;

        function isLeapYear(year) {
            return ((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0);
        }

        function dayOfYear(date) {
            var day = date.getDate();
            var month = date.getMonth();
            if (isLeapYear(date.getFullYear())) {
                return day + leapYearCumulativeMonthTable[month];
            }
            return day + commonYearCumulativeMonthTable[month];
        }

        var date = this._date;
        if (this._secondsOfDay / TimeConstants.SECONDS_PER_DAY < 0.5) {
            dayInYear = dayOfYear(date) - 1;
            fractionOfDay = (this._secondsOfDay / TimeConstants.SECONDS_PER_DAY) + 0.5;
        } else {
            date.setDate(date.getDate() + 1);
            dayInYear = dayOfYear(date) - 1;
            fractionOfDay = (this._secondsOfDay / TimeConstants.SECONDS_PER_DAY) - 0.5;
        }

        if (isLeapYear(date.getFullYear())) {
            return (dayInYear + fractionOfDay) / 366.0;
        }

        return (dayInYear + fractionOfDay) / 365.0;
    };

    /**
     * Returns true if <code>other</code> occurs after this Julian date.
     *
     * @memberof JulianDate
     *
     * @param {JulianDate} other The Julian date to be compared.
     *
     * @return {Boolean} <code>true</code> if this JulianDate is chronologically earlier than <code>other</code>; otherwise, <code>false</code>.
     *
     * @see JulianDate#isAfter
     *
     * @example
     * var start = new JulianDate(new Date("July 6, 1991 12:00:00"));
     * var end = new JulianDate(new Date("July 6, 2011 12:01:00"));
     * start.isBefore(end);     // true
     */
    JulianDate.prototype.isBefore = function(other) {
        return JulianDate.compare(this, other) < 0;
    };

    /**
     * Returns true if <code>other</code> occurs before this Julian date.
     *
     * @memberof JulianDate
     *
     * @param {JulianDate} other The Julian date to be compared.
     *
     * @return {Boolean} <code>true</code> if this JulianDate is chronologically later than <code>other</code>; otherwise, <code>false</code>.
     *
     * @see JulianDate#isBefore
     *
     * @example
     * var start = new JulianDate(new Date("July 6, 1991 12:00:00"));
     * var end = new JulianDate(new Date("July 6, 2011 12:01:00"));
     * end.isAfter(start);      // true
     */
    JulianDate.prototype.isAfter = function(other) {
        return JulianDate.compare(this, other) > 0;
    };

    /**
     * Returns <code>true</code> if this date is equivalent to the specified date.
     *
     * @memberof JulianDate
     *
     * @param {JulianDate} other The JulianDate to be compared.
     * @param {Number} epsilon The number of seconds that should separate the two JulianDates
     *
     * @return {Boolean} <code>true</code> if the two JulianDates are equal; otherwise <code>false</code>.
     *
     * @see JulianDate#equalsEpsilon
     *
     * @example
     * var original = new JulianDate(new Date("July 4, 2011 12:00:00"));
     * var clone = new JulianDate(new Date("July 4, 2011 12:00:00"));
     * original.equals(clone);      // true
     */
    JulianDate.prototype.equals = function(other) {
        return JulianDate.compare(this, other) === 0;
    };

    /**
     * Returns <code>true</code> if this date is within <code>epsilon</code> seconds of the
     * specified date.  That is, in order for the dates to be considered equal (and for
     * this function to return <code>true</code>), the absolute value of the difference between them, in
     * seconds, must be less than <code>epsilon</code>.
     *
     * @memberof JulianDate
     *
     * @param {JulianDate} other The JulianDate to be compared.
     * @param {Number} epsilon The number of seconds that should separate the two JulianDates
     *
     * @return {Boolean} <code>true</code> if the two JulianDates are within <code>epsilon</code> seconds of each other; otherwise <code>false</code>.
     *
     * @see JulianDate#equals
     *
     * @example
     * var original = new JulianDate(new Date("July 4, 2011 12:00:00"));
     * var clone = new JulianDate(new Date("July 4, 2011 12:00:01"));
     * original.equalsEpsilon(clone, 2);    // true
     */
    JulianDate.prototype.equalsEpsilon = function(other, epsilon) {
        return Math.abs(this.getSecondsDifference(other)) <= epsilon;
    };

    return JulianDate;
});
/*global define*/
define('Core/CachePolicy',[
        './DeveloperError',
        './JulianDate'
    ], function(
        DeveloperError,
        JulianDate) {
    

    /**
     * Defines cache replacement policies.
     *
     * @name CachePolicy
     *
     * @see Cache
     */
    var CachePolicy = {};

    /**
     * Least recently used cache replacement policy that replaces the least recently used
     * item from the cache first.
     *
     * @name CachePolicy.LRU
     *
     * @constructor
     *
     * @param {Function} description.fetchFunc A function that given the key will return an object to store in the cache.
     * @param {Function} description.removeFunc A optional function that will be called when the object will be removed from the cache.
     * @param {Number} description.limit  The maximum number of objects that can be stored in the cache, defaults to 128.
     *
     * @exception {DeveloperError} description.fetchFunc is required.
     */
    CachePolicy.LRU = function(description) {
        var desc = description || {};

        if (!desc.fetchFunc || typeof desc.fetchFunc !== "function") {
            throw new DeveloperError("description.fetchFunc is a required function.", "description.fetchFunc");
        }

        this._limit = desc.limit || 128;
        this._count = 0;
        this._fetchFunc = desc.fetchFunc;
        this._removeFunc = (typeof desc.removeFunc === "function") ? desc.removeFunc : null;
    };

    /**
     * This function is called by the cache when an object is requested and is stored in the cache.
     * Updates the object as used recently.
     *
     * @memberof CachePolicy.LRU
     *
     * @param {Object} object The value stored in the cache that was requested by its key.
     */
    CachePolicy.LRU.prototype.hit = function(object) {
        object.lastHit = new JulianDate();
        return object.value;
    };

    /**
     * This function is called by the cache when an object is requested and is not stored in the cache.
     * Replaces the LRU object with the object returned by the fetch function given to the constructor.
     *
     * @memberof CachePolicy.LRU
     *
     * @param {String} name The string name used as a key into the hash.
     * @param {Object} key The object that was used as a key into the cache;
     * @param {Object} object An object used as a hash table. The key/value pairs are elements store in the cache.
     */
    CachePolicy.LRU.prototype.miss = function(name, key, object) {
        var property = {
            key : key,
            value : null,
            lastHit : null
        };

        property.value = this._fetchFunc(key);
        var lruTime = new JulianDate();
        property.lastHit = lruTime;

        if (this._count < this._limit) {
            ++this._count;
            object[name] = property;
            return property.value;
        }

        var element;
        var index = '';
        var keys = Object.keys(object);
        for ( var i = 0; i < keys.length; ++i) {
            element = object[keys[i]];
            if (element.lastHit.isBefore(lruTime)) {
                lruTime = element.lastHit;
                index = keys[i];
            }
        }
        element = object[index];
        if (this._removeFunc) {
            this._removeFunc(element.key);
        }
        delete object[index];

        object[name] = property;
        return property.value;
    };

    return CachePolicy;
});

/*global define*/
define('Core/SunPosition',[
        './Math',
        './Cartesian3',
        './Cartographic2',
        './Matrix3',
        './JulianDate'
    ],
    function(
        CesiumMath,
        Cartesian3,
        Cartographic2,
        Matrix3,
        JulianDate) {
    

    /**
     * DOC_TBA.
     *
     * @exports SunPosition
     */
    var SunPosition = {
        /**
         * Computes the approximate sun position, in the WGS84 coordinate system (Earth's fixed frame), for a given julian date.
         *
         * @param {JulianDate} [julianDate] The julian date to compute the sun's position for.
         *
         * @example
         * // Compute the current sun position
         * var position = SunPosition.compute().position;
         */
        compute : function(julianDate) {
            julianDate = julianDate || new JulianDate();

            var AU_TO_METERS = 149597870700.0;

            function isLeapYear(year) {
                return ((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0);
            }

            function toGregorianDate(julianDate) {
                var j = julianDate + 32044;
                var g = Math.floor(j / 146097);
                var dg = j - Math.floor(j / 146097) * 146097;
                var c = Math.floor((Math.floor(dg / 36524 + 1) * 3) / 4);
                var dc = dg - c * 36524;
                var b = Math.floor(dc / 1461);
                var db = dc - Math.floor(dc / 1461) * 1461;
                var a = Math.floor((Math.floor(db / 365 + 1) * 3) / 4);
                var da = db - a * 365;
                var y = g * 400 + c * 100 + b * 4 + a;
                var m = Math.floor((da * 5 + 308) / 153) - 2;
                var d = da - Math.floor(((m + 4) * 153) / 5) + 122;
                var year = y - 4800 + Math.floor((m + 2) / 12);
                var month = (m + 2) - Math.floor((m + 2) / 12) * 12 + 1;
                var day = Math.floor(d + 1.5);
                return {
                    month : month,
                    day : day,
                    year : year
                };
            }

            var T = (julianDate.getJulianDate() - 2451545.0) / 36525;
            var meanAnomaly = CesiumMath.convertLongitudeRange(CesiumMath.toRadians(357.5277233 + 35999.05034 * T));
            var distanceToSunInAU = 1.000140612 - 0.016708617 * Math.cos(meanAnomaly) - 0.000139589 * Math.cos(2 * meanAnomaly);

            var date = toGregorianDate(julianDate.getJulianDate());
            var dayNumber = 0;
            switch (date.month) {
            case 1:
                dayNumber = date.day;
                break;
            case 2:
                dayNumber = date.day + 31;
                break;
            case 3:
                dayNumber = date.day + 59;
                break;
            case 4:
                dayNumber = date.day + 90;
                break;
            case 5:
                dayNumber = date.day + 120;
                break;
            case 6:
                dayNumber = date.day + 151;
                break;
            case 7:
                dayNumber = date.day + 181;
                break;
            case 8:
                dayNumber = date.day + 212;
                break;
            case 9:
                dayNumber = date.day + 243;
                break;
            case 10:
                dayNumber = date.day + 273;
                break;
            case 11:
                dayNumber = date.day + 304;
                break;
            case 12:
                dayNumber = date.day + 334;
                break;
            }

            if (isLeapYear(date.year) && date.month > 2) {
                dayNumber++;
            }

            var temp = CesiumMath.toRadians((360.0 / 365.0) * (dayNumber - 81.0));
            var equationOfTime = 9.87 * Math.sin(2 * temp) - 7.53 * Math.cos(temp) - 1.5 * Math.sin(temp);
            var timeFraction = julianDate.getJulianTimeFraction();
            var localTime;
            if (timeFraction >= 0.5) {
                localTime = timeFraction * 24.0 - 12.0;
            } else {
                localTime = 12.0 + timeFraction * 24.0;
            }
            var localSolarTime = localTime + (equationOfTime / 60.0);
            var hourAngle = CesiumMath.toRadians(15.0 * (12.0 - localSolarTime));
            var declinationAngle = Math.asin(0.39795 * Math.cos(CesiumMath.toRadians(0.98563 * (dayNumber - 173.0))));
            var x = Math.cos(declinationAngle) * Math.cos(hourAngle);
            var y = Math.cos(declinationAngle) * Math.sin(hourAngle);
            var z = Math.sin(declinationAngle);
            var latitudeAngle = 0.0;

            var transform = new Matrix3(
                    Math.cos(latitudeAngle),        0.0, Math.sin(latitudeAngle),
                    0.0,                            1.0, 0.0,
                    -1.0 * Math.sin(latitudeAngle), 0.0, Math.cos(latitudeAngle));

            var direction = transform.multiplyWithVector(new Cartesian3(x, y, z));
            var distance = distanceToSunInAU * AU_TO_METERS;

            /**
             * DOC_TBA
             */
            return {
                /**
                 * The approximate coordinates of the sun's position in the earth's fixed frame.
                 *
                 * @type Cartesian3
                 */
                position : direction.multiplyWithScalar(distance),

                /**
                 * The cartographic position, in radians, of the sun's position projected onto Earth.  This is accurate to within less than a degree of the true position.
                 *
                 * @type Cartographic2
                 */
                cartographicPosition : new Cartographic2(hourAngle, declinationAngle),

                /**
                 * Returns a unit vector, in Earth's fixed frame, pointing to the sun.
                 *
                 * @type Cartesian3
                 */
                direction : direction,

                /**
                 * The approximate distance from the center of the Earth to the center of the Sun in meters.
                 *
                 * @type Number
                 */
                distance : distance
            };
        }
    };

    return SunPosition;
});

/*global define*/
define('Core/Transforms',[
        './DeveloperError',
        './Math',
        './Matrix3',
        './Matrix4',
        './Cartesian3',
        './TimeStandard',
        './TimeConstants',
        './Ellipsoid'
    ],
    function(
        DeveloperError,
        CesiumMath,
        Matrix3,
        Matrix4,
        Cartesian3,
        TimeStandard,
        TimeConstants,
        Ellipsoid) {
    

    /**
     * @exports Transforms
     *
     * DOC_TBA
     */
    var Transforms = {
        /**
         * Creates a 4x4 transformation matrix from a reference frame center at <code>position</code>
         * with local east-north-up axes to the ellipsoid's fixed reference frame, e.g., WGS84 coordinates
         * for Earth.  The local axes are defined as:
         * <ul>
         * <li>The <code>x</code> axis points in the local east direction.</li>
         * <li>The <code>y</code> axis points in the local north direction.</li>
         * <li>The <code>z</code> axis points in the direction of the ellipsoid surface normal which passes through the position.</li>
         * </ul>
         *
         * DOC_TBA:  Add images
         *
         * @param {Cartesian3} position The center point of the local reference frame.
         * @param {Ellipsoid} [ellipsoid] The ellipsoid whose fixed frame is used in the transform.
         *
         * @see Transforms.northEastDownToFixedFrame
         *
         * @exception {DeveloperError} position is required.
         *
         * @example
         * // Get the transform from local east-north-up at cartographic (0.0, 0.0) to Earth's fixed frame.
         * var ellipsoid = Ellipsoid.getWgs84();
         * var center = ellipsoid.cartographicDegreesToCartesian(Cartographic2.getZero());
         * var transform = Transforms.eastNorthUpToFixedFrame(center);
         */
        eastNorthUpToFixedFrame : function(position, ellipsoid) {
            if (!position) {
                throw new DeveloperError("position is required.", "position");
            }

            ellipsoid = ellipsoid || Ellipsoid.getWgs84();

            if (CesiumMath.equalsEpsilon(position.x, 0.0, CesiumMath.EPSILON14) &&
                    CesiumMath.equalsEpsilon(position.y, 0.0, CesiumMath.EPSILON14)) {
                // The poles are special cases.  If x and y are zero, assume position is at a pole.
                var sign = CesiumMath.sign(position.z);
                return new Matrix4(
                    0.0, sign * -1.0,        0.0, position.x,
                    1.0,         0.0,        0.0, position.y,
                    0.0,         0.0, sign * 1.0, position.z,
                    0.0,         0.0,        0.0, 1.0);
            }

            var normal = ellipsoid.geodeticSurfaceNormal(position);
            var tangent = new Cartesian3(-position.y, position.x, 0.0).normalize();
            var bitangent = normal.cross(tangent);

            return new Matrix4(
                tangent.x, bitangent.x, normal.x, position.x,
                tangent.y, bitangent.y, normal.y, position.y,
                tangent.z, bitangent.z, normal.z, position.z,
                0.0,       0.0,         0.0,      1.0);
        },

        /**
         * Creates a 4x4 transformation matrix from a reference frame center at <code>position</code>
         * with local north-east-down axes to the ellipsoid's fixed reference frame, e.g., WGS84 coordinates
         * for Earth.  The local axes are defined as:
         * <ul>
         * <li>The <code>x</code> axis points in the local north direction.</li>
         * <li>The <code>y</code> axis points in the local east direction.</li>
         * <li>The <code>z</code> axis points in the opposite direction of the ellipsoid surface normal which passes through the position.</li>
         * </ul>
         *
         * DOC_TBA:  Add images
         *
         * @param {Cartesian3} position The center point of the local reference frame.
         * @param {Ellipsoid} [ellipsoid] The ellipsoid whose fixed frame is used in the transform.
         *
         * @see Transforms.eastNorthUpToFixedFrame
         *
         * @exception {DeveloperError} position is required.
         *
         * @example
         * // Get the transform from local north-east-down at cartographic (0.0, 0.0) to Earth's fixed frame.
         * var ellipsoid = Ellipsoid.getWgs84();
         * var center = ellipsoid.cartographicDegreesToCartesian(Cartographic2.getZero());
         * var transform = Transforms.northEastDownToFixedFrame(center);
         */
        northEastDownToFixedFrame : function(position, ellipsoid) {
            if (!position) {
                throw new DeveloperError("position is required.", "position");
            }

            ellipsoid = ellipsoid || Ellipsoid.getWgs84();

            if (CesiumMath.equalsEpsilon(position.x, 0.0, CesiumMath.EPSILON14) &&
                    CesiumMath.equalsEpsilon(position.y, 0.0, CesiumMath.EPSILON14)) {
                // The poles are special cases.  If x and y are zero, assume position is at a pole.
                var sign = CesiumMath.sign(position.z);
                return new Matrix4(
                    sign * -1.0, 0.0, 0.0, position.x,
                    0.0, 1.0,         0.0, position.y,
                    0.0, 0.0, sign * -1.0, position.z,
                    0.0, 0.0,         0.0, 1.0);
            }

            var normal = ellipsoid.geodeticSurfaceNormal(position);
            var tangent = new Cartesian3(-position.y, position.x, 0.0).normalize();
            var bitangent = normal.cross(tangent);

            return new Matrix4(
                bitangent.x, tangent.x, -normal.x, position.x,
                bitangent.y, tangent.y, -normal.y, position.y,
                bitangent.z, tangent.z, -normal.z, position.z,
                0.0,         0.0,        0.0,      1.0);
        }
    };

    return Transforms;
});

/*global define*/
define('Core/EllipsoidTangentPlane',[
        './DeveloperError',
        './Transforms',
        './AxisAlignedBoundingBox',
        './IntersectionTests',
        './Cartesian2',
        './Cartesian3'
    ], function(
        DeveloperError,
        Transforms,
        AxisAlignedBoundingBox,
        IntersectionTests,
        Cartesian2,
        Cartesian3) {
    

    /**
     * DOC_TBA
     * @name EllipsoidTangentPlane
     * @constructor
     *
     * @param {Ellipsoid} ellipsoid
     * @param {Cartesian3} origin
     */
    function EllipsoidTangentPlane(ellipsoid, origin) {
        var o = Cartesian3.clone(origin);
        var eastNorthUp = Transforms.eastNorthUpToFixedFrame(o, ellipsoid);

        this.origin = o;
        this.xAxis = eastNorthUp.getColumn0().getXYZ();
        this.yAxis = eastNorthUp.getColumn1().getXYZ();
        this.normal = eastNorthUp.getColumn2().getXYZ();
        this.d = -o.dot(o);
        this.ellipsoid = ellipsoid;
    }

    /**
     * DOC_TBA
     * @memberof EllipsoidTangentPlane
     */
    EllipsoidTangentPlane.create = function(ellipsoid, positions) {
        if (!ellipsoid || !positions) {
            throw new DeveloperError("ellipsoid and positions are required.");
        }

        var box = new AxisAlignedBoundingBox(positions);
        var origin = ellipsoid.scaleToGeodeticSurface(box.center);
        return new EllipsoidTangentPlane(ellipsoid, origin);
    };

    /**
     * DOC_TBA
     * @memberof EllipsoidTangentPlane
     */
    EllipsoidTangentPlane.prototype.projectPointsOntoPlane = function(positions) {
        if (!positions) {
            throw new DeveloperError("positions is required.", "positions");
        }

        var positionsOnPlane = [];

        var length = positions.length;
        for ( var i = 0; i < length; ++i) {
            var p = this.projectPointOntoPlane(positions[i]);
            if (p) {
                positionsOnPlane.push(p);
            }
        }

        return positionsOnPlane;
    };

    /**
     * DOC_TBA
     * @memberof EllipsoidTangentPlane
     */
    EllipsoidTangentPlane.prototype.projectPointOntoPlane = function(position) {
        if (position) {
            var pos = Cartesian3.clone(position);
            var intersectionPoint = IntersectionTests.rayPlane(pos, pos.normalize(), this.normal, this.d);

            if (intersectionPoint) {
                var v = intersectionPoint.subtract(this.origin);
                return new Cartesian2(this.xAxis.dot(v), this.yAxis.dot(v));
            }
        }
    };

    /**
     * DOC_TBA
     * @memberof EllipsoidTangentPlane
     */
    EllipsoidTangentPlane.prototype.projectPointsOntoEllipsoid = function(positions) {
        if (!positions) {
            throw new DeveloperError("positions is required.", "positions");
        }

        var positionsOnEllipsoid = [];

        var length = positions.length;
        for ( var i = 0; i < length; ++i) {
            var p = this.origin;
            p = p.add(this.xAxis.multiplyWithScalar(positions[i].x));
            p = p.add(this.yAxis.multiplyWithScalar(positions[i].y));

            positionsOnEllipsoid.push(this.ellipsoid.scaleToGeocentricSurface(p));
        }

        return positionsOnEllipsoid;
    };

    return EllipsoidTangentPlane;
});
/*global define*/
define('Core/Shapes',[
        './DeveloperError',
        './Math',
        './Cartesian2',
        './Cartesian3',
        './Quaternion',
        './EllipsoidTangentPlane'
    ], function(
        DeveloperError,
        CesiumMath,
        Cartesian2,
        Cartesian3,
        Quaternion,
        EllipsoidTangentPlane) {
    

    function _computeEllipseQuadrant(cb, cbRadius, aSqr, bSqr, ab, ecc, mag, unitPos, eastVec, northVec, bearing,
                                     thetaPts, thetaPtsIndex, offset, clockDir, ellipsePts, ellipsePtsIndex, numPts) {
        var angle;
        var theta;
        var radius;
        var azimuth;
        var temp;
        var temp2;
        var rotAxis;
        var tempVec;

        for (var i = 0; i < numPts; i++, thetaPtsIndex += clockDir, ++ellipsePtsIndex) {
            theta = (clockDir > 0) ? (thetaPts[thetaPtsIndex] + offset) : (offset - thetaPts[thetaPtsIndex]);

            azimuth = theta + bearing;

            temp = -Math.cos(azimuth);

            rotAxis = eastVec.multiplyWithScalar(temp);

            temp = Math.sin(azimuth);
            tempVec = northVec.multiplyWithScalar(temp);

            rotAxis = rotAxis.add(tempVec);

            temp = Math.cos(theta);
            temp = temp * temp;

            temp2 = Math.sin(theta);
            temp2 = temp2 * temp2;

            radius = ab / Math.sqrt(bSqr * temp + aSqr * temp2);
            angle = radius / cbRadius;

            // Create the quaternion to rotate the position vector to the boundary of the ellipse.
            temp = Math.sin(angle / 2.0);

            var unitQuat = (new Quaternion(rotAxis.x * temp, rotAxis.y * temp, rotAxis.z * temp, Math.cos(angle / 2.0))).normalize();
            var rotMtx = unitQuat.toRotationMatrix();

            var tmpEllipsePts = rotMtx.multiplyWithVector(unitPos);
            var unitCart = tmpEllipsePts.normalize();
            tmpEllipsePts = unitCart.multiplyWithScalar(mag);
            ellipsePts[ellipsePtsIndex] = tmpEllipsePts;
        }
    }

    /**
     * Functions to compute the boundary positions for shapes, such as circles,
     * drawn on the ellipsoid.
     *
     * @exports Shapes
     */
    var Shapes = {
        /**
         * Computes boundary points for a circle on the ellipsoid.
         * <br /><br />
         * The <code>granularity</code> determines the number of points
         * in the boundary.  A lower granularity results in more points and a more
         * exact circle.
         * <br /><br />
         * An outlined circle is rendered by passing the result of this function call to
         * {@link Polyline#setPositions}.  A filled circle is rendered by passing
         * the result to {@link Polygon#setPositions}.
         *
         * @param {Ellipsoid} ellipsoid The ellipsoid the circle will be on.
         * @param {Cartesian3} center The circle's center point in the fixed frame.
         * @param {Number} radius The radius in meters.
         * @param {Number} [granularity] The angular distance between points on the circle.
         *
         * @exception {DeveloperError} ellipsoid, center, and radius are required.
         * @exception {DeveloperError} radius must be greater than zero.
         * @exception {DeveloperError} granularity must be greater than zero.
         *
         * @see Polyline#setPositions
         * @see Polygon#setPositions
         *
         * @example
         * // Create a polyline of a circle
         * var polyline = new Polyline();
         * polyline.setPositions(Shapes.computeCircleBoundary(
         *   ellipsoid, ellipsoid.cartographicDegreesToCartesian(
         *     new Cartographic2(-75.59777, 40.03883)), 100000.0));
         */
        computeCircleBoundary : function(ellipsoid, center, radius, granularity) {
            if (!ellipsoid || !center || !radius) {
                throw new DeveloperError("ellipsoid, center, and radius are required.");
            }

            if (radius <= 0.0) {
                throw new DeveloperError("radius must be greater than zero.", "radius");
            }

            granularity = granularity || CesiumMath.toRadians(1.0);
            if (granularity <= 0.0) {
                throw new DeveloperError("granularity must be greater than zero.", "granularity");
            }

            return this.computeEllipseBoundary(ellipsoid, center, radius, radius, 0, granularity);
        },

        /**
         * Computes boundary points for an ellipse on the ellipsoid.
         * <br /><br />
         * The <code>granularity</code> determines the number of points
         * in the boundary.  A lower granularity results in more points and a more
         * exact circle.
         * <br /><br />
         * An outlined ellipse is rendered by passing the result of this function call to
         * {@link Polyline#setPositions}.  A filled ellipse is rendered by passing
         * the result to {@link Polygon#setPositions}.
         *
         * @param {Ellipsoid} ellipsoid The ellipsoid the ellipse will be on.
         * @param {Cartesian3} center The ellipse's center point in the fixed frame.
         * @param {Number} semiMajorAxis The length of the ellipse's semi-major axis in meters.
         * @param {Number} semiMinorAxis The length of the ellipse's semi-minor axis in meters.
         * @param {Number} [bearing] The angle from north (counter-clockwise) in radians. The default is zero.
         * @param {Number} [granularity] The angular distance between points on the circle.
         *
         * @exception {DeveloperError} ellipsoid, center, semiMajorAxis, and semiMinorAxis are required.
         * @exception {DeveloperError} Semi-major and semi-minor axes must be greater than zero.
         * @exception {DeveloperError} granularity must be greater than zero.
         *
         * @see Polyline#setPositions
         * @see Polygon#setPositions
         *
         * @return The set of points that form the ellipse's boundary.
         *
         * @example
         * // Create a filled ellipse.
         * var polygon = new Cesium.Polygon();
         * polygon.setPositions(Cesium.Shapes.computeEllipseBoundary(
         *   ellipsoid, ellipsoid.cartographicDegreesToCartesian(
         *      new Cesium.Cartographic2(-75.59777, 40.03883)), 500000.0, 300000.0, Cesium.Math.toRadians(60)));
         */
        computeEllipseBoundary : function(ellipsoid, center, semiMajorAxis, semiMinorAxis, bearing, granularity) {
            if (!ellipsoid || !center || !semiMajorAxis || !semiMinorAxis) {
                throw new DeveloperError("ellipsoid, center, semiMajorAxis, and semiMinorAxis are required.");
            }

            if (semiMajorAxis <= 0.0 || semiMinorAxis <= 0.0) {
                throw new DeveloperError("Semi-major and semi-minor axes must be greater than zero.");
            }

            bearing = bearing || 0.0;
            granularity = granularity || CesiumMath.toRadians(1.0);

            if (granularity <= 0.0) {
                throw new DeveloperError("granularity must be greater than zero.", "granularity");
            }

            if (semiMajorAxis < semiMinorAxis) {
               var t = semiMajorAxis;
               semiMajorAxis = semiMinorAxis;
               semiMinorAxis = t;
            }

            var MAX_ANOMALY_LIMIT = 2.31;

            var aSqr = semiMajorAxis * semiMajorAxis;
            var bSqr = semiMinorAxis * semiMinorAxis;
            var ab = semiMajorAxis * semiMinorAxis;

            var value = 1.0 - (bSqr / aSqr);
            var ecc = Math.sqrt(value);

            var surfPos = Cartesian3.clone(center);
            var mag = surfPos.magnitude();

            var tempVec = new Cartesian3(0.0, 0.0, 1);
            var temp = 1.0 / mag;

            var unitPos = surfPos.multiplyWithScalar(temp);
            var eastVec = tempVec.cross(surfPos).normalize();
            var northVec = unitPos.cross(eastVec);

            var numQuadrantPts = 1 + Math.ceil(CesiumMath.PI_OVER_TWO / granularity);
            var deltaTheta = MAX_ANOMALY_LIMIT / (numQuadrantPts - 1);
            var thetaPts = new Array(3 * numQuadrantPts);
            var thetaPtsIndex = 0;

            var sampleTheta = 0.0;
            for (var i = 0; i < numQuadrantPts; i++, sampleTheta += deltaTheta, ++thetaPtsIndex) {
                thetaPts[thetaPtsIndex] = sampleTheta - ecc * Math.sin(sampleTheta);
                if (thetaPts[thetaPtsIndex] >= CesiumMath.PI_OVER_TWO) {
                    thetaPts[thetaPtsIndex] = CesiumMath.PI_OVER_TWO;
                    numQuadrantPts = i + 1;
                    break;
                }
            }

            var ellipsePts = new Array(4 * (numQuadrantPts - 1) + 1);

            _computeEllipseQuadrant(ellipsoid, surfPos.magnitude(), aSqr, bSqr, ab, ecc, mag, unitPos, eastVec, northVec, bearing,
                                   thetaPts, 0.0, 0.0, 1, ellipsePts, 0, numQuadrantPts - 1);

            _computeEllipseQuadrant(ellipsoid, surfPos.magnitude(), aSqr, bSqr, ab, ecc, mag, unitPos, eastVec, northVec, bearing,
                                   thetaPts, numQuadrantPts - 1, Math.PI, -1, ellipsePts, numQuadrantPts - 1, numQuadrantPts - 1);

            _computeEllipseQuadrant(ellipsoid, surfPos.magnitude(), aSqr, bSqr, ab, ecc, mag, unitPos, eastVec, northVec, bearing,
                                   thetaPts, 0.0, Math.PI, 1, ellipsePts, (2 * numQuadrantPts) - 2, numQuadrantPts - 1);

            _computeEllipseQuadrant(ellipsoid, surfPos.magnitude(), aSqr, bSqr, ab, ecc, mag, unitPos, eastVec, northVec, bearing,
                                   thetaPts, numQuadrantPts - 1, CesiumMath.TWO_PI, -1, ellipsePts, (3 * numQuadrantPts) - 3, numQuadrantPts);

            ellipsePts.push(ellipsePts[0].clone()); // Duplicates first and last point for polyline

            return ellipsePts;
        }
    };

    return Shapes;
});
/*global define*/
define('Core/clone',[],function() {
    

    function clone(object) {
        if (object === null || typeof object !== 'object') {
            return object;
        }

        var temp = new object.constructor();
        for ( var key in object) {
            if (object.hasOwnProperty(key)) {
                temp[key] = clone(object[key]);
            }
        }

        return temp;
    }

    return clone;
});

/*global define*/
define('Core/combine',['./DeveloperError'], function(DeveloperError) {
    

    /**
     * DOC_TBA
     *
     * @exception {DeveloperError} Duplicate member.
     */
    function combine() {
        var composite = {};
        var length = arguments.length;
        for ( var i = 0; i < length; ++i) {
            var object = arguments[i];

            // Shallow copy
            for ( var key in object) {
                if (object.hasOwnProperty(key)) {
                    if (composite[key]) {
                        throw new DeveloperError("Duplicate member: " + key);
                    }

                    composite[key] = object[key];
                }
            }
        }

        return composite;
    }

    return combine;
});
/*global define*/
define('Core/createGuid',[],function() {
    

    /**
     * Creates a Globally unique identifier (GUID) string.  A GUID is 128 bits long, and can guarantee uniqueness across space and time.
     *
     * @see <a href="http://www.ietf.org/rfc/rfc4122.txt">RFC 4122 A Universally Unique IDentifier (UUID) URN Namespace</a>
     *
     * @example
     * this.guid = createGuid();
     */
    function createGuid() {
        // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            var r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }

    return createGuid;
});

/*global define*/
define('Core/destroyObject',['./DeveloperError'], function(DeveloperError) {
    

    /**
     * Destroys an object.  Each of the object's functions, including functions in its prototype, is replaced with a function that throws
     * a {@link DeveloperError}, except for the object's <code>isDestroyed</code> function, which is set to a function that returns
     * <code>true</code>.  The object's properties are removed with <code>delete</code>.
     * <br /><br />
     * This function is used by objects that hold native resources, e.g., WebGL resources, which need to be explicitly released.  Client code
     * calls an object's <code>destroy</code> function, which then releases the native resource and calls <code>destroyObject</code> to put
     * itself in a destroyed state.
     *
     * @param {Object} object The object to destroy.
     * @param {String} [name=undefined] The message to include in the exception that is thrown if a destroyed object's function is called.
     *
     * @see DeveloperError
     *
     * @example
     * // How a texture would destroy itself.
     * this.destroy = function () {
     *     _gl.deleteTexture(_texture);
     *     return destroyObject(this);
     * };
     */
    function destroyObject(object, message) {
        message = message || "This object was destroyed, i.e., destroy() was called.";

        function throwOnDestroyed() {
            throw new DeveloperError(message);
        }

        for ( var key in object) {
            if (typeof object[key] === "function") {
                object[key] = throwOnDestroyed;
            } else {
                delete object[key];
            }
        }

        /**
         * @private
         */
        object.isDestroyed = function() {
            return true;
        };

        return undefined;
    }

    return destroyObject;
});

/*global define*/
define('Core/Cache',[
        './DeveloperError',
        './destroyObject'
    ], function(
        DeveloperError,
        destroyObject) {
    

    /**
     * A software cache implementation.
     *
     * @name Cache
     *
     * @constructor
     *
     * @param {Object} policy A cache replacement policy.
     *
     * @exception {DeveloperError} policy is required.
     * @exception {DeveloperError} policy must have a fetch function.
     * @exception {DeveloperError} policy must have a miss function.
     *
     * @see CachePolicy.LRU
     */
    function Cache(policy) {
        if (!policy) {
            throw new DeveloperError("policy is required.", "policy");
        }

        if (!policy.hit || typeof policy.hit !== "function") {
            throw new DeveloperError("policy must have a hit function.", "policy.hit");
        }

        if (!policy.miss || typeof policy.miss !== "function") {
            throw new DeveloperError("policy must have a miss function.", "policy.miss");
        }

        this._cache = {};
        this._policy = policy;
    }

    /**
     * Returns the object at key in the cache. It is the responsibility of the cache replacement policy
     * to fetch items not stored in the cache, which will be stored in the cache and returned.
     *
     * @memberof Cache
     *
     * @param {Object} key The key of the object to remove from the cache.
     *
     * @exception {DeveloperError} key is required.
     * @exception {DeveloperError} key must be a string, have a string property called "key", or
     * have a function called "getKey" that returns a string.
     *
     * @return {Object} The object stored in the cache at <code>key</code>.
     *
     * @see Cache#remove
     */
    Cache.prototype.find = function(key) {
        if (!key) {
            throw new DeveloperError("key is required.", "key");
        }

        var name = key;
        if (typeof key !== 'string') {
            name = key.key || (key.getKey && key.getKey());
        }

        if (!name) {
            throw new DeveloperError("key must be a string, or an object with a string key property or getKey function.", "key");
        }

        var element = this._cache[name];
        if (element) {
            return this._policy.hit(element);
        }

        return this._policy.miss(name, key, this._cache);
    };

    /**
     * Removes the object at key from the cache.
     *
     * @memberof Cache
     *
     * @param {Object} key The key of the object to remove from the cache.
     *
     * @return {Boolean} <code>true</code> is the object was removed from the cache, <code>false</code>
     * if the object was not found and not removed.
     *
     * @see Cache#find
     */
    Cache.prototype.remove = function(key) {
        if (!key) {
            return false;
        }

        var name = key;
        if (typeof key !== 'string') {
            name = key.key || (key.getKey && key.getKey());
        }

        if (!name) {
            return false;
        }

        if (this._cache[name]) {
            delete this._cache[name];
            return true;
        }

        return false;
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof Cache
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see Cache.destroy
     */
    Cache.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>null</code>) to the object as done in the example.
     *
     * @memberof Cache
     *
     * @return {null}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see Cache#isDestroyed
     *
     * @example
     * cache = cache && cache.destroy();
     */
    Cache.prototype.destroy = function() {
        var keys = Object.keys(this._cache);
        for ( var i = 0; i < keys.length; ++i) {
            var e = keys[i];
            if (e && e.isDestroyed && !e.isDestroyed() && e.destroy) {
                e.destroy();
            }
        }
        return destroyObject(this);
    };

    return Cache;
});

/*global define*/
define('Core/EventHandler',[
        './DeveloperError',
        './destroyObject',
        './Cartesian2',
        './JulianDate',
        './MouseEventType',
        './EventModifier'
    ], function(
        DeveloperError,
        destroyObject,
        Cartesian2,
        JulianDate,
        MouseEventType,
        EventModifier) {
    
    /*global document*/

    /**
     * Handles user input events. Custom functions can be added to be executed on
     * when the user enters input.
     *
     * @name EventHandler
     *
     * @param {DOC_TBA} element The element to add events to. Defaults to document.
     * @constructor
     */
    function EventHandler(element) {
        this._keyEvents = {};

        this._mouseEvents = {};
        for ( var button in MouseEventType) {
            if (MouseEventType.hasOwnProperty(button)) {
                this._mouseEvents[button] = 0;
            }
        }

        this._modifiedKeyEvents = {};
        for ( var modifier in EventModifier) {
            if (EventModifier.hasOwnProperty(modifier)) {
                this._modifiedKeyEvents[modifier] = {};
            }
        }

        this._modifiedMouseEvents = {};
        for (modifier in EventModifier) {
            if (EventModifier.hasOwnProperty(modifier)) {
                this._modifiedMouseEvents[modifier] = {};
                for (button in MouseEventType) {
                    if (MouseEventType.hasOwnProperty(button)) {
                        this._modifiedMouseEvents[modifier][button] = 0;
                    }
                }
            }
        }

        this._leftMouseButtonDown = false;
        this._middleMouseButtonDown = false;
        this._rightMouseButtonDown = false;
        this._seenAnyTouchEvents = false;
        this._lastMouseX = 0;
        this._lastMouseY = 0;
        this._totalPixels = 0;

        // TODO: Revisit when doing mobile development. May need to be configurable
        // or determined based on the platform?
        this._clickPixelTolerance = 5;

        this._element = element || document;

        this._register();
    }

    EventHandler.prototype._getPosition = function(event) {
        if (this._element === document) {
            return {
                x : event.clientX,
                y : event.clientY
            };
        }

        var rect = this._element.getBoundingClientRect();
        return {
            x : event.clientX - rect.left,
            y : event.clientY - rect.top
        };
    };

    /**
     * Returns <code>true</code> if the left mouse button is pressed and <code>false</code> otherwise.
     *
     * @memberof EventHandler
     *
     * @return {Boolean} <code>true</code> if the left mouse button is pressed and <code>false</code> otherwise.
     *
     * @see EventHandler#isMiddleMouseButtonDown
     * @see EventHandler#isRightMouseButtonDown
     */
    EventHandler.prototype.isLeftMouseButtonDown = function() {
        return this._leftMouseButtonDown;
    };

    /**
     * Returns the last time that the left mouse button was pressed.
     *
     * @memberof EventHandler
     *
     * @return {JulianDate} The time the left mouse button was pressed.
     *
     * @see EventHandler#getLeftReleaseTime
     * @see EventHandler#getRightPressTime
     * @see EventHandler#getMiddlePressTime
     */
    EventHandler.prototype.getLeftPressTime = function() {
        return this._leftPressTime;
    };

    /**
     * Returns the last time that the left mouse button was released.
     *
     * @memberof EventHandler
     *
     * @return {JulianDate} The time the left mouse button was released.
     *
     * @see EventHandler#getLeftPressTime
     * @see EventHandler#getRightReleaseTime
     * @see EventHandler#getMiddleReleaseTime
     */
    EventHandler.prototype.getLeftReleaseTime = function() {
        return this._leftReleaseTime;
    };

    /**
     * Returns <code>true</code> if the middle mouse button is pressed and <code>false</code> otherwise.
     *
     * @memberof EventHandler
     *
     * @return {Boolean} <code>true</code> if the middle mouse button is pressed and <code>false</code> otherwise.
     *
     * @see EventHandler#isMiddleMouseButtonDown
     * @see EventHandler#isLeftMouseButtonDown
     */
    EventHandler.prototype.isMiddleMouseButtonDown = function() {
        return this._middleMouseButtonDown;
    };

    /**
     * Returns the last time that the middle mouse button was pressed.
     *
     * @memberof EventHandler
     *
     * @return {JulianDate} The time the middle mouse button was pressed.
     *
     * @see EventHandler#getMiddleReleaseTime
     * @see EventHandler#getRightPressTime
     * @see EventHandler#getLeftPressTime
     */
    EventHandler.prototype.getMiddlePressTime = function() {
        return this._middlePressTime;
    };

    /**
     * Returns the last time that the middle mouse button was released.
     *
     * @memberof EventHandler
     *
     * @return {JulianDate} The time the middle mouse button was released.
     *
     * @see EventHandler#getMiddlePressTime
     * @see EventHandler#getRightReleaseTime
     * @see EventHandler#getLeftReleaseTime
     */
    EventHandler.prototype.getMiddleReleaseTime = function() {
        return this._middleReleaseTime;
    };

    /**
     * Returns <code>true</code> if the right mouse button is pressed and <code>false</code> otherwise.
     *
     * @memberof EventHandler
     *
     * @return {Boolean} <code>true</code> if the right mouse button is pressed and <code>false</code> otherwise.
     *
     * @see EventHandler#isMiddleMouseButtonDown
     * @see EventHandler#isLeftMouseButtonDown
     */
    EventHandler.prototype.isRightMouseButtonDown = function() {
        return this._rightMouseButtonDown;
    };

    /**
     * Returns the last time that the right mouse button was pressed.
     *
     * @memberof EventHandler
     *
     * @return {JulianDate} The time the right mouse button was pressed.
     *
     * @see EventHandler#getRightReleaseTime
     * @see EventHandler#getLeftPressTime
     * @see EventHandler#getMiddlePressTime
     */
    EventHandler.prototype.getRightPressTime = function() {
        return this._rightPressTime;
    };

    /**
     * Returns the last time that the right mouse button was released.
     *
     * @memberof EventHandler
     *
     * @return {JulianDate} The time the right mouse button was released.
     *
     * @see EventHandler#getRightPressTime
     * @see EventHandler#getLeftReleaseTime
     * @see EventHandler#getMiddleReleaseTime
     */
    EventHandler.prototype.getRightReleaseTime = function() {
        return this._rightReleaseTime;
    };

    /**
     * Set a function to be executed when a key is entered.
     *
     * @memberof EventHandler
     *
     * @param {Function} action Function to be executed when <code>key</code> is pressed.
     * @param {Character} key The key that is pressed.
     * @param {Enumeration} modifier A EventModifier key that is held when <code>key</code> is pressed.
     *
     * @exception {DeveloperError} action is required.
     * @exception {DeveloperError} key is required.
     *
     * @see EventHandler#getKeyAction
     * @see EventHandler#removeKeyAction
     *
     * @example
     * // Set the camera to a "home" position when 'h' is pressed.
     * customHandler.setKeyAction(
     *    function() {
     *        var position = new Cartesian3(2.0 * Ellipsoid.getWgs84().getRadii().getMaximumComponent(), 0.0, 0.0);
     *        var dir = Cartesian3.getZero().subtract(position).normalize();
     *        var up = Cartesian3.getUnitZ();
     *        camera.position = position;
     *        camera.direction = dir;
     *        camera.up = up;
     *    },
     *    "h"
     * );
     */
    EventHandler.prototype.setKeyAction = function(action, key, modifier) {
        if (!action) {
            throw new DeveloperError("action is required.", "action");
        }

        if (!key) {
            throw new DeveloperError("key is required.", "key");
        }

        var keyEvents;
        if (modifier && modifier.name) {
            keyEvents = this._modifiedKeyEvents[modifier.name];
        } else {
            keyEvents = this._keyEvents;
        }

        if (keyEvents) {
            var ucKey = key.toUpperCase();
            keyEvents[ucKey] = action;
        }
    };

    /**
     * Returns the function executed when <code>key</code> is pressed.
     *
     * @memberof EventHandler
     *
     * @param {Character} key The key
     * @param {Enumeration} The modifier.
     *
     * @exception {DeveloperError} key is required.
     *
     * @see EventHandler#setKeyAction
     * @see EventHandler#removeKeyAction
     */
    EventHandler.prototype.getKeyAction = function(key, modifier) {
        if (!key) {
            throw new DeveloperError("key is required.", "key");
        }

        var keyEvents;
        if (modifier && modifier.name) {
            keyEvents = this._modifiedKeyEvents[modifier.name];
        } else {
            keyEvents = this._keyEvents;
        }

        var ucKey = key.toUpperCase();
        if (keyEvents && keyEvents[ucKey]) {
            return keyEvents[ucKey];
        }

        return null;
    };

    /**
     * Removes the function executed when <code>key</code> is pressed.
     *
     * @memberof EventHandler
     *
     * @param {Character} key The key
     * @param {Enumeration} The modifier.
     *
     * @exception {DeveloperError} key is required.
     *
     * @see EventHandler#setKeyAction
     * @see EventHandler#getKeyAction
     */
    EventHandler.prototype.removeKeyAction = function(key, modifier) {
        if (!key) {
            throw new DeveloperError("key is required.", "key");
        }

        var keyEvents;
        if (modifier && modifier.name) {
            keyEvents = this._modifiedKeyEvents[modifier.name];
        } else {
            keyEvents = this._keyEvents;
        }

        var ucKey = key.toUpperCase();
        if (keyEvents && keyEvents[ucKey]) {
            delete keyEvents[ucKey];
        }
    };

    /**
     * Set a function to be executed on a mouse event.
     *
     * @memberof EventHandler
     *
     * @param {Function} action Function to be executed when the mouse event occurs.
     * @param {Enumeration} type The MouseEventType of mouse event.
     * @param {Enumeration} modifier A EventModifier key that is held when a <code>type</code>
     * event occurs.
     *
     * @exception {DeveloperError} action is required.
     * @exception {DeveloperError} type is required.
     *
     * @see EventHandler#getMouseAction
     * @see EventHandler#removeMouseAction
     */
    EventHandler.prototype.setMouseAction = function(action, type, modifier) {
        if (!action) {
            throw new DeveloperError("action is required.", "action");
        }

        if (!type) {
            throw new DeveloperError("type is required.", "type");
        }

        var mouseEvents;
        if (modifier && modifier.name) {
            mouseEvents = this._modifiedMouseEvents[modifier.name];
        } else {
            mouseEvents = this._mouseEvents;
        }

        if (type && type.name && mouseEvents) {
            mouseEvents[type.name] = action;
        }
    };

    /**
     * Returns the function to be executed on a mouse event.
     *
     * @memberof EventHandler
     *
     * @param {Enumeration} type The MouseEventType of mouse event.
     * @param {Enumeration} modifier A EventModifier key that is held when a <code>type</code>
     * event occurs.
     *
     * @exception {DeveloperError} type is required.
     *
     * @see EventHandler#setMouseAction
     * @see EventHandler#removeMouseAction
     */
    EventHandler.prototype.getMouseAction = function(type, modifier) {
        if (!type) {
            throw new DeveloperError("type is required.", "type");
        }

        var mouseEvents;
        if (modifier && modifier.name) {
            mouseEvents = this._modifiedMouseEvents[modifier.name];
        } else {
            mouseEvents = this._mouseEvents;
        }

        if (type && type.name && mouseEvents) {
            return mouseEvents[type.name];
        }

        return null;
    };

    /**
     * Removes the function to be executed on a mouse event.
     *
     * @memberof EventHandler
     *
     * @param {Enumeration} type The MouseEventType of mouse event.
     * @param {Enumeration} modifier A EventModifier key that is held when a <code>type</code>
     * event occurs.
     *
     * @exception {DeveloperError} type is required.
     *
     * @see EventHandler#getMouseAction
     * @see EventHandler#setMouseAction
     */
    EventHandler.prototype.removeMouseAction = function(type, modifier) {
        if (!type) {
            throw new DeveloperError("type is required.", "type");
        }

        var mouseEvents;
        if (modifier && modifier.name) {
            mouseEvents = this._modifiedMouseEvents[modifier.name];
        } else {
            mouseEvents = this._mouseEvents;
        }

        if (type && type.name && mouseEvents && mouseEvents[type.name]) {
            delete mouseEvents[type.name];
        }
    };

    EventHandler.prototype._getModifier = function(event) {
        if (event.shiftKey) {
            return EventModifier.SHIFT;
        } else if (event.ctrlKey) {
            return EventModifier.CTRL;
        } else if (event.altKey) {
            return EventModifier.ALT;
        }

        return null;
    };

    EventHandler.prototype._handleMouseDown = function(event) {
        var pos = this._getPosition(event);
        this._lastMouseX = pos.x;
        this._lastMouseY = pos.y;
        this._totalPixels = 0;
        if (this._seenAnyTouchEvents) {
            return;
        }

        var modifier = this._getModifier(event);
        var action;

        // IE_TODO:  On some versions of IE, the left-button is 1, and the right-button is 4.
        // See: http://www.unixpapa.com/js/mouse.html
        // This is not the case in Chrome Frame, so we are OK for now, but are there
        // constants somewhere?
        if (event.button === 0) {
            this._leftMouseButtonDown = true;
            this._leftPressTime = new JulianDate();
            action = this.getMouseAction(MouseEventType.LEFT_DOWN, modifier);
        } else if (event.button === 1) {
            this._middleMouseButtonDown = true;
            this._middlePressTime = new JulianDate();
            action = this.getMouseAction(MouseEventType.MIDDLE_DOWN, modifier);
        } else if (event.button === 2) {
            this._rightMouseButtonDown = true;
            this._rightPressTime = new JulianDate();
            action = this.getMouseAction(MouseEventType.RIGHT_DOWN, modifier);
        }

        if (action) {
            action({
                position : new Cartesian2(pos.x, pos.y)
            });
        }
        event.preventDefault();
    };

    EventHandler.prototype._handleMouseUp = function(event) {
        var modifier = this._getModifier(event);
        var action, clickAction;
        if (this._seenAnyTouchEvents) {
            return;
        }

        // IE_TODO:  On some versions of IE, the left-button is 1, and the right-button is 4.
        // See: http://www.unixpapa.com/js/mouse.html
        // This is not the case in Chrome Frame, so we are OK for now, but are there
        // constants somewhere?
        if (event.button === 0) {
            this._leftMouseButtonDown = false;
            this._leftReleaseTime = new JulianDate();
            action = this.getMouseAction(MouseEventType.LEFT_UP, modifier);
            clickAction = this.getMouseAction(MouseEventType.LEFT_CLICK, modifier);
        } else if (event.button === 1) {
            this._middleMouseButtonDown = false;
            this._middleReleaseTime = new JulianDate();
            action = this.getMouseAction(MouseEventType.MIDDLE_UP, modifier);
            clickAction = this.getMouseAction(MouseEventType.MIDDLE_CLICK, modifier);
        } else if (event.button === 2) {
            this._rightMouseButtonDown = false;
            this._rightReleaseTime = new JulianDate();
            action = this.getMouseAction(MouseEventType.RIGHT_UP, modifier);
            clickAction = this.getMouseAction(MouseEventType.RIGHT_CLICK, modifier);
        }

        var pos = this._getPosition(event);

        var xDiff = this._lastMouseX - pos.x;
        var yDiff = this._lastMouseY - pos.y;
        this._totalPixels += Math.sqrt(xDiff * xDiff + yDiff * yDiff);

        if (action) {
            action({
                position : new Cartesian2(pos.x, pos.y)
            });
        }

        if (clickAction && this._totalPixels < this._clickPixelTolerance) {
            clickAction({
                position : new Cartesian2(pos.x, pos.y)
            });
        }
    };

    EventHandler.prototype._handleMouseMove = function(event) {
        var pos = this._getPosition(event);
        if (this._seenAnyTouchEvents) {
            return;
        }

        var xDiff = this._lastMouseX - pos.x;
        var yDiff = this._lastMouseY - pos.y;
        this._totalPixels += Math.sqrt(xDiff * xDiff + yDiff * yDiff);

        var movement = {
            startPosition : new Cartesian2(this._lastMouseX, this._lastMouseY),
            endPosition : new Cartesian2(pos.x, pos.y),
            motion : new Cartesian2(0.0, 0.0)
        };

        var modifier = this._getModifier(event);
        var action = this.getMouseAction(MouseEventType.MOVE, modifier);
        if (action) {
            action(movement);
        }

        this._lastMouseX = movement.endPosition.x;
        this._lastMouseY = movement.endPosition.y;

        if (this._leftMouseButtonDown || this._middleMouseButtonDown || this._rightMouseButtonDown) {
            event.preventDefault();
        }
    };

    EventHandler.prototype._handleTouchStart = function(event) {
        var pos, numberOfTouches = event.touches.length;
        this._seenAnyTouchEvents = true;

        if (numberOfTouches === 1) {
            pos = this._getPosition(event.touches[0]);
            this._lastMouseX = pos.x;
            this._lastMouseY = pos.y;
            this._totalPixels = 0;

            var modifier = this._getModifier(event);
            var action;

            this._leftMouseButtonDown = true;
            this._leftPressTime = new JulianDate();
            action = this.getMouseAction(MouseEventType.LEFT_DOWN, modifier);

            if (action) {
                action({
                    position : new Cartesian2(pos.x, pos.y)
                });
            }
            event.preventDefault();
        } else if (this._leftMouseButtonDown) {
            this._handleTouchEnd(event);
        }
    };

    EventHandler.prototype._handleTouchEnd = function(event) {
        var numberOfTouches = event.touches.length;
        var numberOfTargetTouches = event.targetTouches.length;
        var modifier = this._getModifier(event);
        var action, clickAction;

        if (this._leftMouseButtonDown) {
            this._leftMouseButtonDown = false;
            this._leftReleaseTime = new JulianDate();
            action = this.getMouseAction(MouseEventType.LEFT_UP, modifier);
            clickAction = this.getMouseAction(MouseEventType.LEFT_CLICK, modifier);
        }

        if (numberOfTargetTouches > 0) {
            var pos = this._getPosition(event.targetTouches[0]);

            var xDiff = this._lastMouseX - pos.x;
            var yDiff = this._lastMouseY - pos.y;
            this._totalPixels += Math.sqrt(xDiff * xDiff + yDiff * yDiff);

            if (action) {
                action({
                    position : new Cartesian2(pos.x, pos.y)
                });
            }

            if (clickAction && this._totalPixels < this._clickPixelTolerance) {
                clickAction({
                    position : new Cartesian2(pos.x, pos.y)
                });
            }
        }

        if (numberOfTouches === 1) {
            this._handleTouchStart(event);
        }
    };

    EventHandler.prototype._handleTouchMove = function(event) {
        if (this._leftMouseButtonDown && (event.touches.length === 1)) {
            var pos = this._getPosition(event.touches[0]);

            var xDiff = this._lastMouseX - pos.x;
            var yDiff = this._lastMouseY - pos.y;
            this._totalPixels += Math.sqrt(xDiff * xDiff + yDiff * yDiff);

            var movement = {
                startPosition : new Cartesian2(this._lastMouseX, this._lastMouseY),
                endPosition : new Cartesian2(pos.x, pos.y),
                motion : new Cartesian2(0.0, 0.0)
            };

            var modifier = this._getModifier(event);
            var action = this.getMouseAction(MouseEventType.MOVE, modifier);
            if (action) {
                action(movement);
            }

            this._lastMouseX = movement.endPosition.x;
            this._lastMouseY = movement.endPosition.y;

            if (this._leftMouseButtonDown || this._middleMouseButtonDown || this._rightMouseButtonDown) {
                event.preventDefault();
            }
        }
    };

    EventHandler.prototype._handleKeyDown = function(event) {
        var modifier = this._getModifier(event);
        var key = String.fromCharCode(event.keyCode);
        var action = this.getKeyAction(key, modifier);
        if (action) {
            action();
        }
    };

    EventHandler.prototype._handleMouseWheel = function(event) {
        // Some browsers use event.detail to count the number of clicks. The sign
        // of the integer is the direction the wheel is scrolled. In that case, convert
        // to the angle it was rotated in degrees.
        var delta = event.detail ? event.detail * -120 : event.wheelDelta;

        var modifier = this._getModifier(event);
        var type = MouseEventType.WHEEL;
        var action = this.getMouseAction(type, modifier);

        if (action) {
            event.preventDefault();
            action(delta);
        }
    };

    EventHandler.prototype._handleMouseDblClick = function(event) {
        var modifier = this._getModifier(event);
        var action;
        var pos = this._getPosition(event);

        // IE_TODO:  On some versions of IE, the left-button is 1, and the right-button is 4.
        // See: http://www.unixpapa.com/js/mouse.html
        // This is not the case in Chrome Frame, so we are OK for now, but are there
        // constants somewhere?
        if (event.button === 0) {
            action = this.getMouseAction(MouseEventType.LEFT_DOUBLE_CLICK, modifier);
        } else if (event.button === 1) {
            action = this.getMouseAction(MouseEventType.MIDDLE_DOUBLE_CLICK, modifier);
        } else if (event.button === 2) {
            action = this.getMouseAction(MouseEventType.RIGHT_DOUBLE_CLICK, modifier);
        }

        if (action) {
            action({
                position : new Cartesian2(pos.x, pos.y)
            });
        }
    };

    EventHandler.prototype._register = function() {
        var that = this, useDoc = true;

        this._callbacks = [];
        if (typeof this._element.disableRootEvents !== 'undefined') {
            useDoc = false;
        }

        this._callbacks.push({
            name : 'mousedown',
            onDoc : false,
            action : function(e) {
                that._handleMouseDown(e);
            }
        });
        this._callbacks.push({
            name : 'mouseup',
            onDoc : useDoc,
            action : function(e) {
                that._handleMouseUp(e);
            }
        });
        this._callbacks.push({
            name : 'mousemove',
            onDoc : useDoc,
            action : function(e) {
                that._handleMouseMove(e);
            }
        });
        this._callbacks.push({
            name : 'dblclick',
            onDoc : false,
            action : function(e) {
                that._handleMouseDblClick(e);
            }
        });
        this._callbacks.push({
            name : 'keydown',
            onDoc : false,
            action : function(e) {
                that._handleKeyDown(e);
            }
        });
        this._callbacks.push({
            name : 'touchstart',
            onDoc : false,
            action : function(e) {
                that._handleTouchStart(e);
            }
        });
        this._callbacks.push({
            name : 'touchend',
            onDoc : useDoc,
            action : function(e) {
                that._handleTouchEnd(e);
            }
        });
        this._callbacks.push({
            name : 'touchmove',
            onDoc : useDoc,
            action : function(e) {
                that._handleTouchMove(e);
            }
        });

        // Firefox calls the mouse wheel event 'DOMMouseScroll', all others use 'mousewheel'
        this._callbacks.push({
            name : 'mousewheel',
            onDoc : false,
            action : function(e) {
                that._handleMouseWheel(e);
            }
        });
        this._callbacks.push({
            name : 'DOMMouseScroll',
            onDoc : false,
            action : function(e) {
                that._handleMouseWheel(e);
            }
        });

        for ( var i = 0; i < this._callbacks.length; i++) {
            var cback = this._callbacks[i];
            if (cback.onDoc) {
                document.addEventListener(cback.name, cback.action, false);
            } else {
                this._element.addEventListener(cback.name, cback.action, false);
            }
        }
    };

    EventHandler.prototype._unregister = function() {
        for ( var i = 0; i < this._callbacks.length; i++) {
            var cback = this._callbacks[i];
            if (cback.onDoc) {
                document.removeEventListener(cback.name, cback.action, false);
            } else {
                this._element.removeEventListener(cback.name, cback.action, false);
            }
        }
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof EventHandler
     *
     * @return {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     *
     * @see EventHandler#destroy
     */
    EventHandler.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Removes mouse and keyboard listeners held by this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>null</code>) to the object as done in the example.
     *
     * @memberof EventHandler
     *
     * @return {null}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see EventHandler#isDestroyed
     *
     * @example
     * handler = handler && handler.destroy();
     */
    EventHandler.prototype.destroy = function() {
        this._unregister();
        return destroyObject(this);
    };

    return EventHandler;
});

/*global define*/
define('Core/pointInsideTriangle2D',['./DeveloperError'], function(DeveloperError) {
    

    /**
     * DOC_TBA
     *
     * @param point
     * @param p0
     * @param p1
     * @param p2
     *
     * @exports pointInsideTriangle2D
     *
     * @exception {DeveloperError} point is required.
     * @exception {DeveloperError} p0, p1, and p2 are required.
     */
    function pointInsideTriangle2D(point, p0, p1, p2) {
        if (!point) {
            throw new DeveloperError("point is required.", "point");
        }

        if (!p0 || !p1 || !p2) {
            throw new DeveloperError("p0, p1, and p2 are required.");
        }

        // Implementation based on http://www.blackpawn.com/texts/pointinpoly/default.html.
        var v0 = p1.subtract(p0);
        var v1 = p2.subtract(p0);
        var v2 = point.subtract(p0);

        var dot00 = v0.dot(v0);
        var dot01 = v0.dot(v1);
        var dot02 = v0.dot(v2);
        var dot11 = v1.dot(v1);
        var dot12 = v1.dot(v2);

        var q = 1.0 / (dot00 * dot11 - dot01 * dot01);
        var u = (dot11 * dot02 - dot01 * dot12) * q;
        var v = (dot00 * dot12 - dot01 * dot02) * q;

        return (u > 0) && (v > 0) && (u + v < 1);
    }

    return pointInsideTriangle2D;
});

/*global define*/
define('Core/requestAnimationFrame',[],function() {
    
    /*global window*/

    /**
     * A browser-independent function to request a new animation frame.  This is used to create
     * an application's draw loop as shown in the example below.
     *
     * @param {Object} callback The function to call when animation is ready.
     *
     * @example
     * // Create a draw loop using requestAnimationFrame. The
     * // tick callback function is called for every animation frame.
     * (function tick() {
     *   scene.render();
     *   requestAnimationFrame(tick);
     * }());
     */
    var requestAnimationFrame = function(callback) {
        //delay the selection of the appropriate function until the first invocation
        requestAnimationFrame =
            window.requestAnimationFrame ||
            window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame ||
            window.oRequestAnimationFrame ||
            window.msRequestAnimationFrame ||
            function(callback) {
                window.setTimeout(callback, 1000.0 / 60.0);
            };
        requestAnimationFrame(callback);
    };

    return requestAnimationFrame;
});

/*global define*/
define('Core/shallowEquals',[],function() {
    

    /**
     * DOC_TBA
     */
    function shallowEquals(left, right) {
        if (left && !right) {
            return false;
        } else if (!left && right) {
            return false;
        } else if (!left && !right) {
            return typeof left === typeof right;
        } else {
            // Assumes left and right have the same properties
            for ( var property in left) {
                if (left.hasOwnProperty(property)) {
                    if (left[property] !== right[property]) {
                        return false;
                    }
                }
            }
        }

        return true;
    }

    return shallowEquals;
});

/*global define*/
define('Core/splice',['./DeveloperError'], function(DeveloperError) {
    

    function splice (array, index, howMany) {
        if (Object.prototype.toString.apply(array) !== '[object Array]') {
            throw new DeveloperError("array is not an Array type.", "array");
        }

        index = index || 0;
        howMany = howMany || 0;

        var i;
        var len = array.length;
        for (i = index; i + howMany < len; ++i) {
            array[i] = array[i + howMany];
        }
        array.length = i;
    }

    return splice;
});
/*global define*/
define('Renderer/BlendEquation',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports BlendEquation
     */
    var BlendEquation = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        ADD : new Enumeration(0x8006, "ADD"), // FUNC_ADD

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        SUBTRACT : new Enumeration(0x800A, "SUBTRACT"), // FUNC_SUBTRACT

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        REVERSE_SUBTRACT : new Enumeration(0x800B, "REVERSE_SUBTRACT") // FUNC_REVERSE_SUBTRACT

        // No min and max like in ColladaFX GLES2 profile
    };

    return BlendEquation;
});
/*global define*/
define('Renderer/BlendFunction',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports BlendFunction
     */
    var BlendFunction = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        ZERO : new Enumeration(0, "ZERO"), // ZERO

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        ONE : new Enumeration(1, "ONE"), // ONE

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        SOURCE_COLOR : new Enumeration(0x0300, "SOURCE_COLOR"), // SRC_COLOR

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        ONE_MINUS_SOURCE_COLOR : new Enumeration(0x0301, "ONE_MINUS_SOURCE_COLOR"), // ONE_MINUS_SRC_COLOR

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        DESTINATION_COLOR : new Enumeration(0x0306, "DESTINATION_COLOR"), // DEST_COLOR

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        ONE_MINUS_DESTINATION_COLOR : new Enumeration(0x0307, "ONE_MINUS_DESTINATION_COLOR"), // ONE_MINUS_DEST_COLOR

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        SOURCE_ALPHA : new Enumeration(0x0302, "SOURCE_ALPHA"), // SRC_ALPHA

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        ONE_MINUS_SOURCE_ALPHA : new Enumeration(0x0303, "ONE_MINUS_SOURCE_ALPHA"), // ONE_MINUS_SRC_ALPHA

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        DESTINATION_ALPHA : new Enumeration(0x0304, "DESTINATION_ALPHA"), // DST_ALPHA

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        ONE_MINUS_DESTINATION_ALPHA : new Enumeration(0x0305, "ONE_MINUS_DESTINATION_ALPHA"), // ONE_MINUS_DST_ALPHA

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        CONSTANT_COLOR : new Enumeration(0x8001, "CONSTANT_COLOR"), // CONSTANT_COLOR

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        ONE_MINUS_CONSTANT_COLOR : new Enumeration(0x8002, "ONE_MINUS_CONSTANT_COLOR"), // ONE_MINUS_CONSTANT_COLOR

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        CONSTANT_ALPHA : new Enumeration(0x8003, "CONSTANT_ALPHA"), // CONSTANT_ALPHA

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        ONE_MINUS_CONSTANT_ALPHA : new Enumeration(0x8004, "ONE_MINUS_CONSTANT_ALPHA"), // ONE_MINUS_CONSTANT_ALPHA

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        SOURCE_ALPHA_SATURATE : new Enumeration(0x0308, "SOURCE_ALPHA_SATURATE") // SRC_ALPHA_SATURATE
    };

    return BlendFunction;
});
/*global define*/
define('Renderer/BlendingState',[
        './BlendEquation', 
        './BlendFunction'
    ], function(
        BlendEquation, 
        BlendFunction) {
    

    /**
     * DOC_TBA
     * 
     * @exports BlendingState
     */
    var BlendingState = {
        /**
         * DOC_TBA
         */
        ALPHA_BLEND : {
            enabled : true,
            equationRgb : BlendEquation.ADD,
            equationAlpha : BlendEquation.ADD,
            functionSourceRgb : BlendFunction.SOURCE_ALPHA,
            functionSourceAlpha : BlendFunction.SOURCE_ALPHA,
            functionDestinationRgb : BlendFunction.ONE_MINUS_SOURCE_ALPHA,
            functionDestinationAlpha : BlendFunction.ONE_MINUS_SOURCE_ALPHA
        },

        /**
         * DOC_TBA
         */
        PRE_MULTIPLIED_ALPHA_BLEND : {
            enabled : true,
            equationRgb : BlendEquation.ADD,
            equationAlpha : BlendEquation.ADD,
            functionSourceRgb : BlendFunction.ONE,
            functionSourceAlpha : BlendFunction.ONE,
            functionDestinationRgb : BlendFunction.ONE_MINUS_SOURCE_ALPHA,
            functionDestinationAlpha : BlendFunction.ONE_MINUS_SOURCE_ALPHA
        },

        /**
         * DOC_TBA
         */
        ADDITIVE_BLEND : {
            enabled : true,
            equationRgb : BlendEquation.ADD,
            equationAlpha : BlendEquation.ADD,
            functionSourceRgb : BlendFunction.SOURCE_ALPHA,
            functionSourceAlpha : BlendFunction.SOURCE_ALPHA,
            functionDestinationRgb : BlendFunction.ONE,
            functionDestinationAlpha : BlendFunction.ONE
        }
    };

    return BlendingState;
});
/*global define*/
define('Renderer/Buffer',[
        '../Core/DeveloperError',
        '../Core/destroyObject'
    ], function(
        DeveloperError,
        destroyObject) {
    

    /**
     * DOC_TBA
     *
     * @name Buffer
     * @internalConstructor
     *
     * @see Context#createVertexBuffer
     * @see Context#createIndexBuffer
     */
    function Buffer(gl, bufferTarget, sizeInBytes, usage, buffer) {
        this._gl = gl;
        this._bufferTarget = bufferTarget;
        this._sizeInBytes = sizeInBytes;
        this._usage = usage;
        this._buffer = buffer;
        this._vertexArrayDestroyable = true;
    }

    /**
     * DOC_TBA
     * DOC_TBA: arrayView
     *
     * @memberof Buffer
     * @param {Number} [offsetInBytes=0] DOC_TBA
     *
     * @exception {DeveloperError} arrayView is required.
     * @exception {DeveloperError} This buffer is not large enough.
     * @exception {DeveloperError} This buffer was destroyed, i.e., destroy() was called.
     */
    Buffer.prototype.copyFromArrayView = function(arrayView, offsetInBytes) {
        if (!arrayView) {
            throw new DeveloperError("arrayView is required.", "arrayView");
        }

        offsetInBytes = offsetInBytes || 0;

        if (offsetInBytes + arrayView.byteLength > this._sizeInBytes) {
            throw new DeveloperError("This buffer is not large enough.");
        }

        var gl = this._gl;
        var target = this._bufferTarget;
        gl.bindBuffer(target, this._buffer);
        gl.bufferSubData(target, offsetInBytes, arrayView);
        gl.bindBuffer(target, null);
    };

    Buffer.prototype._getBuffer = function() {
        return this._buffer;
    };

    /**
     * DOC_TBA
     * @memberof Buffer
     *
     * @return {Number} DOC_TBA
     * @exception {DeveloperError} This buffer was destroyed, i.e., destroy() was called.
     */
    Buffer.prototype.getSizeInBytes = function() {
        return this._sizeInBytes;
    };

    /**
     * DOC_TBA
     * @memberof Buffer
     *
     * @return {GLenum} DOC_TBA
     * @exception {DeveloperError} This buffer was destroyed, i.e., destroy() was called.
     */
    Buffer.prototype.getUsage = function() {
        return this._usage;
    };

    /**
     * DOC_TBA
     * @memberof Buffer
     */
    Buffer.prototype.getVertexArrayDestroyable = function() {
        return this._vertexArrayDestroyable;
    };

    /**
     * DOC_TBA
     * @memberof Buffer
     */
    Buffer.prototype.setVertexArrayDestroyable = function(value) {
        this._vertexArrayDestroyable = value;
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof Buffer
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see Buffer.destroy
     */
    Buffer.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>null</code>) to the object as done in the example.
     *
     * @memberof Buffer
     *
     * @return {null}
     *
     * @exception {DeveloperError} This buffer was destroyed, i.e., destroy() was called.
     *
     * @see Buffer#isDestroyed
     * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glDeleteBuffers.xml">glDeleteBuffers</a>
     *
     * @example
     * buffer = buffer && buffer.destroy();
     */
    Buffer.prototype.destroy = function() {
        this._gl.deleteBuffer(this._buffer);
        return destroyObject(this);
    };

    return Buffer;
});
/*global define*/
define('Renderer/BufferUsage',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports BufferUsage
     */
    var BufferUsage = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        STREAM_DRAW : new Enumeration(0x88E0, "STREAM_DRAW"),
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        STATIC_DRAW : new Enumeration(0x88E4, "STATIC_DRAW"),
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        DYNAMIC_DRAW : new Enumeration(0x88E8, "DYNAMIC_DRAW")
    };

    return BufferUsage;
});
/*global define*/
define('Renderer/CullFace',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports CullFace
     */
    var CullFace = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        FRONT : new Enumeration(0x0404, "FRONT"), // FRONT

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        BACK : new Enumeration(0x0405, "BACK"), // BACK

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        FRONT_AND_BACK : new Enumeration(0x0408, "FRONT_AND_BACK") // FRONT_AND_BACK
    };

    return CullFace;
});
/*global define*/
define('Renderer/DepthFunction',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports DepthFunction
     */
    var DepthFunction = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        NEVER : new Enumeration(0x0200, "NEVER"), // NEVER

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        LESS : new Enumeration(0x0201, "LESS"), // LESS

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        EQUAL : new Enumeration(0x0202, "EQUAL"), // EQUAL

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        LESS_OR_EQUAL : new Enumeration(0x0203, "LESS_OR_EQUAL"), // LEQUAL

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        GREATER : new Enumeration(0x0204, "GREATER"), // GREATER

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        NOT_EQUAL : new Enumeration(0x0205, "NOT_EQUAL"), // NOTEQUAL

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        GREATER_OR_EQUAL : new Enumeration(0x0206, "GREATER_OR_EQUAL"), // GEQUAL

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        ALWAYS : new Enumeration(0x0207, "ALWAYS") // ALWAYS
    };

    return DepthFunction;
});
/*global define*/
define('Renderer/Framebuffer',[
        '../Core/DeveloperError',
        '../Core/destroyObject'
    ], function(
        DeveloperError,
        destroyObject) {
    

    /**
     * DOC_TBA
     *
     * @name Framebuffer
     *
     * @see Context#createFramebuffer
     *
     * @internalConstructor
     */
    function Framebuffer(_gl, description) {
        var _framebuffer;
        var _colorTexture;
        var _colorRenderbuffer;
        var _depthRenderbuffer;
        var _stencilRenderbuffer;
        var _depthStencilRenderbuffer;

        /**
        * DOC_TBA.
        * @memberof Framebuffer
        * @exception {DeveloperError} This framebuffer was destroyed, i.e., destroy() was called.
        */
        this.setColorTexture = function(texture) {
            this._bind();

            if (texture) {
                _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, texture._getTarget(), texture._getTexture(), 0);
            } else {
                _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, null, 0);
            }
            this._unBind();

            _colorTexture = texture;
        };

        /**
        * DOC_TBA.
        * @memberof Framebuffer
        * @exception {DeveloperError} This framebuffer was destroyed, i.e., destroy() was called.
        */
        this.getColorTexture = function() {
            return _colorTexture;
        };

        /**
         * DOC_TBA.
         * @memberof Framebuffer
         * @exception {DeveloperError} This framebuffer was destroyed, i.e., destroy() was called.
         */
        this.setColorRenderbuffer = function(renderbuffer) {
            this._bind();
            if (renderbuffer) {
                _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderbuffer._getRenderbuffer());
            } else {
                _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, null);
            }
            this._unBind();

            _colorRenderbuffer = renderbuffer;
        };

        /**
         * DOC_TBA.
         * @memberof Framebuffer
         * @exception {DeveloperError} This framebuffer was destroyed, i.e., destroy() was called.
         */
        this.getColorRenderbuffer = function() {
            return _colorRenderbuffer;
        };

        /**
        * DOC_TBA.
        * @memberof Framebuffer
        * @exception {DeveloperError} This framebuffer was destroyed, i.e., destroy() was called.
        */
        this.setDepthRenderbuffer = function(renderbuffer) {
            this._bind();
            if (renderbuffer) {
                _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer._getRenderbuffer());
            } else {
                _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, null);
            }
            this._unBind();

            _depthRenderbuffer = renderbuffer;
        };

        /**
        * DOC_TBA.
        * @memberof Framebuffer
        * @exception {DeveloperError} This framebuffer was destroyed, i.e., destroy() was called.
        */
        this.getDepthRenderbuffer = function() {
            return _depthRenderbuffer;
        };

        /**
        * DOC_TBA.
        * @memberof Framebuffer
        * @exception {DeveloperError} This framebuffer was destroyed, i.e., destroy() was called.
        */
        this.setStencilRenderbuffer = function(renderbuffer) {
            this._bind();
            if (renderbuffer) {
                _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer._getRenderbuffer());
            } else {
                _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, null);
            }
            this._unBind();

            _stencilRenderbuffer = renderbuffer;
        };

        /**
        * DOC_TBA.
        * @memberof Framebuffer
        * @exception {DeveloperError} This framebuffer was destroyed, i.e., destroy() was called.
        */
        this.getStencilRenderbuffer = function() {
            return _stencilRenderbuffer;
        };

        /**
        * DOC_TBA.
        * @memberof Framebuffer
        * @exception {DeveloperError} This framebuffer was destroyed, i.e., destroy() was called.
        */
        this.setDepthStencilRenderbuffer = function(renderbuffer) {
            this._bind();
            if (renderbuffer) {
                _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer._getRenderbuffer());
            } else {
                _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, null);
            }
            this._unBind();

            _depthStencilRenderbuffer = renderbuffer;
        };

        /**
        * DOC_TBA.
        * @memberof Framebuffer
        * @exception {DeveloperError} This framebuffer was destroyed, i.e., destroy() was called.
        */
        this.getDepthStencilRenderbuffer = function() {
            return _depthStencilRenderbuffer;
        };

        this._bind = function() {
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, _framebuffer);
        };

        this._unBind = function() {
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
        };

        /**
         * Returns true if this object was destroyed; otherwise, false.
         * <br /><br />
         * If this object was destroyed, it should not be used; calling any function other than
         * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
         *
         * @memberof Framebuffer
         *
         * @return {Boolean} True if this object was destroyed; otherwise, false.
         *
         * @see Framebuffer.destroy
         */
        this.isDestroyed = function() {
            return false;
        };

        /**
         * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
         * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
         * <br /><br />
         * Only call this if the framebuffer has no attachments or the framebuffer owns its attachments;
         * otherwise, the owner of the textures/renderbuffers is responsible for deleting them.
         * <br /><br />
         * Once an object is destroyed, it should not be used; calling any function other than
         * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
         * assign the return value (<code>null</code>) to the object as done in the example.
         * <br /><br />
         * This will fail if the color attachment is a face in a cube map texture.
         *
         * @memberof Framebuffer
         *
         * @return {null}
         *
         * @exception {DeveloperError} This framebuffer was destroyed, i.e., destroy() was called.
         *
         * @see Framebuffer.isDestroyed
         * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glDeleteFramebuffers.xml">glDeleteFramebuffers</a>
         * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glDeleteTextures.xml">glDeleteTextures</a>
         * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glDeleteRenderbuffers.xml">glDeleteRenderbuffers</a>
         *
         * @example
         * // Destroying the framebuffer implicitly calls destroy for each of its attachments.
         * var texture = context.createTexture2D({ width : 1, height : 1 });
         * framebuffer = context.createFramebuffer({ colorTexture : texture });
         * // ...
         * framebuffer = framebuffer.destroy();
         * // Calling texture.destroy() would throw <code>DeveloperError</code> at this point.
         */
        this.destroy = function() {
            // TODO:  What should the behavior be if the color attachment is a face in a cube map texture?
            _colorTexture = _colorTexture && _colorTexture.destroy();
            _colorRenderbuffer = _colorRenderbuffer && _colorRenderbuffer.destroy();
            _depthRenderbuffer = _depthRenderbuffer && _depthRenderbuffer.destroy();
            _stencilRenderbuffer = _stencilRenderbuffer && _stencilRenderbuffer.destroy();
            _depthStencilRenderbuffer = _depthStencilRenderbuffer && _depthStencilRenderbuffer.destroy();

            _gl.deleteFramebuffer(_framebuffer);
            return destroyObject(this);
        };

        _framebuffer = _gl.createFramebuffer();

        if (description) {
            if (description.colorTexture) {
                this.setColorTexture(description.colorTexture);
            }

            if (description.colorRenderbuffer) {
                this.setColorRenderbuffer(description.colorRenderbuffer);
            }

            if (description.depthRenderbuffer) {
                this.setDepthRenderbuffer(description.depthRenderbuffer);
            }

            if (description.stencilRenderbuffer) {
                this.setStencilRenderbuffer(description.stencilRenderbuffer);
            }

            if (description.depthStencilRenderbuffer) {
                this.setDepthStencilRenderbuffer(description.depthStencilRenderbuffer);
            }
        }
    }

    return Framebuffer;
});
/*global define*/
define('Renderer/FrontFace',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports FrontFace
     */
    var FrontFace = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        CLOCKWISE : new Enumeration(0x0900, "CLOCKWISE"), // CW

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        COUNTER_CLOCKWISE : new Enumeration(0x0901, "COUNTER_CLOCKWISE") // CCW
    };

    return FrontFace;
});
/*global define*/
define('Renderer/MipmapHint',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports MipmapHint
     */
    var MipmapHint = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        DONT_CARE : new Enumeration(0x1100, "DONT_CARE"), // DONT_CARE

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        FASTEST : new Enumeration(0x1101, "FASTEST"), // FASTEST

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        NICEST : new Enumeration(0x1102, "NICEST") // NICEST
    };

    return MipmapHint;
});
/*global define*/
define('Renderer/PixelDatatype',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports PixelDatatype
     */
    var PixelDatatype = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        UNSIGNED_BYTE : new Enumeration(0x1401, "UNSIGNED_BYTE"), // UNSIGNED_BYTE

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        UNSIGNED_SHORT_4_4_4_4 : new Enumeration(0x8033, "UNSIGNED_SHORT_4_4_4_4"), // UNSIGNED_SHORT_4_4_4_4

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        UNSIGNED_SHORT_5_5_5_1 : new Enumeration(0x8034, "UNSIGNED_SHORT_5_5_5_1"), // UNSIGNED_SHORT_5_5_5_1

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        UNSIGNED_SHORT_5_6_5 : new Enumeration(0x8363, "UNSIGNED_SHORT_5_6_5") // UNSIGNED_SHORT_5_6_5
    };

    return PixelDatatype;
});
/*global define*/
define('Renderer/PixelFormat',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports PixelFormat
     */
    var PixelFormat = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        DEPTH_COMPONENT : new Enumeration(0x1902, "DEPTH_COMPONENT"), // DEPTH_COMPONENT
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        ALPHA : new Enumeration(0x1906, "ALPHA"), // ALPHA
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        RGB : new Enumeration(0x1907, "RGB"), // RGB
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        RGBA : new Enumeration(0x1908, "RGBA"), // RGBA
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        LUMINANCE : new Enumeration(0x1909, "LUMINANCE"), // LUMINANCE
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        LUMINANCE_ALPHA : new Enumeration(0x190A, "LUMINANCE_ALPHA") // LUMINANCE_ALPHA
    };

    return PixelFormat;
});
/*global define*/
define('Renderer/Renderbuffer',[
        '../Core/DeveloperError',
        '../Core/destroyObject'
    ], function(
        DeveloperError,
        destroyObject) {
    

    /**
     * DOC_TBA
     *
     * @name Renderbuffer
     * @internalConstructor
     *
     * @see Context#createRenderbuffer
     */
    function Renderbuffer(_gl, _format, _width, _height) {
        var _renderbuffer = _gl.createRenderbuffer();

        _gl.bindRenderbuffer(_gl.RENDERBUFFER, _renderbuffer);
        _gl.renderbufferStorage(_gl.RENDERBUFFER, _format.value, _width, _height);
        _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);

        /**
        * DOC_TBA
        * @memberof Renderbuffer
        * @return {Boolean} DOC_TBA
        * @exception {DeveloperError} This renderbuffer was destroyed, i.e., destroy() was called.
        */
        this.getFormat = function() {
            return _format;
        };

        /**
        * DOC_TBA
        * @memberof Renderbuffer
        * @return {Boolean} DOC_TBA
        * @exception {DeveloperError} This renderbuffer was destroyed, i.e., destroy() was called.
        */
        this.getWidth = function() {
            return _width;
        };

        /**
        * DOC_TBA
        * @memberof Renderbuffer
        * @return {Boolean} DOC_TBA
        * @exception {DeveloperError} This renderbuffer was destroyed, i.e., destroy() was called.
        */
        this.getHeight = function() {
            return _height;
        };

        this._getRenderbuffer = function() {
            return _renderbuffer;
        };

        /**
         * Returns true if this object was destroyed; otherwise, false.
         * <br /><br />
         * If this object was destroyed, it should not be used; calling any function other than
         * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
         *
         * @memberof Renderbuffer
         *
         * @return {Boolean} True if this object was destroyed; otherwise, false.
         *
         * @see Renderbuffer.destroy
         */
        this.isDestroyed = function() {
            return false;
        };

        /**
         * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
         * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
         * <br /><br />
         * Once an object is destroyed, it should not be used; calling any function other than
         * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
         * assign the return value (<code>null</code>) to the object as done in the example.
         *
         * @memberof Renderbuffer
         *
         * @return {null}
         *
         * @exception {DeveloperError} This shader renderbuffer destroyed, i.e., destroy() was called.
         *
         * @see Renderbuffer.isDestroyed
         * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glDeleteRenderbuffers.xml">glDeleteRenderbuffers</a>
         *
         * @example
         * renderbuffer = renderbuffer && renderbuffer.destroy();
         */
        this.destroy = function() {
            _gl.deleteRenderbuffer(_renderbuffer);
            return destroyObject(this);
        };
    }

    return Renderbuffer;
});
/*global define*/
define('Renderer/RenderbufferFormat',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports RenderbufferFormat
     */
    var RenderbufferFormat = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        RGBA4 : new Enumeration(0x8056, "RGBA4"),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        RGB5_A1 : new Enumeration(0x8057, "RGB5_A1"),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        RGB565 : new Enumeration(0x8D62, "RGB565"),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        DEPTH_COMPONENT16 : new Enumeration(0x81A5, "DEPTH_COMPONENT16"),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        STENCIL_INDEX8 : new Enumeration(0x8D48, "STENCIL_INDEX8"),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        DEPTH_STENCIL : new Enumeration(0x84F9, "DEPTH_STENCIL")
    };

    return RenderbufferFormat;
});
/*global define*/
define('Renderer/PickFramebuffer',[
        '../Core/destroyObject',
        './RenderbufferFormat'
    ], function(
        destroyObject,
        RenderbufferFormat) {
    

    /**
     * DOC_TBA
     *
     * @name PickFramebuffer
     * @internalConstructor
     *
     * @see Context#createPickFramebuffer
     * @see Context#pick
     */
    function PickFramebuffer(context) {
        this._context = context;
        this._fb = null;
        this._width = 0;
        this._height = 0;
    }

    /**
     * DOC_TBA
     * @memberof PickFramebuffer
     */
    PickFramebuffer.prototype.begin = function() {
        var context = this._context;

        // Initially create or recreate renderbuffers and framebuffer used for picking
        if (!this._fb ||
            (this._width !== context.getCanvas().clientWidth) ||
            (this._height !== context.getCanvas().clientHeight)) {
            this._width = context.getCanvas().clientWidth;
            this._height = context.getCanvas().clientHeight;

            this._fb = this._fb && this._fb.destroy();
            this._fb = context.createFramebuffer({
                colorRenderbuffer : context.createRenderbuffer(),
                depthStencilRenderbuffer : context.createRenderbuffer({
                    format : RenderbufferFormat.DEPTH_STENCIL
                })
            });
        }

        // Clear to black.  Since this is the background color, no objects will be black
        context.clear(context.createClearState({
            framebuffer : this._fb,
            color : {
                red : 0.0,
                green : 0.0,
                blue : 0.0,
                alpha : 1.0
            },
            depth : 1.0,
            stencil : 0
        }));

        return this._fb;
    };

    /**
     * DOC_TBA
     * @memberof PickFramebuffer
     */
    PickFramebuffer.prototype.end = function(screenSpacePosition) {
        if (screenSpacePosition) {
            // TODO:  function with custom width/height
            var pixels = this._context.readPixels({
                x : screenSpacePosition.x,
                y : screenSpacePosition.y,
                width : 1,
                height : 1,
                framebuffer : this._fb
            });

            return this._context.getObjectByPickId({
                red : pixels[0],
                green : pixels[1],
                blue : pixels[2],
                alpha : pixels[3]
            });
        }

        return undefined;
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof PickFramebuffer
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see PickFramebuffer#destroy
     */
    PickFramebuffer.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>null</code>) to the object as done in the example.
     *
     * @memberof PickFramebuffer
     *
     * @return {null}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see PickFramebuffer#isDestroyed
     *
     * @example
     * PickFramebuffer = PickFramebuffer && PickFramebuffer.destroy();
     */
    PickFramebuffer.prototype.destroy = function() {
        this._fb = this._fb && this._fb.destroy();
        return destroyObject(this);
    };

    return PickFramebuffer;
});
/*global define*/
define('Renderer/ShaderCache',[
        '../Core/destroyObject'
    ], function(
        destroyObject) {
    

    /**
     * DOC_TBA
     *
     * @name ShaderCache
     *
     * @internalConstructor
     *
     * @see Context#getShaderCache
     */
    function ShaderCache(context) {
        this._context = context;
        this._shaders = {};
        this._shadersToRelease = {};
    }

    /**
     * DOC_TBA
     *
     * @memberof ShaderCache
     *
     * @returns {ShaderProgram} DOC_TBA.
     */
    ShaderCache.prototype.getShaderProgram = function(vertexShaderSource, fragmentShaderSource, attributeLocations) {
        // TODO: compare attributeLocations!
        var keyword = vertexShaderSource + fragmentShaderSource;
        var cachedShader;

        if (this._shaders[keyword]) {
            cachedShader = this._shaders[keyword];
        } else {
            var sp = this._context.createShaderProgram(vertexShaderSource, fragmentShaderSource, attributeLocations);

            cachedShader = {
                cache : this,
                shaderProgram : sp,
                keyword : keyword,
                count : 0
            };

            // A shader can't be in more than one cache.
            sp._cachedShader = cachedShader;
            this._shaders[keyword] = cachedShader;
        }

        ++cachedShader.count;
        return cachedShader.shaderProgram;
    };

    /**
     * DOC_TBA
     * @memberof ShaderCache
     */
    ShaderCache.prototype.destroyReleasedShaderPrograms = function() {
        var shadersToRelease = this._shadersToRelease;

        for ( var keyword in shadersToRelease) {
            if (shadersToRelease.hasOwnProperty(keyword)) {
                // Check the count again here because the shader may have been requested
                // after it was released, in which case, we are avoiding thrashing the cache.
                var cachedShader = shadersToRelease[keyword];
                if (cachedShader.count === 0) {
                    delete this._shaders[cachedShader.keyword];
                    cachedShader.shaderProgram.destroy();
                }
            }
        }

        this._shadersToRelease = {};
    };

    /**
     * DOC_TBA
     *
     * @memberof ShaderCache
     *
     * @parameter {ShaderProgram} shaderProgram DOC_TBA.
     */
    ShaderCache.prototype.releaseShaderProgram = function(shaderProgram) {
        if (shaderProgram) {
            var cachedShader = shaderProgram._cachedShader;
            if (cachedShader && (--cachedShader.count === 0)) {
                this._shadersToRelease[cachedShader.keyword] = cachedShader;
            }
        }

        return null;
    };

    /**
     * DOC_TBA
     * @memberof ShaderCache
     */
    ShaderCache.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * DOC_TBA
     * @memberof ShaderCache
     */
    ShaderCache.prototype.destroy = function() {
        var shaders = this._shaders;

        for ( var keyword in shaders) {
            if (shaders.hasOwnProperty(keyword)) {
                shaders[keyword].shaderProgram.destroy();
            }
        }

        return destroyObject(this);
    };

    return ShaderCache;
});
/*global define*/
define('Renderer/StencilFunction',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports StencilFunction
     */
    var StencilFunction = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        NEVER : new Enumeration(0x0200, "NEVER"), // NEVER

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        LESS : new Enumeration(0x0201, "LESS"), // LESS

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        EQUAL : new Enumeration(0x0202, "EQUAL"), // EQUAL

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        LESS_OR_EQUAL : new Enumeration(0x0203, "LESS_OR_EQUAL"), // LEQUAL

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        GREATER : new Enumeration(0x0204, "GREATER"), // GREATER

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        NOT_EQUAL : new Enumeration(0x0205, "NOT_EQUAL"), // NOTEQUAL

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        GREATER_OR_EQUAL : new Enumeration(0x0206, "GREATER_OR_EQUAL"), // GEQUAL

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        ALWAYS : new Enumeration(0x0207, "ALWAYS") // ALWAYS
    };

    return StencilFunction;
});
/*global define*/
define('Renderer/StencilOperation',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports StencilOperation
     */
    var StencilOperation = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        ZERO : new Enumeration(0, "ZERO"), // ZERO

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        KEEP : new Enumeration(0x1E00, "KEEP"), // KEEP

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        REPLACE : new Enumeration(0x1E01, "REPLACE"), // REPLACE

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        INCREMENT : new Enumeration(0x1E02, "INCREMENT"), // INCR

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        DECREMENT : new Enumeration(0x1E03, "DECREMENT"), // DECR

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        INVERT : new Enumeration(0x150A, "INVERT"), // INVERT

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        INCREMENT_WRAP : new Enumeration(0x8507, "INCREMENT_WRAP"), // INCR_WRAP

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        DECREMENT_WRAP : new Enumeration(0x8508, "DECREMENT_WRAP") // DECR_WRAP
    };

    return StencilOperation;
});
/*global define*/
define('Renderer/TextureAtlas',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/Cartesian2',
        './PixelFormat'
    ], function(
        DeveloperError,
        destroyObject,
        Cartesian2,
        PixelFormat) {
    

    /**
     * DOC_TBA
     *
     * @name TextureAtlas
     *
     * @param {Context} context The context that the created texture will be used by.
     * @param {Array} images DOC_TBA
     * @param {PixelFormat}[pixelFormat = PixelFormat.RGBA] DOC_TBA
     * @param {Number}[borderWidthInPixels = 1]  DOC_TBA
     *
     * @internalConstructor
     *
     * @exception {DeveloperError} context is required.
     * @exception {DeveloperError} images is required and must have length greater than zero.
     * @exception {DeveloperError} borderWidthInPixels must be greater than or equal to zero.
     */
    function TextureAtlas(context, images, pixelFormat, borderWidthInPixels) {
        if (!context) {
            throw new DeveloperError("context is required.", "images");
        }

        if (!images || (images.length < 1)) {
            throw new DeveloperError("images is required and must have length greater than zero.", "images");
        }

        pixelFormat = (typeof pixelFormat === "undefined") ? PixelFormat.RGBA : pixelFormat;
        borderWidthInPixels = (typeof borderWidthInPixels === "undefined") ? 1 : borderWidthInPixels;

        if (borderWidthInPixels < 0) {
            throw new DeveloperError("borderWidthInPixels must be greater than or equal to zero.", "borderWidthInPixels");
        }

        var annotatedImages = [];
        var numberOfImages = images.length;
        var i;
        var image;

        for (i = 0; i < numberOfImages; ++i) {
            annotatedImages.push({
                image : images[i],
                index : i
            });
        }

        // Sort images by maximum to minimum height
        annotatedImages.sort(function(left, right) {
            return right.image.height - left.image.height;
        });

        // Heuristically compute atlas width to keep texture relatively square
        var atlasWidth = (function(images, numberOfImages) {
            var maxWidth = 0;
            var area = 0;
            for ( var i = 0; i < numberOfImages; ++i) {
                var image = images[i];
                area += (image.width + borderWidthInPixels) * (image.height + borderWidthInPixels);
                maxWidth = Math.max(maxWidth, image.width);
            }

            return Math.max(Math.floor(Math.sqrt(area)), maxWidth + borderWidthInPixels);
        }(images, numberOfImages));

        var xOffset = 0;
        var yOffset = 0;
        var rowHeight = 0;
        var offsets = [];

        // PERFORMANCE_IDEA:  Pack more tightly using algorithm in:
        //     http://www-ui.is.s.u-tokyo.ac.jp/~takeo/papers/i3dg2001.pdf

        // Compute subrectangle positions and, finally, the atlas' height
        for (i = 0; i < numberOfImages; ++i) {
            image = annotatedImages[i].image;
            var widthIncrement = image.width + borderWidthInPixels;

            if (xOffset + widthIncrement > atlasWidth) {
                xOffset = 0;
                yOffset += rowHeight + borderWidthInPixels;
            }

            if (xOffset === 0) {
                // The first bitmap of the row determines the row height.
                // This is worst case since bitmaps are sorted by height.
                rowHeight = image.height;
            }

            offsets.push(new Cartesian2(xOffset, yOffset));
            xOffset += widthIncrement;
        }
        var atlasHeight = yOffset + rowHeight;

        // Write images into a texture, saving the texture coordinates rectangle for each
        var textureCoordinates = [];
        var texture = context.createTexture2D({
            width : atlasWidth,
            height : atlasHeight,
            pixelFormat : pixelFormat
        });

        for (i = 0; i < numberOfImages; ++i) {
            var lowerLeft = offsets[i];
            image = annotatedImages[i];

            textureCoordinates[image.index] = {
                // Lower Left
                x0 : lowerLeft.x / atlasWidth,
                y0 : lowerLeft.y / atlasHeight,

                // Upper Right
                x1 : (lowerLeft.x + image.image.width) / atlasWidth,
                y1 : (lowerLeft.y + image.image.height) / atlasHeight
            };

            texture.copyFrom(image.image, lowerLeft.x, lowerLeft.y);
        }

        this._context = context;
        this._borderWidthInPixels = borderWidthInPixels;
        this._texture = texture;
        this._textureCoordinates = textureCoordinates;
    }

    /**
     * Add a set of sub-regions of one atlas image as additional image indices.
     *
     * @memberof TextureAtlas
     *
     * @param {Number} index The index of the source image that will be broken into sub-regions.
     * @param {Array} subRegions A list of {@link Rectangle} sub-regions measured in pixels from the upper-left.
     *
     * @return {Number} The index of the first newly-added region.
     *
     * @exception {DeveloperError} invalid image index.
     */
    TextureAtlas.prototype.addSubRegions = function(index, subRegions) {
        var atlasWidth = this._texture.getWidth();
        var atlasHeight = this._texture.getHeight();
        var numTextureCoordinates = this._textureCoordinates.length;
        var numSubRegions = subRegions.length;

        if ((index < 0) || (index >= numTextureCoordinates)) {
            throw new DeveloperError("invalid image index.", "index");
        }
        var baseRegion = this._textureCoordinates[index];

        for (var i = 0; i < numSubRegions; ++i) {
            var thisRegion = subRegions[i];
            this._textureCoordinates.push({
                // Lower Left
                x0 : baseRegion.x0 + (thisRegion.x / atlasWidth),
                y0 : baseRegion.y1 - ((thisRegion.y + thisRegion.height) / atlasHeight),

                // Upper Right
                x1 : baseRegion.x0 + ((thisRegion.x + thisRegion.width) / atlasWidth),
                y1 : baseRegion.y1 - (thisRegion.y / atlasHeight)
            });
        }

        return numTextureCoordinates;
    };

    /**
     * DOC_TBA
     * @memberof TextureAtlas
     */
    TextureAtlas.prototype.getContext = function() {
        return this._context;
    };

    /**
     * DOC_TBA
     * @memberof TextureAtlas
     */
    TextureAtlas.prototype.getBorderWidthInPixels = function() {
        return this._borderWidthInPixels;
    };

    /**
     * DOC_TBA
     * @memberof TextureAtlas
     */
    TextureAtlas.prototype.getTextureCoordinates = function() {
        return this._textureCoordinates;
    };

    /**
     * DOC_TBA
     * @memberof TextureAtlas
     */
    TextureAtlas.prototype.getTexture = function() {
        return this._texture;
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof TextureAtlas
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see TextureAtlas#destroy
     */
    TextureAtlas.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>null</code>) to the object as done in the example.
     *
     * @memberof TextureAtlas
     *
     * @return {null}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see TextureAtlas#isDestroyed
     *
     * @example
     * atlas = atlas && atlas.destroy();
     */
    TextureAtlas.prototype.destroy = function() {
        this._texture = this._texture && this._texture.destroy();
        return destroyObject(this);
    };

    return TextureAtlas;
});
/*global define*/
define('Renderer/TextureMagnificationFilter',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports TextureMagnificationFilter
     */
    var TextureMagnificationFilter = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        NEAREST : new Enumeration(0x2600, "NEAREST"), // NEAREST

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        LINEAR : new Enumeration(0x2601, "LINEAR") // LINEAR
    };

    return TextureMagnificationFilter;
});
/*global define*/
define('Renderer/TextureMinificationFilter',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports TextureMinificationFilter
     */
    var TextureMinificationFilter = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        NEAREST : new Enumeration(0x2600, "NEAREST"), // NEAREST

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        LINEAR : new Enumeration(0x2601, "LINEAR"), // LINEAR

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        NEAREST_MIPMAP_NEAREST : new Enumeration(0x2700, "NEAREST_MIPMAP_NEAREST"), // NEAREST_MIPMAP_NEAREST

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        LINEAR_MIPMAP_NEAREST : new Enumeration(0x2701, "LINEAR_MIPMAP_NEAREST"), // LINEAR_MIPMAP_NEAREST

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        NEAREST_MIPMAP_LINEAR : new Enumeration(0x2702, "NEAREST_MIPMAP_LINEAR"), // NEAREST_MIPMAP_LINEAR

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        LINEAR_MIPMAP_LINEAR : new Enumeration(0x2703, "LINEAR_MIPMAP_LINEAR") // LINEAR_MIPMAP_LINEAR
    };

    return TextureMinificationFilter;
});
/*global define*/
define('Renderer/TextureWrap',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports TextureWrap
     */
    var TextureWrap = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        CLAMP : new Enumeration(0x812F, "CLAMP"), // CLAMP_TO_EDGE

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        REPEAT : new Enumeration(0x2901, "REPEAT"), // REPEAT

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        MIRRORED_REPEAT : new Enumeration(0x8370, "MIRRORED_REPEAT") // MIRRORED_REPEAT
    };

    return TextureWrap;
});
/*global define*/
define('Renderer/CubeMap',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        './MipmapHint',
        './TextureMagnificationFilter',
        './TextureMinificationFilter',
        './TextureWrap'
    ], function(
        DeveloperError,
        destroyObject,
        MipmapHint,
        TextureMagnificationFilter,
        TextureMinificationFilter,
        TextureWrap) {
    

    /**
     * DOC_TBA
     *
     * @name CubeMap
     * @internalConstructor
     *
     * @see Context#createCubeMap
     */
    function CubeMap(gl, textureFilterAnisotropic, textureTarget, texture, pixelFormat, pixelDatatype, size, preMultiplyAlpha) {
        this._gl = gl;
        this._textureFilterAnisotropic = textureFilterAnisotropic;
        this._textureTarget = textureTarget;
        this._texture = texture;
        this._pixelFormat = pixelFormat;
        this._pixelDatatype = pixelDatatype;
        this._size = size;
        this._preMultiplyAlpha = preMultiplyAlpha;
        this._sampler = undefined;

        this.setSampler();
    }

    /**
     * DOC_TBA
     *
     * @memberof CubeMap
     *
     * @param {Object} source The source {ImageData}, {HTMLImageElement}, {HTMLCanvasElement}, or {HTMLVideoElement}.
     * @param {Number} xOffset optional
     * @param {Number} yOffset optional
     *
     * @exception {DeveloperError} source is required.
     * @exception {DeveloperError} xOffset must be greater than or equal to zero.
     * @exception {DeveloperError} yOffset must be greater than or equal to zero.
     * @exception {DeveloperError} xOffset + source.width must be less than or equal to getWidth().
     * @exception {DeveloperError} yOffset + source.height must be less than or equal to getHeight().
     * @exception {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.
     */
    CubeMap.prototype._copyFrom = function(targetFace, source, xOffset, yOffset) {
        if (!source) {
            throw new DeveloperError("source is required.", "source");
        }

        xOffset = xOffset || 0;
        yOffset = yOffset || 0;

        var width = source.width;
        var height = source.height;

        if (xOffset < 0) {
            throw new DeveloperError("xOffset must be greater than or equal to zero.", "xOffset");
        }

        if (yOffset < 0) {
            throw new DeveloperError("yOffset must be greater than or equal to zero.", "yOffset");
        }

        if (xOffset + width > this._size) {
            throw new DeveloperError("xOffset + source.width must be less than or equal to getWidth().");
        }

        if (yOffset + height > this._size) {
            throw new DeveloperError("yOffset + source.height must be less than or equal to getHeight().");
        }

        var gl = this._gl;
        var target = this._textureTarget;

        // TODO: gl.pixelStorei(gl._UNPACK_ALIGNMENT, 4);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this._preMultiplyAlpha);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(target, this._texture);

        if (source.arrayBufferView) {
            gl.texSubImage2D(targetFace, 0, xOffset, yOffset, width, height, this._pixelFormat.value, this._pixelDatatype.value, source.arrayBufferView);
        } else {
            gl.texSubImage2D(targetFace, 0, xOffset, yOffset, this._pixelFormat.value, this._pixelDatatype.value, source);
        }

        gl.bindTexture(target, null);
    };

    /**
     * DOC_TBA
     *
     * @memberof CubeMap
     *
     * @param {Number} xOffset optional
     * @param {Number} yOffset optional
     * @param {Number} framebufferXOffset optional
     * @param {Number} framebufferYOffset optional
     * @param {Number} width optional
     * @param {Number} height optional
     *
     * @exception {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.
     * @exception {DeveloperError} xOffset must be greater than or equal to zero.
     * @exception {DeveloperError} yOffset must be greater than or equal to zero.
     * @exception {DeveloperError} framebufferXOffset must be greater than or equal to zero.
     * @exception {DeveloperError} framebufferYOffset must be greater than or equal to zero.
     * @exception {DeveloperError} xOffset + source.width must be less than or equal to getWidth().
     * @exception {DeveloperError} yOffset + source.height must be less than or equal to getHeight().
     */
    CubeMap.prototype._copyFromFramebuffer = function(targetFace, xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height) {
        xOffset = xOffset || 0;
        yOffset = yOffset || 0;
        framebufferXOffset = framebufferXOffset || 0;
        framebufferYOffset = framebufferYOffset || 0;
        width = width || this._size;
        height = height || this._size;

        if (xOffset < 0) {
            throw new DeveloperError("xOffset must be greater than or equal to zero.", "xOffset");
        }

        if (yOffset < 0) {
            throw new DeveloperError("yOffset must be greater than or equal to zero.", "yOffset");
        }

        if (framebufferXOffset < 0) {
            throw new DeveloperError("framebufferXOffset must be greater than or equal to zero.", "framebufferXOffset");
        }

        if (framebufferYOffset < 0) {
            throw new DeveloperError("framebufferYOffset must be greater than or equal to zero.", "framebufferYOffset");
        }

        if (xOffset + width > this._size) {
            throw new DeveloperError("xOffset + source.width must be less than or equal to getWidth().");
        }

        if (yOffset + height > this._size) {
            throw new DeveloperError("yOffset + source.height must be less than or equal to getHeight().");
        }

        var gl = this._gl;
        var target = this._textureTarget;

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(target, this._texture);
        gl.copyTexSubImage2D(targetFace, 0, xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height);
        gl.bindTexture(target, null);
    };

    /**
     * DOC_TBA
     * @memberof CubeMap
     */
    CubeMap.prototype.getPositiveX = function() {
        var that = this;
        return {
            copyFrom : function(source, xOffset, yOffset) {
                that._copyFrom(that._gl.TEXTURE_CUBE_MAP_POSITIVE_X, source, xOffset, yOffset);
            },

            copyFromFramebuffer : function(xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height) {
                that._copyFromFramebuffer(that._gl.TEXTURE_CUBE_MAP_POSITIVE_X, xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height);
            },

            _getTexture : function() {
                return that._texture;
            },

            _getTarget : function() {
                return that._gl.TEXTURE_CUBE_MAP_POSITIVE_X;
            }
        };
    };

    /**
     * DOC_TBA
     * @memberof CubeMap
     */
    CubeMap.prototype.getNegativeX = function() {
        var that = this;
        return {
            copyFrom : function(source, xOffset, yOffset) {
                that._copyFrom(that._gl.TEXTURE_CUBE_MAP_NEGATIVE_X, source, xOffset, yOffset);
            },

            copyFromFramebuffer : function(xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height) {
                that._copyFromFramebuffer(that._gl.TEXTURE_CUBE_MAP_NEGATIVE_X, xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height);
            },

            _getTexture : function() {
                return that._texture;
            },

            _getTarget : function() {
                return that._gl.TEXTURE_CUBE_MAP_NEGATIVE_X;
            }
        };
    };

    /**
     * DOC_TBA
     * @memberof CubeMap
     */
    CubeMap.prototype.getPositiveY = function() {
        var that = this;
        return {
            copyFrom : function(source, xOffset, yOffset) {
                that._copyFrom(that._gl.TEXTURE_CUBE_MAP_POSITIVE_Y, source, xOffset, yOffset);
            },

            copyFromFramebuffer : function(xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height) {
                that._copyFromFramebuffer(that._gl.TEXTURE_CUBE_MAP_POSITIVE_Y, xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height);
            },

            _getTexture : function() {
                return that._texture;
            },

            _getTarget : function() {
                return that._gl.TEXTURE_CUBE_MAP_POSITIVE_Y;
            }
        };
    };

    /**
     * DOC_TBA
     * @memberof CubeMap
     */
    CubeMap.prototype.getNegativeY = function() {
        var that = this;
        return {
            copyFrom : function(source, xOffset, yOffset) {
                that._copyFrom(that._gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, source, xOffset, yOffset);
            },

            copyFromFramebuffer : function(xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height) {
                that._copyFromFramebuffer(that._gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height);
            },

            _getTexture : function() {
                return that._texture;
            },

            _getTarget : function() {
                return that._gl.TEXTURE_CUBE_MAP_NEGATIVE_Y;
            }
        };
    };

    /**
     * DOC_TBA
     * @memberof CubeMap
     */
    CubeMap.prototype.getPositiveZ = function() {
        var that = this;
        return {
            copyFrom : function(source, xOffset, yOffset) {
                that._copyFrom(that._gl.TEXTURE_CUBE_MAP_POSITIVE_Z, source, xOffset, yOffset);
            },

            copyFromFramebuffer : function(xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height) {
                that._copyFromFramebuffer(that._gl.TEXTURE_CUBE_MAP_POSITIVE_Z, xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height);
            },

            _getTexture : function() {
                return that._texture;
            },

            _getTarget : function() {
                return that._gl.TEXTURE_CUBE_MAP_POSITIVE_Z;
            }
        };
    };

    /**
     * DOC_TBA
     * @memberof CubeMap
     */
    CubeMap.prototype.getNegativeZ = function() {
        var that = this;
        return {
            copyFrom : function(source, xOffset, yOffset) {
                that._copyFrom(that._gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, source, xOffset, yOffset);
            },

            copyFromFramebuffer : function(xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height) {
                that._copyFromFramebuffer(that._gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height);
            },

            _getTexture : function() {
                return that._texture;
            },

            _getTarget : function() {
                return that._gl.TEXTURE_CUBE_MAP_NEGATIVE_Z;
            }
        };
    };

    /**
     * DOC_TBA
     *
     * @memberof CubeMap
     *
     * @param {MipmapHint} hint optional.
     *
     * @exception {DeveloperError} Invalid hint.
     * @exception {DeveloperError} This CubeMap's width must be a power of two to call generateMipmap().
     * @exception {DeveloperError} This CubeMap's height must be a power of two to call generateMipmap().
     * @exception {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.
     */
    CubeMap.prototype.generateMipmap = function(hint) {
        if ((this._size > 1) && (this._size % 2 !== 0)) {
            throw new DeveloperError("This CubeMap's width and height must be a power of two to call generateMipmap().");
        }

        var gl = this._gl;
        var target = this._textureTarget;

        hint = hint || MipmapHint.DONT_CARE;
        var glHint = hint.value;
        if ((glHint !== gl.DONT_CARE) &&
            (glHint !== gl.FASTEST) &&
            (glHint !== gl.NICEST)) {
            throw new DeveloperError("Invalid hint.", "hint");
        }

        gl.hint(gl.GENERATE_MIPMAP_HINT, glHint);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(target, this._texture);
        gl.generateMipmap(target);
        gl.bindTexture(target, null);
    };

    /**
     * DOC_TBA
     *
     * @memberof CubeMap
     *
     * @param sampler optional.
     *
     * @exception {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.
     */
    CubeMap.prototype.setSampler = function(sampler) {
        var s = sampler || {
            wrapS : TextureWrap.CLAMP,
            wrapT : TextureWrap.CLAMP,
            minificationFilter : TextureMinificationFilter.LINEAR,
            magnificationFilter : TextureMagnificationFilter.LINEAR,
            maximumAnisotropy : 1.0
        };

        var gl = this._gl;
        var target = this._textureTarget;

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(target, this._texture);
        gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, s.minificationFilter);
        gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, s.magnificationFilter);
        gl.texParameteri(target, gl.TEXTURE_WRAP_S, s.wrapS);
        gl.texParameteri(target, gl.TEXTURE_WRAP_T, s.wrapT);
        if (this._textureFilterAnisotropic) {
            gl.texParameteri(target, this._textureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, s.maximumAnisotropy);
        }
        gl.bindTexture(target, null);

        this._sampler = {
            wrapS : s.wrapS,
            wrapT : s.wrapT,
            minificationFilter : s.minificationFilter,
            magnificationFilter : s.magnificationFilter,
            maximumAnisotropy : s.maximumAnisotropy
        };
    };

    /**
     * DOC_TBA
     *
     * @memberof CubeMap
     *
     * @exception {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.
     */
    CubeMap.prototype.getSampler = function() {
        return this._sampler;
    };

    /**
     * DOC_TBA
     *
     * @memberof CubeMap
     *
     * @exception {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.
     */
    CubeMap.prototype.getPixelFormat = function() {
        return this._pixelFormat;
    };

    /**
     * DOC_TBA
     *
     * @memberof CubeMap
     *
     * @exception {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.
     */
    CubeMap.prototype.getPixelDatatype = function() {
        return this._pixelDatatype;
    };

    /**
     * DOC_TBA
     *
     * @memberof CubeMap
     *
     * @exception {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.
     */
    CubeMap.prototype.getWidth = function() {
        return this._size;
    };

    /**
     * DOC_TBA
     *
     * @memberof CubeMap
     *
     * @exception {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.
     */
    CubeMap.prototype.getHeight = function() {
        return this._size;
    };

    /**
     * DOC_TBA
     *
     * @memberof CubeMap
     *
     * @exception {DeveloperError} This texture was destroyed, i.e., destroy() was called.
     */
    CubeMap.prototype.getPreMultiplyAlpha = function() {
        return this._preMultiplyAlpha;
    };

    CubeMap.prototype._getTexture = function() {
        return this._texture;
    };

    CubeMap.prototype._getTarget = function() {
        return this._textureTarget;
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof CubeMap
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see CubeMap.destroy
     */
    CubeMap.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>null</code>) to the object as done in the example.
     *
     * @memberof CubeMap
     *
     * @return {null}
     *
     * @exception {DeveloperError} This cube map was destroyed, i.e., destroy() was called.
     *
     * @see CubeMap.isDestroyed
     * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glDeleteTextures.xml">glDeleteTextures</a>
     *
     * @example
     * cubeMap = cubeMap && cubeMap.destroy();
     */
    CubeMap.prototype.destroy = function() {
        this._gl.deleteTexture(this._texture);
        return destroyObject(this);
    };

    return CubeMap;
});
/*global define*/
define('Renderer/Texture',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/Cartesian2',
        './MipmapHint',
        './TextureMagnificationFilter',
        './TextureMinificationFilter',
        './TextureWrap'
    ], function(
        DeveloperError,
        destroyObject,
        Cartesian2,
        MipmapHint,
        TextureMagnificationFilter,
        TextureMinificationFilter,
        TextureWrap) {
    

    /**
     * DOC_TBA
     *
     * @name Texture
     * @internalConstructor
     *
     * @see Context#createTexture2D
     * @see Context#createTexture2DFromFramebuffer
     */
    function Texture(gl, textureFilterAnisotropic, textureTarget, texture, pixelFormat, pixelDatatype, width, height, preMultiplyAlpha) {
        this._gl = gl;
        this._textureFilterAnisotropic = textureFilterAnisotropic;
        this._textureTarget = textureTarget;
        this._texture = texture;
        this._pixelFormat = pixelFormat;
        this._pixelDatatype = pixelDatatype;
        this._width = width;
        this._height = height;
        this._dimensions = new Cartesian2(width, height);
        this._preMultiplyAlpha = preMultiplyAlpha;
        this._sampler = undefined;

        this.setSampler();
    }

    /**
     * DOC_TBA
     *
     * @memberof Texture
     *
     * @param {Object} source The source {ImageData}, {HTMLImageElement}, {HTMLCanvasElement}, or {HTMLVideoElement}.
     * @param {Number} xOffset optional
     * @param {Number} yOffset optional
     *
     * @exception {DeveloperError} source is required.
     * @exception {DeveloperError} xOffset must be greater than or equal to zero.
     * @exception {DeveloperError} yOffset must be greater than or equal to zero.
     * @exception {DeveloperError} xOffset + source.width must be less than or equal to getWidth().
     * @exception {DeveloperError} yOffset + source.height must be less than or equal to getHeight().
     * @exception {DeveloperError} This texture was destroyed, i.e., destroy() was called.
     */
    Texture.prototype.copyFrom = function(source, xOffset, yOffset) {
        if (!source) {
            throw new DeveloperError("Source is required.", "source");
        }

        xOffset = xOffset || 0;
        yOffset = yOffset || 0;

        var width = source.width;
        var height = source.height;

        if (xOffset < 0) {
            throw new DeveloperError("xOffset must be greater than or equal to zero.", "xOffset");
        }

        if (yOffset < 0) {
            throw new DeveloperError("yOffset must be greater than or equal to zero.", "yOffset");
        }

        if (xOffset + width > this._width) {
            throw new DeveloperError("xOffset + source.width must be less than or equal to getWidth().");
        }

        if (yOffset + height > this._height) {
            throw new DeveloperError("yOffset + source.height must be less than or equal to getHeight().");
        }

        var gl = this._gl;
        var target = this._textureTarget;

        // TODO: gl.pixelStorei(gl._UNPACK_ALIGNMENT, 4);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this._preMultiplyAlpha);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(target, this._texture);

        if (source.arrayBufferView) {
            gl.texSubImage2D(target, 0, xOffset, yOffset, width, height, this._pixelFormat.value, this._pixelDatatype.value, source.arrayBufferView);
        } else {
            gl.texSubImage2D(target, 0, xOffset, yOffset, this._pixelFormat.value, this._pixelDatatype.value, source);
        }

        gl.bindTexture(target, null);
    };

    /**
     * DOC_TBA
     *
     * @memberof Texture
     *
     * @param {Number} xOffset optional
     * @param {Number} yOffset optional
     * @param {Number} framebufferXOffset optional
     * @param {Number} framebufferYOffset optional
     * @param {Number} width optional
     * @param {Number} height optional
     *
     * @exception {DeveloperError} This texture was destroyed, i.e., destroy() was called.
     * @exception {DeveloperError} xOffset must be greater than or equal to zero.
     * @exception {DeveloperError} yOffset must be greater than or equal to zero.
     * @exception {DeveloperError} framebufferXOffset must be greater than or equal to zero.
     * @exception {DeveloperError} framebufferYOffset must be greater than or equal to zero.
     * @exception {DeveloperError} xOffset + source.width must be less than or equal to getWidth().
     * @exception {DeveloperError} yOffset + source.height must be less than or equal to getHeight().
     */
    Texture.prototype.copyFromFramebuffer = function(xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height) {
        xOffset = xOffset || 0;
        yOffset = yOffset || 0;
        framebufferXOffset = framebufferXOffset || 0;
        framebufferYOffset = framebufferYOffset || 0;
        width = width || this._width;
        height = height || this._height;

        if (xOffset < 0) {
            throw new DeveloperError("xOffset must be greater than or equal to zero.", "xOffset");
        }

        if (yOffset < 0) {
            throw new DeveloperError("yOffset must be greater than or equal to zero.", "yOffset");
        }

        if (framebufferXOffset < 0) {
            throw new DeveloperError("framebufferXOffset must be greater than or equal to zero.", "framebufferXOffset");
        }

        if (framebufferYOffset < 0) {
            throw new DeveloperError("framebufferYOffset must be greater than or equal to zero.", "framebufferYOffset");
        }

        if (xOffset + width > this._width) {
            throw new DeveloperError("xOffset + source.width must be less than or equal to getWidth().");
        }

        if (yOffset + height > this._height) {
            throw new DeveloperError("yOffset + source.height must be less than or equal to getHeight().");
        }

        var gl = this._gl;
        var target = this._textureTarget;

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(target, this._texture);
        gl.copyTexSubImage2D(target, 0, xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height);
        gl.bindTexture(target, null);
    };

    /**
     * DOC_TBA
     *
     * @memberof Texture
     *
     * @param {MipmapHint} hint optional.
     *
     * @exception {DeveloperError} Invalid hint.
     * @exception {DeveloperError} This texture's width must be a power of two to call generateMipmap().
     * @exception {DeveloperError} This texture's height must be a power of two to call generateMipmap().
     * @exception {DeveloperError} This texture was destroyed, i.e., destroy() was called.
     */
    Texture.prototype.generateMipmap = function(hint) {
        if ((this._width > 1) && (this._width % 2 !== 0)) {
            throw new DeveloperError("This texture's width must be a power of two to call generateMipmap().");
        } else if ((this._height > 1) && (this._height % 2 !== 0)) {
            throw new DeveloperError("This texture's height must be a power of two to call generateMipmap().");
        }

        var gl = this._gl;
        var target = this._textureTarget;

        hint = hint || MipmapHint.DONT_CARE;
        var glHint = hint.value;
        if ((glHint !== gl.DONT_CARE) &&
            (glHint !== gl.FASTEST) &&
            (glHint !== gl.NICEST)) {
            throw new DeveloperError("Invalid hint.", "hint");
        }

        gl.hint(gl.GENERATE_MIPMAP_HINT, glHint);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(target, this._texture);
        gl.generateMipmap(target);
        gl.bindTexture(target, null);
    };

    /**
    * DOC_TBA
    *
    * @memberof Texture
    *
    * @param sampler optional.
    *
    * @exception {DeveloperError} This texture was destroyed, i.e., destroy() was called.
    */
    Texture.prototype.setSampler = function(sampler) {
        var s = sampler || {
            wrapS : TextureWrap.CLAMP,
            wrapT : TextureWrap.CLAMP,
            minificationFilter : TextureMinificationFilter.LINEAR,
            magnificationFilter : TextureMagnificationFilter.LINEAR,
            maximumAnisotropy : 1.0
        };

        var gl = this._gl;
        var target = this._textureTarget;

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(target, this._texture);
        gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, s.minificationFilter.value);
        gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, s.magnificationFilter.value);
        gl.texParameteri(target, gl.TEXTURE_WRAP_S, s.wrapS.value);
        gl.texParameteri(target, gl.TEXTURE_WRAP_T, s.wrapT.value);
        if (this._textureFilterAnisotropic) {
            gl.texParameteri(target, this._textureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, s.maximumAnisotropy);
        }
        gl.bindTexture(target, null);

        this._sampler = {
            wrapS : s.wrapS,
            wrapT : s.wrapT,
            minificationFilter : s.minificationFilter,
            magnificationFilter : s.magnificationFilter,
            maximumAnisotropy : s.maximumAnisotropy
        };
    };

    /**
     * DOC_TBA
     * @memberof Texture
     * @exception {DeveloperError} This texture was destroyed, i.e., destroy() was called.
     */
    Texture.prototype.getSampler = function() {
        return this._sampler;
    };

    /**
     * DOC_TBA
     * @memberof Texture
     * @exception {DeveloperError} This texture was destroyed, i.e., destroy() was called.
     */
    Texture.prototype.getPixelFormat = function() {
        return this._pixelFormat;
    };

    /**
     * DOC_TBA
     * @memberof Texture
     * @exception {DeveloperError} This texture was destroyed, i.e., destroy() was called.
     */
    Texture.prototype.getPixelDatatype = function() {
        return this._pixelDatatype;
    };

    /**
     * DOC_TBA
     * @memberof Texture
     * @exception {DeveloperError} This texture was destroyed, i.e., destroy() was called.
     */
    Texture.prototype.getWidth = function() {
        return this._width;
    };

    /**
     * DOC_TBA
     * @memberof Texture
     * @exception {DeveloperError} This texture was destroyed, i.e., destroy() was called.
     */
    Texture.prototype.getDimensions = function() {
        return this._dimensions;
    };

    /**
     * DOC_TBA
     * @memberof Texture
     * @exception {DeveloperError} This texture was destroyed, i.e., destroy() was called.
     */
    Texture.prototype.getPreMultiplyAlpha = function() {
        return this._preMultiplyAlpha;
    };

    /**
     * DOC_TBA
     * @memberof Texture
     * @exception {DeveloperError} This texture was destroyed, i.e., destroy() was called.
     */
    Texture.prototype.getHeight = function() {
        return this._height;
    };

    Texture.prototype._getTexture = function() {
        return this._texture;
    };

    Texture.prototype._getTarget = function() {
        return this._textureTarget;
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof Texture
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see Texture.destroy
     */
    Texture.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>null</code>) to the object as done in the example.
     *
     * @memberof Texture
     *
     * @return {null}
     *
     * @exception {DeveloperError} This texture was destroyed, i.e., destroy() was called.
     *
     * @see Texture.isDestroyed
     * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glDeleteTextures.xml">glDeleteTextures</a>
     *
     * @example
     * texture = texture && texture.destroy();
     */
    Texture.prototype.destroy = function() {
        this._gl.deleteTexture(this._texture);
        return destroyObject(this);
    };

    return Texture;
});
/*global define*/
define('Renderer/UniformDatatype',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * Indicates a GLSL uniform's datatype.
     *
     * @exports UniformDatatype
     * @see Uniform.getDatatype
     */
    var UniformDatatype = {
        /**
         * A <code>float</code> uniform.
         *
         * @constant
         * @type {Enumeration}
         */
        FLOAT : new Enumeration(0x1406, "FLOAT", {
            getGLSL : function() {
                return "float";
            }
        }), // FLOAT

        /**
         * A <code>vec2</code> uniform: a two-component floating-point vector.
         *
         * @constant
         * @type {Enumeration}
         */
        FLOAT_VECTOR2 : new Enumeration(0x8B50, "FLOAT_VECTOR2", {
            getGLSL : function() {
                return "vec2";
            }
        }), // FLOAT_VEC2

        /**
         * A <code>vec3</code> uniform: a three-component floating-point vector.
         *
         * @constant
         * @type {Enumeration}
         */
        FLOAT_VECTOR3 : new Enumeration(0x8B51, "FLOAT_VECTOR3", {
            getGLSL : function() {
                return "vec3";
            }
        }), // FLOAT_VEC3

        /**
         * A <code>vec4</code> uniform: a four-component floating-point vector.
         *
         * @constant
         * @type {Enumeration}
         */
        FLOAT_VECTOR4 : new Enumeration(0x8B52, "FLOAT_VECTOR4", {
            getGLSL : function() {
                return "vec4";
            }
        }), // FLOAT_VEC4

        /**
         * An <code>int</code> uniform.
         *
         * @constant
         * @type {Enumeration}
         */
        INT : new Enumeration(0x1404, "INT", {
            getGLSL : function() {
                return "int";
            }
        }), // INT

        /**
         * An <code>ivec2</code> uniform: a two-component integer vector.
         *
         * @constant
         * @type {Enumeration}
         */
        INT_VECTOR2 : new Enumeration(0x8B53, "INT_VECTOR2", {
            getGLSL : function() {
                return "ivec2";
            }
        }), // INT_VEC2

        /**
         * An <code>ivec3</code> uniform: a three-component integer vector.
         *
         * @constant
         * @type {Enumeration}
         */
        INT_VECTOR3 : new Enumeration(0x8B54, "INT_VECTOR3", {
            getGLSL : function() {
                return "ivec3";
            }
        }), // INT_VEC3

        /**
         * An <code>ivec4</code> uniform: a four-component integer vector.
         *
         * @constant
         * @type {Enumeration}
         */
        INT_VECTOR4 : new Enumeration(0x8B55, "INT_VECTOR4", {
            getGLSL : function() {
                return "ivec4";
            }
        }), // INT_VEC4

        /**
         * A <code>bool</code> uniform.
         *
         * @constant
         * @type {Enumeration}
         */
        BOOL : new Enumeration(0x8B56, "BOOL", {
            getGLSL : function() {
                return "bool";
            }
        }), // BOOL

        /**
         * A <code>bvec2</code> uniform: a two-component boolean vector.
         *
         * @constant
         * @type {Enumeration}
         */
        BOOL_VECTOR2 : new Enumeration(0x8B57, "BOOL_VECTOR2", {
            getGLSL : function() {
                return "bvec2";
            }
        }), // BOOL_VEC2

        /**
         * A <code>bvec3</code> uniform: a three-component boolean vector.
         *
         * @constant
         * @type {Enumeration}
         */
        BOOL_VECTOR3 : new Enumeration(0x8B58, "BOOL_VECTOR3", {
            getGLSL : function() {
                return "bvec3";
            }
        }), // BOOL_VEC3

        /**
         * A <code>bvec4</code> uniform: a four-component boolean vector.
         *
         * @constant
         * @type {Enumeration}
         */
        BOOL_VECTOR4 : new Enumeration(0x8B59, "BOOL_VECTOR4", {
            getGLSL : function() {
                return "bvec4";
            }
        }), // BOOL_VEC4

        /**
         * An <code>mat2</code> uniform: a 2x2 floating-point matrix.
         *
         * @constant
         * @type {Enumeration}
         */
        FLOAT_MATRIX2 : new Enumeration(0x8B5A, "FLOAT_MATRIX2", {
            getGLSL : function() {
                return "mat2";
            }
        }), // FLOAT_MAT2

        /**
         * An <code>mat3</code> uniform: a 3x3 floating-point matrix.
         *
         * @constant
         * @type {Enumeration}
         */
        FLOAT_MATRIX3 : new Enumeration(0x8B5B, "FLOAT_MATRIX3", {
            getGLSL : function() {
                return "mat3";
            }
        }), // FLOAT_MAT3

        /**
         * An <code>mat4</code> uniform: a 4x4 floating-point matrix.
         *
         * @constant
         * @type {Enumeration}
         */
        FLOAT_MATRIX4 : new Enumeration(0x8B5C, "FLOAT_MATRIX4", {
            getGLSL : function() {
                return "mat4";
            }
        }), // FLOAT_MAT4

        /**
         * A <code>sampler2D</code> uniform: an opaque type to access 2D textures.
         *
         * @constant
         * @type {Enumeration}
         */
        SAMPLER_2D : new Enumeration(0x8B5E, "SAMPLER_2D", {
            getGLSL : function() {
                return "sampler2D";
            }
        }), // SAMPLER_2D

        /**
         * A <code>samplerCube</code> uniform: an opaque type to access cube-map textures.
         *
         * @constant
         * @type {Enumeration}
         */
        SAMPLER_CUBE : new Enumeration(0x8B60, "SAMPLER_CUBE", {
            getGLSL : function() {
                return "samplerCube";
            }
        }) // SAMPLER_CUBE
    };

    return UniformDatatype;
});
/*global define*/
define('Renderer/ShaderProgram',[
        '../Core/DeveloperError',
        '../Core/RuntimeError',
        '../Core/destroyObject',
        '../Core/Math',
        '../Core/Matrix4',
        './UniformDatatype'
    ], function(
        DeveloperError,
        RuntimeError,
        destroyObject,
        CesiumMath,
        Matrix4,
        UniformDatatype) {
    
    /*global console*/

    function getUniformDatatype(gl, activeUniformType) {
        switch (activeUniformType) {
        case gl.FLOAT:
            return function() {
                return UniformDatatype.FLOAT;
            };
        case gl.FLOAT_VEC2:
            return function() {
                return UniformDatatype.FLOAT_VECTOR2;
            };
        case gl.FLOAT_VEC3:
            return function() {
                return UniformDatatype.FLOAT_VECTOR3;
            };
        case gl.FLOAT_VEC4:
            return function() {
                return UniformDatatype.FLOAT_VECTOR4;
            };
        case gl.INT:
            return function() {
                return UniformDatatype.INT;
            };
        case gl.INT_VEC2:
            return function() {
                return UniformDatatype.INT_VECTOR2;
            };
        case gl.INT_VEC3:
            return function() {
                return UniformDatatype.INT_VECTOR3;
            };
        case gl.INT_VEC4:
            return function() {
                return UniformDatatype.INT_VECTOR4;
            };
        case gl.BOOL:
            return function() {
                return UniformDatatype.BOOL;
            };
        case gl.BOOL_VEC2:
            return function() {
                return UniformDatatype.BOOL_VECTOR2;
            };
        case gl.BOOL_VEC3:
            return function() {
                return UniformDatatype.BOOL_VECTOR3;
            };
        case gl.BOOL_VEC4:
            return function() {
                return UniformDatatype.BOOL_VECTOR4;
            };
        case gl.FLOAT_MAT2:
            return function() {
                return UniformDatatype.FLOAT_MATRIX2;
            };
        case gl.FLOAT_MAT3:
            return function() {
                return UniformDatatype.FLOAT_MATRIX3;
            };
        case gl.FLOAT_MAT4:
            return function() {
                return UniformDatatype.FLOAT_MATRIX4;
            };
        case gl.SAMPLER_2D:
            return function() {
                return UniformDatatype.SAMPLER_2D;
            };
        case gl.SAMPLER_CUBE:
            return function() {
                return UniformDatatype.SAMPLER_CUBE;
            };
        default:
            throw new RuntimeError("Unrecognized uniform type: " + activeUniformType);
        }
    }

    /**
     * A shader program's uniform, including the uniform's value.  This is most commonly used to change
     * the value of a uniform, but can also be used retrieve a uniform's name and datatype,
     * which is useful for creating user interfaces for tweaking shaders.
     * <br /><br />
     * Do not create a uniform object with the <code>new</code> keyword; a shader program's uniforms
     * are available via {@link ShaderProgram#getAllUniforms}.
     * <br /><br />
     * Changing a uniform's value will affect future calls to {@link Context#draw}
     * that use the corresponding shader program.
     * <br /><br />
     * The datatype of the <code>value</code> property depends on the datatype
     * used in the GLSL declaration as shown in the examples in the table below.
     * <br /><br />
     * <table border="1">
     * <tr>
     * <td>GLSL</td>
     * <td>JavaScript</td>
     * </tr>
     * <tr>
     * <td><code>uniform float u_float; </code></td>
     * <td><code> sp.getAllUniforms().u_float.value = 1.0;</code></td>
     * </tr>
     * <tr>
     * <td><code>uniform vec2 u_vec2; </code></td>
     * <td><code> sp.getAllUniforms().u_vec2.value = new Cartesian2(1.0, 2.0);</code></td>
     * </tr>
     * <tr>
     * <td><code>uniform vec3 u_vec3; </code></td>
     * <td><code> sp.getAllUniforms().u_vec3.value = new Cartesian3(1.0, 2.0, 3.0);</code></td>
     * </tr>
     * <tr>
     * <td><code>uniform vec4 u_vec4; </code></td>
     * <td><code> sp.getAllUniforms().u_vec4.value = new Cartesian4(1.0, 2.0, 3.0, 4.0);</code></td>
     * </tr>
     * <tr>
     * <td><code>uniform int u_int; </code></td>
     * <td><code> sp.getAllUniforms().u_int.value = 1;</code></td>
     * </tr>
     * <tr>
     * <td><code>uniform ivec2 u_ivec2; </code></td>
     * <td><code> sp.getAllUniforms().u_ivec2.value = new Cartesian2(1, 2);</code></td>
     * </tr>
     * <tr>
     * <td><code>uniform ivec3 u_ivec3; </code></td>
     * <td><code> sp.getAllUniforms().u_ivec3.value = new Cartesian3(1, 2, 3);</code></td>
     * </tr>
     * <tr>
     * <td><code>uniform ivec4 u_ivec4; </code></td>
     * <td><code> sp.getAllUniforms().u_ivec4.value = new Cartesian4(1, 2, 3, 4);</code></td>
     * </tr>
     * <tr>
     * <td><code>uniform bool u_bool; </code></td>
     * <td><code> sp.getAllUniforms().u_bool.value = true;</code></td>
     * </tr>
     * <tr>
     * <td><code>uniform bvec2 u_bvec2; </code></td>
     * <td><code> sp.getAllUniforms().u_bvec2.value = new Cartesian2(true, true);</code></td>
     * </tr>
     * <tr>
     * <td><code>uniform bvec3 u_bvec3; </code></td>
     * <td><code> sp.getAllUniforms().u_bvec3.value = new Cartesian3(true, true, true);</code></td>
     * </tr>
     * <tr>
     * <td><code>uniform bvec4 u_bvec4; </code></td>
     * <td><code> sp.getAllUniforms().u_bvec4.value = new Cartesian4(true, true, true, true);</code></td>
     * </tr>
     * <tr>
     * <td><code>uniform mat2 u_mat2; </code></td>
     * <td><code> sp.getAllUniforms().u_mat2.value = new Matrix2(1.0, 2.0, 3.0, 4.0);</code></td>
     * </tr>
     * <tr>
     * <td><code>uniform mat3 u_mat3; </code></td>
     * <td><code> sp.getAllUniforms().u_mat3.value = new Matrix3(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0);</code></td>
     * </tr>
     * <tr>
     * <td><code>uniform mat4 u_mat4; </code></td>
     * <td><code> sp.getAllUniforms().u_mat4.value = new Matrix4(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 8.0, 7.0, 6.0, 5.0, 4.0, 3.0, 2.0);</code></td>
     * </tr>
     * <tr>
     * <td><code>uniform sampler2D u_texture; </code></td>
     * <td><code> sp.getAllUniforms().u_texture.value = context.createTexture2D(...);</code></td>
     * </tr>
     * <tr>
     * <td><code>uniform samplerCube u_cubeMap; </code></td>
     * <td><code> sp.getAllUniforms().u_cubeMap.value = context.createCubeMap(...);</code></td>
     * </tr>
     * </table>
     * <br />
     * When the GLSL uniform is declared as an array, <code>value</code> is also an array as shown in Example 2.
     * Individual members of a <code>struct uniform</code> can be accessed as done in Example 3.
     * <br /><br />
     * Uniforms whose names starting with <code>agi_</code>, such as {@link agi_viewProjection}, are called
     * automatic uniforms; they are implicitly declared and automatically assigned to in
     * <code>Context.draw</code> based on the {@link UniformState}.
     *
     * @name Uniform
     * @internalConstructor
     *
     * @see Uniform#value
     * @see UniformDatatype
     * @see ShaderProgram#getAllUniforms
     * @see UniformState
     * @see Context#draw
     * @see Context#createTexture2D
     * @see Context#createCubeMap
     *
     * @example
     * // Example 1. Create a shader program and set its
     * // one uniform, a 4x4 matrix, to the identity matrix
     * var vs =
     *   "attribute vec4 position; " +
     *   "uniform mat4 u_mvp; " +
     *   "void main() { gl_Position = u_mvp * position; }";
     * var fs = // ...
     * var sp = context.createShaderProgram(vs, fs);
     *
     * var mvp = sp.getAllUniforms().u_mvp;
     * console.log(mvp.getName());           // "u_mvp"
     * console.log(mvp.getDatatype().name);  // "FLOAT_MATRIX4"
     * mvp.value = Matrix4.getIdentity();
     *
     * //////////////////////////////////////////////////////////////////////
     *
     * // Example 2. Setting values for a GLSL array uniform
     * // GLSL:  uniform float u_float[2];
     * sp.getAllUniforms().u_float.value = new Cartesian2(1.0, 2.0);
     *
     * // GLSL:  uniform vec4 u_vec4[2];
     * sp.getAllUniforms().u_vec4.value = [
     *   Cartesian4.getUnitX(),
     *   Cartesian4.getUnitY()
     * ];
     *
     * //////////////////////////////////////////////////////////////////////
     *
     * // Example 3. Setting values for members of a GLSL struct
     * // GLSL:  uniform struct { float f; vec4 v; } u_struct;
     * sp.getAllUniforms()["u_struct.f"].value = 1.0;
     * sp.getAllUniforms()["u_struct.v"].value = new Cartesian4(1.0, 2.0, 3.0, 4.0);
     */
    function Uniform(_gl, activeUniform, _uniformName, _location, uniformValue) {
        /**
         * The value of the uniform.  The datatype depends on the datatype used in the
         * GLSL declaration as explained in the {@link Uniform} help and shown
         * in the examples below.
         *
         * @field
         * @name Uniform#value
         *
         * @see Context#createTexture2D
         *
         * @example
         * // GLSL:  uniform float u_float;
         * sp.getAllUniforms().u_float.value = 1.0;
         *
         * // GLSL:  uniform vec4 u_vec4;
         * sp.getAllUniforms().u_vec4.value = Cartesian4.getZero();
         *
         * // GLSL:  uniform bvec4 u_bvec4;
         * sp.getAllUniforms().u_bvec4.value = new Cartesian4(true, true, true, true);
         *
         * // GLSL:  uniform mat4 u_mat4;
         * sp.getAllUniforms().u_mat4.value = Matrix4.getIdentity();
         *
         * // GLSL:  uniform sampler2D u_texture;
         * sp.getAllUniforms().u_texture.value = context.createTexture2D(...);
         *
         * // GLSL:  uniform vec2 u_vec2[2];
         * sp.getAllUniforms().u_vec2.value = [
         *   new Cartesian2(1.0, 2.0),
         *   new Cartesian2(3.0, 4.0)
         * ];
         *
         * // GLSL:  uniform struct { float f; vec4 v; } u_struct;
         * sp.getAllUniforms()["u_struct.f"].value = 1.0;
         * sp.getAllUniforms()["u_struct.v"].value = new Cartesian4(1.0, 2.0, 3.0, 4.0);
         */
        this.value = uniformValue;

        /**
         * Returns the case-sensitive name of the GLSL uniform.
         *
         * @returns {String} The name of the uniform.
         * @function
         * @name Uniform#getName
         *
         * @example
         * // GLSL: uniform mat4 u_mvp;
         * console.log(sp.getAllUniforms().u_mvp.getName());  // "u_mvp"
         */
        this.getName = function() {
            return _uniformName;
        };

        /**
         * Returns the datatype of the uniform.  This is useful when dynamically
         * creating a user interface to tweak shader uniform values.
         *
         * @returns {UniformDatatype} The datatype of the uniform.
         * @function
         * @name Uniform#getDatatype
         *
         * @see UniformDatatype
         *
         * @example
         * // GLSL: uniform mat4 u_mvp;
         * console.log(sp.getAllUniforms().u_mvp.getDatatype().name);  // "FLOAT_MATRIX4"
         */
        this.getDatatype = getUniformDatatype(_gl, activeUniform.type);

        this._getLocation = function() {
            return _location;
        };

        this._set = function() {
            switch (activeUniform.type) {
            case _gl.FLOAT:
                return function() {
                    _gl.uniform1f(_location, this.value);
                };
            case _gl.FLOAT_VEC2:
                return function() {
                    var v = this.value;
                    _gl.uniform2f(_location, v.x, v.y);
                };
            case _gl.FLOAT_VEC3:
                return function() {
                    var v = this.value;
                    _gl.uniform3f(_location, v.x, v.y, v.z);
                };
            case _gl.FLOAT_VEC4:
                return function() {
                    var v = this.value;

                    if (typeof v.red !== "undefined") {
                        _gl.uniform4f(_location, v.red, v.green, v.blue, v.alpha);
                    } else if (typeof v.x !== "undefined") {
                        _gl.uniform4f(_location, v.x, v.y, v.z, v.w);
                    } else {
                        throw new DeveloperError("Invalid vec4 value.");
                    }
                };
            case _gl.SAMPLER_2D:
            case _gl.SAMPLER_CUBE:
                // See _setSampler()
                return undefined;
            case _gl.INT:
            case _gl.BOOL:
                return function() {
                    _gl.uniform1i(_location, this.value);
                };
            case _gl.INT_VEC2:
            case _gl.BOOL_VEC2:
                return function() {
                    var v = this.value;
                    _gl.uniform2i(_location, v.x, v.y);
                };
            case _gl.INT_VEC3:
            case _gl.BOOL_VEC3:
                return function() {
                    var v = this.value;
                    _gl.uniform3i(_location, v.x, v.y, v.z);
                };
            case _gl.INT_VEC4:
            case _gl.BOOL_VEC4:
                return function() {
                    var v = this.value;
                    _gl.uniform4i(_location, v.x, v.y, v.z, v.w);
                };
            case _gl.FLOAT_MAT2:
                return function() {
                    _gl.uniformMatrix2fv(_location, false, this.value.values);
                };
            case _gl.FLOAT_MAT3:
                return function() {
                    _gl.uniformMatrix3fv(_location, false, this.value.values);
                };
            case _gl.FLOAT_MAT4:
                return function() {
                    _gl.uniformMatrix4fv(_location, false, this.value.values);
                };
            default:
                throw new RuntimeError("Unrecognized uniform type: " + activeUniform.type);
            }
        }();

        if ((activeUniform.type === _gl.SAMPLER_2D) || (activeUniform.type === _gl.SAMPLER_CUBE)) {
            this._setSampler = function(textureUnitIndex) {
                _gl.activeTexture(_gl.TEXTURE0 + textureUnitIndex);
                _gl.bindTexture(this.value._getTarget(), this.value._getTexture());
                _gl.uniform1i(_location, textureUnitIndex);

                return textureUnitIndex + 1;
            };

            this._clearSampler = function(textureUnitIndex) {
                _gl.activeTexture(_gl.TEXTURE0 + textureUnitIndex);
                _gl.bindTexture(this.value._getTarget(), null);

                return textureUnitIndex + 1;
            };
        }
    }

    /*
     * Uniform and UniformArray have the same documentation.  It is just an implementation
     * detail that they are two different types.
     *
     * @name UniformArray
     */
    function UniformArray(_gl, activeUniform, _uniformName, locations, value) {
        this.value = value;

        var _locations = locations;

        /**
         * @private
         */
        this.getName = function() {
            return _uniformName;
        };

        this.getDatatype = getUniformDatatype(_gl, activeUniform.type);

        this._getLocations = function() {
            return _locations;
        };

        this._set = function() {
            switch (activeUniform.type) {
            case _gl.FLOAT:
                return function() {
                    for ( var i = 0; i < _locations.length; ++i) {
                        _gl.uniform1f(_locations[i], this.value[i]);
                    }
                };
            case _gl.FLOAT_VEC2:
                return function() {
                    for ( var i = 0; i < _locations.length; ++i) {
                        var v = this.value[i];
                        _gl.uniform2f(_locations[i], v.x, v.y);
                    }
                };
            case _gl.FLOAT_VEC3:
                return function() {
                    for ( var i = 0; i < _locations.length; ++i) {
                        var v = this.value[i];
                        _gl.uniform3f(_locations[i], v.x, v.y, v.z);
                    }
                };
            case _gl.FLOAT_VEC4:
                return function() {
                    for ( var i = 0; i < _locations.length; ++i) {
                        var v = this.value[i];

                        if (typeof v.red !== "undefined") {
                            _gl.uniform4f(_locations[i], v.red, v.green, v.blue, v.alpha);
                        } else if (typeof v.x !== "undefined") {
                            _gl.uniform4f(_locations[i], v.x, v.y, v.z, v.w);
                        } else {
                            throw new DeveloperError("Invalid vec4 value.");
                        }
                    }
                };
            case _gl.SAMPLER_2D:
            case _gl.SAMPLER_CUBE:
                // See _setSampler()
                return undefined;
            case _gl.INT:
            case _gl.BOOL:
                return function() {
                    for ( var i = 0; i < _locations.length; ++i) {
                        _gl.uniform1i(_locations[i], this.value[i]);
                    }
                };
            case _gl.INT_VEC2:
            case _gl.BOOL_VEC2:
                return function() {
                    for ( var i = 0; i < _locations.length; ++i) {
                        var v = this.value[i];
                        _gl.uniform2i(_locations[i], v.x, v.y);
                    }
                };
            case _gl.INT_VEC3:
            case _gl.BOOL_VEC3:
                return function() {
                    for ( var i = 0; i < _locations.length; ++i) {
                        var v = this.value[i];
                        _gl.uniform3i(_locations[i], v.x, v.y, v.z);
                    }
                };
            case _gl.INT_VEC4:
            case _gl.BOOL_VEC4:
                return function() {
                    for ( var i = 0; i < _locations.length; ++i) {
                        var v = this.value[i];
                        _gl.uniform4i(_locations[i], v.x, v.y, v.z, v.w);
                    }
                };
            case _gl.FLOAT_MAT2:
                return function() {
                    for ( var i = 0; i < _locations.length; ++i) {
                        _gl.uniformMatrix2fv(_locations[i], false, this.value[i].values);
                    }
                };
            case _gl.FLOAT_MAT3:
                return function() {
                    for ( var i = 0; i < _locations.length; ++i) {
                        _gl.uniformMatrix3fv(_locations[i], false, this.value[i].values);
                    }
                };
            case _gl.FLOAT_MAT4:
                return function() {
                    for ( var i = 0; i < _locations.length; ++i) {
                        _gl.uniformMatrix4fv(_locations[i], false, this.value[i].values);
                    }
                };
            default:
                throw new RuntimeError("Unrecognized uniform type: " + activeUniform.type);
            }
        }();

        if ((activeUniform.type === _gl.SAMPLER_2D) || (activeUniform.type === _gl.SAMPLER_CUBE)) {
            this._setSampler = function(textureUnitIndex) {
                for ( var i = 0; i < _locations.length; ++i) {
                    var index = textureUnitIndex + i;
                    _gl.activeTexture(_gl.TEXTURE0 + index);
                    _gl.bindTexture(this.value[i]._getTarget(), this.value[i]._getTexture());
                    _gl.uniform1i(_locations[i], index);
                }

                return textureUnitIndex + _locations.length;
            };

            this._clearSampler = function(textureUnitIndex) {
                for ( var i = 0; i < _locations.length; ++i) {
                    _gl.activeTexture(_gl.TEXTURE0 + textureUnitIndex + i);
                    _gl.bindTexture(this.value[i]._getTarget(), null);
                }

                return textureUnitIndex + _locations.length;
            };
        }
    }

    /**
     * DOC_TBA
     *
     * @name ShaderProgram
     * @internalConstructor
     *
     * @see Context#createShaderProgram
     * @see Context#getShaderCache
     */
    function ShaderProgram(gl, logShaderCompilation, builtInGlslFunctions, vertexShaderSource, fragmentShaderSource, attributeLocations) {
        var getAllAutomaticUniforms = function() {
            var uniforms = {
                /**
                 * An automatic GLSL uniform containing the viewport's <code>x</code>, <code>y</code>, <code>width</code>,
                 * and <code>height</code> properties in an <code>ivec4</code>'s <code>x</code>, <code>y</code>, <code>z</code>,
                 * and <code>w</code> components, respectively.
                 * <br /><br />
                 * Like all automatic uniforms, <code>agi_viewport</code> does not need to be explicitly declared.
                 * However, it can be explicitly declared when a shader is also used by other applications such
                 * as a third-party authoring tool.
                 *
                 * @name agi_viewport
                 * @glslUniform
                 *
                 * @see Context#getViewport
                 *
                 * @example
                 * // GLSL declaration
                 * uniform ivec4 agi_viewport;
                 *
                 * // Scale the window coordinate components to [0, 1] by dividing
                 * // by the viewport's width and height.
                 * vec2 v = gl_FragCoord.xy / agi_viewport.zw;
                 */
                agi_viewport : {
                    /**
                     * @private
                     */
                    getSize : function() {
                        return 1;
                    },

                    /**
                     * @private
                     */
                    getDatatype : function() {
                        return UniformDatatype.INT_VECTOR4;
                    },

                    /**
                     * @private
                     */
                    create : function(uniform) {
                        return {
                            _set : function(uniformState) {
                                var v = uniformState.getContext().getViewport();
                                uniform.value = {
                                    x : v.x,
                                    y : v.y,
                                    z : v.width,
                                    w : v.height
                                };
                            }
                        };
                    }
                },

                /**
                 * An automatic GLSL uniform representing a 4x4 orthographic projection matrix that
                 * transforms window coordinates to clip coordinates.  Clip coordinates is the
                 * coordinate system for a vertex shader's <code>gl_Position</code> output.
                 * <br /><br />
                 * This transform is useful when a vertex shader inputs or manipulates window coordinates
                 * as done by {@link BillboardCollection}.
                 * <br /><br />
                 * Do not confuse {@link agi_viewportTransformation} with <code>agi_viewportOrthographic</code>.
                 * The former transforms from normalized device coordinates to window coordinates; the later transforms
                 * from window coordinates to clip coordinates, and is often used to assign to <code>gl_Position</code>.
                 * <br /><br />
                 * Like all automatic uniforms, <code>agi_viewportOrthographic</code> does not need to be explicitly declared.
                 * However, it can be explicitly declared when a shader is also used by other applications such
                 * as a third-party authoring tool.
                 *
                 * @name agi_viewportOrthographic
                 * @glslUniform
                 *
                 * @see UniformState#getViewportOrthographic
                 * @see agi_viewport
                 * @see agi_viewportTransformation
                 * @see BillboardCollection
                 *
                 * @example
                 * // GLSL declaration
                 * uniform mat4 agi_viewportOrthographic;
                 *
                 * // Example
                 * gl_Position = agi_viewportOrthographic * vec4(windowPosition, 0.0, 1.0);
                 */
                agi_viewportOrthographic : {
                    /**
                     * @private
                     */
                    getSize : function() {
                        return 1;
                    },

                    /**
                     * @private
                     */
                    getDatatype : function() {
                        return UniformDatatype.FLOAT_MATRIX4;
                    },

                    /**
                     * @private
                     */
                    create : function(uniform) {
                        return {
                            _set : function(uniformState) {
                                uniform.value = uniformState.getViewportOrthographic();
                            }
                        };
                    }
                },

                /**
                 * An automatic GLSL uniform representing a 4x4 transformation matrix that
                 * transforms normalized device coordinates to window coordinates.  The context's
                 * full viewport is used, and the depth range is assumed to be <code>near = 0</code>
                 * and <code>far = 1</code>.
                 * <br /><br />
                 * This transform is useful when there is a need to manipulate window coordinates
                 * in a vertex shader as done by {@link BillboardCollection}.  In many cases,
                 * this matrix will not be used directly; instead, {@link agi_modelToWindowCoordinates}
                 * will be used to transform directly from model to window coordinates.
                 * <br /><br />
                 * Do not confuse <code>agi_viewportTransformation</code> with {@link agi_viewportOrthographic}.
                 * The former transforms from normalized device coordinates to window coordinates; the later transforms
                 * from window coordinates to clip coordinates, and is often used to assign to <code>gl_Position</code>.
                 * <br /><br />
                 * Like all automatic uniforms, <code>agi_viewportTransformation</code> does not need to be explicitly declared.
                 * However, it can be explicitly declared when a shader is also used by other applications such
                 * as a third-party authoring tool.
                 *
                 * @name agi_viewportTransformation
                 * @glslUniform
                 *
                 * @see UniformState#getViewportTransformation
                 * @see agi_viewport
                 * @see agi_viewportOrthographic
                 * @see agi_modelToWindowCoordinates
                 * @see BillboardCollection
                 *
                 * @example
                 * // GLSL declaration
                 * uniform mat4 agi_viewportTransformation;
                 *
                 * // Use agi_viewportTransformation as part of the
                 * // transform from model to window coordinates.
                 * vec4 q = agi_modelViewProjection * positionMC;              // model to clip coordinates
                 * q.xyz /= q.w;                                                // clip to normalized device coordinates (ndc)
                 * q.xyz = (agi_viewportTransformation * vec4(q.xyz, 1.0)).xyz; // ndc to window coordinates
                 */
                agi_viewportTransformation : {
                    /**
                     * @private
                     */
                    getSize : function() {
                        return 1;
                    },

                    /**
                     * @private
                     */
                    getDatatype : function() {
                        return UniformDatatype.FLOAT_MATRIX4;
                    },

                    /**
                     * @private
                     */
                    create : function(uniform) {
                        return {
                            _set : function(uniformState) {
                                uniform.value = uniformState.getViewportTransformation();
                            }
                        };
                    }
                },

                /**
                 * An automatic GLSL uniform representing a 4x4 model transformation matrix that
                 * transforms model coordinates to world coordinates.
                 * <br /><br />
                 * Like all automatic uniforms, <code>agi_model</code> does not need to be explicitly declared.
                 * However, it can be explicitly declared when a shader is also used by other applications such
                 * as a third-party authoring tool.
                 *
                 * @name agi_model
                 * @glslUniform
                 *
                 * @see UniformState#getModel
                 * @see agi_modelView
                 * @see agi_modelViewProjection
                 *
                 * @example
                 * // GLSL declaration
                 * uniform mat4 agi_model;
                 *
                 * // Example
                 * vec4 worldPosition = agi_model * modelPosition;
                 */
                agi_model : {
                    /**
                     * @private
                     */
                    getSize : function() {
                        return 1;
                    },

                    /**
                     * @private
                     */
                    getDatatype : function() {
                        return UniformDatatype.FLOAT_MATRIX4;
                    },

                    /**
                     * @private
                     */
                    create : function(uniform) {
                        return {
                            _set : function(uniformState) {
                                uniform.value = uniformState.getModel();
                            }
                        };
                    }
                },

                /**
                 * An automatic GLSL uniform representing a 4x4 transformation matrix that
                 * transforms from eye coordinates to world coordinates.
                 * <br /><br />
                 * Like all automatic uniforms, <code>agi_inverseView</code> does not need to be explicitly declared.
                 * However, it can be explicitly declared when a shader is also used by other applications such
                 * as a third-party authoring tool.
                 *
                 * @name agi_inverseView
                 * @glslUniform
                 *
                 * @see UniformState#getInverseView
                 * @see agi_view
                 * @see agi_inverseNormal
                 *
                 * @example
                 * // GLSL declaration
                 * uniform mat4 agi_inverseView;
                 *
                 * // Example
                 * vec4 worldPosition = agi_inverseView * eyePosition;
                 */
                agi_inverseView : {
                    getSize : function() {
                        return 1;
                    },

                    getDatatype : function() {
                        return UniformDatatype.FLOAT_MATRIX4;
                    },

                    create : function(uniform) {
                        return {
                            _set : function(uniformState) {
                                uniform.value = uniformState.getInverseView();
                            }
                        };
                    }
                },

                /**
                 * An automatic GLSL uniform representing a 4x4 view transformation matrix that
                 * transforms world coordinates to eye coordinates.
                 * <br /><br />
                 * Like all automatic uniforms, <code>agi_view</code> does not need to be explicitly declared.
                 * However, it can be explicitly declared when a shader is also used by other applications such
                 * as a third-party authoring tool.
                 *
                 * @name agi_view
                 * @glslUniform
                 *
                 * @see UniformState#getView
                 * @see agi_modelView
                 * @see agi_viewProjection
                 * @see agi_modelViewProjection
                 * @see agi_inverseView
                 *
                 * @example
                 * // GLSL declaration
                 * uniform mat4 agi_view;
                 *
                 * // Example
                 * vec4 eyePosition = agi_view * worldPosition;
                 */
                agi_view : {
                    getSize : function() {
                        return 1;
                    },

                    getDatatype : function() {
                        return UniformDatatype.FLOAT_MATRIX4;
                    },

                    create : function(uniform) {
                        return {
                            _set : function(uniformState) {
                                uniform.value = uniformState.getView();
                            }
                        };
                    }
                },

                /**
                 * An automatic GLSL uniform representing a 4x4 projection transformation matrix that
                 * transforms eye coordinates to clip coordinates.  Clip coordinates is the
                 * coordinate system for a vertex shader's <code>gl_Position</code> output.
                 * <br /><br />
                 * Like all automatic uniforms, <code>agi_projection</code> does not need to be explicitly declared.
                 * However, it can be explicitly declared when a shader is also used by other applications such
                 * as a third-party authoring tool.
                 *
                 * @name agi_projection
                 * @glslUniform
                 *
                 * @see UniformState#getProjection
                 * @see agi_viewProjection
                 * @see agi_modelViewProjection
                 * @see agi_infiniteProjection
                 *
                 * @example
                 * // GLSL declaration
                 * uniform mat4 agi_projection;
                 *
                 * // Example
                 * gl_Position = agi_projection * eyePosition;
                 */
                agi_projection : {
                    getSize : function() {
                        return 1;
                    },

                    getDatatype : function() {
                        return UniformDatatype.FLOAT_MATRIX4;
                    },

                    create : function(uniform) {
                        return {
                            _set : function(uniformState) {
                                uniform.value = uniformState.getProjection();
                            }
                        };
                    }
                },

                /**
                 * An automatic GLSL uniform representing a 4x4 projection transformation matrix with the far plane at infinity,
                 * that transforms eye coordinates to clip coordinates.  Clip coordinates is the
                 * coordinate system for a vertex shader's <code>gl_Position</code> output.  An infinite far plane is used
                 * in algorithms like shadow volumes and GPU ray casting with proxy geometry to ensure that triangles
                 * are not clipped by the far plane.
                 * <br /><br />
                 * Like all automatic uniforms, <code>agi_infiniteProjection</code> does not need to be explicitly declared.
                 * However, it can be explicitly declared when a shader is also used by other applications such
                 * as a third-party authoring tool.
                 *
                 * @name agi_infiniteProjection
                 * @glslUniform
                 *
                 * @see UniformState#getInfiniteProjection
                 * @see agi_projection
                 * @see agi_modelViewInfiniteProjection
                 *
                 * @example
                 * // GLSL declaration
                 * uniform mat4 agi_infiniteProjection;
                 *
                 * // Example
                 * gl_Position = agi_infiniteProjection * eyePosition;
                 */
                agi_infiniteProjection : {
                    getSize : function() {
                        return 1;
                    },

                    getDatatype : function() {
                        return UniformDatatype.FLOAT_MATRIX4;
                    },

                    create : function(uniform) {
                        return {
                            _set : function(uniformState) {
                                uniform.value = uniformState.getInfiniteProjection();
                            }
                        };
                    }
                },

                /**
                 * An automatic GLSL uniform representing a 4x4 model-view transformation matrix that
                 * transforms model coordinates to eye coordinates.
                 * <br /><br />
                 * Positions should be transformed to eye coordinates using <code>agi_modelView</code> and
                 * normals should be transformed using {@link agi_normal}.
                 * <br /><br />
                 * Like all automatic uniforms, <code>agi_modelView</code> does not need to be explicitly declared.
                 * However, it can be explicitly declared when a shader is also used by other applications such
                 * as a third-party authoring tool.
                 *
                 * @name agi_modelView
                 * @glslUniform
                 *
                 * @see UniformState#getModelView
                 * @see agi_model
                 * @see agi_view
                 * @see agi_modelViewProjection
                 * @see agi_normal
                 *
                 * @example
                 * // GLSL declaration
                 * uniform mat4 agi_modelView;
                 *
                 * // Example
                 * vec4 eyePosition = agi_modelView * modelPosition;
                 *
                 * // The above is equivalent to, but more efficient than:
                 * vec4 eyePosition = agi_view * agi_model * modelPosition;
                 */
                agi_modelView : {
                    getSize : function() {
                        return 1;
                    },

                    getDatatype : function() {
                        return UniformDatatype.FLOAT_MATRIX4;
                    },

                    create : function(uniform) {
                        return {
                            _set : function(uniformState) {
                                uniform.value = uniformState.getModelView();
                            }
                        };
                    }
                },

                /**
                 * An automatic GLSL uniform representing a 4x4 transformation matrix that
                 * transforms from eye coordinates to model coordinates.
                 * <br /><br />
                 * Like all automatic uniforms, <code>agi_inverseModelView</code> does not need to be explicitly declared.
                 * However, it can be explicitly declared when a shader is also used by other applications such
                 * as a third-party authoring tool.
                 *
                 * @name agi_inverseModelView
                 * @glslUniform
                 *
                 * @see UniformState#getInverseModelView
                 * @see agi_modelView
                 *
                 * @example
                 * // GLSL declaration
                 * uniform mat4 agi_inverseModelView;
                 *
                 * // Example
                 * vec4 modelPosition = agi_inverseModelView * eyePosition;
                 */
                agi_inverseModelView : {
                    getSize : function() {
                        return 1;
                    },

                    getDatatype : function() {
                        return UniformDatatype.FLOAT_MATRIX4;
                    },

                    create : function(uniform) {
                        return {
                            _set : function(uniformState) {
                                uniform.value = uniformState.getInverseModelView();
                            }
                        };
                    }
                },

                /**
                 * An automatic GLSL uniform representing a 4x4 view-projection transformation matrix that
                 * transforms world coordinates to clip coordinates.  Clip coordinates is the
                 * coordinate system for a vertex shader's <code>gl_Position</code> output.
                 * <br /><br />
                 * Like all automatic uniforms, <code>agi_viewProjection</code> does not need to be explicitly declared.
                 * However, it can be explicitly declared when a shader is also used by other applications such
                 * as a third-party authoring tool.
                 *
                 * @name agi_viewProjection
                 * @glslUniform
                 *
                 * @see UniformState#getViewProjection
                 * @see agi_view
                 * @see agi_projection
                 * @see agi_modelViewProjection
                 *
                 * @example
                 * // GLSL declaration
                 * uniform mat4 agi_viewProjection;
                 *
                 * // Example
                 * vec4 gl_Position = agi_viewProjection * agi_model * modelPosition;
                 *
                 * // The above is equivalent to, but more efficient than:
                 * gl_Position = agi_projection * agi_view * agi_model * modelPosition;
                 */
                agi_viewProjection : {
                    getSize : function() {
                        return 1;
                    },

                    getDatatype : function() {
                        return UniformDatatype.FLOAT_MATRIX4;
                    },

                    create : function(uniform) {
                        return {
                            _set : function(uniformState) {
                                uniform.value = uniformState.getViewProjection();
                            }
                        };
                    }
                },

                /**
                 * An automatic GLSL uniform representing a 4x4 model-view-projection transformation matrix that
                 * transforms model coordinates to clip coordinates.  Clip coordinates is the
                 * coordinate system for a vertex shader's <code>gl_Position</code> output.
                 * <br /><br />
                 * Like all automatic uniforms, <code>agi_modelViewProjection</code> does not need to be explicitly declared.
                 * However, it can be explicitly declared when a shader is also used by other applications such
                 * as a third-party authoring tool.
                 *
                 * @name agi_modelViewProjection
                 * @glslUniform
                 *
                 * @see UniformState#getModelViewProjection
                 * @see agi_model
                 * @see agi_view
                 * @see agi_projection
                 * @see agi_modelView
                 * @see agi_viewProjection
                 * @see agi_modelViewInfiniteProjection
                 *
                 * @example
                 * // GLSL declaration
                 * uniform mat4 agi_modelViewProjection;
                 *
                 * // Example
                 * vec4 gl_Position = agi_modelViewProjection * modelPosition;
                 *
                 * // The above is equivalent to, but more efficient than:
                 * gl_Position = agi_projection * agi_view * agi_model * modelPosition;
                 */
                agi_modelViewProjection : {
                    getSize : function() {
                        return 1;
                    },

                    getDatatype : function() {
                        return UniformDatatype.FLOAT_MATRIX4;
                    },

                    create : function(uniform) {
                        return {
                            _set : function(uniformState) {
                                uniform.value = uniformState.getModelViewProjection();
                            }
                        };
                    }
                },

                /**
                 * An automatic GLSL uniform representing a 4x4 model-view-projection transformation matrix that
                 * transforms model coordinates to clip coordinates.  Clip coordinates is the
                 * coordinate system for a vertex shader's <code>gl_Position</code> output.  The projection matrix places
                 * the far plane at infinity.  This is useful in algorithms like shadow volumes and GPU ray casting with
                 * proxy geometry to ensure that triangles are not clipped by the far plane.
                 * <br /><br />
                 * Like all automatic uniforms, <code>agi_modelViewInfiniteProjection</code> does not need to be explicitly declared.
                 * However, it can be explicitly declared when a shader is also used by other applications such
                 * as a third-party authoring tool.
                 *
                 * @name agi_modelViewInfiniteProjection
                 * @glslUniform
                 *
                 * @see UniformState#getModelViewInfiniteProjection
                 * @see agi_model
                 * @see agi_view
                 * @see agi_infiniteProjection
                 * @see agi_modelViewProjection
                 *
                 * @example
                 * // GLSL declaration
                 * uniform mat4 agi_modelViewInfiniteProjection;
                 *
                 * // Example
                 * vec4 gl_Position = agi_modelViewInfiniteProjection * modelPosition;
                 *
                 * // The above is equivalent to, but more efficient than:
                 * gl_Position = agi_infiniteProjection * agi_view * agi_model * modelPosition;
                 */
                agi_modelViewInfiniteProjection : {
                    getSize : function() {
                        return 1;
                    },

                    getDatatype : function() {
                        return UniformDatatype.FLOAT_MATRIX4;
                    },

                    create : function(uniform) {
                        return {
                            _set : function(uniformState) {
                                uniform.value = uniformState.getModelViewInfiniteProjection();
                            }
                        };
                    }
                },

                /**
                 * An automatic GLSL uniform representing a 3x3 normal transformation matrix that
                 * transforms normal vectors in model coordinates to eye coordinates.
                 * <br /><br />
                 * Positions should be transformed to eye coordinates using {@link agi_modelView} and
                 * normals should be transformed using <code>agi_normal</code>.
                 * <br /><br />
                 * Like all automatic uniforms, <code>agi_normal</code> does not need to be explicitly declared.
                 * However, it can be explicitly declared when a shader is also used by other applications such
                 * as a third-party authoring tool.
                 *
                 * @name agi_normal
                 * @glslUniform
                 *
                 * @see UniformState#getNormal
                 * @see agi_inverseNormal
                 * @see agi_modelView
                 *
                 * @example
                 * // GLSL declaration
                 * uniform mat3 agi_normal;
                 *
                 * // Example
                 * vec3 eyeNormal = agi_normal * normal;
                 */
                agi_normal : {
                    getSize : function() {
                        return 1;
                    },

                    getDatatype : function() {
                        return UniformDatatype.FLOAT_MATRIX3;
                    },

                    create : function(uniform) {
                        return {
                            _set : function(uniformState) {
                                uniform.value = uniformState.getNormal();
                            }
                        };
                    }
                },

                /**
                 * An automatic GLSL uniform representing a 3x3 normal transformation matrix that
                 * transforms normal vectors in eye coordinates to model coordinates.  This is
                 * in the opposite transform provided by {@link agi_normal}.
                 * <br /><br />
                 * Like all automatic uniforms, <code>agi_inverseNormal</code> does not need to be explicitly declared.
                 * However, it can be explicitly declared when a shader is also used by other applications such
                 * as a third-party authoring tool.
                 *
                 * @name agi_inverseNormal
                 * @glslUniform
                 *
                 * @see UniformState#getInverseNormal
                 * @see agi_normal
                 * @see agi_modelView
                 * @see agi_inverseView
                 *
                 * @example
                 * // GLSL declaration
                 * uniform mat3 agi_inverseNormal;
                 *
                 * // Example
                 * vec3 normalMC = agi_inverseNormal * normalEC;
                 */
                agi_inverseNormal : {
                    getSize : function() {
                        return 1;
                    },

                    getDatatype : function() {
                        return UniformDatatype.FLOAT_MATRIX3;
                    },

                    create : function(uniform) {
                        return {
                            _set : function(uniformState) {
                                uniform.value = uniformState.getInverseNormal();
                            }
                        };
                    }
                },

                /**
                 * An automatic GLSL uniform representing the direction of the sun in eye coordinates.
                 * This is commonly used for directional lighting computations.
                 * <br /><br />
                 * Like all automatic uniforms, <code>agi_sunDirectionEC</code> does not need to be explicitly declared.
                 * However, it can be explicitly declared when a shader is also used by other applications such
                 * as a third-party authoring tool.
                 *
                 * @name agi_sunDirectionEC
                 * @glslUniform
                 *
                 * @see UniformState#getSunDirectionEC
                 * @see agi_sunDirectionWC
                 *
                 * @example
                 * // GLSL declaration
                 * uniform vec3 agi_sunDirectionEC;
                 *
                 * // Example
                 * float diffuse = max(dot(agi_sunDirectionEC, normalEC), 0.0);
                 */
                agi_sunDirectionEC : {
                    getSize : function() {
                        return 1;
                    },

                    getDatatype : function() {
                        return UniformDatatype.FLOAT_VECTOR3;
                    },

                    create : function(uniform) {
                        return {
                            _set : function(uniformState) {
                                uniform.value = uniformState.getSunDirectionEC();
                            }
                        };
                    }
                },

                /**
                 * An automatic GLSL uniform representing a normalized vector from the origin
                 * in world coordinates to the sun.  This is commonly used for lighting computations.
                 * <br /><br />
                 * Like all automatic uniforms, <code>agi_sunDirectionWC</code> does not need to be explicitly declared.
                 * However, it can be explicitly declared when a shader is also used by other applications such
                 * as a third-party authoring tool.
                 *
                 * @name agi_sunDirectionWC
                 * @glslUniform
                 *
                 * @see UniformState#getSunDirectionWC
                 * @see agi_sunDirectionEC
                 *
                 * @example
                 * // GLSL declaration
                 * uniform vec3 agi_sunDirectionWC;
                 */
                agi_sunDirectionWC : {
                    getSize : function() {
                        return 1;
                    },

                    getDatatype : function() {
                        return UniformDatatype.FLOAT_VECTOR3;
                    },

                    create : function(uniform) {
                        return {
                            _set : function(uniformState) {
                                uniform.value = uniformState.getSunDirectionWC();
                            }
                        };
                    }
                },

                /**
                 * An automatic GLSL uniform representing the position of the viewer (camera) in world coordinates.
                 * <br /><br />
                 * Like all automatic uniforms, <code>agi_sunDirectionWC</code> does not need to be explicitly declared.
                 * However, it can be explicitly declared when a shader is also used by other applications such
                 * as a third-party authoring tool.
                 *
                 * @name agi_viewerPositionWC
                 * @glslUniform
                 *
                 * @example
                 * // GLSL declaration
                 * uniform vec3 agi_viewerPositionWC;
                 */
                agi_viewerPositionWC : {
                    getSize : function() {
                        return 1;
                    },

                    getDatatype : function() {
                        return UniformDatatype.FLOAT_VECTOR3;
                    },

                    create : function(uniform) {
                        return {
                            _set : function(uniformState) {
                                uniform.value = uniformState.getInverseView().getTranslation();
                            }
                        };
                    }
                }

            };

            getAllAutomaticUniforms = function() {
                return uniforms;
            };

            return uniforms;
        };

        function extractShaderVersion(source) {
            // This will fail if the first #version is actually in a comment.
            var index = source.indexOf("#version");
            if (index !== -1) {
                var newLineIndex = source.indexOf("\n", index);

                // We could throw an exception if there is not a new line after
                // #version, but the GLSL compiler will catch it.
                if (index !== -1) {
                    // Extract #version directive, including the new line.
                    var version = source.substring(index, newLineIndex + 1);

                    // Comment out original #version directive so the line numbers
                    // are not off by one.  There can be only one #version directive
                    // and it must appear at the top of the source, only preceded by
                    // whitespace and comments.
                    var modified = source.substring(0, index) + "//" + source.substring(index);

                    return {
                        versionDirective : version,
                        modifiedSource : modified
                    };
                }
            }

            return {
                versionDirective : "", // defaults to #version 100
                modifiedSource : source // no modifications required
            };
        }

        function getAutomaticUniformDeclaration(uniforms, uniform) {
            var factory = uniforms[uniform];
            var declaration = "uniform " + factory.getDatatype().getGLSL() + " " + uniform;

            var size = factory.getSize();
            if (size === 1) {
                declaration += ";";
            } else {
                declaration += "[" + size.toString() + "];";
            }

            return declaration;
        }

        function commentOutAutomaticUniforms(source) {
            // Comment out automatic uniforms that the user may have declared, perhaps
            // because the shader was authored in a third-party tool like RenderMonkey.
            // At runtime, all automatic uniforms are declared by the engine itself.

            // This function has problems if the automatic uniform was declared with the
            // wrong datatype or with extra whitespace or comments in the declaration.

            var modifiedSource = source;
            var uniforms = getAllAutomaticUniforms();
            for ( var uniform in uniforms) {
                if (uniforms.hasOwnProperty(uniform)) {
                    var declaration = getAutomaticUniformDeclaration(uniforms, uniform);
                    var index = modifiedSource.indexOf(declaration);
                    if (index !== -1) {
                        modifiedSource =
                            modifiedSource.substring(0, index) +
                            "/*" +
                            modifiedSource.substring(index, declaration.length) +
                            "*/" +
                            modifiedSource.substring(index + declaration.length);
                    }
                }
            }

            return modifiedSource;
        }

        function getFragmentShaderPrecision() {
            // TODO: Performance?
            return "#ifdef GL_FRAGMENT_PRECISION_HIGH \n" +
                   "  precision highp float; \n" +
                   "#else \n" +
                   "  precision mediump float; \n" +
                   "#endif \n\n";
        }

        function getBuiltinConstants() {
            var constants = {
                /**
                 * A built-in GLSL floating-point constant for <code>Math.PI</code>.
                 *
                 * @name agi_pi
                 * @glslConstant
                 *
                 * @see CesiumMath.PI
                 *
                 * @example
                 * // GLSL declaration
                 * const float agi_pi = ...;
                 *
                 * // Example
                 * float twoPi = 2.0 * agi_pi;
                 */
                agi_pi : Math.PI.toString(),

                /**
                 * A built-in GLSL floating-point constant for <code>1/pi</code>.
                 *
                 * @name agi_oneOverPi
                 * @glslConstant
                 *
                 * @see CesiumMath.ONE_OVER_PI
                 *
                 * @example
                 * // GLSL declaration
                 * const float agi_oneOverPi = ...;
                 *
                 * // Example
                 * float pi = 1.0 / agi_oneOverPi;
                 */
                agi_oneOverPi : CesiumMath.ONE_OVER_PI.toString(),

                /**
                 * A built-in GLSL floating-point constant for <code>pi/2</code>.
                 *
                 * @name agi_piOverTwo
                 * @glslConstant
                 *
                 * @see CesiumMath.PI_OVER_TWO
                 *
                 * @example
                 * // GLSL declaration
                 * const float agi_piOverTwo = ...;
                 *
                 * // Example
                 * float pi = 2.0 * agi_piOverTwo;
                 */
                agi_piOverTwo : CesiumMath.PI_OVER_TWO.toString(),

                /**
                 * A built-in GLSL floating-point constant for <code>pi/3</code>.
                 *
                 * @name agi_piOverThree
                 * @glslConstant
                 *
                 * @see CesiumMath.PI_OVER_THREE
                 *
                 * @example
                 * // GLSL declaration
                 * const float agi_piOverThree = ...;
                 *
                 * // Example
                 * float pi = 3.0 * agi_piOverThree;
                 */
                agi_piOverThree : CesiumMath.PI_OVER_THREE.toString(),

                /**
                 * A built-in GLSL floating-point constant for <code>pi/4</code>.
                 *
                 * @name agi_piOverFour
                 * @glslConstant
                 *
                 * @see CesiumMath.PI_OVER_FOUR
                 *
                 * @example
                 * // GLSL declaration
                 * const float agi_piOverFour = ...;
                 *
                 * // Example
                 * float pi = 4.0 * agi_piOverFour;
                 */
                agi_piOverFour : CesiumMath.PI_OVER_FOUR.toString(),

                /**
                 * A built-in GLSL floating-point constant for <code>pi/6</code>.
                 *
                 * @name agi_piOverSix
                 * @glslConstant
                 *
                 * @see CesiumMath.PI_OVER_SIX
                 *
                 * @example
                 * // GLSL declaration
                 * const float agi_piOverSix = ...;
                 *
                 * // Example
                 * float pi = 6.0 * agi_piOverSix;
                 */
                agi_piOverSix : CesiumMath.PI_OVER_SIX.toString(),

                /**
                 * A built-in GLSL floating-point constant for <code>3pi/2</code>.
                 *
                 * @name agi_threePiOver2
                 * @glslConstant
                 *
                 * @see CesiumMath.THREE_PI_OVER_TWO
                 *
                 * @example
                 * // GLSL declaration
                 * const float agi_threePiOver2 = ...;
                 *
                 * // Example
                 * float pi = (2.0 / 3.0) * agi_threePiOver2;
                 */
                agi_threePiOver2 : CesiumMath.THREE_PI_OVER_TWO.toString(),

                /**
                 * A built-in GLSL floating-point constant for <code>2pi</code>.
                 *
                 * @name agi_twoPi
                 * @glslConstant
                 *
                 * @see CesiumMath.TWO_PI
                 *
                 * @example
                 * // GLSL declaration
                 * const float agi_twoPi = ...;
                 *
                 * // Example
                 * float pi = agi_twoPi / 2.0;
                 */
                agi_twoPi : CesiumMath.TWO_PI.toString(),

                /**
                 * A built-in GLSL floating-point constant for <code>1/2pi</code>.
                 *
                 * @name agi_oneOverTwoPi
                 * @glslConstant
                 *
                 * @see CesiumMath.ONE_OVER_TWO_PI
                 *
                 * @example
                 * // GLSL declaration
                 * const float agi_oneOverTwoPi = ...;
                 *
                 * // Example
                 * float pi = 2.0 * agi_oneOverTwoPi;
                 */
                agi_oneOverTwoPi : CesiumMath.ONE_OVER_TWO_PI.toString(),

                /**
                 * A built-in GLSL floating-point constant for converting degrees to radians.
                 *
                 * @name agi_radiansPerDegree
                 * @glslConstant
                 *
                 * @see CesiumMath.RADIANS_PER_DEGREE
                 *
                 * @example
                 * // GLSL declaration
                 * const float agi_radiansPerDegree = ...;
                 *
                 * // Example
                 * float rad = agi_radiansPerDegree * deg;
                 */
                agi_radiansPerDegree : CesiumMath.RADIANS_PER_DEGREE.toString(),

                /**
                 * A built-in GLSL floating-point constant for converting radians to degrees.
                 *
                 * @name agi_degreesPerRadian
                 * @glslConstant
                 *
                 * @see CesiumMath.DEGREES_PER_RADIAN
                 *
                 * @example
                 * // GLSL declaration
                 * const float agi_degreesPerRadian = ...;
                 *
                 * // Example
                 * float deg = agi_degreesPerRadian * rad;
                 */
                agi_degreesPerRadian : CesiumMath.DEGREES_PER_RADIAN.toString()
            };

            var glslConstants = "";
            for ( var name in constants) {
                if (constants.hasOwnProperty(name)) {
                    glslConstants += "const float " + name + " = " + constants[name] + "; \n";
                }
            }
            glslConstants += " \n";

            return glslConstants;
        }

        function getAutomaticUniforms() {
            var automatics = "";

            var uniforms = getAllAutomaticUniforms();
            for ( var uniform in uniforms) {
                if (uniforms.hasOwnProperty(uniform)) {
                    automatics += getAutomaticUniformDeclaration(uniforms, uniform) + " \n";
                }
            }
            automatics += "\n";

            return automatics;
        }

        var getShaderDefinitions = function() {
            // I think this should be #line 1 given what the GL ES spec says:
            //
            //   After processing this directive (including its new-line), the implementation will
            //   behave as if the following line has line number line...
            //
            // But this works, at least on NVIDIA hardware.

            // Functions after constants and uniforms because functions depend on them.
            var definitions = getBuiltinConstants() +
                              getAutomaticUniforms() +
                              builtInGlslFunctions + "\n\n" +
                              "#line 0 \n";

            getShaderDefinitions = function() {
                return definitions;
            };

            return definitions;
        };

        function createAndLinkProgram() {
            var vsSourceVersioned = extractShaderVersion(vertexShaderSource);
            var fsSourceVersioned = extractShaderVersion(fragmentShaderSource);

            var vsSource = vsSourceVersioned.versionDirective +
                           getShaderDefinitions() +
                           commentOutAutomaticUniforms(vsSourceVersioned.modifiedSource);
            var fsSource = fsSourceVersioned.versionDirective +
                           getFragmentShaderPrecision() +
                           getShaderDefinitions() +
                           commentOutAutomaticUniforms(fsSourceVersioned.modifiedSource);

            var vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertexShader, vsSource);
            gl.compileShader(vertexShader);
            var vsLog = gl.getShaderInfoLog(vertexShader);

            if (logShaderCompilation && vsLog && vsLog.length) {
                console.log("[GL] Vertex shader compile log: " + vsLog);
            }

            if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                gl.deleteShader(vertexShader);
                console.error("[GL] Vertex shader compile log: " + vsLog);
                throw new RuntimeError("Vertex shader failed to compile.  Compile log: " + vsLog);
            }

            var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, fsSource);
            gl.compileShader(fragmentShader);
            var fsLog = gl.getShaderInfoLog(fragmentShader);

            if (logShaderCompilation && fsLog && fsLog.length) {
                console.log("[GL] Fragment shader compile log: " + fsLog);
            }

            if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                gl.deleteShader(vertexShader);
                gl.deleteShader(fragmentShader);
                console.error("[GL] Fragment shader compile log: " + fsLog);
                throw new RuntimeError("Fragment shader failed to compile.  Compile log: " + fsLog);
            }

            var program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);

            gl.deleteShader(vertexShader);
            gl.deleteShader(fragmentShader);

            if (attributeLocations) {
                for ( var attribute in attributeLocations) {
                    if (attributeLocations.hasOwnProperty(attribute)) {
                        gl.bindAttribLocation(program, attributeLocations[attribute], attribute);
                    }
                }
            }

            gl.linkProgram(program);
            var linkLog = gl.getProgramInfoLog(program);

            if (logShaderCompilation && linkLog && linkLog.length) {
                console.log("[GL] Shader program link log: " + linkLog);
            }

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                gl.deleteProgram(program);
                console.error("[GL] Shader program link log: " + linkLog);
                throw new RuntimeError("Program failed to link.  Link log: " + linkLog);
            }

            return program;
        }

        function findVertexAttributes(program, numberOfAttributes) {
            var attributes = {};
            for ( var i = 0; i < numberOfAttributes; ++i) {
                var attr = gl.getActiveAttrib(program, i);
                var location = gl.getAttribLocation(program, attr.name);

                attributes[attr.name] = {
                    name : attr.name,
                    type : attr.type,
                    index : location
                };
            }

            return attributes;
        }

        function findUniforms(program) {
            var allUniforms = {};
            var uniforms = [];
            var samplerUniforms = [];

            var numberOfUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);

            for ( var i = 0; i < numberOfUniforms; ++i) {
                var activeUniform = gl.getActiveUniform(program, i);
                var suffix = "[0]";
                var uniformName =
                    activeUniform.name.indexOf(suffix, activeUniform.name.length - suffix.length) !== -1 ? activeUniform.name.slice(0, activeUniform.name.length - 3) : activeUniform.name;

                // Ignore GLSL built-in uniforms returned in Firefox.
                if (uniformName.indexOf("gl_") !== 0) {
                    if (activeUniform.size === 1) {
                        // Single uniform
                        var location = gl.getUniformLocation(program, uniformName);
                        var uniformValue = gl.getUniform(program, location);
                        var uniform = new Uniform(gl, activeUniform, uniformName, location, uniformValue);

                        allUniforms[uniformName] = uniform;

                        if (uniform._setSampler) {
                            samplerUniforms.push(uniform);
                        } else {
                            uniforms.push(uniform);
                        }
                    } else {
                        // Uniform array
                        var locations = [];
                        var value = [];
                        for ( var j = 0; j < activeUniform.size; ++j) {
                            var loc = gl.getUniformLocation(program, uniformName + "[" + j + "]");
                            locations.push(loc);
                            value.push(gl.getUniform(program, loc));
                        }
                        var uniformArray = new UniformArray(gl, activeUniform, uniformName, locations, value);

                        allUniforms[uniformName] = uniformArray;

                        if (uniformArray._setSampler) {
                            samplerUniforms.push(uniformArray);
                        } else {
                            uniforms.push(uniformArray);
                        }
                    }
                }
            }

            return {
                allUniforms : allUniforms,
                uniforms : uniforms,
                samplerUniforms : samplerUniforms
            };
        }

        function findAutomaticUniforms(uniforms) {
            var automaticUniforms = [];
            var manualUniforms = {};

            var allAutomaticUniforms = getAllAutomaticUniforms();

            for ( var uniform in uniforms) {
                if (uniforms.hasOwnProperty(uniform)) {
                    var factory = allAutomaticUniforms[uniform];
                    if (factory) {
                        automaticUniforms.push(factory.create(uniforms[uniform]));
                    } else {
                        manualUniforms[uniform] = uniforms[uniform];
                    }
                }
            }

            return {
                automaticUniforms : automaticUniforms,
                manualUniforms : manualUniforms
            };
        }

        var _program = createAndLinkProgram();
        var _numberOfVertexAttributes = gl.getProgramParameter(_program, gl.ACTIVE_ATTRIBUTES);
        var _vertexAttributes = findVertexAttributes(_program, _numberOfVertexAttributes);
        var uniforms = findUniforms(_program);
        var _allUniforms = uniforms.allUniforms;
        var _uniforms = uniforms.uniforms;
        var _samplerUniforms = uniforms.samplerUniforms;
        var automaticUniforms = findAutomaticUniforms(_allUniforms);
        var _automaticUniforms = automaticUniforms.automaticUniforms;
        var _manualUniforms = automaticUniforms.manualUniforms;

        this._getProgram = function() {
            return _program;
        };

        /**
        * DOC_TBA
        *
        * @return {Object} DOC_TBA
        * @exception {DeveloperError} This shader program was destroyed, i.e., destroy() was called.
        */
        this.getVertexAttributes = function() {
            return _vertexAttributes;
        };

        /**
        * DOC_TBA
        *
        * @return {Number} DOC_TBA
        * @exception {DeveloperError} This shader program was destroyed, i.e., destroy() was called.
        */
        this.getNumberOfVertexAttributes = function() {
            return _numberOfVertexAttributes;
        };

        /**
        * DOC_TBA
        *
        * @return {Object} DOC_TBA
        *
        * @exception {DeveloperError} This shader program was destroyed, i.e., destroy() was called.
        *
        * @see ShaderProgram#getManualUniforms
        */
        this.getAllUniforms = function() {
            return _allUniforms;
        };

        /**
         * DOC_TBA
         *
         * @exception {DeveloperError} This shader program was destroyed, i.e., destroy() was called.
         *
         * @see ShaderProgram#getAllUniforms
         */
        this.getManualUniforms = function() {
            return _manualUniforms;
        };

        this._bind = function() {
            gl.useProgram(_program);
        };

        this._setUniforms = function(uniformMap, uniformState) {
            // TODO: Performance

            var len;
            var i;

            if (uniformMap) {
                uniformState.setModel(uniformMap.u_model ? uniformMap.u_model() : Matrix4.getIdentity());

                for ( var uniform in _manualUniforms) {
                    if (_manualUniforms.hasOwnProperty(uniform)) {
                        _manualUniforms[uniform].value = uniformMap[uniform]();
                    }
                }
            }

            len = _automaticUniforms.length;
            for (i = 0; i < len; ++i) {
                _automaticUniforms[i]._set(uniformState);
            }

            ///////////////////////////////////////////////////////////////////

            len = _uniforms.length;
            for (i = 0; i < len; ++i) {
                _uniforms[i]._set();
            }

            var textureUnitIndex = 0;
            len = _samplerUniforms.length;
            for (i = 0; i < len; ++i) {
                textureUnitIndex = _samplerUniforms[i]._setSampler(textureUnitIndex);
            }
        };

        this._unBind = function() {
            gl.useProgram(null);

            var textureUnitIndex = 0;
            var len = _samplerUniforms.length;
            for ( var i = 0; i < len; ++i) {
                textureUnitIndex = _samplerUniforms[i]._clearSampler(textureUnitIndex);
            }
        };

        /**
         * Returns true if this object was destroyed; otherwise, false.
         * <br /><br />
         * If this object was destroyed, it should not be used; calling any function other than
         * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
         *
         * @return {Boolean} True if this object was destroyed; otherwise, false.
         *
         * @see ShaderProgram.destroy
         */
        this.isDestroyed = function() {
            return false;
        };

        /**
         * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
         * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
         * <br /><br />
         * Once an object is destroyed, it should not be used; calling any function other than
         * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
         * assign the return value (<code>null</code>) to the object as done in the example.
         *
         * @return {null}
         *
         * @exception {DeveloperError} This shader program was destroyed, i.e., destroy() was called.
         *
         * @see ShaderProgram.isDestroyed
         * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glDeleteShader.xml">glDeleteShader</a>
         * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glDeleteProgram.xml">glDeleteProgram</a>
         *
         * @example
         * shaderProgram = shaderProgram && shaderProgram.destroy();
         */
        this.destroy = function() {
            gl.deleteProgram(_program);
            return destroyObject(this);
        };

        /**
         * DOC_TBA
         */
        this.release = function() {
            if (this._cachedShader) {
                return this._cachedShader.cache.releaseShaderProgram(this);
            }

            return this.destroy();
        };

        return null;
    }

    return ShaderProgram;
});

/*global define*/
define('Renderer/UniformState',[
        '../Core/DeveloperError',
        '../Core/Ellipsoid',
        '../Core/Matrix4',
        '../Core/Cartesian3',
        '../Core/Cartesian4'
    ], function(
        DeveloperError,
        Ellipsoid,
        Matrix4,
        Cartesian3,
        Cartesian4) {
    

    /**
     * DOC_TBA
     *
     * @name UniformState
     *
     * @internalConstructor
     */
    function UniformState(context) {
        this._context = context;
        this._viewport = {
            x : 0,
            y : 0,
            width : 0,
            height : 0
        };
        this._viewportOrthographicMatrix = Matrix4.getIdentity();
        this._viewportTransformation = Matrix4.getIdentity();

        this._model = Matrix4.getIdentity();
        this._view = Matrix4.getIdentity();
        this._projection = Matrix4.getIdentity();

        this._infiniteProjection = Matrix4.getIdentity();

        // Arbitrary.  The user will explicitly set this later.
        this._sunPosition = new Cartesian3(2.0 * Ellipsoid.getWgs84().getRadii().x, 0.0, 0.0);

        // Derived members
        this._inverseViewDirty = true;
        this._modelViewDirty = true;
        this._inverseModelViewDirty = true;
        this._viewProjectionDirty = true;
        this._modelViewProjectionDirty = true;
        this._modelViewInfiniteProjectionDirty = true;
        this._normalDirty = true;
        this._inverseNormalDirty = true;
        this._sunDirectionECDirty = true;
        this._sunDirectionWCDirty = true;
    }

    /**
     * DOC_TBA
     * @memberof UniformState
     */
    UniformState.prototype.getContext = function() {
        return this._context;
    };

    UniformState.prototype._cleanViewport = function() {
        var current = this._viewport;
        var v = this._context.getViewport();

        if ((current.x !== v.x) ||
            (current.y !== v.y) ||
            (current.width !== v.width) ||
            (current.height !== v.height)) {
            current.x = v.x;
            current.y = v.y;
            current.width = v.width;
            current.height = v.height;

            this._viewportOrthographicMatrix = Matrix4.createOrthographicOffCenter(v.x, v.x + v.width, v.y, v.y + v.height, 0.0, 1.0);
            this._viewportTransformation = Matrix4.createViewportTransformation(v);
        }
    };

    /**
     * DOC_TBA
     * @memberof UniformState
     *
     *
     * @see agi_viewportOrthographic
     */
    UniformState.prototype.getViewportOrthographic = function() {
        this._cleanViewport();
        return this._viewportOrthographicMatrix;
    };

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @see agi_viewportTransformation
     */
    UniformState.prototype.getViewportTransformation = function() {
        this._cleanViewport();
        return this._viewportTransformation;
    };

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @param {Matrix4} [matrix] DOC_TBA.
     *
     * @see UniformState#getModel
     * @see agi_model
     */
    UniformState.prototype.setModel = function(matrix) {
        matrix = matrix || Matrix4.getIdentity();

        this._model = matrix;
        this._modelViewDirty = true;
        this._inverseModelViewDirty = true;
        this._modelViewProjectionDirty = true;
        this._modelViewInfiniteProjectionDirty = true;
        this._normalDirty = true;
        this._inverseNormalDirty = true;
        this._sunDirectionWCDirty = true;
    };

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @return {Matrix4} DOC_TBA.
     *
     * @see UniformState#setModel
     * @see agi_model
     */
    UniformState.prototype.getModel = function() {
        return this._model;
    };

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @param {Matrix4} [matrix] DOC_TBA.
     *
     * @see UniformState#getView
     * @see agi_view
     */
    UniformState.prototype.setView = function(matrix) {
        matrix = matrix || Matrix4.getIdentity();

        this._view = matrix;
        this._inverseViewDirty = true;
        this._modelViewDirty = true;
        this._inverseModelViewDirty = true;
        this._viewProjectionDirty = true;
        this._modelViewProjectionDirty = true;
        this._modelViewInfiniteProjectionDirty = true;
        this._normalDirty = true;
        this._inverseNormalDirty = true;
        this._sunDirectionECDirty = true;
    };

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @return {Matrix4} DOC_TBA.
     *
     * @see UniformState#setView
     * @see agi_view
     */
    UniformState.prototype.getView = function() {
        return this._view;
    };

    UniformState.prototype._cleanInverseView = function() {
        if (this._inverseViewDirty) {
            this._inverseViewDirty = false;

            var n = this.getView().inverse();
            this._inverseView = n;
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @return {Matrix4} DOC_TBA.
     *
     * @see agi_inverseView
     */
    UniformState.prototype.getInverseView = function() {
        this._cleanInverseView();
        return this._inverseView;
    };

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @param {Matrix4} [matrix] DOC_TBA.
     *
     * @see UniformState#getProjection
     * @see agi_projection
     */
    UniformState.prototype.setProjection = function(matrix) {
        matrix = matrix || Matrix4.getIdentity();

        this._projection = matrix;
        this._viewProjectionDirty = true;
        this._modelViewProjectionDirty = true;
    };

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @return {Matrix4} DOC_TBA.
     *
     * @see UniformState#setProjection
     * @see agi_projection
     */
    UniformState.prototype.getProjection = function() {
        return this._projection;
    };

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @param {Matrix4} [matrix] DOC_TBA.
     *
     * @see UniformState#getInfiniteProjection
     * @see agi_infiniteProjection
     */
    UniformState.prototype.setInfiniteProjection = function(matrix) {
        matrix = matrix || Matrix4.getIdentity();

        this._infiniteProjection = matrix;
        this._modelViewInfiniteProjectionDirty = true;
    };

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @return {Matrix4} DOC_TBA.
     *
     * @see UniformState#setInfiniteProjection
     * @see agi_infiniteProjection
     */
    UniformState.prototype.getInfiniteProjection = function() {
        return this._infiniteProjection;
    };

    // Derived
    UniformState.prototype._cleanModelView = function() {
        if (this._modelViewDirty) {
            this._modelViewDirty = false;

            var mv = this._view.multiplyWithMatrix(this._model);
            this._modelView = mv;
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @return {Matrix4} DOC_TBA.
     *
     * @see agi_modelView
     */
    UniformState.prototype.getModelView = function() {
        this._cleanModelView();
        return this._modelView;
    };

    UniformState.prototype._cleanInverseModelView = function() {
        if (this._inverseModelViewDirty) {
            this._inverseModelViewDirty = false;

            var m = this.getModelView().inverse();
            this._inverseModelView = m;
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @return {Matrix4} DOC_TBA.
     *
     * @see agi_inverseModelView
     */
    UniformState.prototype.getInverseModelView = function() {
        this._cleanInverseModelView();
        return this._inverseModelView;
    };

    UniformState.prototype._cleanViewProjection = function() {
        if (this._viewProjectionDirty) {
            this._viewProjectionDirty = false;

            var vp = this.getProjection().multiplyWithMatrix(this.getView());
            this._viewProjection = vp;
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @return {Matrix4} DOC_TBA.
     *
     * @see agi_viewProjection
     */
    UniformState.prototype.getViewProjection = function() {
        this._cleanViewProjection();
        return this._viewProjection;
    };

    UniformState.prototype._cleanModelViewProjection = function() {
        if (this._modelViewProjectionDirty) {
            this._modelViewProjectionDirty = false;

            var mvp = this._projection.multiplyWithMatrix(this.getModelView());
            this._modelViewProjection = mvp;
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @return {Matrix4} DOC_TBA.
     *
     * @see agi_modelViewProjection
     */
    UniformState.prototype.getModelViewProjection = function() {
        this._cleanModelViewProjection();
        return this._modelViewProjection;
    };

    UniformState.prototype._cleanModelViewInfiniteProjection = function() {
        if (this._modelViewInfiniteProjectionDirty) {
            this._modelViewInfiniteProjectionDirty = false;

            var mvp = this._infiniteProjection.multiplyWithMatrix(this.getModelView());
            this._modelViewInfiniteProjection = mvp;
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @return {Matrix4} DOC_TBA.
     *
     * @see agi_modelViewProjection
     */
    UniformState.prototype.getModelViewInfiniteProjection = function() {
        this._cleanModelViewInfiniteProjection();
        return this._modelViewInfiniteProjection;
    };

    UniformState.prototype._cleanNormal = function() {
        if (this._normalDirty) {
            this._normalDirty = false;

            // TODO:  Inverse, transpose of the whole 4x4?  Or we can just do the 3x3?
            var n = this.getModelView().inverse().transpose().getRotation();
            this._normal = n;
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @return {Matrix3} DOC_TBA.
     *
     * @see agi_normal
     */
    UniformState.prototype.getNormal = function() {
        this._cleanNormal();
        return this._normal;
    };

    UniformState.prototype._cleanInverseNormal = function() {
        if (this._inverseNormalDirty) {
            this._inverseNormalDirty = false;

            // TODO:  Inverse of the whole 4x4?  Or we can just do the 3x3?
            var n = this.getModelView().inverse().getRotation();
            this._inverseNormal = n;
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @return {Matrix3} DOC_TBA.
     *
     * @see agi_inverseNormal
     */
    UniformState.prototype.getInverseNormal = function() {
        this._cleanInverseNormal();
        return this._inverseNormal;
    };

    UniformState.prototype._cleanSunDirectionEC = function() {
        if (this._sunDirectionECDirty) {
            this._sunDirectionECDirty = false;

            var sunPosition = new Cartesian4(this._sunPosition.x, this._sunPosition.y, this._sunPosition.z, 0.0);
            var sunEC = this.getView().multiplyWithVector(sunPosition);
            var p = new Cartesian3(sunEC.x, sunEC.y, sunEC.z).normalize();

            this._sunDirectionEC = p;
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @param {Matrix4} sunPosition The position of the sun in the sun's reference frame.
     *
     * @exception {DeveloperError} sunPosition is required.
     *
     * @see UniformState#getSunPosition
     */
    UniformState.prototype.setSunPosition = function(sunPosition) {
        if (!sunPosition) {
            throw new DeveloperError("sunPosition is required.", "sunPosition");
        }

        this._sunPosition = sunPosition;
        this._sunDirectionECDirty = true;
        this._sunDirectionWCDirty = true;
    };

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @see UniformState#setSunPosition
     */
    UniformState.prototype.getSunPosition = function() {
        return this._sunPosition;
    };

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @return {Cartesian3} The sun's direction in eye coordinates.
     *
     * @see agi_sunDirectionEC
     * @see UniformState#getSunDirectionEC
     */
    UniformState.prototype.getSunDirectionEC = function() {
        this._cleanSunDirectionEC();
        return this._sunDirectionEC;
    };

    UniformState.prototype._cleanSunDirectionWC = function() {
        if (this._sunDirectionWCDirty) {
            this._sunDirectionWCDirty = false;
            this._sunDirectionWC = this._sunPosition.normalize();
        }
    };

    /**
    * DOC_TBA
    *
    * @memberof UniformState
    *
    * @return {Cartesian3} A normalized vector from the model's origin to the sun in model coordinates.
    *
    * @see agi_sunDirectionWC
    */
    UniformState.prototype.getSunDirectionWC = function() {
        this._cleanSunDirectionWC();
        return this._sunDirectionWC;
    };

    UniformState.prototype.getHighResolutionSnapScale = function() {
        return 1.0;
    };

    return UniformState;
});
/*global define*/
define('Renderer/VertexArray',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/ComponentDatatype'
    ], function(
        DeveloperError,
        destroyObject,
        ComponentDatatype) {
    

    /**
     * DOC_TBA
     *
     * @name VertexArray
     *
     * @internalConstructor
     *
     * @see {@link Context#createVertexArray}
     * @see {@link Context#createVertexArrayFromMesh}
     */
    function VertexArray(gl, attributes, indexBuffer) {
        this._gl = gl;
        this._attributes = [];
        this._indexBuffer = indexBuffer;

        if (attributes) {
            for ( var i = 0; i < attributes.length; ++i) {
                try {
                    this._addAttribute(attributes[i], i);
                } catch (e) {
                    throw new DeveloperError(e.message, "attributes");
                }
            }
        }

        // Verify all attribute names are unique
        var uniqueIndices = {};
        for ( var j = 0; j < this._attributes.length; ++j) {
            var index = this._attributes[j].index;
            if (uniqueIndices[index]) {
                throw new DeveloperError("Index " + index + " is used by more than one attribute.", "attributes");
            }

            uniqueIndices[index] = true;
        }
    }

    VertexArray.prototype._addAttribute = function(attribute, index) {
        if (!attribute.vertexBuffer && !attribute.value) {
            throw new DeveloperError("attribute must have a vertexBuffer or a value.");
        }

        if (attribute.vertexBuffer && attribute.value) {
            throw new DeveloperError("attribute cannot have both a vertexBuffer and a value.  It must have either a vertexBuffer property defining per-vertex data or a value property defining data for all vertices.");
        }

        var componentsPerAttribute = attribute.value ? attribute.value.length : attribute.componentsPerAttribute;

        if ((componentsPerAttribute !== 1) &&
            (componentsPerAttribute !== 2) &&
            (componentsPerAttribute !== 3) &&
            (componentsPerAttribute !== 4)) {
            if (attribute.value) {
                throw new DeveloperError("attribute.value.length must be in the range [1, 4].");
            }

            throw new DeveloperError("attribute.componentsPerAttribute must be in the range [1, 4].");
        }

        if (attribute.componentDatatype) {
            var datatype = attribute.componentDatatype.value;
            if ((datatype !== ComponentDatatype.BYTE.value) &&
                (datatype !== ComponentDatatype.UNSIGNED_BYTE.value) &&
                (datatype !== ComponentDatatype.SHORT.value) &&
                (datatype !== ComponentDatatype.UNSIGNED_SHORT.value) &&
                (datatype !== ComponentDatatype.FLOAT.value)) {
                throw new DeveloperError("attribute must have a valid componentDatatype or not specify it.");
            }
        }

        if (attribute.strideInBytes && (attribute.strideInBytes > 255)) {
            // WebGL limit.  Not in GL ES.
            throw new DeveloperError("attribute must have a strideInBytes less than or equal to 255 or not specify it.");
        }

        // Shallow copy the attribute; we do not want to copy the vertex buffer.
        var attr = {
            index : (typeof attribute.index === "undefined") ? index : attribute.index,
            enabled : (typeof attribute.enabled === "undefined") ? true : attribute.enabled,
            vertexBuffer : attribute.vertexBuffer,
            value : attribute.value ? attribute.value.slice() : undefined,
            componentsPerAttribute : componentsPerAttribute,
            componentDatatype : attribute.componentDatatype || ComponentDatatype.FLOAT,
            normalize : attribute.normalize || false,
            offsetInBytes : attribute.offsetInBytes || 0,
            strideInBytes : attribute.strideInBytes || 0
        };

        if (attr.vertexBuffer) {
            // Common case: vertex buffer for per-vertex data
            attr.vertexAttrib = function(gl) {
                gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer._getBuffer());
                gl.vertexAttribPointer(this.index, this.componentsPerAttribute, this.componentDatatype.value, this.normalize, this.strideInBytes, this.offsetInBytes);
                gl.enableVertexAttribArray(this.index);
            };

            attr.disableVertexAttribArray = function(gl) {
                gl.disableVertexAttribArray(this.index);
            };
        } else {
            // Less common case: value array for the same data for each vertex
            switch (attr.componentsPerAttribute) {
            case 1:
                attr.vertexAttrib = function(gl) {
                    gl.vertexAttrib1fv(this.index, this.value);
                };
                break;
            case 2:
                attr.vertexAttrib = function(gl) {
                    gl.vertexAttrib2fv(this.index, this.value);
                };
                break;
            case 3:
                attr.vertexAttrib = function(gl) {
                    gl.vertexAttrib3fv(this.index, this.value);
                };
                break;
            case 4:
                attr.vertexAttrib = function(gl) {
                    gl.vertexAttrib4fv(this.index, this.value);
                };
                break;
            }

            attr.disableVertexAttribArray = function(gl) {
            };
        }

        this._attributes.push(attr);
    };

    /**
     * DOC_TBA
     *
     * index is the location in the array of attributes, not the index property of an attribute.
     *
     * @memberof VertexArray
     *
     * @exception {DeveloperError} index is required.
     * @exception {DeveloperError} This vertex array was destroyed, i.e., destroy() was called.
     */
    VertexArray.prototype.getAttribute = function(index) {
        if (typeof index === "undefined") {
            throw new DeveloperError("index is required.", "index");
        }

        return this._attributes[index];
    };

    /**
    * DOC_TBA
    *
    * @memberof VertexArray
    *
    * @exception {DeveloperError} This vertex array was destroyed, i.e., destroy() was called.
    */
    VertexArray.prototype.getNumberOfAttributes = function() {
        return this._attributes.length;
    };

    /**
     * DOC_TBA
     *
     * @memberof VertexArray
     *
     * @exception {DeveloperError} Attribute must have a vertexBuffer.
     * @exception {DeveloperError} Attribute must have a componentsPerAttribute.
     * @exception {DeveloperError} Attribute must have a valid componentDatatype or not specify it.
     * @exception {DeveloperError} Attribute must have a strideInBytes less than or equal to 255 or not specify it.
     * @exception {DeveloperError} Index is already in use.
     * @exception {DeveloperError} This vertex array was destroyed, i.e., destroy() was called.
     */
    VertexArray.prototype.addAttribute = function(attribute) {
        if (attribute) {
            var attributes = this._attributes;
            var index = (typeof attribute.index === "undefined") ? attributes.length : attribute.index;
            for ( var i = 0; i < attributes.length; ++i) {
                if (index === attributes[i].index) {
                    throw new DeveloperError("Index " + index + " is already in use.", "attribute");
                }
            }

            try {
                this._addAttribute(attribute, index);
            } catch (e) {
                throw new DeveloperError(e.message, "attribute");
            }
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof VertexArray
     *
     * @return {Boolean} True if the attribute was removed; false if the attribute was not found in the vertex array.
     *
     * @exception {DeveloperError} Attribute must have an index.
     * @exception {DeveloperError} This vertex array was destroyed, i.e., destroy() was called.
     */
    VertexArray.prototype.removeAttribute = function(attribute) {
        if (attribute) {
            if (typeof attribute.index === "undefined") {
                throw new DeveloperError("Attribute must have an index.", "attribute");
            }

            var attributes = this._attributes;
            for ( var i = 0; i < attributes.length; ++i) {
                if (attributes[i].index === attribute.index) {
                    attributes.splice(i, 1);
                    return true;
                }
            }
        }

        return false;
    };

    /**
     * DOC_TBA
     *
     * @memberof VertexArray
     *
     * @return {Buffer} DOC_TBA.
     * @exception {DeveloperError} This vertex array was destroyed, i.e., destroy() was called.
     */
    VertexArray.prototype.getIndexBuffer = function() {
        return this._indexBuffer;
    };

    /**
     * DOC_TBA
     *
     * @memberof VertexArray
     *
     * @exception {DeveloperError} This vertex array was destroyed, i.e., destroy() was called.
     */
    VertexArray.prototype.setIndexBuffer = function(indexBuffer) {
        this._indexBuffer = indexBuffer;
    };

    VertexArray.prototype._bind = function() {
        var attributes = this._attributes;
        var gl = this._gl;

        // TODO:  Performance: sort by vertex buffer?
        for ( var i = 0; i < attributes.length; ++i) {
            var attribute = attributes[i];
            if (attribute.enabled) {
                attribute.vertexAttrib(gl);
            }
        }

        if (this._indexBuffer) {
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer._getBuffer());
        }
    };

    VertexArray.prototype._unBind = function() {
        var attributes = this._attributes;
        var gl = this._gl;

        for ( var i = 0; i < attributes.length; ++i) {
            var attribute = attributes[i];
            if (attribute.enabled) {
                attribute.disableVertexAttribArray(gl);
            }
        }
        if (this._indexBuffer) {
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        }
    };

    /**
     * This assumes that each vertex buffer in the vertex array has the same number of vertices.
     * @private
     */
    VertexArray.prototype._getNumberOfVertices = function() {
        if (this._attributes.length > 0) {
            var attribute = this._attributes[0];
            var bytes = attribute.strideInBytes || (attribute.componentsPerAttribute * attribute.componentDatatype.sizeInBytes);

            return attribute.vertexBuffer.getSizeInBytes() / bytes;
        }

        return 0;
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof VertexArray
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see VertexArray#destroy
     */
    VertexArray.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Only call this if the vertex array owns the vertex buffers referenced by the attributes and owns its
     * index buffer; otherwise, the owner of the buffers is responsible for destroying them.  A vertex or
     * index buffer is only destroyed if it's <code>getVertexArrayDestroyable</code> function returns
     * <code>true</code> (the default).  This allows combining destroyable and non-destroyable buffers
     * in the same vertex array.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>null</code>) to the object as done in the example.
     *
     * @memberof VertexArray
     *
     * @return {null}
     *
     * @exception {DeveloperError} This vertex array was destroyed, i.e., destroy() was called.
     *
     * @see VertexArray#isDestroyed
     * @see Buffer#getVertexArrayDestroyable
     * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glDeleteBuffers.xml">glDeleteBuffers</a>
     *
     * @example
     * // Destroying the vertex array implicitly calls destroy for each of its vertex
     * // buffers and its index buffer.
     * var vertexBuffer = context.createVertexBuffer(new Float32Array([0, 0, 0]),
     *     BufferUsage.STATIC_DRAW);
     * var vertexArray = context.createVertexArray();
     * vertexArray.addAttribute({ vertexBuffer : vertexBuffer, componentsPerAttribute : 3 });
     * // ...
     * vertexArray = vertexArray.destroy();
     * // Calling vertexBuffer.destroy() would throw DeveloperError at this point.
     */
    VertexArray.prototype.destroy = function() {
        var attributes = this._attributes;
        for ( var i = 0; i < attributes.length; ++i) {
            var vertexBuffer = attributes[i].vertexBuffer;
            if (vertexBuffer && !vertexBuffer.isDestroyed() && vertexBuffer.getVertexArrayDestroyable()) {
                vertexBuffer.destroy();
            }
        }

        var indexBuffer = this._indexBuffer;
        if (indexBuffer && indexBuffer.getVertexArrayDestroyable()) {
            this._indexBuffer = indexBuffer.destroy();
        }

        return destroyObject(this);
    };

    return VertexArray;
});
/*global define*/
define('Renderer/VertexArrayFacade',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/ComponentDatatype',
        './BufferUsage'
    ], function(
        DeveloperError,
        destroyObject,
        ComponentDatatype,
        BufferUsage) {
    
    /*global Uint8Array,ArrayBuffer*/

    /**
     * DOC_TBA
     *
     * @name VertexArrayFacade
     *
     * @constructor
     *
     * @exception {DeveloperError} context is required.
     * @exception {DeveloperError} At least one attribute is required.
     * @exception {DeveloperError} Attribute must have a componentsPerAttribute.
     * @exception {DeveloperError} Attribute must have a valid componentDatatype or not specify it.
     * @exception {DeveloperError} Attribute must have a valid usage or not specify it.
     * @exception {DeveloperError} Index n is used by more than one attribute.
     */
    function VertexArrayFacade(context, attributes, sizeInVertices) {
        if (!context) {
            throw new DeveloperError("context is required.", "context");
        }

        if (!attributes || (attributes.length === 0)) {
            throw new DeveloperError("At least one attribute is required.", "attributes");
        }

        var attrs = VertexArrayFacade._verifyAttributes(attributes);

        sizeInVertices = sizeInVertices || 0;

        var staticAttributes = [];
        var streamAttributes = [];
        var dynamicAttributes = [];
        var precreatedAttributes = [];

        var length = attrs.length;
        for ( var i = 0; i < length; ++i) {
            var attribute = attrs[i];

            // If the attribute already has a vertex buffer, we do not need
            // to manage a vertex buffer or typed array for it.
            if (attribute.vertexBuffer) {
                precreatedAttributes.push(attribute);
            } else {
                switch (attribute.usage.value) {
                case BufferUsage.STATIC_DRAW.value:
                    staticAttributes.push(attribute);
                    break;
                case BufferUsage.STREAM_DRAW.value:
                    streamAttributes.push(attribute);
                    break;
                case BufferUsage.DYNAMIC_DRAW.value:
                    dynamicAttributes.push(attribute);
                    break;
                }
            }
        }

        // Sort attributes by the size of their components.  From left to right, a vertex stores floats, shorts, and then bytes.
        function compare(left, right) {
            return right.componentDatatype.sizeInBytes - left.componentDatatype.sizeInBytes;
        }

        staticAttributes.sort(compare);
        streamAttributes.sort(compare);
        dynamicAttributes.sort(compare);

        var staticVertexSizeInBytes = VertexArrayFacade._vertexSizeInBytes(staticAttributes);
        var streamVertexSizeInBytes = VertexArrayFacade._vertexSizeInBytes(streamAttributes);
        var dynamicVertexSizeInBytes = VertexArrayFacade._vertexSizeInBytes(dynamicAttributes);

        this._size = 0;

        this._static = {
            vertexSizeInBytes : staticVertexSizeInBytes,

            vertexBuffer : undefined,
            usage : BufferUsage.STATIC_DRAW,
            needsCommit : false,

            arrayBuffer : undefined,
            arrayViews : VertexArrayFacade._createArrayViews(staticAttributes, staticVertexSizeInBytes)
        };

        this._stream = {
            vertexSizeInBytes : streamVertexSizeInBytes,

            vertexBuffer : undefined,
            usage : BufferUsage.STREAM_DRAW,
            needsCommit : false,

            arrayBuffer : undefined,
            arrayViews : VertexArrayFacade._createArrayViews(streamAttributes, streamVertexSizeInBytes)
        };

        this._dynamic = {
            vertexSizeInBytes : dynamicVertexSizeInBytes,

            vertexBuffer : undefined,
            usage : BufferUsage.DYNAMIC_DRAW,
            needsCommit : false,

            arrayBuffer : undefined,
            arrayViews : VertexArrayFacade._createArrayViews(dynamicAttributes, dynamicVertexSizeInBytes)
        };

        this._precreated = precreatedAttributes;
        this._context = context;

        /**
         * DOC_TBA
         */
        this.writers = undefined;

        /**
         * DOC_TBA
         */
        this.va = undefined;

        this.resize(sizeInVertices);
    }

    VertexArrayFacade._verifyAttributes = function(attributes) {
        var attrs = [];

        for ( var i = 0; i < attributes.length; ++i) {
            var attribute = attributes[i];

            var attr = {
                index : (typeof attribute.index === "undefined") ? i : attribute.index,
                enabled : (typeof attribute.enabled === "undefined") ? true : attribute.enabled,
                componentsPerAttribute : attribute.componentsPerAttribute,
                componentDatatype : attribute.componentDatatype || ComponentDatatype.FLOAT,
                normalize : attribute.normalize || false,

                // There will be either a vertexBuffer or an [optional] usage.
                vertexBuffer : attribute.vertexBuffer,
                usage : attribute.usage || BufferUsage.STATIC_DRAW
            };
            attrs.push(attr);

            if ((attr.componentsPerAttribute !== 1) && (attr.componentsPerAttribute !== 2) && (attr.componentsPerAttribute !== 3) && (attr.componentsPerAttribute !== 4)) {
                throw new DeveloperError("attribute.componentsPerAttribute must be in the range [1, 4].");
            }

            var datatype = attr.componentDatatype.value;
            if ((datatype !== ComponentDatatype.BYTE.value) && (datatype !== ComponentDatatype.UNSIGNED_BYTE.value) && (datatype !== ComponentDatatype.SHORT.value) &&
                    (datatype !== ComponentDatatype.UNSIGNED_SHORT.value) && (datatype !== ComponentDatatype.FLOAT.value)) {
                throw new DeveloperError("Attribute must have a valid componentDatatype or not specify it.");
            }

            var usage = attr.usage.value;
            if ((usage !== BufferUsage.STATIC_DRAW.value) && (usage !== BufferUsage.STREAM_DRAW.value) && (usage !== BufferUsage.DYNAMIC_DRAW.value)) {
                throw new DeveloperError("Attribute must have a valid usage or not specify it.");
            }
        }

        // Verify all attribute names are unique
        var uniqueIndices = {};
        for ( var j = 0; j < attrs.length; ++j) {
            var index = attrs[j].index;
            if (uniqueIndices[index]) {
                throw new DeveloperError("Index " + index + " is used by more than one attribute.", "attributes");
            }
            uniqueIndices[index] = true;
        }

        return attrs;
    };

    VertexArrayFacade._vertexSizeInBytes = function(attributes) {
        var sizeInBytes = 0;

        var length = attributes.length;
        for ( var i = 0; i < length; ++i) {
            var attribute = attributes[i];
            sizeInBytes += (attribute.componentsPerAttribute * attribute.componentDatatype.sizeInBytes);
        }

        var maxComponentSizeInBytes = (length > 0) ? attributes[0].componentDatatype.sizeInBytes : 0; // Sorted by size
        var remainder = (maxComponentSizeInBytes > 0) ? (sizeInBytes % maxComponentSizeInBytes) : 0;
        var padding = (remainder === 0) ? 0 : (maxComponentSizeInBytes - remainder);
        sizeInBytes += padding;

        return sizeInBytes;
    };

    VertexArrayFacade._createArrayViews = function(attributes, vertexSizeInBytes) {
        var views = [];
        var offsetInBytes = 0;

        var length = attributes.length;
        for ( var i = 0; i < length; ++i) {
            var attribute = attributes[i];
            var componentDatatype = attribute.componentDatatype;

            views.push({
                index : attribute.index,
                enabled : attribute.enabled,
                componentsPerAttribute : attribute.componentsPerAttribute,
                componentDatatype : componentDatatype,
                normalize : attribute.normalize,

                offsetInBytes : offsetInBytes,
                vertexSizeInComponentType : vertexSizeInBytes / componentDatatype.sizeInBytes,

                view : undefined
            });

            offsetInBytes += (attribute.componentsPerAttribute * componentDatatype.sizeInBytes);
        }

        return views;
    };

    /**
     * DOC_TBA
     *
     * Invalidates writers.  Can't render again until commit is called.
     *
     * @memberof VertexArrayFacade
     */
    VertexArrayFacade.prototype.resize = function(sizeInVertices) {
        this._size = sizeInVertices;

        VertexArrayFacade._resize(this._static, this._size);
        VertexArrayFacade._resize(this._stream, this._size);
        VertexArrayFacade._resize(this._dynamic, this._size);

        // Reserving invalidates the writers, so if client's cache them, they need to invalidate their cache.
        this.writers = {};
        VertexArrayFacade._appendWriters(this.writers, this._static);
        VertexArrayFacade._appendWriters(this.writers, this._stream);
        VertexArrayFacade._appendWriters(this.writers, this._dynamic);

        // VAs are recreated next time commit is called.
        this._destroyVA();
    };

    VertexArrayFacade._resize = function(buffer, size) {
        if (buffer.vertexSizeInBytes > 0) {
            // Create larger array buffer
            var arrayBuffer = new ArrayBuffer(size * buffer.vertexSizeInBytes);

            // Copy contents from previous array buffer
            if (buffer.arrayBuffer) {
                var destView = new Uint8Array(arrayBuffer);
                var sourceView = new Uint8Array(buffer.arrayBuffer);
                var sourceLength = sourceView.length;
                for ( var j = 0; j < sourceLength; ++j) {
                    destView[j] = sourceView[j];
                }
            }

            // Create typed views into the new array buffer
            var views = buffer.arrayViews;
            var length = views.length;
            for ( var i = 0; i < length; ++i) {
                var view = views[i];
                view.view = view.componentDatatype.createArrayBufferView(arrayBuffer, view.offsetInBytes);
            }

            buffer.arrayBuffer = arrayBuffer;
        }
    };

    var createWriters = [
    // 1 component per attribute
    function(buffer, view, vertexSizeInComponentType) {
        return function(index, attribute) {
            view[index * vertexSizeInComponentType] = attribute;
            buffer.needsCommit = true;
        };
    },

    // 2 component per attribute
    function(buffer, view, vertexSizeInComponentType) {
        return function(index, component0, component1) {
            var i = index * vertexSizeInComponentType;
            view[i] = component0;
            view[i + 1] = component1;
            buffer.needsCommit = true;
        };
    },

    // 3 component per attribute
    function(buffer, view, vertexSizeInComponentType) {
        return function(index, component0, component1, component2) {
            var i = index * vertexSizeInComponentType;
            view[i] = component0;
            view[i + 1] = component1;
            view[i + 2] = component2;
            buffer.needsCommit = true;
        };
    },

    // 4 component per attribute
    function(buffer, view, vertexSizeInComponentType) {
        return function(index, component0, component1, component2, component3) {
            var i = index * vertexSizeInComponentType;
            view[i] = component0;
            view[i + 1] = component1;
            view[i + 2] = component2;
            view[i + 3] = component3;
            buffer.needsCommit = true;
        };
    }];

    VertexArrayFacade._appendWriters = function(writers, buffer) {
        var arrayViews = buffer.arrayViews;
        var length = arrayViews.length;
        for ( var i = 0; i < length; ++i) {
            var arrayView = arrayViews[i];
            writers[arrayView.index] = createWriters[arrayView.componentsPerAttribute - 1](buffer, arrayView.view, arrayView.vertexSizeInComponentType);
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof VertexArrayFacade
     */
    VertexArrayFacade.prototype.commit = function(indexBuffer) {
        var recreateVA = false;
        recreateVA = this._commit(this._static) || recreateVA;
        recreateVA = this._commit(this._stream) || recreateVA;
        recreateVA = this._commit(this._dynamic) || recreateVA;

        ///////////////////////////////////////////////////////////////////////

        if (recreateVA || !this.va) {
            // Using unsigned short indices, 64K vertices can be indexed by one index buffer
            var sixtyFourK = 64 * 1024;

            var va = [];
            var numberOfVertexArrays = Math.ceil(this._size / sixtyFourK);
            for ( var k = 0; k < numberOfVertexArrays; ++k) {
                var attributes = [];
                VertexArrayFacade._appendAttributes(attributes, this._static, k * (this._static.vertexSizeInBytes * sixtyFourK));
                VertexArrayFacade._appendAttributes(attributes, this._stream, k * (this._stream.vertexSizeInBytes * sixtyFourK));
                VertexArrayFacade._appendAttributes(attributes, this._dynamic, k * (this._dynamic.vertexSizeInBytes * sixtyFourK));

                attributes = attributes.concat(this._precreated);

                va.push({
                    va : this._context.createVertexArray(attributes, indexBuffer),
                    indicesCount : 1.5 * ((k !== (numberOfVertexArrays - 1)) ? sixtyFourK : (this._size % sixtyFourK))
                // TODO: not hardcode 1.5
                });
            }

            this._destroyVA();
            this.va = va;
        }
    };

    VertexArrayFacade.prototype._commit = function(buffer) {
        if (buffer.needsCommit && (buffer.vertexSizeInBytes > 0)) {
            buffer.needsCommit = false;

            var vertexBuffer = buffer.vertexBuffer;
            var vertexBufferSizeInBytes = this._size * buffer.vertexSizeInBytes;
            if (!vertexBuffer || (vertexBuffer.getSizeInBytes() < vertexBufferSizeInBytes)) {
                if (vertexBuffer) {
                    vertexBuffer.destroy();
                }
                buffer.vertexBuffer = this._context.createVertexBuffer(buffer.arrayBuffer, buffer.usage);
                buffer.vertexBuffer.setVertexArrayDestroyable(false);

                return true; // Created new vertex buffer
            }

            buffer.vertexBuffer.copyFromArrayView(buffer.arrayBuffer);
        }

        return false; // Did not create new vertex buffer
    };

    VertexArrayFacade._appendAttributes = function(attributes, buffer, vertexBufferOffset) {
        var arrayViews = buffer.arrayViews;
        var length = arrayViews.length;
        for ( var i = 0; i < length; ++i) {
            var view = arrayViews[i];

            attributes.push({
                index : view.index,
                enabled : view.enabled,
                componentsPerAttribute : view.componentsPerAttribute,
                componentDatatype : view.componentDatatype,
                normalize : view.normalize,
                vertexBuffer : buffer.vertexBuffer,
                offsetInBytes : vertexBufferOffset + view.offsetInBytes,
                strideInBytes : buffer.vertexSizeInBytes
            });
        }
    };

    /**
     * DOC_TBA
     * @memberof VertexArrayFacade
     */
    VertexArrayFacade.prototype.subCommit = function(offsetInVertices, lengthInVertices) {
        if (offsetInVertices < 0 || offsetInVertices >= this._size) {
            throw new DeveloperError("offsetInVertices must be greater than or equal to zero and less than the vertex array's size.", offsetInVertices);
        }

        if (offsetInVertices + lengthInVertices > this._size) {
            throw new DeveloperError("offsetInVertices + lengthInVertices cannot exceed the vertex array's size.");
        }

        this._subCommit(this._static, offsetInVertices, lengthInVertices);
        this._subCommit(this._stream, offsetInVertices, lengthInVertices);
        this._subCommit(this._dynamic, offsetInVertices, lengthInVertices);
    };

    VertexArrayFacade.prototype._subCommit = function(buffer, offsetInVertices, lengthInVertices) {
        if (buffer.needsCommit && (buffer.vertexSizeInBytes > 0)) {
            var byteOffset = buffer.vertexSizeInBytes * offsetInVertices;
            var byteLength = buffer.vertexSizeInBytes * lengthInVertices;

            // PERFORMANCE_IDEA: If we want to get really crazy, we could consider updating
            // individual attributes instead of the entire (sub-)vertex.
            //
            // PERFORMANCE_IDEA: Does creating the typed view add too much GC overhead?
            buffer.vertexBuffer.copyFromArrayView(new Uint8Array(buffer.arrayBuffer, byteOffset, byteLength), byteOffset);
        }
    };

    /**
     * DOC_TBA
     * @memberof VertexArrayFacade
     */
    VertexArrayFacade.prototype.endSubCommits = function() {
        this._static.needsCommit = false;
        this._stream.needsCommit = false;
        this._dynamic.needsCommit = false;
    };

    VertexArrayFacade.prototype._destroyVA = function() {
        var va = this.va;
        if (va) {
            this.va = undefined;

            var length = va.length;
            for ( var i = 0; i < length; ++i) {
                va[i].va.destroy();
            }
        }
    };

    /**
     * DOC_TBA
     * @memberof VertexArrayFacade
     */
    VertexArrayFacade.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * DOC_TBA
     * @memberof VertexArrayFacade
     */
    VertexArrayFacade.prototype.destroy = function() {
        this._static.vertexBuffer = this._static.vertexBuffer && this._static.vertexBuffer.destroy();
        this._stream.vertexBuffer = this._stream.vertexBuffer && this._stream.vertexBuffer.destroy();
        this._dynamic.vertexBuffer = this._dynamic.vertexBuffer && this._dynamic.vertexBuffer.destroy();
        this._destroyVA();

        return destroyObject(this);
    };

    return VertexArrayFacade;
});
/*global define*/
define('Renderer/VertexLayout',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * Determines if vertex attributes are interleaved in a single vertex buffer or if each attribute is stored in a separate vertex buffer.
     *
     * @exports VertexLayout
     *
     * @see Context#createVertexArrayFromMesh
     */
    var VertexLayout = {
        /**
         * Each attribute will be stored in a separate vertex buffer.  This can be slightly slower
         * than using a single interleaved vertex buffer, but it is more flexible; more easily allowing
         * the sharing of vertex buffers among vertex arrays.  It also requires much less initial CPU
         * processing than interleaving.
         *
         * @constant
         * @type {Enumeration}
         */
        SEPARATE : new Enumeration(0, "SEPARATE"),
        /**
         * Each attribute will be interleaved in a single vertex buffer.  This can have a slight
         * performance advantage over using a separate vertex buffer per attribute, but it requires
         * extra CPU processing to initially interleave the vertex data.  This is recommended for
         * static data that will be rendered over several frames.
         *
         * @constant
         * @type {Enumeration}
         */
        INTERLEAVED : new Enumeration(1, "INTERLEAVED")
    };

    return VertexLayout;
});
/*global define*/
define('Scene/BingMapsStyle',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * An enumeration of the types of imagery provided by Bing Maps.
     *
     * @exports BingMapsStyle
     *
     * @see BingMapsTileProvider
     */
    var BingMapsStyle = {
        /**
         * Aerial imagery.
         *
         * @constant
         * @type {Enumeration}
         */
        AERIAL : new Enumeration(0, "Aerial"),

        /**
         * Aerial imagery with a road overlay.
         *
         * @constant
         * @type {Enumeration}
         */
        AERIAL_WITH_LABELS : new Enumeration(1, "AerialwithLabels"),

        /**
         * Roads without additional imagery.
         *
         * @constant
         * @type {Enumeration}
         */
        ROAD : new Enumeration(2, "Road"),

        /**
         * Ordnance Survey imagery
         *
         * @constant
         * @type {Enumeration}
         */
        ORDNANCE_SURVEY : new Enumeration(3, "OrdnanceSurvey"),

        /**
         * Collins Bart imagery.
         *
         * @constant
         * @type {Enumeration}
         */
        COLLINS_BART : new Enumeration(4, "CollinsBart")
    };

    return BingMapsStyle;
});
/*global define*/
define('Scene/CameraEventType',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports CameraEventType
     */
    var CameraEventType = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        LEFT_DRAG : new Enumeration(0, "Left Drag"),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        RIGHT_DRAG : new Enumeration(1, "Right Drag"),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        MIDDLE_DRAG : new Enumeration(2, "Middle Drag"),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        WHEEL : new Enumeration(3, "Wheel")
    };

    return CameraEventType;
});
/*global define*/
define('Scene/CameraEventHandler',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/Math',
        '../Core/EventHandler',
        '../Core/MouseEventType',
        '../Core/Cartesian2',
        '../Core/JulianDate',
        './CameraEventType'
    ], function(
        DeveloperError,
        destroyObject,
        CesiumMath,
        EventHandler,
        MouseEventType,
        Cartesian2,
        JulianDate,
        CameraEventType) {
    

    /**
     * DOC_TBA
     *
     * @name CameraEventHandler
     *
     * @param {HTMLCanvasElement} canvas DOC_TBA
     * @param {CameraEventType} moveType DOC_TBA
     * @param {EventModifier} moveModifier DOC_TBA
     *
     * @exception {DeveloperError} canvas is required.
     * @exception {DeveloperError} moveType is required.
     *
     * @constructor
     *
     * @see EventHandler
     */
    function CameraEventHandler(canvas, moveType, moveModifier) {
        if (!canvas) {
            throw new DeveloperError("description.canvas is required.", "description.canvas");
        }

        if (!moveType) {
            throw new DeveloperError("moveType is required.", "moveType");
        }

        this._eventHandler = new EventHandler(canvas);

        this._eventDownFunc = null;
        this._eventPressTimeFunc = null;
        this._eventReleaseTimeFunc = null;

        this._update = true;
        this._movement = null;
        this._lastMovement = null;

        var that = this;

        if (moveType !== CameraEventType.WHEEL) {
            var down;
            if (moveType === CameraEventType.LEFT_DRAG) {
                down = MouseEventType.LEFT_DOWN;

                this._eventDownFunc = this._eventHandler.isLeftMouseButtonDown;
                this._eventPressTimeFunc = this._eventHandler.getLeftPressTime;
                this._eventReleaseTimeFunc = this._eventHandler.getLeftReleaseTime;
            } else if (moveType === CameraEventType.RIGHT_DRAG) {
                down = MouseEventType.RIGHT_DOWN;

                this._eventDownFunc = this._eventHandler.isRightMouseButtonDown;
                this._eventPressTimeFunc = this._eventHandler.getRightPressTime;
                this._eventReleaseTimeFunc = this._eventHandler.getRightReleaseTime;
            } else if (moveType === CameraEventType.MIDDLE_DRAG) {
                down = MouseEventType.MIDDLE_DOWN;

                this._eventDownFunc = this._eventHandler.isMiddleMouseButtonDown;
                this._eventPressTimeFunc = this._eventHandler.getMiddlePressTime;
                this._eventReleaseTimeFunc = this._eventHandler.getRightReleaseTime;
            } else {
                this._eventHandler = this._eventHandler && this._eventHandler.destroy();
                throw new DeveloperError("The event type must be of type CameraEventType.", "moveType");
            }

            this._eventHandler.setMouseAction(function(movement) {
                that._lastMovement = null;
            }, down, moveModifier);

            this._eventHandler.setMouseAction(function(movement) {
                if (that._eventDownFunc.call(that._eventHandler)) {
                    if (!that._update) {
                        that._movement.endPosition = movement.endPosition.clone();
                    } else {
                        that._lastMovement = that._movement;
                        that._movement = movement;
                        that._update = false;
                    }
                }
            }, MouseEventType.MOVE, moveModifier);
        } else {
            this._wheelStart = null;
            this._wheelEnd = null;

            this._eventHandler.setMouseAction(function(delta) {
                // TODO: magic numbers
                var arcLength = 2 * CesiumMath.toRadians(delta);
                if (!that._update) {
                    that._movement.endPosition.y = that._movement.endPosition.y + arcLength;
                } else {
                    that._movement = {
                        startPosition : new Cartesian2(0.0, 0.0),
                        endPosition : new Cartesian2(0.0, arcLength),
                        motion : new Cartesian2(0.0, 0.0)
                    };
                    that._lastMovement = that._movement; // This looks unusual, but its needed for wheel inertia.
                    that._update = false;
                }
                that._wheelStart = new JulianDate();
                that._wheelEnd = that._wheelStart.addSeconds(Math.abs(arcLength) * 0.005);
            }, MouseEventType.WHEEL, moveModifier);
        }
    }

    /**
     * DOC_TBA
     *
     * @memberof CameraEventHandler
     *
     * @return {Object} DOC_TBA
     */
    CameraEventHandler.prototype.isMoving = function() {
        return !this._update;
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraEventHandler
     *
     * @return {Object} DOC_TBA
     */
    CameraEventHandler.prototype.getMovement = function() {
        var movement = this._movement;
        this._update = true;
        return movement;
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraEventHandler
     *
     * @return {Object} DOC_TBA
     */
    CameraEventHandler.prototype.getLastMovement = function() {
        return this._lastMovement;
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraEventHandler
     *
     * @return {Object} DOC_TBA
     *
     */
    CameraEventHandler.prototype.isButtonDown = function() {
        if (this._eventDownFunc) {
            return this._eventDownFunc.call(this._eventHandler);
        }
        return false;
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraEventHandler
     *
     * @return {Object} DOC_TBA
     *
     */
    CameraEventHandler.prototype.getButtonPressTime = function() {
        if (this._eventPressTimeFunc) {
            return this._eventPressTimeFunc.call(this._eventHandler);
        } else if (this._wheelStart) {
            return this._wheelStart;
        }
        return null;
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraEventHandler
     *
     * @return {Object} DOC_TBA
     *
     */
    CameraEventHandler.prototype.getButtonReleaseTime = function() {
        if (this._eventReleaseTimeFunc) {
            return this._eventReleaseTimeFunc.call(this._eventHandler);
        }

        else if (this._wheelEnd) {
            return this._wheelEnd;
        }
        return null;
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof CameraEventHandler
     *
     * @return {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     *
     * @see CameraEventHandler#destroy
     */
    CameraEventHandler.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Removes mouse and keyboard listeners held by this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>null</code>) to the object as done in the example.
     *
     * @memberof CameraEventHandler
     *
     * @return {null}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CameraEventHandler#isDestroyed
     *
     * @example
     * handler = handler && handler.destroy();
     */
    CameraEventHandler.prototype.destroy = function() {
        this._eventHandler = this._eventHandler && this._eventHandler.destroy();
        return destroyObject(this);
    };

    return CameraEventHandler;
});
/*global define*/
define('Scene/CameraFlightController',[
        '../Core/destroyObject',
        '../Core/EventHandler',
        '../Core/MouseEventType',
        '../Core/Quaternion',
        '../Core/Cartesian3',
        '../Core/HermiteSpline',
        '../Core/JulianDate'
    ], function(
        destroyObject,
        EventHandler,
        MouseEventType,
        Quaternion,
        Cartesian3,
        HermiteSpline,
        JulianDate) {
    

    /**
     * A type that defines camera behavior: the camera will follow a path from the
     * current position of the camera to an end point around an ellipsoid.
     *
     * @name CameraFlightController
     * @internalConstructor
     *
     * @param {HTMLCanvasElement} canvas An HTML canvas element used to listen for user events.
     * @param {Camera} camera The camera to use.
     * @param {Ellipsoid} ellipsoid The ellipsoid to move the camera around.
     * @param {Cartesian} destination The Cartesian point that is the end of the path.
     * @param {Number} duration The time, in seconds, to travel along the path.
     *
     * @see CameraControllerCollection#addFlight
     */
    function CameraFlightController(canvas, camera, ellipsoid, destination, duration, complete) {
        // get minimum altitude from which the whole ellipsoid is visible
        var radius = ellipsoid.getRadii().getMaximumComponent();

        var frustum = camera.frustum;
        var near = frustum.near;
        var top = frustum.near * Math.tan(0.5 * frustum.fovy);
        var right = frustum.aspectRatio * top;

        var dx = radius * near / right;
        var dy = radius * near / top;
        var dm = Math.max(dx, dy);
        var altitude = dm - radius;

        this._camera = camera;
        this._start = new JulianDate();
        this._end = this._start.addSeconds(duration);
        this._path = this._createPath(ellipsoid, altitude, destination, duration);
        this._canceled = false;
        this._complete = complete;

        var that = this;
        var cancelFlight = function() {
            that._canceled = true;
        };

        this._handler = new EventHandler(canvas);
        this._handler.setMouseAction(cancelFlight, MouseEventType.LEFT_DOWN);
        this._handler.setMouseAction(cancelFlight, MouseEventType.RIGHT_DOWN);
        this._handler.setMouseAction(cancelFlight, MouseEventType.MIDDLE_DOWN);
    }

    CameraFlightController.prototype._createPath = function(ellipsoid, altitude, endPoint, duration) {
        var start = this._camera.position;

        var maxStartAlt = ellipsoid.getMaximumRadius() + altitude;
        var dot = start.normalize().dot(endPoint.normalize());

        var abovePercentage, incrementPercentage;
        var startAboveMaxAlt = (start.magnitude() > maxStartAlt);
        if (startAboveMaxAlt) {
            abovePercentage = 0.6;
            incrementPercentage = 0.35;
        } else {
            // TODO: revisit when hi-res imagery is implemented.
            abovePercentage = Math.max(0.1, 1.0 - Math.abs(dot));
            incrementPercentage = 0.5;
        }

        maxStartAlt = ellipsoid.getMaximumRadius() + abovePercentage * altitude;

        var aboveEnd = endPoint.normalize().multiplyWithScalar(maxStartAlt);
        var afterStart = start.normalize().multiplyWithScalar(maxStartAlt);

        var points, axis, angle, rotation;
        if (start.magnitude() > maxStartAlt && dot > 0) {
            var middle = start.subtract(aboveEnd).multiplyWithScalar(0.5).add(aboveEnd);

            points = [{
                point : start
            }, {
                point : middle
            }, {
                point : aboveEnd
            }, {
                point : endPoint
            }];
        } else {
            points = [{
                point : start
            }];

            angle = Math.acos(afterStart.normalize().dot(aboveEnd.normalize()));
            axis = aboveEnd.cross(afterStart);

            var increment = incrementPercentage * angle;
            var startCondition = (startAboveMaxAlt) ? angle - increment : angle;
            for ( var i = startCondition; i > 0.0; i = i - increment) {
                rotation = Quaternion.fromAxisAngle(axis, i).toRotationMatrix();
                points.push({
                    point : rotation.multiplyWithVector(aboveEnd)
                });
            }

            points.push({
                point : aboveEnd
            }, {
                point : endPoint
            });
        }

        var scalar = duration / (points.length - 1);
        for ( var k = 0; k < points.length; ++k) {
            points[k].time = k * scalar;
        }

        return new HermiteSpline(points);
    };

    /**
     * @private
     */
    CameraFlightController.prototype.update = function() {
        var time = new JulianDate(),
            diff,
            position,
            normal,
            tangent,
            target;

        var now = time.isAfter(this._end) ? this._end : time;

        diff = this._start.getSecondsDifference(now);
        position = this._path.evaluate(diff);
        normal = Cartesian3.getUnitZ().cross(position).normalize();
        tangent = position.cross(normal).normalize();
        target = Cartesian3.getZero();
        this._camera.lookAt(position, target, tangent);

        var isComplete = (now === this._end) || this._canceled;
        if(isComplete && !this._canceled && (typeof this._complete !== 'undefined')){
            this._complete();
        }
        return !isComplete;
    };

    /**
      * Returns true if this object was destroyed; otherwise, false.
      * <br /><br />
      * If this object was destroyed, it should not be used; calling any function other than
      * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
      *
      * @memberof CameraFlightController
      *
      * @return {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
      *
      * @see CameraFlightController#destroy
      */
    CameraFlightController.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Removes keyboard listeners held by this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>null</code>) to the object as done in the example.
     *
     * @memberof CameraFlightController
     *
     * @return {null}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CameraFlightControllerController#isDestroyed
     *
     * @example
     * controller = controller && controller.destroy();
     */
    CameraFlightController.prototype.destroy = function() {
        this._handler.destroy();
        return destroyObject(this);
    };

    return CameraFlightController;
});
/*global define*/
define('Scene/CameraHelpers',[
        '../Core/Math',
        '../Core/Cartesian2',
        '../Core/JulianDate'
    ], function(
        CesiumMath,
        Cartesian2,
        JulianDate) {
    

    function move(camera, direction, rate) {
        var position = camera.position;
        var newPosition = position.add(direction.multiplyWithScalar(rate));
        camera.position = newPosition;
    }

    function decay(time, coefficient) {
        if (time < 0) {
            return 0.0;
        }

        var tau = (1.0 - coefficient) * 25.0;
        return Math.exp(-tau * time);
    }

    function sameMousePosition(movement) {
        return movement.startPosition.equalsEpsilon(movement.endPosition, CesiumMath.EPSILON14);
    }

    // If the time between mouse down and mouse up is not between
    // these thresholds, the camera will not move with inertia.
    // This value is probably dependent on the browser and/or the
    // hardware. Should be investigated further.
    var inertiaMaxClickTimeThreshold = 0.4;
    var inertiaMaxTimeThreshold = 2.0;
    
    function maintainInertia(handler, decayCoef, action, object, lastMovementName) {
        var ts = handler.getButtonPressTime();
        var tr = handler.getButtonReleaseTime();
        var threshold = ts && tr && ts.getSecondsDifference(tr);
        if (ts && tr && threshold < inertiaMaxClickTimeThreshold) {
            var now = new JulianDate();
            var fromNow = tr.getSecondsDifference(now);
            if (fromNow > inertiaMaxTimeThreshold) {
                return;
            }

            var d = decay(fromNow, decayCoef);

            if (!object[lastMovementName]) {
                var lastMovement = handler.getLastMovement();
                if (!lastMovement || sameMousePosition(lastMovement)) {
                    return;
                }

                var motionX = (lastMovement.endPosition.x - lastMovement.startPosition.x) * 0.5;
                var motionY = (lastMovement.endPosition.y - lastMovement.startPosition.y) * 0.5;
                object[lastMovementName] = {
                    startPosition : new Cartesian2(lastMovement.startPosition.x, lastMovement.startPosition.y),
                    endPosition : new Cartesian2(lastMovement.startPosition.x + motionX * d, lastMovement.startPosition.y + motionY * d),
                    motion : new Cartesian2(motionX, motionY)
                };
            } else {
                object[lastMovementName] = {
                    startPosition : object[lastMovementName].endPosition.clone(),
                    endPosition : new Cartesian2(
                            object[lastMovementName].endPosition.x + object[lastMovementName].motion.x * d,
                            object[lastMovementName].endPosition.y + object[lastMovementName].motion.y * d),
                    motion : new Cartesian2(0.0, 0.0)
                };
            }

            // If value from the decreasing exponential function is close to zero,
            // the end coordinates may be NaN.
            if (isNaN(object[lastMovementName].endPosition.x) || isNaN(object[lastMovementName].endPosition.y) || sameMousePosition(object[lastMovementName])) {
                object[lastMovementName] = undefined;
                return;
            }

            if (!handler.isButtonDown()) {
                action.apply(object, [object[lastMovementName]]);
            }
        }
    }
    
    /**
     * This function is similar to maintainInertia except that it does not require a handler. 
     * Instead, the touch start time, touch release time, and last movement are passed as arguments.
     * 
     * @param {JulianDate} ts The time the mouse touch started.
     * @param {JulianDate} tr The time the mouse touch released.
     * @param {Object} lastMovement
     * @param {Number} decayCoef
     * @param {Function} action 
     * @param {Object} object
     * @param {String} lastMovementName
     */
    function createInertia(ts, tr, lastMovement, decayCoef, action, object, lastMovementName) {
    	if(ts && tr) {
    		// In VWF, ts and tr will be untyped objects that were originally JulianDates.
    		ts = new Cesium.JulianDate(ts._julianDayNumber, ts._secondsOfDay, ts._timeStandard);
        	tr = new Cesium.JulianDate(tr._julianDayNumber, tr._secondsOfDay, tr._timeStandard);
    	}
    	var threshold = ts && tr && ts.getSecondsDifference(tr);
        if (ts && tr && threshold < inertiaMaxClickTimeThreshold) {
            var now = new JulianDate();
            var fromNow = tr.getSecondsDifference(now);
            if (fromNow > inertiaMaxTimeThreshold) {
                return;
            }

            var d = decay(fromNow, decayCoef);

            if (!object[lastMovementName]) {
                if (!lastMovement) {
                    return;
                }

                var motionX = (lastMovement.endPosition.x - lastMovement.startPosition.x) * 0.5;
                var motionY = (lastMovement.endPosition.y - lastMovement.startPosition.y) * 0.5;
                object[lastMovementName] = {
                    startPosition : new Cartesian2(lastMovement.startPosition.x, lastMovement.startPosition.y),
                    endPosition : new Cartesian2(lastMovement.startPosition.x + motionX * d, lastMovement.startPosition.y + motionY * d),
                    motion : new Cartesian2(motionX, motionY)
                };
            } else {
                object[lastMovementName] = {
                    startPosition : object[lastMovementName].endPosition.clone(),
                    endPosition : new Cartesian2(
                            object[lastMovementName].endPosition.x + object[lastMovementName].motion.x * d,
                            object[lastMovementName].endPosition.y + object[lastMovementName].motion.y * d),
                    motion : new Cartesian2(0.0, 0.0)
                };
            }

            // If value from the decreasing exponential function is close to zero,
            // the end coordinates may be NaN.
            if (isNaN(object[lastMovementName].endPosition.x) || isNaN(object[lastMovementName].endPosition.y) || sameMousePosition(object[lastMovementName])) {
                object[lastMovementName] = undefined;
                return;
            }

            action.apply(object, [object[lastMovementName]]);
        }
    }

    function handleZoom(object, movement, distanceMeasure) {
        // distanceMeasure should be the height above the ellipsoid.
        // The zoomRate slows as it approaches the surface and stops 20m above it.
        var zoomRate = object._zoomFactor * (distanceMeasure - 20.0);

        if (zoomRate > object._maximumZoomRate) {
            zoomRate = object._maximumZoomRate;
        }

        var diff = movement.endPosition.y - movement.startPosition.y;
        if (diff === 0) {
            return;
        }

        var rangeWindowRatio = diff / object._canvas.clientHeight;
        var dist = zoomRate * rangeWindowRatio;

        if (zoomRate < object._minimumZoomRate && dist > 0.0) {
            return;
        }

        if (dist > 0.0) {
            object.zoomIn(dist);
        } else {
            object.zoomOut(-dist);
        }
    }

    function zoom(camera, rate) {
        move(camera, camera.direction, rate);
    }

    return {
        move : move,
        handleZoom : handleZoom,
        maintainInertia : maintainInertia,
        createInertia : createInertia,
        zoom : zoom
    };
});
/*global define*/
define('Scene/Camera2DController',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/FAR',
        '../Core/Math',
        '../Core/Quaternion',
        '../Core/Ellipsoid',
        '../Core/Cartesian2',
        './CameraEventHandler',
        './CameraEventType',
        './CameraHelpers'
    ], function(
        DeveloperError,
        destroyObject,
        FAR,
        CesiumMath,
        Quaternion,
        Ellipsoid,
        Cartesian2,
        CameraEventHandler,
        CameraEventType,
        CameraHelpers) {
    

    var move = CameraHelpers.move;
    var maintainInertia = CameraHelpers.maintainInertia;
    var handleZoom = CameraHelpers.handleZoom;

    /**
     * A type that defines camera behavior: movement of the position in the direction
     * of the camera's axes and manipulating a camera's orthographic frustum for a zooming effect.
     *
     * @name Camera2DController
     *
     * @param {HTMLCanvasElement} canvas An HTML canvas element used for its dimensions
     * and for listening on user events.
     * @param {Camera} camera The camera to use.
     * @param {Ellipsoid} [ellipsoid=WGS84 Ellipsoid] DOC_TBA.
     *
     * @internalConstructor
     */
    function Camera2DController(canvas, camera, ellipsoid) {
        ellipsoid = ellipsoid || Ellipsoid.getWgs84();

        this._canvas = canvas;
        this._camera = camera;
        this._ellipsoid = ellipsoid;
        this._zoomRate = 100000.0;
        this._moveRate = 100000.0;

        /**
         * A parameter in the range <code>[0, 1)</code> used to determine how long
         * the camera will continue to translate because of inertia.
         * With value of zero, the camera will have no inertia.
         *
         * @type Number
         */
        this.inertiaTranslate = 0.9;

        /**
         * A parameter in the range <code>[0, 1)</code> used to determine how long
         * the camera will continue to zoom because of inertia.
         * With value of zero, the camera will have no inertia.
         *
         * @type Number
         */
        this.inertiaZoom = 0.8;

        this._zoomFactor = 5.0;
        this._translateFactor = 1.0;
        this._minimumZoomRate = 20.0;
        this._maximumZoomRate = FAR;

        this._translateHandler = new CameraEventHandler(canvas, CameraEventType.LEFT_DRAG);
        this._zoomHandler = new CameraEventHandler(canvas, CameraEventType.RIGHT_DRAG);
        this._zoomWheel = new CameraEventHandler(canvas, CameraEventType.WHEEL);
        this._twistHandler = new CameraEventHandler(canvas, CameraEventType.MIDDLE_DRAG);

        this._lastInertiaTranslateMovement = undefined;
        this._lastInertiaZoomMovement = undefined;
        this._lastInertiaWheelZoomMovement = undefined;
    }

    /**
     * DOC_TBA
     *
     * @memberof Camera2DController
     *
     * @param {Matrix4} transform DOC_TBA
     * @param {Ellipsoid} ellipsoid DOC_TBA
     *
     * @example
     * // Example 1.
     * // Change the reference frame to one centered at a point on the ellipsoid's surface.
     * // Set the 2D controller's ellipsoid to a unit sphere for easy rotation around that point.
     * var center = ellipsoid.cartographicDegreesToCartesian(new Cartographic2(-75.59777, 40.03883));
     * var transform = Transforms.eastNorthUpToFixedFrame(center);
     * scene.getCamera().getControllers().get(0).setReferenceFrame(transform, Ellipsoid.getUnitSphere());
     *
     * // Example 2.
     * // Reset to the defaults.
     * scene.getCamera().getControllers().get(0).setReferenceFrame(Matrix4.getIdentity());
     *
     */
    Camera2DController.prototype.setReferenceFrame = function (transform, ellipsoid) {
        this._camera.transform = transform;
        this.setEllipsoid(ellipsoid);
    };

    /**
     * Returns the ellipsoid that the camera is moving around.
     *
     * @memberof Camera2DController
     *
     * @returns {Ellipsoid} The ellipsoid that the camera is moving around.
     *
     * @see Camera2DController#setEllipsoid
     */
    Camera2DController.prototype.getEllipsoid = function() {
        return this._ellipsoid;
    };

    /**
     * Sets the ellipsoid that the camera is moving around.
     *
     * @memberof Camera2DController
     *
     * @param {Ellipsoid} [ellipsoid] The ellipsoid that the camera is moving around.
     *
     * @see Camera2DController#getEllipsoid
     */
    Camera2DController.prototype.setEllipsoid = function(ellipsoid) {
        ellipsoid = ellipsoid || Ellipsoid.getWgs84();

        var radius = ellipsoid.getRadii().getMaximumComponent();
        this._ellipsoid = ellipsoid;
        this._rateAdjustment = radius;
    };

    /**
     * Translates the camera's position by <code>rate</code> along the camera's up vector.
     *
     * @memberof Camera2DController
     *
     * @param {Number} rate The rate to move.
     *
     * @see Camera2DController#moveDown
     */
    Camera2DController.prototype.moveUp = function(rate) {
        move(this._camera, this._camera.up, rate || this._moveRate);
    };

    /**
     * Translates the camera's position by <code>rate</code> along the opposite direction
     * of the camera's up vector.
     *
     * @memberof Camera2DController
     *
     * @param {Number} rate The rate to move.
     *
     * @see Camera2DController#moveUp
     */
    Camera2DController.prototype.moveDown = function(rate) {
        move(this._camera, this._camera.up, -rate || -this._moveRate);
    };

    /**
     * Translates the camera's position by <code>rate</code> along the camera's right vector.
     *
     * @memberof Camera2DController
     *
     * @param {Number} rate The rate to move.
     *
     * @see Camera2DController#moveLeft
     */
    Camera2DController.prototype.moveRight = function(rate) {
        move(this._camera, this._camera.right, rate || this._moveRate);
    };

    /**
     * Translates the camera's position by <code>rate</code> along the opposite direction
     * of the camera's right vector.
     *
     * @memberof Camera2DController
     *
     * @param {Number} rate The rate to move.
     *
     * @see Camera2DController#moveRight
     */
    Camera2DController.prototype.moveLeft = function(rate) {
        move(this._camera, this._camera.right, -rate || -this._moveRate);
    };

    /**
     * DOC_TBA
     *
     * @memberof Camera2DController
     *
     * @param {Number} rate The rate to move.
     *
     * @see Camera2DController#zoomOut
     */
    Camera2DController.prototype.zoomIn = function(rate) {
        var moveRate = rate || this._zoomRate;
        var frustum = this._camera.frustum;

        if (frustum.left === null || frustum.right === null ||
            frustum.top === null || frustum.bottom === null) {
                throw new DeveloperError("The camera frustum is expected to be orthographic for 2D camera control.", "frustum");
        }

        var newRight = frustum.right - moveRate;
        var newLeft = frustum.left + moveRate;
        if (newRight > newLeft) {
            var ratio = frustum.top / frustum.right;
            frustum.right = newRight;
            frustum.left = newLeft;
            frustum.top = frustum.right * ratio;
            frustum.bottom = -frustum.top;
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof Camera2DController
     *
     * @param {Number} rate The rate to move.
     *
     * @see Camera2DController#zoomIn
     */
    Camera2DController.prototype.zoomOut = function(rate) {
        this.zoomIn(-rate || -this._zoomRate);
    };

    /**
     * @private
     */
    Camera2DController.prototype.update = function() {
        var translate = this._translateHandler;
        var rightZoom = this._zoomHandler;
        var wheelZoom = this._zoomWheel;
        var translating = translate.isMoving() && translate.getMovement();
        var rightZooming = rightZoom.isMoving();
        var wheelZooming = wheelZoom.isMoving();

        if (translating) {
            this._translate(translate.getMovement());
        }

        if (!translating && this.inertiaTranslate < 1.0) {
            maintainInertia(translate, this.inertiaTranslate, this._translate, this, '_lastInertiaTranslateMovement');
        }

        if (rightZooming) {
            this._zoom(rightZoom.getMovement());
        }
        else if (wheelZooming) {
            this._zoom(wheelZoom.getMovement());
        }

        if (!rightZooming && this.inertiaZoom < 1.0) {
            maintainInertia(rightZoom, this.inertiaZoom, this._zoom, this, '_lastInertiaZoomMovement');
        }

        if (!wheelZooming && this.inertiaZoom < 1.0) {
            maintainInertia(wheelZoom, this.inertiaZoom, this._zoom, this, '_lastInertiaWheelZoomMovement');
        }

        if (this._twistHandler.isMoving()) {
            this._twist(this._twistHandler.getMovement());
        }

        return true;
    };

    Camera2DController.prototype._translate = function(movement) {
       var frustum = this._camera.frustum;

       if (frustum.left === null || frustum.right === null ||
           frustum.top === null || frustum.bottom === null) {
               throw new DeveloperError("The camera frustum is expected to be orthographic for 2D camera control.", "frustum");
       }

       var width = this._canvas.clientWidth;
       var height = this._canvas.clientHeight;

       var start = new Cartesian2();
       start.x = (2.0 / width) * movement.startPosition.x - 1.0;
       start.x = (start.x * (frustum.right - frustum.left) + frustum.right + frustum.left) * 0.5;
       start.y = (2.0 / height) * (height - movement.startPosition.y) - 1.0;
       start.y = (start.y * (frustum.top - frustum.bottom) + frustum.top + frustum.bottom) * 0.5;

       var end = new Cartesian2();
       end.x = (2.0 / width) * movement.endPosition.x - 1.0;
       end.x = (end.x * (frustum.right - frustum.left) + frustum.right + frustum.left) * 0.5;
       end.y = (2.0 / height) * (height - movement.endPosition.y) - 1.0;
       end.y = (end.y * (frustum.top - frustum.bottom) + frustum.top + frustum.bottom) * 0.5;

       var distance = start.subtract(end);
       if (distance.x !== 0) {
           this.moveRight(distance.x);
       }
       if (distance.y !== 0) {
           this.moveUp(distance.y);
       }
   };

   Camera2DController.prototype._zoom = function(movement) {
       var camera = this._camera;
       var mag = Math.max(camera.frustum.right - camera.frustum.left, camera.frustum.top - camera.frustum.bottom);
       handleZoom(this, movement, mag);
   };

   Camera2DController.prototype._twist = function(movement) {
       var width = this._canvas.clientWidth;
       var height = this._canvas.clientHeight;

       var start = new Cartesian2();
       start.x = (2.0 / width) * movement.startPosition.x - 1.0;
       start.y = (2.0 / height) * (height - movement.startPosition.y) - 1.0;
       start = start.normalize();

       var end = new Cartesian2();
       end.x = (2.0 / width) * movement.endPosition.x - 1.0;
       end.y = (2.0 / height) * (height - movement.endPosition.y) - 1.0;
       end = end.normalize();

       var startTheta = Math.acos(start.x);
       if (start.y < 0) {
           startTheta = CesiumMath.TWO_PI - startTheta;
       }
       var endTheta = Math.acos(end.x);
       if (end.y < 0) {
           endTheta = CesiumMath.TWO_PI - endTheta;
       }
       var theta = endTheta - startTheta;

       var camera = this._camera;
       var rotation = Quaternion.fromAxisAngle(camera.direction, theta).toRotationMatrix();
       camera.up = rotation.multiplyWithVector(camera.up);
       camera.right = camera.direction.cross(camera.up);
   };

   /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof Camera2DController
     *
     * @return {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     *
     * @see Camera2DController#destroy
     */
    Camera2DController.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Removes mouse and keyboard listeners held by this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>null</code>) to the object as done in the example.
     *
     * @memberof Camera2DController
     *
     * @return {null}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see Camera2DController#isDestroyed
     *
     * @example
     * controller = controller && controller.destroy();
     */
    Camera2DController.prototype.destroy = function () {
        this._translateHandler = this._translateHandler && this._translateHandler.destroy();
        this._zoomHandler = this._zoomHandler && this._zoomHandler.destroy();
        return destroyObject(this);
    };

    return Camera2DController;
});
/*global define*/
define('Scene/CameraFreeLookController',[
        '../Core/destroyObject',
        '../Core/Math',
        '../Core/EventModifier',
        '../Core/Quaternion',
        '../Core/Cartesian2',
        '../Core/Cartesian3',
        './CameraEventHandler',
        './CameraEventType',
        './CameraHelpers'
    ], function(
        destroyObject,
        CesiumMath,
        EventModifier,
        Quaternion,
        Cartesian2,
        Cartesian3,
        CameraEventHandler,
        CameraEventType,
        CameraHelpers) {
    

    var move = CameraHelpers.move;

    /**
     * A type that defines camera behavior: movement of the position in the direction
     * of the camera's axes and rotation of the axes keeping the position stationary.
     *
     * @name CameraFreeLookController
     *
     * @param {HTMLCanvasElement} canvas An HTML canvas element used for its dimensions
     * and for listening on user events.
     * @param {Camera} camera The camera to use.
     *
     * @internalConstructor
     */
    function CameraFreeLookController(canvas, camera) {
        this._canvas = canvas;
        this._camera = camera;
        this._handler = new CameraEventHandler(canvas, CameraEventType.LEFT_DRAG, EventModifier.SHIFT);

        this._maximumMoveRate = 2000000.0;
        this._minimumMoveRate = 1.0 / 5000.0;
        this._maximumTurnRate = Math.PI / 8.0;
        this._minimumTurnRate = Math.PI / 120.0;

        this._moveRate = 100000.0;
        this._turnRate = Math.PI / 60.0;

        /**
         * DOC_TBD
         */
        this.horizontalRotationAxis = undefined;
    }

    /**
     * Translates the camera's position by <code>rate</code> along the camera's view vector.
     *
     * @memberof CameraFreeLookController
     *
     * @param {Number} rate The rate to move.
     *
     * @see CameraFreeLookController#moveBackward
     */
    CameraFreeLookController.prototype.moveForward = function(rate) {
        move(this._camera, this._camera.direction, rate || this._moveRate);
    };

    /**
     * Translates the camera's position by <code>rate</code> along the opposite direction
     * of the camera's view vector.
     *
     * @memberof CameraFreeLookController
     *
     * @param {Number} rate The rate to move.
     *
     * @see CameraFreeLookController#moveForward
     */
    CameraFreeLookController.prototype.moveBackward = function(rate) {
        move(this._camera, this._camera.direction, -rate || -this._moveRate);
    };

    /**
     * Translates the camera's position by <code>rate</code> along the camera's up vector.
     *
     * @memberof CameraFreeLookController
     *
     * @param {Number} rate The rate to move.
     *
     * @see CameraFreeLookController#moveDown
     */
    CameraFreeLookController.prototype.moveUp = function(rate) {
        move(this._camera, this._camera.up, rate || this._moveRate);
    };

    /**
     * Translates the camera's position by <code>rate</code> along the opposite direction
     * of the camera's up vector.
     *
     * @memberof CameraFreeLookController
     *
     * @param {Number} rate The rate to move.
     *
     * @see CameraFreeLookController#moveUp
     */
    CameraFreeLookController.prototype.moveDown = function(rate) {
        move(this._camera, this._camera.up, -rate || -this._moveRate);
    };

    /**
     * Translates the camera's position by <code>rate</code> along the camera's right vector.
     *
     * @memberof CameraFreeLookController
     *
     * @param {Number} rate The rate to move.
     *
     * @see CameraFreeLookController#moveLeft
     */
    CameraFreeLookController.prototype.moveRight = function(rate) {
        move(this._camera, this._camera.right, rate || this._moveRate);
    };

    /**
     * Translates the camera's position by <code>rate</code> along the opposite direction
     * of the camera's right vector.
     *
     * @memberof CameraFreeLookController
     *
     * @param {Number} rate The rate to move.
     *
     * @see CameraFreeLookController#moveRight
     */
    CameraFreeLookController.prototype.moveLeft = function(rate) {
        move(this._camera, this._camera.right, -rate || -this._moveRate);
    };

    /**
     * Rotates the camera around its up vector by rate, in radians, in the opposite direction
     * of its right vector.
     *
     * @memberof CameraFreeLookController
     *
     * @param {Number} rate The rate, in radians, to rotate by.
     *
     * @see CameraFreeLookController#lookRight
     */
    CameraFreeLookController.prototype.lookLeft = function(rate) {
        var turnRate = rate || this._turnRate;
        var rotated = this._rotateTwoAxes(this._camera.direction, this._camera.right, this._camera.up, turnRate);
        this._camera.direction = rotated[0];
        this._camera.right = rotated[1];
    };

    /**
     * Rotates the camera around its up vector by rate, in radians, in the direction
     * of its right vector.
     *
     * @memberof CameraFreeLookController
     *
     * @param {Number} rate The rate, in radians, to rotate by.
     *
     * @see CameraFreeLookController#lookLeft
     */
    CameraFreeLookController.prototype.lookRight = function(rate) {
        this.lookLeft(-rate || -this._turnRate);
    };

    /**
     * Rotates the camera around its right vector by rate, in radians, in the direction
     * of its up vector.
     *
     * @memberof CameraFreeLookController
     *
     * @param {Number} rate The rate, in radians, to rotate by.
     *
     * @see CameraFreeLookController#lookDown
     */
    CameraFreeLookController.prototype.lookUp = function(rate) {
        var turnRate = rate || this._turnRate;
        var rotated = this._rotateTwoAxes(this._camera.direction, this._camera.up, this._camera.right, turnRate);
        this._camera.direction = rotated[0];
        this._camera.up = rotated[1];
    };

    /**
     * Rotates the camera around its right vector by rate, in radians, in the opposite direction
     * of its up vector.
     *
     * @memberof CameraFreeLookController
     *
     * @param {Number} rate The rate, in radians, to rotate by.
     *
     * @see CameraFreeLookController#lookUp
     */
    CameraFreeLookController.prototype.lookDown = function(rate) {
        this.lookUp(-rate || -this._turnRate);
    };

    CameraFreeLookController.prototype._rotateTwoAxes = function(v0, v1, axis, angle) {
        var rotation = Quaternion.fromAxisAngle(axis, angle).toRotationMatrix();
        var u0 = rotation.multiplyWithVector(v0);
        var u1 = rotation.multiplyWithVector(v1);
        return [u0, u1];
    };

    /**
     * Rotate each of the camera's orientation vectors around <code>axis</code> by <code>angle</code>
     *
     * @memberof CameraFreeLookController
     *
     * @param {Cartesian3} axis The axis to rotate around.
     * @param {Number} angle The angle, in radians, to rotate by.
     *
     * @see CameraFreeLookcontroller#lookUp
     * @see CameraFreeLookcontroller#lookDown
     * @see CameraFreeLookcontroller#lookLeft
     * @see CameraFreeLookcontroller#lookRight
     */
    CameraFreeLookController.prototype.rotate = function(axis, angle) {
        var a = Cartesian3.clone(axis);
        var turnAngle = angle || this._moveRate;
        var rotation = Quaternion.fromAxisAngle(a, turnAngle).toRotationMatrix();
        var direction = rotation.multiplyWithVector(this._camera.direction);
        var up = rotation.multiplyWithVector(this._camera.up);
        var right = rotation.multiplyWithVector(this._camera.right);
        this._camera.direction = direction;
        this._camera.up = up;
        this._camera.right = right;
    };

    /**
     * @private
     */
    CameraFreeLookController.prototype.update = function(time) {
        if (this._handler.isMoving()) {
            this._look(this._handler.getMovement());
        }

        return true;
    };

    CameraFreeLookController.prototype._look = function(movement) {
        var camera = this._camera;

        var width = this._canvas.clientWidth;
        var height = this._canvas.clientHeight;

        var tanPhi = Math.tan(camera.frustum.fovy * 0.5);
        var tanTheta = camera.frustum.aspectRatio * tanPhi;
        var near = camera.frustum.near;

        var startNDC = new Cartesian2((2.0 / width) * movement.startPosition.x - 1.0, (2.0 / height) * (height - movement.startPosition.y) - 1.0);
        var endNDC = new Cartesian2((2.0 / width) * movement.endPosition.x - 1.0, (2.0 / height) * (height - movement.endPosition.y) - 1.0);

        var nearCenter = camera.position.add(camera.direction.multiplyWithScalar(near));

        var startX = camera.right.multiplyWithScalar(startNDC.x * near * tanTheta);
        startX = nearCenter.add(startX).subtract(camera.position).normalize();
        var endX = camera.right.multiplyWithScalar(endNDC.x * near * tanTheta);
        endX = nearCenter.add(endX).subtract(camera.position).normalize();

        var dot = startX.dot(endX);
        var angle = 0.0;
        var axis = (this.horizontalRotationAxis) ? this.horizontalRotationAxis : camera.position;
        axis = (movement.startPosition.x > movement.endPosition.x) ? axis : axis.negate();
        axis = axis.normalize();
        if (dot < 1.0) { // dot is in [0, 1]
            angle = -Math.acos(dot);
        }
        var rotation = Quaternion.fromAxisAngle(axis, angle).toRotationMatrix();

        if (1.0 - Math.abs(camera.direction.dot(axis)) > CesiumMath.EPSILON6) {
            camera.direction = rotation.multiplyWithVector(camera.direction);
        }

        if (1.0 - Math.abs(camera.up.dot(axis)) > CesiumMath.EPSILON6) {
            camera.up = rotation.multiplyWithVector(camera.up);
        }

        var startY = camera.up.multiplyWithScalar(startNDC.y * near * tanPhi);
        startY = nearCenter.add(startY).subtract(camera.position).normalize();
        var endY = camera.up.multiplyWithScalar(endNDC.y * near * tanPhi);
        endY = nearCenter.add(endY).subtract(camera.position).normalize();

        dot = startY.dot(endY);
        angle = 0.0;
        axis = startY.cross(endY);
        if (dot < 1.0 && !axis.equalsEpsilon(Cartesian3.getZero(), CesiumMath.EPSILON14)) { // dot is in [0, 1]
            angle = -Math.acos(dot);
        } else { // no rotation
            axis = Cartesian3.getUnitX();
        }
        rotation = Quaternion.fromAxisAngle(axis, angle).toRotationMatrix();

        if (1.0 - Math.abs(camera.direction.dot(axis)) > CesiumMath.EPSILON6) {
            camera.direction = rotation.multiplyWithVector(camera.direction);
        }

        if (1.0 - Math.abs(camera.up.dot(axis)) > CesiumMath.EPSILON6) {
            camera.up = rotation.multiplyWithVector(camera.up);
        }

        camera.right = camera.direction.cross(camera.up);
    };

    /**
      * Returns true if this object was destroyed; otherwise, false.
      * <br /><br />
      * If this object was destroyed, it should not be used; calling any function other than
      * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
      *
      * @memberof CameraFreeLookController
      *
      * @return {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
      *
      * @see CameraFreeLookController#destroy
      */
    CameraFreeLookController.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Removes mouse and keyboard listeners held by this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>null</code>) to the object as done in the example.
     *
     * @memberof CameraFreeLookController
     *
     * @return {null}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CameraFreeLookController#isDestroyed
     *
     * @example
     * controller = controller && controller.destroy();
     */
    CameraFreeLookController.prototype.destroy = function() {
        this._handler = this._handler && this._handler.destroy();
        return destroyObject(this);
    };

    return CameraFreeLookController;
});
/*global define*/
define('Scene/CameraSpindleControllerMode',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * This enumerated type is for describing how the <code>CameraSpindleController</code>
     * will handle mouse events.
     *
     * @exports CameraSpindleControllerMode
     *
     * @see {CameraSpindleController#mode}
     */
    var CameraSpindleControllerMode = {
        /**
         * This mode is useful for rotating around arbitrary ellipsoids.
         *
         * @constant
         * @type {Enumeration}
         */
        ROTATE : new Enumeration(0, "Rotate"),

        /**
         * This mode will cause the controller to rotate around an ellipsoid such that
         * the point under the mouse cursor will remain there when dragged. This mode can only
         * be used for larger ellipsoids like the WGS84 ellipsoid.
         *
         * @constant
         * @type {Enumeration}
         */
        PAN : new Enumeration(1, "Pan"),

        /**
         * This mode will choose the best mode for the mouse input.
         *
         * @constant
         * @type {Enumeration}
         */
        AUTO : new Enumeration(2, "Auto")
    };

    return CameraSpindleControllerMode;
});
/*global define*/
define('Scene/CameraSpindleController',[
        '../Core/destroyObject',
        '../Core/FAR',
        '../Core/Math',
        '../Core/Quaternion',
        '../Core/Ellipsoid',
        '../Core/Cartesian3',
        './CameraEventHandler',
        './CameraEventType',
        './CameraSpindleControllerMode',
        './CameraHelpers'
    ], function(
        destroyObject,
        FAR,
        CesiumMath,
        Quaternion,
        Ellipsoid,
        Cartesian3,
        CameraEventHandler,
        CameraEventType,
        CameraSpindleControllerMode,
        CameraHelpers) {
    

    var handleZoom = CameraHelpers.handleZoom;
    var maintainInertia = CameraHelpers.maintainInertia;
    var zoom = CameraHelpers.zoom;

    /**
     * A type that defines camera behavior: the camera's position and axes will be rotated around the center
     * of the camera's reference frame.
     *
     * @name CameraSpindleController
     *
     * @param {HTMLCanvasElement} canvas An HTML canvas element used for its dimensions
     * and for listening on user events.
     * @param {Camera} camera The camera to use.
     * @param {Ellipsoid} [ellipsoid=WGS84 Ellipsoid] The ellipsoid to move around.
     *
     * @internalConstructor
     */
    function CameraSpindleController(canvas, camera, ellipsoid) {
        ellipsoid = ellipsoid || Ellipsoid.getWgs84();

        this._canvas = canvas;
        this._camera = camera;
        this._ellipsoid = ellipsoid;
        this._zoomRate = 100000.0;
        this._moveRate = Math.PI / 3600.0;

        /**
         * A parameter in the range <code>[0, 1]</code> used to determine how long
         * the camera will continue to spin because of inertia.
         * With a value of one, the camera will spin forever and
         * with value of zero, the camera will have no inertia.
         *
         * @type Number
         */
        this.inertiaSpin = 0.9;

        /**
         * A parameter in the range <code>[0, 1)</code> used to determine how long
         * the camera will continue to zoom because of inertia.
         * With value of zero, the camera will have no inertia.
         *
         * @type Number
         */
        this.inertiaZoom = 0.8;

        /**
         * If set to true, the camera will not be able to rotate past the poles.
         * If this is set to true while in pan mode, the position clicked on the ellipsoid
         * while not always map directly to the cursor.
         *
         * @type Boolean
         *
         * @see CameraSpindleController#mode
         */
        this.mouseConstrainedZAxis = false;

        /**
         * Determines the rotation behavior on mouse events.
         *
         * @type CameraSpindleControllerMode
         */
        this.mode = CameraSpindleControllerMode.AUTO;

        this._zAxis = Cartesian3.getUnitZ();

        var radius = this._ellipsoid.getRadii().getMaximumComponent();
        this._zoomFactor = 5.0;
        this._minimumZoomRate = 20.0;
        this._maximumZoomRate = FAR;
        this._rotateFactor = 1.0 / radius;
        this._rotateRateRangeAdjustment = radius;
        this._maximumRotateRate = 1.77;
        this._minimumRotateRate = 1.0 / 5000.0;

        this._spinHandler = new CameraEventHandler(canvas, CameraEventType.LEFT_DRAG);
        this._zoomHandler = new CameraEventHandler(canvas, CameraEventType.RIGHT_DRAG);
        this._zoomWheel = new CameraEventHandler(canvas, CameraEventType.WHEEL);

        this._lastInertiaSpinMovement = undefined;
        this._lastInertiaZoomMovement = undefined;
        this._lastInertiaWheelZoomMovement = undefined;
    }

    /**
     * DOC_TBA
     *
     * @memberof CameraSpindleController
     *
     * @param {Matrix4} transform DOC_TBA
     * @param {Ellipsoid} [ellipsoid=WGS84 Ellipsoid] DOC_TBA
     *
     * @example
     * // Example 1.
     * // Change the reference frame to one centered at a point on the ellipsoid's surface.
     * // Set the spindle controller's ellipsoid to a unit sphere for easy rotation around that point.
     * var center = ellipsoid.cartographicDegreesToCartesian(new Cartographic2(-75.59777, 40.03883));
     * var transform = Transforms.eastNorthUpToFixedFrame(center);
     * scene.getCamera().getControllers().get(0).setReferenceFrame(transform, Ellipsoid.getUnitSphere());
     *
     * // Example 2.
     * // Reset to the defaults.
     * scene.getCamera().getControllers().get(0).setReferenceFrame(Matrix4.getIdentity());
     *
     */
    CameraSpindleController.prototype.setReferenceFrame = function (transform, ellipsoid) {
        this._camera.transform = transform;
        this.setEllipsoid(ellipsoid);
    };

    /**
     * Returns the ellipsoid that the camera is moving around.
     *
     * @memberof CameraSpindleController
     *
     * @returns {Ellipsoid} The ellipsoid that the camera is moving around.
     *
     * @see CameraSpindleController#setEllipsoid
     */
    CameraSpindleController.prototype.getEllipsoid = function() {
        return this._ellipsoid;
    };

    /**
     * Sets the ellipsoid that the camera is moving around.
     *
     * @memberof CameraSpindleController
     *
     * @param {Ellipsoid} [ellipsoid=WGS84 Ellipsoid] The ellipsoid that the camera is moving around.
     *
     * @see CameraSpindleController#getEllipsoid
     */
    CameraSpindleController.prototype.setEllipsoid = function(ellipsoid) {
        ellipsoid = ellipsoid || Ellipsoid.getWgs84();

        var radius = ellipsoid.getRadii().getMaximumComponent();
        this._ellipsoid = ellipsoid;
        this._rotateFactor = 1.0 / radius;
        this._rotateRateRangeAdjustment = radius;
    };

    /**
     * Rotates the camera around <code>axis</code> by <code>angle</code>. The distance
     * of the camera's position to the center of the camera's reference frame remains the same.
     *
     * @memberof CameraSpindleController
     *
     * @param {Cartesian3} axis The axis to rotate around given in world coordinates.
     * @param {Number} angle The angle, in radians, to rotate by. The direction of rotation is
     * determined by the sign of the angle.
     *
     * @see CameraSpindleController#moveUp
     * @see CameraSpindleController#moveDown
     * @see CameraSpindleController#moveLeft
     * @see CameraSpindleController#moveRight
    */
    CameraSpindleController.prototype.rotate = function(axis, angle) {
        var a = Cartesian3.clone(axis);
        var turnAngle = angle || this._moveRate;
        var rotation = Quaternion.fromAxisAngle(a, turnAngle).toRotationMatrix();

        var camera = this._camera;
        camera.position = rotation.multiplyWithVector(camera.position);
        camera.direction = rotation.multiplyWithVector(camera.direction);
        camera.up = rotation.multiplyWithVector(camera.up);
        camera.right = camera.direction.cross(camera.up);
    };

    /**
     * Rotates the camera around the center of the camera's reference frame by angle downwards.
     *
     * @memberof CameraSpindleController
     *
     * @param {Number} angle The angle to rotate in radians.
     *
     * @see CameraSpindleController#moveUp
     * @see CameraSpindleController#rotate
     */
    CameraSpindleController.prototype.moveDown = function(angle) {
        angle = -angle || -this._moveRate;
        this._moveVertical(angle, false);
    };

    /**
     * Rotates the camera around the center of the camera's reference frame by angle upwards.
     *
     * @memberof CameraSpindleController
     *
     * @param {Number} angle The angle to rotate in radians.
     *
     * @see CameraSpindleController#moveDown
     * @see CameraSpindleController#rotate
     */
    CameraSpindleController.prototype.moveUp = function(angle) {
        angle = angle || this._moveRate;
        this._moveVertical(angle, false);
    };

    /**
     * Rotates the camera around the center of the camera's reference frame by angle downwards
     * and keeps the camera's up vector pointing towards the z-axis.
     *
     * @memberof CameraSpindleController
     *
     * @param {Number} angle The angle to rotate in radians.
     *
     * @see CameraSpindleController#moveUp
     * @see CameraSpindleController#rotate
     */
    CameraSpindleController.prototype.moveDownWithConstrainedZ = function(angle) {
        angle = -angle || -this._moveRate;
        this._moveVertical(angle, true);
    };

    /**
     * Rotates the camera around the center of the camera's reference frame by angle upwards
     * and keeps the camera's up vector pointing towards the z-axis.
     *
     * @memberof CameraSpindleController
     *
     * @param {Number} angle The angle to rotate in radians.
     *
     * @see CameraSpindleController#moveDown
     * @see CameraSpindleController#rotate
     */
    CameraSpindleController.prototype.moveUpWithConstrainedZ = function(angle) {
        angle = angle || this._moveRate;
        this._moveVertical(angle, true);
    };

    CameraSpindleController.prototype._moveVertical = function (angle, constrainedZ) {
        var direction = (angle > 0) ? 1.0 : -1.0;
        if (constrainedZ) {
            var p = this._camera.position.normalize();
            if (CesiumMath.equalsEpsilon(direction, p.dot(this._zAxis), CesiumMath.EPSILON6)) {
                return;
            }

            this.rotate(p.cross(this._zAxis), angle);
        }
        else {
            this.rotate(this._camera.right, angle);
        }
    };

    /**
     * Rotates the camera around the center of the camera's reference frame by angle to the right.
     *
     * @memberof CameraSpindleController
     *
     * @param {Number} angle The angle to rotate in radians.
     *
     * @see CameraSpindleController#moveLeft
     * @see CameraSpindleController#rotate
     */
    CameraSpindleController.prototype.moveRight = function(angle) {
        angle = angle || this._moveRate;
        this._moveHorizontal(angle, false);
    };

    /**
     * Rotates the camera around the center of the camera's reference frame by angle to the left.
     *
     * @memberof CameraSpindleController
     *
     * @param {Number} angle The angle to rotate in radians.
     *
     * @see CameraSpindleController#moveRight
     * @see CameraSpindleController#rotate
     */
    CameraSpindleController.prototype.moveLeft = function(angle) {
        angle = -angle || -this._moveRate;
        this._moveHorizontal(angle, false);
    };

    /**
     * Rotates the camera around the center of the camera's reference frame by angle to the right
     * and keeps the camera's up vector pointing towards the z-axis.
     *
     * @memberof CameraSpindleController
     *
     * @param {Number} angle The angle to rotate in radians.
     *
     * @see CameraSpindleController#moveLeft
     * @see CameraSpindleController#rotate
     */
    CameraSpindleController.prototype.moveRightWithConstrainedZ = function(angle) {
        angle = angle || this._moveRate;
        this._moveHorizontal(angle, true);
    };

    /**
     * Rotates the camera around the center of the camera's reference frame by angle to the left
     * and keeps the camera's up vector pointing towards the z-axis.
     *
     * @memberof CameraSpindleController
     *
     * @param {Number} angle The angle to rotate in radians.
     *
     * @see CameraSpindleController#moveRight
     * @see CameraSpindleController#rotate
     */
    CameraSpindleController.prototype.moveLeftWithConstrainedZ = function(angle) {
        angle = -angle || -this._moveRate;
        this._moveHorizontal(angle, true);
    };

    CameraSpindleController.prototype._moveHorizontal = function(angle, constrainedZ) {
        if (constrainedZ) {
            this.rotate(this._zAxis, angle);
        }
        else {
            this.rotate(this._camera.up, angle);
        }
    };

    /**
     * Translates the camera's position by <code>rate</code> along the camera's view vector.
     *
     * @memberof CameraSpindleController
     *
     * @param {Number} rate The rate to move.
     *
     * @see CameraSpindleController#zoomOut
     */
    CameraSpindleController.prototype.zoomIn = function(rate) {
        zoom(this._camera, rate || this._zoomRate);
    };

    /**
     * Translates the camera's position by <code>rate</code> along the opposite direction of
     * the camera's view vector.
     *
     * @memberof CameraSpindleController
     *
     * @param {Number} rate The rate to move.
     *
     * @see CameraSpindleController#zoomIn
     */
    CameraSpindleController.prototype.zoomOut = function(rate) {
        zoom(this._camera, -rate || -this._zoomRate);
    };

    /**
     * @private
     */
    CameraSpindleController.prototype.update = function() {
        var spin = this._spinHandler;
        var rightZoom = this._zoomHandler;
        var wheelZoom = this._zoomWheel;
        var rotating = spin && spin.isMoving() && spin.getMovement();
        var rightZooming = rightZoom && rightZoom.isMoving();
        var wheelZooming = wheelZoom && wheelZoom.isMoving();

        if (rotating) {
            this._spin(spin.getMovement());
        }

        if (spin && !rotating && this.inertiaSpin < 1.0) {
            maintainInertia(spin, this.inertiaSpin, this._spin, this, '_lastInertiaSpinMovement');
        }

        if (rightZooming) {
            this._zoom(rightZoom.getMovement());
        }
        else if (wheelZooming) {
            this._zoom(wheelZoom.getMovement());
        }

        if (rightZoom && !rightZooming && this.inertiaZoom < 1.0) {
            maintainInertia(rightZoom, this.inertiaZoom, this._zoom, this, '_lastInertiaZoomMovement');
        }

        if (wheelZoom && !wheelZooming && this.inertiaZoom < 1.0) {
            maintainInertia(wheelZoom, this.inertiaZoom, this._zoom, this, '_lastInertiaWheelZoomMovement');
        }

        return true;
    };
    
    CameraSpindleController.prototype._spin = function (movement) {
        if (this.mode === CameraSpindleControllerMode.AUTO) {
            var point = this._camera.pickEllipsoid(this._ellipsoid, movement.startPosition);
            if (point) {
                this._pan(movement);
            }
            else {
                this._rotate(movement);
            }
        }
        else if (this.mode === CameraSpindleControllerMode.ROTATE) {
            this._rotate(movement);
        }
        else {
            this._pan(movement);
        }
    };

    CameraSpindleController.prototype._rotate = function (movement) {
        var position = this._camera.position;
        var rho = position.magnitude();
        var theta = Math.acos(position.z / rho);
        var rotateRate = this._rotateFactor * (rho - this._rotateRateRangeAdjustment);

        if (rotateRate > this._maximumRotateRate) {
            rotateRate = this._maximumRotateRate;
        }

        if (rotateRate < this._minimumRotateRate) {
            rotateRate = this._minimumRotateRate;
        }

        var phiWindowRatio = (movement.endPosition.x - movement.startPosition.x) / this._canvas.clientWidth;
        var thetaWindowRatio = (movement.endPosition.y - movement.startPosition.y) / this._canvas.clientHeight;

        var deltaPhi = -rotateRate * phiWindowRatio * Math.PI * 2.0;
        var deltaTheta = -rotateRate * thetaWindowRatio * Math.PI;

        theta += deltaTheta;

        if (this.mouseConstrainedZAxis && (theta < 0 || theta > Math.PI)) {
            deltaTheta = 0;
        }

        this._moveHorizontal(deltaPhi, this.mouseConstrainedZAxis);
        this._moveVertical(deltaTheta);
    };

    CameraSpindleController.prototype._pan = function (movement) {
        var camera = this._camera;
        var p0 = camera.pickEllipsoid(this._ellipsoid, movement.startPosition);
        var p1 = camera.pickEllipsoid(this._ellipsoid, movement.endPosition);

        if (!p0 || !p1) {
            return;
        }

        if (!this.mouseConstrainedZAxis) {
            p0 = p0.normalize();
            p1 = p1.normalize();
            var dot = p0.dot(p1);
            var axis = p0.cross(p1);
            var angle = 0.0;

            if(dot < 1.0 && !axis.equalsEpsilon(Cartesian3.getZero(), CesiumMath.EPSILON14)) { // dot is in [0, 1]
                angle = -Math.acos(dot);
            } else { // no rotation
                axis = Cartesian3.getUnitX();
            }
            this.rotate(axis, angle);
        }
        else {
            var startRho = p0.magnitude();
            var startPhi = Math.atan2(p0.y, p0.x);
            var startTheta = Math.acos(p0.z / startRho);

            var endRho = p1.magnitude();
            var endPhi = Math.atan2(p1.y, p1.x);
            var endTheta = Math.acos(p1.z / endRho);

            var deltaPhi = startPhi - endPhi;
            var deltaTheta = startTheta - endTheta;

            var theta = Math.acos(camera.position.z / camera.position.magnitude()) + deltaTheta;
            if (theta < 0 || theta > Math.PI) {
                deltaTheta = 0;
            }

            this._moveHorizontal(deltaPhi, this.mouseConstrainedZAxis);

            var normal = camera.right.cross(this._zAxis);
            if (p0.dot(normal) > 0) {
                this._moveVertical(deltaTheta);
            }
        }
    };

   CameraSpindleController.prototype._zoom = function(movement) {
       handleZoom(this, movement, this._ellipsoid.toCartographic3(this._camera.position).height);
   };

   /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof CameraSpindleController
     *
     * @return {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     *
     * @see CameraSpindleController#destroy
     */
    CameraSpindleController.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Removes mouse and keyboard listeners held by this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>null</code>) to the object as done in the example.
     *
     * @memberof CameraSpindleController
     *
     * @return {null}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CameraSpindleController#isDestroyed
     *
     * @example
     * controller = controller && controller.destroy();
     */
    CameraSpindleController.prototype.destroy = function () {
        this._spinHandler = this._spinHandler && this._spinHandler.destroy();
        this._zoomHandler = this._zoomHandler && this._zoomHandler.destroy();
        return destroyObject(this);
    };

    return CameraSpindleController;
});
/*global define*/
define('Scene/CameraColumbusViewController',[
        '../Core/destroyObject',
        '../Core/FAR',
        '../Core/Ellipsoid',
        '../Core/Cartesian3',
        '../Core/Cartesian4',
        '../Core/Matrix4',
        './CameraEventHandler',
        './CameraEventType',
        './CameraSpindleController',
        './CameraFreeLookController',
        './CameraHelpers'
    ], function(
        destroyObject,
        FAR,
        Ellipsoid,
        Cartesian3,
        Cartesian4,
        Matrix4,
        CameraEventHandler,
        CameraEventType,
        CameraSpindleController,
        CameraFreeLookController,
        CameraHelpers) {
    

    var maintainInertia = CameraHelpers.maintainInertia;

    /**
     * DOC_TBD
     * @name CameraColumbusViewController
     * @constructor
     */
    function CameraColumbusViewController(canvas, camera) {
        this._canvas = canvas;
        this._camera = camera;

        /**
         * A parameter in the range <code>[0, 1]</code> used to determine how long
         * the camera will continue to translate because of inertia.
         * With a value of zero, the camera will have no inertia.
         *
         * @type Number
         */
        this.inertiaTranslate = 0.9;

        this._translateFactor = 1.0;
        this._minimumZoomRate = 20.0;
        this._maximumZoomRate = FAR;

        this._translateHandler = new CameraEventHandler(canvas, CameraEventType.LEFT_DRAG);

        this._spindleController = new CameraSpindleController(canvas, camera, Ellipsoid.getUnitSphere());

        // TODO: Shouldn't change private variables like this, need to be able to change event modifiers
        //       on controllers.
        this._spindleController._spinHandler = this._spindleController._spinHandler && this._spindleController._spinHandler.destroy();

        this._freeLookController = new CameraFreeLookController(canvas, camera);
        this._freeLookController.horizontalRotationAxis = Cartesian3.getUnitZ();

        this._transform = this._camera.transform.clone();

        this._lastInertiaTranslateMovement = undefined;
    }

    /**
     * @private
     */
    CameraColumbusViewController.prototype.update = function() {
        var translate = this._translateHandler;
        var translating = translate.isMoving() && translate.getMovement();

        if (translating) {
            this._translate(translate.getMovement());
        }

        if (!translating && this.inertiaTranslate < 1.0) {
            maintainInertia(translate, this.inertiaTranslate, this._translate, this, '_lastInertiaTranslateMovement');
        }

        this._spindleController.update();
        this._freeLookController.update();

        return true;
    };

    CameraColumbusViewController.prototype._translate = function(movement) {
        var camera = this._camera;

        var startRay = camera.getPickRay(movement.startPosition);
        var endRay = camera.getPickRay(movement.endPosition);

        var scalar = -startRay.position.z / startRay.direction.z;
        var startPlanePos = startRay.position.add(startRay.direction.multiplyWithScalar(scalar));
        scalar = -endRay.position.z / endRay.direction.z;
        var endPlanePos = endRay.position.add(endRay.direction.multiplyWithScalar(scalar));

        var diff = startPlanePos.subtract(endPlanePos);
        camera.position = camera.position.add(diff);

        this._updateReferenceFrame();
    };

    CameraColumbusViewController.prototype._updateReferenceFrame = function() {
        var camera = this._camera;

        var position = camera.position;
        var direction = camera.direction;

        var scalar = -position.z / direction.z;
        var center = position.add(direction.multiplyWithScalar(scalar));
        center = new Cartesian4(center.x, center.y, center.z, 1.0);
        var centerWC = camera.transform.multiplyWithVector(center);
        this._transform.setColumn3(centerWC);

        var cameraPosition = new Cartesian4(camera.position.x, camera.position.y, camera.position.z, 1.0);
        var positionWC = camera.transform.multiplyWithVector(cameraPosition);
        camera.transform = this._transform.clone();
        camera.position = camera.getInverseTransform().multiplyWithVector(positionWC).getXYZ();
    };

    /**
      * Returns true if this object was destroyed; otherwise, false.
      * <br /><br />
      * If this object was destroyed, it should not be used; calling any function other than
      * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
      *
      * @memberof CameraColumbusViewController
      *
      * @return {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
      *
      * @see CameraSpindleController#destroy
      */
    CameraColumbusViewController.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Removes mouse and keyboard listeners held by this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>null</code>) to the object as done in the example.
     *
     * @memberof CameraColumbusViewController
     *
     * @return {null}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CameraColumbusViewController#isDestroyed
     *
     * @example
     * controller = controller && controller.destroy();
     */
    CameraColumbusViewController.prototype.destroy = function() {
        this._translateHandler = this._translateHandler && this._translateHandler.destroy();
        this._spindleController = this._spindleController && this._spindleController.destroy();
        this._freeLookController = this._freeLookController && this._freeLookController.destroy();
        return destroyObject(this);
    };

    return CameraColumbusViewController;
});
/*global define*/
define('Scene/CameraControllerCollection',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/Ellipsoid',
        '../Core/Cartographic3',
        './Camera2DController',
        './CameraFlightController',
        './CameraSpindleController',
        './CameraFreeLookController',
        './CameraColumbusViewController'
    ], function(
        DeveloperError,
        destroyObject,
        Ellipsoid,
        Cartographic3,
        Camera2DController,
        CameraFlightController,
        CameraSpindleController,
        CameraFreeLookController,
        CameraColumbusViewController) {
    

    /**
     * DOC_TBA
     *
     * @name CameraControllerCollection
     * @internalConstructor
     *
     * @see Camera#getControllers
     */
    function CameraControllerCollection(camera, canvas) {
        this._controllers = [];
        this._canvas = canvas;
        this._camera = camera;
    }

    /**
     * DOC_TBA
     *
     * @memberof CameraControllerCollection
     *
     * @see CameraControllerCollection#addFreeLook
     * @see CameraControllerCollection#addFlight
     * @see CameraControllerCollection#addSpindle
     * @see CameraControllerCollection#addColumbusView
     */
    CameraControllerCollection.prototype.add2D = function(ellipsoid) {
        var twoD = new Camera2DController(this._canvas, this._camera, ellipsoid);
        this._controllers.push(twoD);
        return twoD;
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraControllerCollection
     *
     * @see CameraControllerCollection#addFreeLook
     * @see CameraControllerCollection#addFlight
     * @see CameraControllerCollection#add2D
     * @see CameraControllerCollection#addColumbusView
     */
    CameraControllerCollection.prototype.addSpindle = function(ellipsoid) {
        var spindle = new CameraSpindleController(this._canvas, this._camera, ellipsoid);
        this._controllers.push(spindle);
        return spindle;
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraControllerCollection
     *
     * @see CameraControllerCollection#addSpindle
     * @see CameraControllerCollection#addFlight
     * @see CameraControllerCollection#add2D
     * @see CameraControllerCollection#addColumbusView
     */
    CameraControllerCollection.prototype.addFreeLook = function(ellipsoid) {
        var freeLook = new CameraFreeLookController(this._canvas, this._camera);
        this._controllers.push(freeLook);
        return freeLook;
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraControllerCollection
     *
     * @see CameraControllerCollection#addSpindle
     * @see CameraControllerCollection#addFlight
     * @see CameraControllerCollection#add2D
     * @see CameraControllerCollection#addFreeLook
     */
    CameraControllerCollection.prototype.addColumbusView = function() {
        var cv = new CameraColumbusViewController(this._canvas, this._camera);
        this._controllers.push(cv);
        return cv;
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraControllerCollection
     *
     * @see CameraControllerCollection#addSpindle
     * @see CameraControllerCollection#addFreeLook
     * @see CameraControllerCollection#add2D
     * @see CameraControllerCollection#addColumbusView
     */
    CameraControllerCollection.prototype.addFlight = function(template) {
        var t = template || {};
        var ellipsoid = t.ellipsoid || Ellipsoid.getWgs84();
        var destination = t.destination || Ellipsoid.getWgs84().cartographicDegreesToCartesian(new Cartographic3(0.0, 0.0, 0.0));
        var duration = t.duration || 4.0;
        var complete = template.complete;
		var flightController = new CameraFlightController(this._canvas, this._camera, ellipsoid, destination, duration, complete);
		this._controllers.push(flightController);
		return flightController;
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraControllerCollection
     *
     * @see CameraControllerCollection#removeAll
     */
    CameraControllerCollection.prototype.remove = function(controller) {
        if (controller) {
            var controllers = this._controllers;
            var i = controllers.indexOf(controller);
            if (i !== -1) {
                controllers[i].destroy();
                controllers.splice(i, 1);
                return true;
            }
        }

        return false;
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraControllerCollection
     *
     * @see CameraControllerCollection#remove
     */
    CameraControllerCollection.prototype.removeAll = function() {
        var controllers = this._controllers;
        var length = controllers.length;
        for ( var i = 0; i < length; ++i) {
            controllers[i].destroy();
        }

        this._controllers = [];
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraControllerCollection
     */
    CameraControllerCollection.prototype.contains = function(controller) {
        if (controller) {
            return (this._controllers.indexOf(controller) !== -1);
        }

        return false;
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraControllerCollection
     *
     * @see CameraControllerCollection#getLength
     */
    CameraControllerCollection.prototype.get = function(index) {
        if (typeof index === "undefined") {
            throw new DeveloperError("index is required.", "index");
        }

        return this._controllers[index];
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraControllerCollection
     *
     * @see CameraControllerCollection#get
     */
    CameraControllerCollection.prototype.getLength = function() {
        return this._controllers.length;
    };

    /**
     * @private
     */
    CameraControllerCollection.prototype.update = function() {
        var toRemove = [];

        var controllers = this._controllers;
        var length = controllers.length;
        for ( var i = 0; i < length; ++i) {
            if (!controllers[i].update()) {
                toRemove.push(i);
            }
        }

        // Automatically remove expired controllers
        for ( var j = 0; j < toRemove.length; ++j) {
            var index = toRemove[j];
            controllers[index].destroy();
            controllers.splice(index, 1);
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraControllerCollection
     */
    CameraControllerCollection.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraControllerCollection
     */
    CameraControllerCollection.prototype.destroy = function() {
        this.removeAll();
        return destroyObject(this);
    };

    return CameraControllerCollection;
});

/*global define*/
define('Scene/CompositePrimitive',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/createGuid'
    ], function(
        DeveloperError,
        destroyObject,
        createGuid) {
    

    // PERFORMANCE_IDEA: Add hierarchical culling and state sorting.

    /**
     * DOC_TBA
     *
     * @name CompositePrimitive
     * @constructor
     *
     * @example
     * // Example 1. Add primitives to a composite.
     * var primitives = new CompositePrimitive();
     * primitives.setCentralBody(new CentralBody());
     * primitives.add(billboards);
     * primitives.add(labels);
     *
     * //////////////////////////////////////////////////////////////////
     *
     * // Example 2. Create composites of composites.
     * var children = new CompositePrimitive();
     * children.add(billboards);
     *
     * var parent = new CompositePrimitive();
     * parent.add(children);    // Add composite
     * parent.add(labels);      // Add regular primitive
     */
    function CompositePrimitive() {
        this._centralBody = null;
        this._primitives = [];
        this._guid = createGuid();

        /**
         * DOC_TBA
         *
         * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
         *
         * @see CompositePrimitive#destroy
         * @see CompositePrimitive#setCentralBody
         * @see CompositePrimitive#remove
         * @see CompositePrimitive#removeAll
         *
         * @example
         * // Example 1. Primitives are destroyed by default.
         * var primitives = new CompositePrimitive();
         * primitives.add(labels);
         * primitives = primitives.destroy();
         * var b = labels.isDestroyed(); // true
         *
         * //////////////////////////////////////////////////////////////////
         *
         * // Example 2. Do not destroy primitives in a composite.
         * var primitives = new CompositePrimitive();
         * primitives.destroyPrimitives = false;
         * primitives.add(labels);
         * primitives = primitives.destroy();
         * var b = labels.isDestroyed(); // false
         * labels = labels.destroy();    // explicitly destroy
         */
        this.destroyPrimitives = true;

        /**
         * Determines if primitives in this composite will be shown.
         *
         * @type Boolean
         */
        this.show = true;
    }

    /**
     * DOC_TBA
     *
     * @memberof CompositePrimitive
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CompositePrimitive#setCentralBody
     */
    CompositePrimitive.prototype.getCentralBody = function() {
        return this._centralBody;
    };

    /**
     * DOC_TBA
     *
     * Implicitly sets the depth-test ellipsoid.
     *
     * @memberof CompositePrimitive
     *
     * @see CompositePrimitive#depthTestEllipsoid
     * @see CompositePrimitive#getCentralBody
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @example
     * var primitives = new CompositePrimitive();
     * primitives.setCentralBody(new CentralBody());
     */
    CompositePrimitive.prototype.setCentralBody = function(centralBody) {
        this._centralBody = this.destroyPrimitives && this._centralBody && this._centralBody.destroy();
        this._centralBody = centralBody;
    };

    /**
     * DOC_TBA
     *
     * @memberof CompositePrimitive
     *
     * @param {Object} primitive DOC_TBA
     *
     * @exception {DeveloperError} primitive is required.
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CompositePrimitive#add
     *
     * @example
     * primitives.add(billboards);
     * primitives.add(labels);
     */
    CompositePrimitive.prototype.add = function(primitive) {
        if (!primitive) {
            throw new DeveloperError("primitive is required.", "primitive");
        }

        var external = (primitive._external = primitive._external || {});
        var composites = (external._composites = external._composites || {});
        composites[this._guid] = {
            composite : this
        };

        this._primitives.push(primitive);
    };

    /**
     * DOC_TBA
     *
     * @memberof CompositePrimitive
     *
     * @param {Object} primitive DOC_TBA
     *
     * @return {Boolean} <code>true</code> if the primitive was removed; <code>false</code> if the primitive was not found in the composite.
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CompositePrimitive#removeAll
     *
     * @example
     * primitives.add(p);
     * primitives.remove(p);  // Returns true
     */
    CompositePrimitive.prototype.remove = function(primitive) {
        // PERFORMANCE_IDEA:  We can obviously make this a lot faster.
        if (this.contains(primitive)) {
            var index = this._primitives.indexOf(primitive);
            if (index !== -1) {
                this._primitives.splice(index, 1);

                delete primitive._external._composites[this._guid];

                if (this.destroyPrimitives) {
                    primitive.destroy();
                }

                return true;
            }
            // else ... this is not possible, I swear.
        }

        return false;
    };

    /**
     * DOC_TBA
     *
     * @memberof CompositePrimitive
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CompositePrimitive#remove
     *
     * @example
     * primitives.add(...);
     * primitives.add(...);
     * primitives.removeAll();
     */
    CompositePrimitive.prototype.removeAll = function() {
        if (this.destroyPrimitives) {
            var primitives = this._primitives;
            var length = primitives.length;
            for ( var i = 0; i < length; ++i) {
                primitives[i].destroy();
            }
        }
        this._primitives = [];
    };

    /**
     * DOC_TBA
     *
     * @memberof CompositePrimitive
     *
     * Does not include central body.
     *
     * @param {Object} primitive DOC_TBA
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CompositePrimitive#get
     */
    CompositePrimitive.prototype.contains = function(primitive) {
        return !!(primitive &&
                  primitive._external &&
                  primitive._external._composites &&
                  primitive._external._composites[this._guid]);
    };

    CompositePrimitive.prototype._getPrimitiveIndex = function(primitive) {
        if (!this.contains(primitive)) {
            throw new DeveloperError("primitive is not in this composite.", "primitive");
        }

        return this._primitives.indexOf(primitive);
    };

    /**
     * DOC_TBA
     *
     * @memberof CompositePrimitive
     *
     * @exception {DeveloperError} primitive is not in this composite.
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CompositePrimitive#bringToFront
     * @see CompositePrimitive#sendBackward
     * @see CompositePrimitive#sendToBack
     * @see CompositePrimitive#addGround
     */
    CompositePrimitive.prototype.bringForward = function(primitive) {
        if (primitive) {
            var index = this._getPrimitiveIndex(primitive);
            var primitives = this._primitives;

            if (index !== primitives.length - 1) {
                var p = primitives[index];
                primitives[index] = primitives[index + 1];
                primitives[index + 1] = p;
            }
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof CompositePrimitive
     *
     * @exception {DeveloperError} primitive is not in this composite.
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CompositePrimitive#bringForward
     * @see CompositePrimitive#sendBackward
     * @see CompositePrimitive#sendToBack
     * @see CompositePrimitive#addGround
     */
    CompositePrimitive.prototype.bringToFront = function(primitive) {
        if (primitive) {
            var index = this._getPrimitiveIndex(primitive);
            var primitives = this._primitives;

            if (index !== primitives.length - 1) {
                // PERFORMANCE_IDEA:  Could be faster
                primitives.splice(index, 1);
                primitives.push(primitive);
            }
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof CompositePrimitive
     *
     * @exception {DeveloperError} primitive is not in this composite.
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CompositePrimitive#sendToBack
     * @see CompositePrimitive#bringForward
     * @see CompositePrimitive#bringToFront
     * @see CompositePrimitive#addGround
     */
    CompositePrimitive.prototype.sendBackward = function(primitive) {
        if (primitive) {
            var index = this._getPrimitiveIndex(primitive);
            var primitives = this._primitives;

            if (index !== 0) {
                var p = primitives[index];
                primitives[index] = primitives[index - 1];
                primitives[index - 1] = p;
            }
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof CompositePrimitive
     *
     * @exception {DeveloperError} primitive is not in this composite.
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CompositePrimitive#sendBackward
     * @see CompositePrimitive#bringForward
     * @see CompositePrimitive#bringToFront
     * @see CompositePrimitive#addGround
     */
    CompositePrimitive.prototype.sendToBack = function(primitive) {
        if (primitive) {
            var index = this._getPrimitiveIndex(primitive);
            var primitives = this._primitives;

            if (index !== 0) {
                // PERFORMANCE_IDEA:  Could be faster
                primitives.splice(index, 1);
                primitives.unshift(primitive);
            }
        }
    };

    /**
     * DOC_TBA
     *
     * The index is based on the order the primitives were added to the composite.
     *
     * @memberof CompositePrimitive
     *
     * @exception {DeveloperError} index is required.
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CompositePrimitive#getLength
     *
     * @example
     * // Toggle the show property of every primitive in the composite -
     * // not recursive on child composites.
     * var len = primitives.getLength();
     * for (var i = 0; i < len; ++i) {
     *   var p = primitives.get(i);
     *   p.show = !p.show;
     * }
     */
    CompositePrimitive.prototype.get = function(index) {
        if (typeof index === "undefined") {
            throw new DeveloperError("index is required.", "index");
        }

        return this._primitives[index];
    };

    /**
     * DOC_TBA
     *
     * @memberof CompositePrimitive
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CompositePrimitive#get
     *
     * @example
     * // Toggle the show property of every primitive in the composite -
     * // not recursive on child composites.
     * var len = primitives.getLength();
     * for (var i = 0; i < len; ++i) {
     *   var p = primitives.get(i);
     *   p.show = !p.show;
     * }
     */
    CompositePrimitive.prototype.getLength = function() {
        return this._primitives.length;
    };

    /**
     * @private
     */
    CompositePrimitive.prototype.update = function(context, sceneState) {
        if (this.show) {
            if (this._centralBody) {
                this._centralBody.update(context, sceneState);
            }

            var primitives = this._primitives;
            var length = primitives.length;
            for ( var i = 0; i < length; ++i) {
                primitives[i].update(context, sceneState);
            }
        }
    };

    /**
     * DOC_TBA
     * @memberof CompositePrimitive
     */
    CompositePrimitive.prototype.render = function(context) {
        if (this.show) {
            var cb = this._centralBody;
            var primitives = this._primitives;
            var primitivesLen = primitives.length;

            if (cb) {
                cb.render(context);
            }
            for ( var i = 0; i < primitivesLen; ++i) {
                var primitive = primitives[i];
                primitive.render(context);
            }
        }
    };

    /**
     * @private
     */
    CompositePrimitive.prototype.updateForPick = function(context) {
        if (this.show) {
            if (this._centralBody && this._centralBody.updateForPick) {
                this._centralBody.updateForPick(context);
            }

            var primitives = this._primitives;
            var length = primitives.length;
            for ( var i = 0; i < length; ++i) {
                var primitive = primitives[i];
                if (primitive.updateForPick) {
                    primitives[i].updateForPick(context);
                }
            }
        }
    };

    /**
     * DOC_TBA
     * @memberof CompositePrimitive
     */
    CompositePrimitive.prototype.renderForPick = function(context, framebuffer) {
        if (this.show) {
            var cb = this._centralBody;
            var primitives = this._primitives;
            var primitivesLen = primitives.length;

            if (cb) {
                cb.renderForPick(context, framebuffer);
            }
            for ( var i = 0; i < primitivesLen; ++i) {
                var primitive = primitives[i];
                if (primitive.renderForPick) {
                    primitive.renderForPick(context, framebuffer);
                }
            }
        }
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof CompositePrimitive
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see CompositePrimitive#destroy
     */
    CompositePrimitive.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by each primitive in this composite.  Explicitly destroying this
     * composite allows for deterministic release of WebGL resources, instead of relying on the garbage
     * collector to destroy this composite.
     * <br /><br />
     * Since destroying a composite destroys all the contained primitives, only destroy a composite
     * when you are sure no other code is still using any of the contained primitives.
     * <br /><br />
     * Once this composite is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>null</code>) to the object as done in the example.
     *
     * @memberof CompositePrimitive
     *
     * @return {null}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CompositePrimitive#isDestroyed
     *
     * @example
     * primitives = primitives && primitives.destroy();
     */
    CompositePrimitive.prototype.destroy = function() {
        this.removeAll();

        this._centralBody = this.destroyPrimitives && this._centralBody && this._centralBody.destroy();

        return destroyObject(this);
    };

    return CompositePrimitive;
});
/*global define*/
define('Scene/CompositeTileProvider',[
        '../Core/DeveloperError',
        '../Core/Ellipsoid'
    ], function(
        DeveloperError,
        Ellipsoid) {
    

    /**
     * A container for tile providers that will change based of the altitude of the camera.
     *
     * @name CompositeTileProvider
     * @constructor
     *
     * @param {Array} list An array of objects with provider and height attributes. The height attribute determines
     * the minimum height at which to use the accompanying provider.
     * @param {Camera} camera The camera.
     * @param {Ellipsoid} ellipsoid An ellipsoid to test the altitude against. Defaults to a WGS84 ellipsoid.
     *
     * @exception {DeveloperError} A non-empty list is required.
     * @exception {DeveloperError} camera is required.
     *
     * @see SingleTileProvider
     * @see ArcGISTileProvider
     * @see OpenStreetMapTileProvider
     * @see BingMapsTileProvider
     *
     * @example
     * // Create a CompositeTileProvider from a SingleTileProvider and BingMapsTileProvider
     *
     * // Single
     *  var single = new SingleTileProvider("Images/NE2_50M_SR_W_4096.jpg");
     *  // Bing Maps
     *  var bing = new BingMapsTileProvider({
     *      server : "dev.virtualearth.net",
     *      mapStyle : BingMapsStyle.AERIAL
     *  });
     *  // Composite
     *  var composite = new CompositeTileProvider([
     *      { provider : single, height : 1000000 },
     *      { provider : bing, height : 0}
     *  ], scene.getCamera(), ellipsoid);
     *
     */
    function CompositeTileProvider(list, camera, ellipsoid) {
        if (!list) {
            throw new DeveloperError("A non-empty list is required.", "list");
        }

        if (!camera) {
            throw new DeveloperError("camera is required.", "camera");
        }

        this._camera = camera;

        ellipsoid = ellipsoid || Ellipsoid.getWgs84();
        this._radius = ellipsoid.getMaximumRadius();

        this._list = list;
        this._list.sort(CompositeTileProvider._compare);

        /**
         * The cartographic extent of the base tile, with north, south, east and
         * west properties in radians.
         *
         * @constant
         * @type {Object}
         */
        this.maxExtent = this._list[0].provider.maxExtent;

        /**
         * The minimum zoom level that can be requested.
         *
         * @constant
         * @type {Number}
         */
        this.zoomMin = this._list[0].provider.zoomMin;

        /**
         * The maximum zoom level that can be requested.
         *
         * @constant
         * @type {Number}
         */
        this.zoomMax = this._list[this._list.length - 1].provider.zoomMax;

        /**
         * The smallest width of any image loaded.
         *
         * @type {Number}
         */
        this.tileWidth = Number.MAX_VALUE;

        /**
         * The smallest height of any image loaded.
         *
         * @type {Number}
         */
        this.tileHeight = Number.MAX_VALUE;

        // TODO: good idea?
        for ( var i = 0; i < this._list.length; ++i) {
            var provider = this._list[i].provider;
            if (provider.tileHeight < this.tileHeight || provider.tileWidth < this.tileWidth) {
                this.tileHeight = provider.tileHeight;
                this.tileWidth = provider.tileWidth;
            }
        }

        if (this.tileWidth === Number.MAX_VALUE) {
            this.tileWidth = null;
        }
        if (this.tileHeight === Number.MAX_VALUE) {
            this.tileHeight = null;
        }
    }

    CompositeTileProvider._compare = function(a, b) {
        return b.height - a.height;
    };

    /**
     * Loads the top-level tile.
     *
     * @memberof CompositeTileProvider
     *
     * @param {Tile} tile The top-level tile.
     * @param {Function} onload A function that will be called when the image is finished loading.
     * @param {Function} onerror A function that will be called if there is an error loading the image.
     * @param {Function} oninvalid A function that will be called if the image loaded is not valid.
     *
     * @exception {DeveloperError} <code>tile.zoom</code> is less than <code>zoomMin</code>
     * or greater than <code>zoomMax</code>.
     */
    CompositeTileProvider.prototype.loadTileImage = function(tile, onload, onerror, oninvalid) {
        if (tile.zoom < this.zoomMin || tile.zoom > this.zoomMax) {
            throw new DeveloperError("The zoom must be between in [zoomMin, zoomMax].", "tile.zoom");
        }

        var height = this._camera.position.magnitude() - this._radius;
        var provider = null;
        var image = null;
        for ( var i = 0; i < this._list.length; ++i) {
            var val = this._list[i];
            provider = val.provider;
            if (val.height < height) {
                break;
            }
        }

        if (tile.zoom >= provider.zoomMin && tile.zoom <= provider.zoomMax) {
            image = provider.loadTileImage(tile, onload, onerror, oninvalid);
            tile.projection = provider.projection;
        } else {
            if (oninvalid && typeof oninvalid === "function") {
                oninvalid();
            }
        }

        return image;
    };

    return CompositeTileProvider;
});
/*global define*/
define('Scene/EulerSolver',[],function() {
    

    function EulerSolver() {
    }

    // TODO: adaptive step-size
    EulerSolver.step = function(particleSystem, timeStep) {
        if (particleSystem) {
            timeStep = timeStep || 1.0;

            var derivativeVector = particleSystem.calculateDerivative();
            EulerSolver._scaleVector(derivativeVector, timeStep);

            var stateVector = particleSystem.getState();
            EulerSolver._addVectors(stateVector, derivativeVector);

            particleSystem.setState(stateVector);
            particleSystem.time += timeStep;
        }
    };

    EulerSolver._scaleVector = function(vector, scalar) {
        var length = vector.length;
        for ( var i = 0; i < length; ++i) {
            vector[i] *= scalar;
        }
    };

    EulerSolver._addVectors = function(vector, incrementVector) {
        var length = vector.length;
        for ( var i = 0; i < length; ++i) {
            vector[i] += incrementVector[i];
        }
    };

    // TODO:  Midpoint and 4th-order Runge-Kutta solvers
    return EulerSolver;
});
/*global define*/
define('Scene/GravityForce',['../Core/Ellipsoid'], function(Ellipsoid) {
    

    /**
     * DOC_TBA
     *
     * @name GravityForce
     * @constructor
     */
    function GravityForce(template) {
        template = template || {};
        this.ellipsoid = template.ellipsoid || Ellipsoid.getWgs84();
        this.gravitationalConstant = template.gravitationalConstant || 1.0;
    }

    /**
     * DOC_TBA
     * @memberof GravityForce
     */
    GravityForce.prototype.apply = function(particles) {
        if (particles) {
            var ellipsoid = this.ellipsoid;
            var gravitationalConstant = this.gravitationalConstant;

            var length = particles.length;
            for ( var i = 0; i < length; ++i) {
                var particle = particles[i];

                var positionOnSurface = ellipsoid.scaleToGeodeticSurface(particle.position);
                var upNormal = ellipsoid.geodeticSurfaceNormal(positionOnSurface);
                var downNormal = upNormal.negate();
                var force = downNormal.multiplyWithScalar(gravitationalConstant);

                particle.force = particle.force.add(force.multiplyWithScalar(particle.mass)); // f += m * g
            }
        }
    };

    return GravityForce;
});
/*global define*/
define('Scene/HorizontalOrigin',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * The horizontal location of an origin relative to an object, e.g., a {@link Billboard}.
     * For example, the horizontal origin is used to display a billboard to the left or right (in
     * screen space) of the actual position.
     *
     * @exports HorizontalOrigin
     *
     * @see Billboard#setHorizontalOrigin
     */
    var HorizontalOrigin = {
        /**
         * The origin is at the horizontal center of the object.
         *
         * @constant
         * @type {Enumeration}
         */
        CENTER : new Enumeration(0, "CENTER"),
        /**
         * The origin is on the left side of the object.
         *
         * @constant
         * @type {Enumeration}
         */
        LEFT : new Enumeration(1, "LEFT"),
        /**
         * The origin is on the right side of the object.
         *
         * @constant
         * @type {Enumeration}
         */
        RIGHT : new Enumeration(-1, "RIGHT")
    };

    return HorizontalOrigin;
});
/*global define*/
define('Scene/LabelStyle',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports LabelStyle
     *
     * @see Label#setStyle
     */
    var LabelStyle = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        FILL : new Enumeration(0, "FILL"),
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        OUTLINE : new Enumeration(1, "OUTLINE"),
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        FILL_AND_OUTLINE : new Enumeration(2, "FILL_AND_OUTLINE")
    };

    return LabelStyle;
});
/*global define*/
define('Scene/OrthographicFrustum',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/Cartesian3',
        '../Core/Cartesian4',
        '../Core/Matrix4'
    ], function(
        DeveloperError,
        destroyObject,
        Cartesian3,
        Cartesian4,
        Matrix4) {
    

    /**
     * The viewing frustum is defined by 6 planes.
     * Each plane is represented by a {Cartesian4} object, where the x, y, and z components
     * define the unit vector normal to the plane, and the w component is the distance of the
     * plane from the origin/camera position.
     *
     * @name OrthographicFrustum
     * @constructor
     *
     * @example
     * var maxRadii = ellipsoid.getMaximumRadius();
     *
     * var frustum = new OrthographicFrustum();
     * frustum.right = maxRadii * CesiumMath.PI;
     * frustum.left = -c.frustum.right;
     * frustum.top = c.frustum.right * (canvas.clientHeight / canvas.clientWidth);
     * frustum.bottom = -c.frustum.top;
     * frustum.near = 0.01 * maxRadii;
     * frustum.far = 50.0 * maxRadii;
     */
    function OrthographicFrustum() {
        /**
         * DOC_TBA
         *
         * @type {Number}
         */
        this.left = null;
        this._left = null;

        /**
         * DOC_TBA
         *
         * @type {Number}
         */
        this.right = null;
        this._right = null;

        /**
         * DOC_TBA
         *
         * @type {Number}
         */
        this.top = null;
        this._top = null;

        /**
         * DOC_TBA
         *
         * @type {Number}
         */
        this.bottom = null;
        this._bottom = null;

        /**
         * The distance of the near plane from the camera's position.
         *
         * @type {Number}
         */
        this.near = null;
        this._near = null;

        /**
         * The The distance of the far plane from the camera's position.
         *
         * @type {Number}
         */
        this.far = null;
        this._far = null;

        this._orthographicMatrix = null;
    }

    /**
     * Returns the orthographic projection matrix computed from the view frustum.
     *
     * @memberof OrthographicFrustum
     *
     * @return {Matrix4} The orthographic projection matrix.
     *
     * @see OrthographicFrustum#getInfiniteProjectionMatrix
     */
    OrthographicFrustum.prototype.getProjectionMatrix = function() {
        this._update();
        return this._orthographicMatrix;
    };

    OrthographicFrustum.prototype._update = function() {
        if (this.left === null || this.right === null || this.top === null || this.bottom === null || this.near === null || this.far === null) {
            throw new DeveloperError("The frustum parameters are not set.", "left, right, top, bottom, near, or far");
        }

        if (this.left !== this._left || this.right !== this._right || this.top !== this._top || this.bottom !== this._bottom || this.near !== this._near || this.far !== this._far) {
            if (this.left > this.right) {
                throw new DeveloperError("right must be greater than left.", "right");
            }

            if (this.bottom > this.top) {
                throw new DeveloperError("top must be greater than bottom.", "top");
            }

            if (this.near < 0 || this.near > this.far) {
                throw new DeveloperError("near must be greater than zero and less than far.", "near");
            }

            this._left = this.left;
            this._right = this.right;
            this._top = this.top;
            this._bottom = this.bottom;
            this._near = this.near;
            this._far = this.far;

            this._updateProjectionMatrices();
        }
    };

    OrthographicFrustum.prototype._updateProjectionMatrices = function() {
        this._orthographicMatrix = Matrix4.createOrthographicOffCenter(this.left, this.right, this.bottom, this.top, this.near, this.far);
    };

    /**
     * DOC_TBA
     *
     * @memberof OrthographicFrustum
     *
     * @param {Cartesian3} position The eye position.
     * @param {Cartesian3} direction The view direction.
     * @param {Cartesian3} up The up direction.
     *
     * @exception {DeveloperError} position is required.
     * @exception {DeveloperError} direction is required.
     * @exception {DeveloperError} up is required.
     */
    OrthographicFrustum.prototype.getPlanes = function(position, direction, up) {
        if (!position) {
            throw new DeveloperError("position is required.", "position");
        }

        if (!direction) {
            throw new DeveloperError("direction is required.", "direction");
        }

        if (!up) {
            throw new DeveloperError("up is required.", "up");
        }

        var pos = Cartesian3.clone(position);
        var dir = Cartesian3.clone(direction);
        var u = Cartesian3.clone(up);

        var right = dir.cross(u);

        var planes = [];
        planes.length = 6;

        var planePoint;
        var nearCenter = pos.add(dir.multiplyWithScalar(this.near));

        // Left plane
        planePoint = nearCenter.add(right.multiplyWithScalar(this.left));
        planes[0] = new Cartesian4(right.x, right.y, right.z, -right.dot(planePoint));

        // Right plane
        planePoint = nearCenter.add(right.multiplyWithScalar(this.right));
        planes[1] = new Cartesian4(-right.x, -right.y, -right.z, -right.negate().dot(planePoint));

        // Bottom plane
        planePoint = nearCenter.add(u.multiplyWithScalar(this.bottom));
        planes[2] = new Cartesian4(u.x, u.y, u.z, -u.dot(planePoint));

        // Top plane
        planePoint = nearCenter.add(u.multiplyWithScalar(this.top));
        planes[3] = new Cartesian4(-u.x, -u.y, -u.z, -u.negate().dot(planePoint));

        // Near plane
        planes[4] = new Cartesian4(direction.x, direction.y, direction.z, -direction.dot(nearCenter));

        // Far plane
        planePoint = position.add(direction.multiplyWithScalar(this.far));
        planes[5] = new Cartesian4(-direction.x, -direction.y, -direction.z, -direction.negate().dot(planePoint));

        return planes;
    };

    /**
     * Returns a duplicate of a OrthographicFrustum instance.
     *
     * @memberof OrthographicFrustum
     *
     * @return {OrthographicFrustum} A new copy of the OrthographicFrustum instance.
     */
    OrthographicFrustum.prototype.clone = function() {
        var frustum = new OrthographicFrustum();
        frustum.left = this.left;
        frustum.right = this.right;
        frustum.top = this.top;
        frustum.bottom = this.bottom;
        frustum.near = this.near;
        frustum.far = this.far;
        return frustum;
    };

    /**
     * DOC_TBA
     *
     * @memberof OrthographicFrustum
     */
    OrthographicFrustum.prototype.equals = function(other) {
        return (this.left === other.left &&
                this.right === other.right &&
                this.top === other.top &&
                this.bottom === other.bottom &&
                this.near === other.near &&
                this.far === other.far);
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof OrthographicFrustum
     *
     * @return {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     *
     * @see OrthographicFrustum#destroy
     */
    OrthographicFrustum.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Removes keyboard listeners held by this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>null</code>) to the object as done in the example.
     *
     * @memberof OrthographicFrustum
     *
     * @return {null}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see OrthographicFrustum#isDestroyed
     *
     * @example
     * frustum = frustum && frustum.destroy();
     */
    OrthographicFrustum.prototype.destroy = function() {
        return destroyObject(this);
    };

    return OrthographicFrustum;
});
/*global define*/
define('Scene/Particle',[
        '../Core/DeveloperError',
        '../Core/Cartesian3'
    ], function(
        DeveloperError,
        Cartesian3) {
    

    /**
     * DOC_TBA
     * @name Particle
     * @constructor
     */
    function Particle(template) {
        template = template || {};
        template.position = template.position || Cartesian3.getZero();
        template.velocity = template.velocity || Cartesian3.getZero(); // initial velocity
        template.mass = (typeof template.mass === "undefined") ? 1.0 : template.mass;

        if (template.mass < 0) {
            throw new DeveloperError("template.mass must be positive.", "template");
        }

        this.position = new Cartesian3(template.position.x, template.position.y, template.position.z);
        this.velocity = new Cartesian3(template.velocity.x, template.velocity.y, template.velocity.z);
        this.mass = template.mass;
        this.force = Cartesian3.getZero(); // force accumulator
    }

    return Particle;
});
/*global define*/
define('Scene/ParticleSystem',[
        '../Core/DeveloperError',
        '../Core/Cartesian3'
    ], function(
        DeveloperError,
        Cartesian3) {
    
    /*global Float64Array*/

    // TODO:  This file belongs in Core, not here.
    // TODO:  Cloth simulation abstraction built on top of particle system

    // Particle system based on:  http://www.cs.cmu.edu/~baraff/sigcourse/

    /**
     * DOC_TBA
     *
     * @name ParticleSystem
     * @constructor
     */
    function ParticleSystem() {
        this.particles = [];
        this.forces = [];
        this.time = 0.0;
    }

    ParticleSystem.prototype._clearForces = function() {
        var particles = this.particles;
        var length = particles.length;
        for ( var i = 0; i < length; ++i) {
            particles[i].force = Cartesian3.getZero();
        }
    };

    ParticleSystem.prototype._calculateForces = function() {
        var particles = this.particles;
        var forces = this.forces;
        var length = forces.length;
        for ( var i = 0; i < length; ++i) {
            forces[i].apply(particles);
        }
    };

    /**
     * DOC_TBA
     * @memberof ParticleSystem
     */
    ParticleSystem.prototype.getDimension = function() {
        return 6 * this.particles.length; // 3 for position.  3 for velocity.
    };

    /**
     * DOC_TBA
     * @memberof ParticleSystem
     */
    ParticleSystem.prototype.calculateDerivative = function() {
        this._clearForces();
        this._calculateForces();

        var state = new Float64Array(this.getDimension());

        var particles = this.particles;
        var length = particles.length;
        var j = 0;
        for ( var i = 0; i < length; ++i) {
            var particle = particles[i];
            var velocity = particle.velocity;
            var force = particle.force;
            var oneOverMass = 1.0 / particle.mass;

            state[j + 0] = velocity.x; // xdot = v
            state[j + 1] = velocity.y;
            state[j + 2] = velocity.z;
            state[j + 3] = force.x * oneOverMass; // vdot = f / m
            state[j + 4] = force.y * oneOverMass;
            state[j + 5] = force.z * oneOverMass;
            j += 6;
        }

        return state;
    };

    /**
     * DOC_TBA
     * @memberof ParticleSystem
     */
    ParticleSystem.prototype.getState = function() {
        var state = new Float64Array(this.getDimension());

        var particles = this.particles;
        var length = particles.length;
        var j = 0;
        for ( var i = 0; i < length; ++i) {
            var particle = particles[i];
            var position = particle.position;
            var velocity = particle.velocity;
            state[j + 0] = position.x;
            state[j + 1] = position.y;
            state[j + 2] = position.z;
            state[j + 3] = velocity.x;
            state[j + 4] = velocity.y;
            state[j + 5] = velocity.z;
            j += 6;
        }

        return state;
    };

    /**
     * DOC_TBA
     * @memberof ParticleSystem
     */
    ParticleSystem.prototype.setState = function(state) {
        if (state) {
            if (state.length !== this.getDimension()) {
                throw new DeveloperError("The dimensions of the state vector does not equal the dimensions of this particle system.  Call getDimension().", "state");
            }

            var particles = this.particles;
            var length = particles.length;
            var j = 0;
            for ( var i = 0; i < length; ++i) {
                var particle = particles[i];
                particle.position = new Cartesian3(state[j + 0], state[j + 1], state[j + 2]);
                particle.velocity = new Cartesian3(state[j + 3], state[j + 4], state[j + 5]);

                j += 6;
            }
        }
    };

    return ParticleSystem;
});
/*global define*/
define('Scene/PerspectiveFrustum',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/Cartesian3',
        '../Core/Cartesian4',
        '../Core/Matrix4'
    ], function(
        DeveloperError,
        destroyObject,
        Cartesian3,
        Cartesian4,
        Matrix4) {
    

    /**
     * The viewing frustum is defined by 6 planes.
     * Each plane is represented by a {Cartesian4} object, where the x, y, and z components
     * define the unit vector normal to the plane, and the w component is the distance of the
     * plane from the origin/camera position.
     *
     * @name PerspectiveFrustum
     * @constructor
     *
     * @example
     * var frustum = new PerspectiveFrustum();
     * frustum.fovy = CesiumMath.PI_OVER_THREE;
     * frustum.aspectRatio = canvas.clientWidth / canvas.clientHeight;
     * frustum.near = 1.0;
     * frustum.far = 2.0;
     */
    function PerspectiveFrustum() {
        /**
         * The angle of the field of view, in radians.
         *
         * @type {Number}
         */
        this.fovy = null;
        this._fovy = null;

        /**
         * The aspect ratio of the frustum's width to it's height.
         *
         * @type {Number}
         */
        this.aspectRatio = null;
        this._aspectRatio = null;

        /**
         * The distance of the near plane from the camera's position.
         *
         * @type {Number}
         */
        this.near = null;
        this._near = null;

        /**
         * The The distance of the far plane from the camera's position.
         *
         * @type {Number}
         */
        this.far = null;
        this._far = null;

        this._perspectiveMatrix = null;
        this._infinitePerspective = null;
    }

    /**
     * Returns the perspective projection matrix computed from the view frustum.
     *
     * @memberof PerspectiveFrustum
     *
     * @return {Matrix4} The perspective projection matrix.
     *
     * @see PerspectiveFrustum#getInfiniteProjectionMatrix
     */
    PerspectiveFrustum.prototype.getProjectionMatrix = function() {
        this._update();
        return this._perspectiveMatrix;
    };

    /**
     * DOC_TBA
     *
     * @memberof PerspectiveFrustum
     *
     * @see PerspectiveFrustum#getProjectionMatrix
     */
    PerspectiveFrustum.prototype.getInfiniteProjectionMatrix = function() {
        this._update();
        return this._infinitePerspective;
    };

    PerspectiveFrustum.prototype._update = function() {
        if (this.fovy === null || this.aspectRatio === null || this.near === null || this.far === null) {
            throw new DeveloperError("The frustum parameters are not set.", "fovy, aspectRatio, near, or far");
        }

        if (this.fovy !== this._fovy || this.aspectRatio !== this._aspectRatio || this.near !== this._near || this.far !== this._far) {
            if (this.fovy < 0 || this.fovy >= Math.PI) {
                throw new DeveloperError("fovy must be in the range [0, PI).", "fovy");
            }

            if (this.aspectRatio < 0) {
                throw new DeveloperError("aspectRatio must be positive.", "aspectRatio");
            }

            if (this.near < 0 || this.near > this.far) {
                throw new DeveloperError("near must be greater than zero and less than far.", "near");
            }

            this._fovy = this.fovy;
            this._aspectRatio = this.aspectRatio;
            this._near = this.near;
            this._far = this.far;

            this._updateProjectionMatrices();
        }
    };

    PerspectiveFrustum.prototype._updateProjectionMatrices = function() {
        var t = this.near * Math.tan(0.5 * this.fovy);
        var b = -t;
        var r = this.aspectRatio * t;
        var l = -r;
        var n = this.near;
        var f = this.far;

        this._perspectiveMatrix = Matrix4.createPerspectiveOffCenter(l, r, b, t, n, f);
        this._infinitePerspective = Matrix4.createInfinitePerspectiveOffCenter(l, r, b, t, n);
    };

    /**
     * DOC_TBA
     *
     * @memberof PerspectiveFrustum
     *
     * @param {Cartesian3} position The eye position.
     * @param {Cartesian3} direction The view direction.
     * @param {Cartesian3} up The up direction.
     *
     * @exception {DeveloperError} position is required.
     * @exception {DeveloperError} direction is required.
     * @exception {DeveloperError} up is required.
     */
    PerspectiveFrustum.prototype.getPlanes = function(position, direction, up) {
        if (!position) {
            throw new DeveloperError("position is required.", "position");
        }

        if (!direction) {
            throw new DeveloperError("direction is required.", "direction");
        }

        if (!up) {
            throw new DeveloperError("up is required.", "up");
        }

        var pos = Cartesian3.clone(position);
        var dir = Cartesian3.clone(direction);
        var u = Cartesian3.clone(up);

        var right = dir.cross(u);

        var t = this.near * Math.tan(0.5 * this.fovy);
        var r = this.aspectRatio * t;
        var n = this.near;
        var f = this.far;

        var planes = [];
        planes.length = 6;

        var normal, planeVec;
        var nearCenter = pos.add(dir.multiplyWithScalar(n));
        var farCenter = pos.add(dir.multiplyWithScalar(f));

        //Left plane computation
        planeVec = nearCenter.add(right.negate().multiplyWithScalar(r)).subtract(pos);
        planeVec = planeVec.normalize();
        normal = planeVec.cross(u);
        planes[0] = new Cartesian4(normal.x, normal.y, normal.z, -normal.dot(pos));

        //Right plane computation
        planeVec = nearCenter.add(right.multiplyWithScalar(r)).subtract(pos);
        planeVec = planeVec.normalize();
        normal = u.cross(planeVec);
        planes[1] = new Cartesian4(normal.x, normal.y, normal.z, -normal.dot(pos));

        //Bottom plane computation
        planeVec = nearCenter.add(u.negate().multiplyWithScalar(t)).subtract(position);
        planeVec = planeVec.normalize();
        normal = right.cross(planeVec);
        planes[2] = new Cartesian4(normal.x, normal.y, normal.z, -normal.dot(pos));

        //Top plane computation
        planeVec = nearCenter.add(u.multiplyWithScalar(t)).subtract(pos);
        planeVec = planeVec.normalize();
        normal = planeVec.cross(right);
        planes[3] = new Cartesian4(normal.x, normal.y, normal.z, -normal.dot(pos));

        //Near plane computation
        normal = direction;
        planes[4] = new Cartesian4(normal.x, normal.y, normal.z, -normal.dot(nearCenter));

        //Far plane computation
        normal = direction.negate();
        planes[5] = new Cartesian4(normal.x, normal.y, normal.z, -normal.dot(farCenter));

        return planes;
    };

    /**
     * Returns a duplicate of a PerspectiveFrustum instance.
     *
     * @memberof PerspectiveFrustum
     *
     * @return {PerspectiveFrustum} A new copy of the PerspectiveFrustum instance.
     */
    PerspectiveFrustum.prototype.clone = function() {
        var frustum = new PerspectiveFrustum();
        frustum.fovy = this.fovy;
        frustum.aspectRatio = this.aspectRatio;
        frustum.near = this.near;
        frustum.far = this.far;
        return frustum;
    };

    /**
     * DOC_TBA
     *
     * @memberof PerspectiveFrustum
     */
    PerspectiveFrustum.prototype.equals = function(other) {
        return (this.fovy === other.fovy && this.aspectRatio === other.aspectRatio && this.near === other.near && this.far === other.far);
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof PerspectiveFrustum
     *
     * @return {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     *
     * @see PerspectiveFrustum#destroy
     */
    PerspectiveFrustum.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Removes keyboard listeners held by this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>null</code>) to the object as done in the example.
     *
     * @memberof PerspectiveFrustum
     *
     * @return {null}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see PerspectiveFrustum#isDestroyed
     *
     * @example
     * frustum = frustum && frustum.destroy();
     */
    PerspectiveFrustum.prototype.destroy = function() {
        return destroyObject(this);
    };

    return PerspectiveFrustum;
});
/*global define*/
define('Scene/Camera',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/Math',
        '../Core/Intersect',
        '../Core/Ellipsoid',
        '../Core/IntersectionTests',
        '../Core/Cartesian3',
        '../Core/Cartesian4',
        '../Core/Cartographic3',
        '../Core/Matrix4',
        './CameraControllerCollection',
        './PerspectiveFrustum'
    ], function(
        DeveloperError,
        destroyObject,
        CesiumMath,
        Intersect,
        Ellipsoid,
        IntersectionTests,
        Cartesian3,
        Cartesian4,
        Cartographic3,
        Matrix4,
        CameraControllerCollection,
        PerspectiveFrustum) {
    

    /**
     * The camera is defined by a position, orientation, and view frustum.
     * <br /><br />
     * The orientation forms an orthonormal basis with a view, up and right = view x up unit vectors.
     * <br /><br />
     * The viewing frustum is defined by 6 planes.
     * Each plane is represented by a {Cartesian4} object, where the x, y, and z components
     * define the unit vector normal to the plane, and the w component is the distance of the
     * plane from the origin/camera position.
     *
     * @name Camera
     *
     * @exception {DeveloperError} canvas is required.
     *
     * @constructor
     *
     * @example
     * // Create a camera looking down the negative z-axis, positioned at the origin,
     * // with a field of view of 60 degrees, and 1:1 aspect ratio.
     * var camera = new Camera(canvas);
     * camera.position = new Cartesian3();
     * camera.direction = Cartesian3.getUnitZ().negate();
     * camera.up = Cartesian3.getUnitY();
     * camera.fovy = CesiumMath.PI_OVER_THREE;
     * camera.near = 1.0;
     * camera.far = 2.0;
     */
    function Camera(canvas) {
        if(!canvas) {
            throw new DeveloperError("canvas is required.", "canvas");
        }

        var maxRadii = Ellipsoid.getWgs84().getRadii().getMaximumComponent();

        /**
         * DOC_TBA
         *
         * @type {Matrix4}
         */
        this.transform = Matrix4.getIdentity();
        this._transform = this.transform.clone();
        this._invTransform = Matrix4.getIdentity();

        var position = new Cartesian3(0.0, -2.0, 1.0).normalize().multiplyWithScalar(2.0 * maxRadii);
        var direction = Cartesian3.getZero().subtract(position).normalize();
        var right = direction.cross(Cartesian3.getUnitZ()).normalize();
        var up = right.cross(direction);

        /**
         * The position of the camera.
         *
         * @type {Cartesian3}
         */
        this.position = position;
        this._position = position.clone();

        /**
         * The view direction of the camera.
         *
         * @type {Cartesian3}
         */
        this.direction = direction;
        this._direction = direction.clone();

        /**
         * The up direction of the camera.
         *
         * @type {Cartesian3}
         */
        this.up = up;
        this._up = up.clone();

        /**
         * The right direction of the camera.
         *
         * @type {Cartesian3}
         */
        this.right = right;
        this._right = right.clone();

        /**
         * DOC_TBA
         *
         * @type {Frustum}
         */
        this.frustum = new PerspectiveFrustum();
        this.frustum.fovy = CesiumMath.toRadians(60.0);
        this.frustum.aspectRatio = canvas.clientWidth / canvas.clientHeight;
        this.frustum.near = 0.01 * maxRadii;
        this.frustum.far = 20.0 * maxRadii;

        this._viewMatrix = undefined;
        this._invViewMatrix = undefined;
        this._updateViewMatrix();

        this._planes = undefined;
        this._updatePlanes();

        this._canvas = canvas;
        this._controllers = new CameraControllerCollection(this, canvas);
    }
    
    /**
     * DOC_TBA
     * @memberof Camera
     */
    Camera.prototype.getControllers = function() {
        return this._controllers;
    };

    /**
     * DOC_TBA
     * @memberof Camera
     */
    Camera.prototype.update = function() {
        this._controllers.update();
    };

    /**
     * Sets the camera position and orientation with an eye position, target, and up vector.
     *
     * @memberof Camera
     *
     * @param {Array} arguments If one parameter is passed to this function, it must have three
     * properties with the names eye, target, and up; otherwise three arguments are expected which
     * the same as the properties of one object and given in the order given above.
     *
     */
    Camera.prototype.lookAt = function() {
        var eye, target, up;
        if(arguments.length === 1) {
            var param = arguments[0];
            if(param.eye && param.target && param.up) {
                eye = param.eye;
                target = param.target;
                up = param.up;
            } else {
                return;
            }
        } else if(arguments.length === 3) {
            eye = arguments[0];
            target = arguments[1];
            up = arguments[2];
        } else {
            return;
        }

        this.position = eye;
        this.direction = target.subtract(eye).normalize();
        this.up = up.normalize();
        this.right = this.direction.cross(this.up);
    };

    /**
     * Zooms to a cartographic extent on the centralBody. The camera will be looking straight down at the extent, with the up vector pointing toward local north.
     *
     * @memberof Camera
     * @param {Ellipsoid} ellipsoid The ellipsoid to view.
     * @param {double} west The west longitude of the extent.
     * @param {double} south The south latitude of the extent.
     * @param {double} east The east longitude of the extent.
     * @param {double} north The north latitude of the extent.
     *
     */
    Camera.prototype.viewExtent = function(ellipsoid, west, south, east, north) {
        //
        // Ensure we go from -180 to 180
        //
        west = CesiumMath.negativePiToPi(west);
        east = CesiumMath.negativePiToPi(east);

        // If we go across the International Date Line
        if(west > east) {
            east += CesiumMath.TWO_PI;
        }

        var lla = new Cartographic3(0.5 * (west + east), 0.5 * (north + south), 0.0);
        var northVector = ellipsoid.toCartesian(new Cartographic3(lla.longitude, north, 0.0));
        var eastVector = ellipsoid.toCartesian(new Cartographic3(east, lla.latitude, 0.0));
        var centerVector = ellipsoid.toCartesian(lla);
        var invTanHalfPerspectiveAngle = 1.0 / Math.tan(0.5 * this.frustum.fovy);
        var screenViewDistanceX;
        var screenViewDistanceY;
        var tempVec;
        if(this._canvas.clientWidth >= this._canvas.clientHeight) {
            tempVec = eastVector.subtract(centerVector);
            screenViewDistanceX = Math.sqrt(tempVec.dot(tempVec) * invTanHalfPerspectiveAngle);
            tempVec = northVector.subtract(centerVector);
            screenViewDistanceY = Math.sqrt(tempVec.dot(tempVec) * invTanHalfPerspectiveAngle * this._canvas.clientWidth / this._canvas.clientHeight);
        } else {
            tempVec = eastVector.subtract(centerVector);
            screenViewDistanceX = Math.sqrt(tempVec.dot(tempVec) * invTanHalfPerspectiveAngle * this._canvas.clientWidth / this._canvas.clientHeight);
            tempVec = northVector.subtract(centerVector);
            screenViewDistanceY = Math.sqrt(tempVec.dot(tempVec) * invTanHalfPerspectiveAngle);
        }
        lla.height += Math.max(screenViewDistanceX, screenViewDistanceY);

        this.position = ellipsoid.toCartesian(lla);
        this.direction = Cartesian3.getZero().subtract(centerVector).normalize();
        this.right = this.direction.cross(Cartesian3.getUnitZ()).normalize();
        this.up = this.right.cross(this.direction);
    };

    Camera.prototype._orthonormalizeAxes = function() {
        this._direction = this._direction.normalize();

        var invUpMag = 1.0 / this._up.magnitudeSquared();
        var scalar = this._up.dot(this._direction) * invUpMag;
        var w0 = this._direction.multiplyWithScalar(scalar);
        this._up = this._up.subtract(w0).normalize();

        this._right = this._direction.cross(this._up);
    };

    Camera.prototype._updateViewMatrix = function() {
        var r = this._right;
        var u = this._up;
        var d = this._direction;
        var e = this._position;

        this._viewMatrix = new Matrix4(r.x, r.y, r.z, -r.dot(e), u.x, u.y, u.z, -u.dot(e), -d.x, -d.y, -d.z, d.dot(e), 0.0, 0.0, 0.0, 1.0);
        this._viewMatrix = this._viewMatrix.multiplyWithMatrix(this._invTransform);

        this._invViewMatrix = this._viewMatrix.inverseTransformation();
    };

    Camera.prototype._updatePlanes = function() {
        var position = new Cartesian4(this._position.x, this._position.y, this._position.z, 1.0);
        position = this._transform.multiplyWithVector(position).getXYZ();

        var direction = new Cartesian4(this._direction.x, this._direction.y, this._direction.z, 0.0);
        direction = this._transform.multiplyWithVector(direction).getXYZ();

        var up = new Cartesian4(this._up.x, this._up.y, this._up.z, 0.0);
        up = this._transform.multiplyWithVector(up).getXYZ();

        this._planes = this.frustum.getPlanes(position, direction, up);
    };

    Camera.prototype._update = function() {
        if ((this.position && !this.position.equals(this._position)) || (this.direction && !this.direction.equals(this._direction)) || (this.up && !this.up.equals(this._up)) ||
                (this.right && !this.right.equals(this._right)) || (this.transform && !this.transform.equals(this._transform))) {

            this._position = this.position && this.position.clone();
            this._direction = this.direction && this.direction.clone();
            this._up = this.up && this.up.clone();
            this._right = this.right && this.right.clone();
            this._transform = this.transform && this.transform.clone();
            this._invTransform = this._transform.inverseTransformation();

            var det = this._direction.dot(this._up.cross(this._right));
            if(Math.abs(1.0 - det) > CesiumMath.EPSILON2) {
                this._orthonormalizeAxes();
            }

            this.position = this._position.clone();
            this.direction = this._direction.clone();
            this.up = this._up.clone();
            this.right = this._right.clone();

            this._updateViewMatrix();
            this._updatePlanes();
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof Camera
     *
     * @return {Matrix4} DOC_TBA
     */
    Camera.prototype.getInverseTransform = function() {
        this._update();
        return this._invTransform;
    };

    /**
     * Returns the view matrix.
     *
     * @memberof Camera
     *
     * @return {Matrix4} The view matrix.
     *
     * @see UniformState#getView
     * @see UniformState#setView
     * @see agi_view
     */
    Camera.prototype.getViewMatrix = function() {
        this._update();
        return this._viewMatrix;
    };

    /**
     * DOC_TBA
     * @memberof Camera
     */
    Camera.prototype.getInverseViewMatrix = function() {
        this._update();
        return this._invViewMatrix;
    };

    /**
     * DOC_TBA
     * @memberof Camera
     */
    Camera.prototype.getPickRay = function(windowPosition) {
        var width = this._canvas.clientWidth;
        var height = this._canvas.clientHeight;

        var tanPhi = Math.tan(this.frustum.fovy * 0.5);
        var tanTheta = this.frustum.aspectRatio * tanPhi;
        var near = this.frustum.near;

        var x = (2.0 / width) * windowPosition.x - 1.0;
        var y = (2.0 / height) * (height - windowPosition.y) - 1.0;

        var nearCenter = this.position.add(this.direction.multiplyWithScalar(near));
        var xDir = this.right.multiplyWithScalar(x * near * tanTheta);
        var yDir = this.up.multiplyWithScalar(y * near * tanPhi);
        var direction = nearCenter.add(xDir).add(yDir).subtract(this.position).normalize();

        return {
            position : this.position.clone(),
            direction : direction
        };
    };

    /**
     * DOC_TBA
     * @memberof Camera
     */
    Camera.prototype.pickEllipsoid = function(ellipsoid, windowPosition) {
        var ray = this.getPickRay(windowPosition);
        var intersection = IntersectionTests.rayEllipsoid(ray.position, ray.direction, ellipsoid);
        if(!intersection) {
            return null;
        }

        var iPt = ray.position.add(ray.direction.multiplyWithScalar(intersection.start));
        return iPt;
    };

    /**
     * Determines whether a bounding volume intersects with the frustum or not.
     *
     * @memberof Camera
     *
     * @param {Object} object The bounding volume whose intersection with the frustum is to be tested.
     * @param {Function} planeIntersectTest The function that tests for intersections between a plane
     * and the bounding volume type of object
     *
     * @return {Enumeration}  Intersect.OUTSIDE,
     *                                 Intersect.INTERSECTING, or
     *                                 Intersect.INSIDE.
     */
    Camera.prototype.getVisibility = function(object, planeIntersectTest) {
        this._update();
        var planes = this._planes;
        var intersecting = false;
        for(var k = 0; k < planes.length; k++) {
            var result = planeIntersectTest(object, planes[k]);
            if(result === Intersect.OUTSIDE) {
                return Intersect.OUTSIDE;
            } else if(result === Intersect.INTERSECTING) {
                intersecting = true;
            }
        }

        return intersecting ? Intersect.INTERSECTING : Intersect.INSIDE;
    };

    /**
     * Returns a duplicate of a Camera instance.
     *
     * @memberof Camera
     *
     * @return {Camera} A new copy of the Camera instance.
     */
    Camera.prototype.clone = function() {
        var camera = new Camera(this._canvas);
        camera.position = this.position.clone();
        camera.direction = this.direction.clone();
        camera.up = this.up.clone();
        camera.right = this.right.clone();
        camera.transform = this.transform.clone();
        camera.frustum = this.frustum.clone();
        return camera;
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof Camera
     *
     * @return {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     *
     * @see Camera#destroy
     */
    Camera.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Removes keyboard listeners held by this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>null</code>) to the object as done in the example.
     *
     * @memberof Camera
     *
     * @return {null}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see Camera#isDestroyed
     *
     * @example
     * camera = camera && camera.destroy();
     */
    Camera.prototype.destroy = function() {
        this._controllers.destroy();
        return destroyObject(this);
    };

    return Camera;
});

/*global define*/
define('Scene/Projections',[
        '../Core/DeveloperError',
        '../Core/Enumeration'
    ], function(
        DeveloperError,
        Enumeration) {
    
    /*global document*/

    /**
     * DOC_TBA
     *
     * @exports Projections
     */
    var Projections = {
        WGS84 : new Enumeration(0, "WGS84", {
            toWgs84 : function(extent, image) {
                return image;
            }
        }),
        MERCATOR : new Enumeration(1, "MERCATOR", {
            toWgs84 : function(extent, image) {
                if (!extent || typeof extent.north === "undefined" || typeof extent.south === "undefined") {
                    throw new DeveloperError("extent, extent.north and extent.south are required.", "extent");
                }

                if (!image) {
                    throw new DeveloperError("image is required.", "image");
                }

                var width = parseInt(image.width, 10);
                var height = parseInt(image.height, 10);
                var wRowBytes = width * 4; // Always 4 bytes per pixel.

                // draw image to canvas and get the pixels
                var canvas = document.createElement("canvas");
                canvas.width = width;
                canvas.height = height;
                var context = canvas.getContext("2d");
                context.drawImage(image, 0, 0);
                var fromPixels = context.getImageData(0, 0, width, height).data;

                // create array of pixels
                var newImageData = context.createImageData(width, height);
                var toPixels = newImageData.data;

                // WGS84 parameters
                var deltaWLat = (extent.north - extent.south) / height;
                var currentWLat = extent.north - (0.5 * deltaWLat);

                // mercator parameters
                var sinTheta = Math.sin(extent.south);
                var minMLat = 0.5 * Math.log((1 + sinTheta) / (1 - sinTheta));
                sinTheta = Math.sin(extent.north);
                var maxMLat = 0.5 * Math.log((1 + sinTheta) / (1 - sinTheta));
                var invMLatDim = 1.0 / (maxMLat - minMLat);

                // first row
                var heightMinusOne = height - 1;
                var i = 0;
                for (; i < wRowBytes; ++i) {
                    toPixels[i] = fromPixels[i];
                }

                // interior rows
                var end, mLat, mRow;
                var j = 1;
                for (; j < heightMinusOne; ++j, currentWLat -= deltaWLat) {
                    sinTheta = Math.sin(currentWLat);
                    mLat = 0.5 * Math.log((1.0 + sinTheta) / (1.0 - sinTheta));
                    mRow = Math.floor(heightMinusOne - ((heightMinusOne * (mLat - minMLat) * invMLatDim)));
                    end = i + wRowBytes;
                    for ( var k = 0; i < end; ++i, ++k) {
                        toPixels[i] = fromPixels[mRow * wRowBytes + k];
                    }
                }

                // last row
                end = i + wRowBytes;
                for (j = 0; i < end; ++i, ++j) {
                    toPixels[i] = fromPixels[i];
                }

                // paint new image to canvas
                context.putImageData(newImageData, 0, 0);

                return canvas;
            }
        })
    };

    return Projections;
});
/*global define*/
define('Scene/OpenStreetMapTileProvider',[
        '../Core/DeveloperError',
        '../Core/Math',
        './Projections'
    ], function(
        DeveloperError,
        CesiumMath,
        Projections) {
    
    /*global document,Image*/

    /**
     * Provides tile images hosted by OpenStreetMap.
     *
     * @name OpenStreetMapTileProvider
     * @constructor
     *
     * @param {String} description.url The OpenStreetMap url.
     * @param {String} description.proxy A proxy URL to send image requests through. This URL will have the desired image URL appended as a query parameter.
     *
     * @see SingleTileProvider
     * @see BingMapsTileProvider
     * @see ArcGISTileProvider
     * @see CompositeTileProvider
     *
     * @see <a href="http://wiki.openstreetmap.org/wiki/Main_Page">OpenStreetMap Wiki</a>
     * @see <a href="http://www.w3.org/TR/cors/">Cross-Origin Resource Sharing</a>
     *
     * @example
     * // OpenStreetMap tile provider
     * var osm = new OpenStreetMapTileProvider({
     *     url : 'http://tile.openstreetmap.org/'
     * });
     */
    function OpenStreetMapTileProvider(description) {
        var desc = description || {};

        this._url = desc.url || 'http://tile.openstreetmap.org/';

        /**
         * A proxy URL to send image requests through. This URL will have the desired image URL appended as a query parameter.
         * @type {String}
         */
        this.proxy = desc.proxy;

        // TODO: should not hard-code, get from server?

        /**
         * The cartographic extent of the base tile, with north, south, east and
         * west properties in radians.
         *
         * @type {Object}
         */
        this.maxExtent = {
            north : CesiumMath.toRadians(85.05112878),
            south : CesiumMath.toRadians(-85.05112878),
            west : -CesiumMath.PI,
            east : CesiumMath.PI
        };

        /**
         * The width of every image loaded.
         *
         * @type {Number}
         */
        this.tileWidth = 256;

        /**
         * The height of every image loaded.
         *
         * @type {Number}
         */
        this.tileHeight = 256;

        /**
         * The maximum zoom level that can be requested.
         *
         * @type {Number}
         */
        this.zoomMax = 18;

        /**
         * The minimum zoom level that can be requested.
         *
         * @type {Number}
         */
        this.zoomMin = 0;

        /**
         * The map projection of the image.
         *
         * @type {Enumeration}
         * @see Projections
         */
        this.projection = Projections.MERCATOR;

        this._logo = undefined;
    }

    OpenStreetMapTileProvider.prototype._getUrl = function(tile) {
        var url = '';
        if (this.proxy) {
            url += this.proxy + '?';
        }
        url += this._url + tile.zoom + '/' + tile.x + '/' + tile.y + '.png';

        return url;
    };

    /**
     * Loads the image for <code>tile</code>.
     *
     * @memberof OpenStreetMapTileProvider
     *
     * @param {Tile} tile The tile to load the image for.
     * @param {Function} onload A function that will be called when the image is finished loading.
     * @param {Function} onerror A function that will be called if there is an error loading the image.
     *
     * @exception {DeveloperError} <code>tile.zoom</code> is less than <code>zoomMin</code>
     * or greater than <code>zoomMax</code>.
     */
    OpenStreetMapTileProvider.prototype.loadTileImage = function(tile, onload, onerror) {
        if (tile.zoom < this.zoomMin || tile.zoom > this.zoomMax) {
            throw new DeveloperError("The zoom must be between in [zoomMin, zoomMax].", "tile.zoom");
        }

        var image = new Image();
        if (onload && typeof onload === "function") {
            image.onload = function() {
                onload();
            };
        }
        if (onerror && typeof onerror === "function") {
            image.onerror = function() {
                onerror();
            };
        }
        image.crossOrigin = '';
        image.src = this._getUrl(tile);

        return image;
    };

    /**
     * DOC_TBA
     * @memberof OpenStreetMapTileProvider
     */
    OpenStreetMapTileProvider.prototype.getLogo = function() {
        if (!this._logo) {
            var credit = "MapQuest, Open Street Map and contributors, CC-BY-SA";
            var canvas = document.createElement("canvas");
            canvas.width = 800.0;
            canvas.height = 20.0;

            var context = canvas.getContext("2d");
            context.fillStyle = "#fff";
            context.font = '12px sans-serif';
            context.textBaseline = 'top';
            context.fillText(credit, 0, 0);

            this._logo = canvas;
        }

        return this._logo;
    };

    return OpenStreetMapTileProvider;
});

/*global define*/
define('Scene/ProxyUsagePolicy',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * An enumeration describing when to use a proxy URL to load images.
     *
     * @exports ProxyUsagePolicy
     *
     * @see BingMapsTileProvider
     */
    var ProxyUsagePolicy = {
        /**
         * Use CORS (Cross-Origin Resource Sharing) for all images that are
         * known to support it, fall back on the proxy for other images.
         *
         * @constant
         * @type {Enumeration}
         */
        USE_CORS : new Enumeration(0, "Use CORS"),

        /**
         * Request all images through the proxy.
         *
         * @constant
         * @type {Enumeration}
         */
        ALWAYS : new Enumeration(1, "Always")
    };

    return ProxyUsagePolicy;
});
/*global define*/
define('Scene/SceneMode',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports SceneMode
     */
    var SceneMode = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        SCENE2D : new Enumeration(0, "SCENE2D"),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        COLUMBUS_VIEW : new Enumeration(1, "COLUMBUS_VIEW"),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        SCENE3D : new Enumeration(2, "SCENE3D"),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        MORPHING : new Enumeration(3, "MORPHING")
    };

    return SceneMode;
});
/*global define*/
define('Scene/SingleTileProvider',[
        '../Core/DeveloperError',
        '../Core/Math',
        './Projections'
    ], function(
        DeveloperError,
        CesiumMath,
        Projections) {
    
    /*global Image*/

    /**
     * Provides a single, top-level tile.
     *
     * @name SingleTileProvider
     * @constructor
     *
     * @param {String} url The url for the tile.
     *
     * @exception {DeveloperError} url is required.
     *
     * @see ArcGISTileProvider
     * @see BingMapsTileProvider
     * @see OpenStreetMapTileProvider
     * @see CompositeTileProvider
     */
    function SingleTileProvider(url) {
        if (!url) {
            throw new DeveloperError("url is required.", "url");
        }

        this._url = url;

        /**
         * The cartographic extent of the base tile, with north, south, east and
         * west properties in radians.
         *
         * @constant
         * @type {Object}
         */
        this.maxExtent = {
            north : CesiumMath.PI_OVER_TWO,
            south : -CesiumMath.PI_OVER_TWO,
            west : -CesiumMath.PI,
            east : CesiumMath.PI
        };

        /**
         * The maximum zoom level that can be requested.
         *
         * @constant
         * @type {Number}
         */
        this.zoomMax = 0;

        /**
         * The minimum zoom level that can be requested.
         *
         * @constant
         * @type {Number}
         */
        this.zoomMin = 0;

        /**
         * The map projection of the image.
         *
         * @type {Enumeration}
         * @see Projections
         */
        this.projection = Projections.WGS84;
    }

    /**
     * Loads the top-level tile.
     *
     * @memberof SingleTileProvider
     *
     * @param {Tile} tile The top-level tile.
     * @param {Function} onload A function that will be called when the image is finished loading.
     * @param {Function} onerror A function that will be called if there is an error loading the image.
     *
     * @exception {DeveloperError} <code>tile.zoom</code> is less than <code>zoomMin</code>
     * or greater than <code>zoomMax</code>.
     */
    SingleTileProvider.prototype.loadTileImage = function(tile, onload, onerror) {
        if (tile.zoom < this.zoomMin || tile.zoom > this.zoomMax) {
            throw new DeveloperError("The zoom must be between in [zoomMin, zoomMax].", "tile.zoom");
        }

        var image = new Image();

        if (onload && typeof onload === "function") {
            image.onload = function() {
                onload();
            };
        }
        if (onerror && typeof onerror === "function") {
            image.onerror = function() {
                onerror();
            };
        }
        image.crossOrigin = '';
        image.src = this._url;

        return image;
    };

    return SingleTileProvider;
});
/*global define*/
define('Scene/SphericalRepulsionForce',[
        '../Core/DeveloperError',
        '../Core/Cartesian3'
    ], function(
        DeveloperError,
        Cartesian3) {
    

    /**
     * DOC_TBA
     * @name SphericalRepulsionForce
     * @constructor
     */
    function SphericalRepulsionForce(template) {
        template = template || {};
        template.center = template.center || Cartesian3.getZero();
        template.radius = (typeof template.radius === "undefined") ? 1.0 : template.radius;

        if (template.radius < 0) {
            throw new DeveloperError("template.radius must be nonnegative.", "template");
        }

        this.center = new Cartesian3(template.center.x, template.center.y, template.center.z);
        this.radius = template.radius;
    }

    /**
     * DOC_TBA
     * @memberof SphericalRepulsionForce
     */
    SphericalRepulsionForce.prototype.apply = function(particles) {
        if (particles) {
            var center = this.center;
            var radius = this.radius;
            var length = particles.length;
            for ( var i = 0; i < length; ++i) {
                var particle = particles[i];

                var centerToPosition = particle.position.subtract(center);
                var magnitudeDifference = radius - centerToPosition.magnitude();

                // Repel if particle is in sphere
                if (magnitudeDifference > 0) {
                    particle.force = particle.force.add(centerToPosition.normalize().multiplyWithScalar(magnitudeDifference));
                }
            }
        }
    };

    return SphericalRepulsionForce;
});
/*global define*/
define('Scene/SpringForce',['../Core/DeveloperError'], function(DeveloperError) {
    

    /**
     * DOC_TBA
     * @name SpringForce
     * @constructor
     */
    function SpringForce(template) {
        template = template || {};

        if (!template.particleOne || !template.particleTwo) {
            throw new DeveloperError("template.particleOne and template.particleTwo are required.", "template");
        }

        this.particleOne = template.particleOne;
        this.particleTwo = template.particleTwo;

        // TODO: Throw if these are negative

        this.restLength = (typeof template.restLength === "undefined") ? 1.0 : template.restLength;
        this.springConstant = (typeof template.springConstant === "undefined") ? 1.0 : template.springConstant;
        this.dampingConstant = (typeof template.dampingConstant === "undefined") ? 1.0 : template.dampingConstant;
    }

    /**
     * DOC_TBA
     * @memberof SpringForce
     */
    SpringForce.prototype.apply = function(particles) {
        // The entire list of particles is not needed.  The force on
        // each of the two particles connected by this spring is computed.

        // Hook's law:

        var a = this.particleOne;
        var b = this.particleTwo;
        var l = a.position.subtract(b.position); // vector from b to a
        var dl = a.velocity.subtract(b.velocity); // time derivative of l
        var ml = l.magnitude(); // magnitude of l
        var nl = l.divideByScalar(ml); // normalized l vector

        var s = this.springConstant * (ml - this.restLength); // spring force magnitude
        var d = this.dampingConstant * (dl.dot(l) / ml); // damping force magnitude

        var f = nl.multiplyWithScalar(-(s + d));

        // Apply equal and opposite forces
        a.force = a.force.add(f);
        b.force = b.force.add(f.negate());
    };

    return SpringForce;
});
/*global define*/
define('Scene/Texture2DPool',[
        '../Core/DeveloperError',
        '../Core/destroyObject'
    ], function(
        DeveloperError,
        destroyObject) {
    

    /**
     * A collection of textures with the same width and height. Textures can be added and removed to
     * the texture pool, but the textures will not be destroyed until the entire texture pool is
     * destroyed. The pool can be queried for available textures and be marked as unavailable when
     * the texture is to be used.
     * <br/><br/>
     * Texture pools are useful when textures are being created and released repeatedly.
     *
     * @name Texture2DPool
     * @constructor
     *
     * @exception {DeveloperError} width is required and must be greater than 0.
     * @exception {DeveloperError} height is required and must be greater than 0.
     *
     * @see Texture
     * @see Context#createTexture2D
     */
    function Texture2DPool(width, height) {
        if (typeof width === "undefined" || width <= 0) {
            throw new DeveloperError("width is required and must be greater than 0.", "width");
        }

        if (typeof height === "undefined" || height <= 0) {
            throw new DeveloperError("height is required and must be greater than 0.", "height");
        }

        this._width = width;
        this._height = height;

        this._used = {
            head : null,
            tail : null
        };
        this._unused = {
            head : null,
            tail : null
        };

        this._usedCount = 0;
        this._unusedCount = 0;
    }

    /**
     * Returns the width of every texture in the pool.
     *
     * @memberof Texture2DPool
     *
     * @return {Number} The width of the textures.
     *
     * @see Texture2DPool#getHeight
     */
    Texture2DPool.prototype.getWidth = function() {
        return this._width;
    };

    /**
     * Returns the height of every texture in the pool.
     *
     * @memberof Texture2DPool
     *
     * @return {Number} The height of the textures.
     *
     * @see Texture2DPool#getWidth
     */
    Texture2DPool.prototype.getHeight = function() {
        return this._height;
    };

    Texture2DPool.prototype._addBack = function(list, texture) {
        var node = {
            texture : texture,
            previous : list.tail,
            next : null
        };

        if (list.tail) {
            list.tail.next = node;
            list.tail = node;
        } else {
            list.head = node;
            list.tail = node;
        }
    };

    /**
     * Add a texture to the pool.
     *
     * @memberof Texture2DPool
     *
     * @param {Texture} texture The texture to be added to the pool.
     * @param {Boolean} unused If left undefined or has a falsy value, the texture is currently being used.
     * Otherwise, the texture will be marked as available for use.
     *
     * @exception {DeveloperError} The texture width and/or height does not match that of every
     * other texture in the pool.
     *
     * @see Texture2DPool#remove
     * @see Texture2DPool#removeAll
     * @see Texture2DPool#getTexture
     */
    Texture2DPool.prototype.add = function(texture, unused) {
        if (!texture) {
            return;
        }

        if (texture.getWidth() !== this._width || texture.getHeight() !== this._height) {
            throw new DeveloperError("All textures in this pool must have the same dimensions.", "texture");
        }

        if (unused) {
            this._addBack(this._unused, texture);
            ++this._unusedCount;
        } else {
            this._addBack(this._used, texture);
            ++this._usedCount;
        }
    };

    /**
     * If the texture is already being managed by the texture pool, then it will be marked as available
     * for use. If the texture is not being tracked by the texture pool, then it will be added to the pool
     * and be marked as available for use.
     *
     * @memberof Texture2DPool
     *
     * @param {Texture} texture The texture to be marked as available.
     *
     * @see Texture2DPool#add
     * @see Texture2DPool#removeAll
     * @see Texture2DPool#getTexture
     */
    Texture2DPool.prototype.remove = function(texture) {
        if (!texture) {
            return;
        }

        var node = this._used.head;
        while (node !== null) {
            if (node.texture === texture) {
                break;
            }
            node = node.next;
        }

        if (node) {
            if (node.previous) {
                node.previous.next = node.next;
                if (node.next) {
                    node.next.previous = node.previous;
                } else {
                    this._used.tail = node.previous;
                }
            } else {
                this._used.head = node.next;
                if (this._used.head) {
                    this._used.head.previous = null;
                } else {
                    this._used.tail = null;
                }
            }
            --this._usedCount;
        }

        this.add(texture, true);
    };

    /**
     * Marks all textures in the pool as being available for use.
     *
     * @memberof Texture2DPool
     *
     * @see Texture2DPool#add
     * @see Texture2DPool#remove
     * @see Texture2DPool#getTexture
     */
    Texture2DPool.prototype.removeAll = function() {
        if (this._used.head && this._used.tail) {
            if (this._unused.tail) {
                this._unused.tail.next = this._used.head;
                this._unused.tail = this._used.tail;
            } else {
                this._unused.head = this._used.head;
                this._unused.tail = this._used.tail;
            }

            this._used.head = this._used.tail = null;
        }

        this._unusedCount += this._usedCount;
        this._usedCount = 0;
    };

    /**
     * Returns a boolean indicating whether any textures in the pool are available for use.
     *
     * @memberof Texture2DPool
     *
     * @return {Boolean} <code>true</code> if there are textures available for use and false otherwise.
     *
     * @see Texture2DPool#getTexture
     */
    Texture2DPool.prototype.hasAvailable = function() {
        return this._unusedCount !== 0;
    };

    /**
     * If there is a texture available for use, it will be marked as used and returned.
     *
     * @memberof Texture2DPool
     *
     * @return {Texture} A texture that can be used or <code>null</code> if none are available.
     *
     * @see Texture2DPool#add
     * @see Texture2DPool#remove
     * @see Texture2DPool#removeAll
     * @see Texture2DPool#hasAvailable
     */
    Texture2DPool.prototype.getTexture = function() {
        var node = this._unused.head;

        if (node) {
            this._unused.head = node.next;

            if (this._unused.head) {
                this._unused.head.previous = null;
            } else {
                this._unused.tail = null;
            }

            node.next = this._used.head;

            if (this._used.head) {
                this._used.head.previous = node;
            } else {
                this._used.tail = node;
            }

            this._used.head = node;

            ++this._usedCount;
            --this._unusedCount;

            return node.texture;
        }

        return null;
    };

    /**
     * Returns the number of textures being managed, includes the number in use and the number not in use.
     *
     * @memberof Texture2DPool
     *
     * @return {Number} The number of textures being managed.
     *
     * @see Texture2DPool#getNumInUse
     */
    Texture2DPool.prototype.size = function() {
        return this._usedCount + this._unusedCount;
    };

    /**
     * Returns the number of textures being managed, includes only the number in use.
     *
     * @memberof Texture2DPool
     *
     * @return {Number} The number of textures in use.
     *
     * @see Texture2DPool#size
     */
    Texture2DPool.prototype.getNumInUse = function() {
        return this._usedCount;
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof Texture2DPool
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see Texture2DPool#destroy
     */
    Texture2DPool.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>null</code>) to the object as done in the example.
     *
     * @memberof Texture2DPool
     *
     * @return {null}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see Texture2DPool#isDestroyed
     *
     * @example
     * pool = pool && pool.destroy();
     */
    Texture2DPool.prototype.destroy = function() {
        var destroyTextures = function(list) {
            var node = list.head;
            while (node !== null) {
                node.texture = node.texture && node.texture.destroy();
                node = node.next;
            }
        };
        destroyTextures(this._used);
        destroyTextures(this._unused);
        return destroyObject(this);
    };

    return Texture2DPool;
});
/*global define*/
define('Scene/Tile',[
        '../Core/DeveloperError',
        '../Core/Math',
        '../Core/Occluder',
        '../Core/Ellipsoid',
        '../Core/BoundingSphere',
        '../Core/Rectangle',
        '../Core/Cartesian3',
        '../Core/Cartographic2',
        '../Core/Cartographic3'
    ], function(
        DeveloperError,
        CesiumMath,
        Occluder,
        Ellipsoid,
        BoundingSphere,
        Rectangle,
        Cartesian3,
        Cartographic2,
        Cartographic3) {
    

    /**
     * A single piece of a uniformly subdivided image mapped to the surface of an ellipsoid.
     *
     * @name Tile
     * @constructor
     *
     * @param {Object} description.extent The cartographic extent of the tile, with north, south, east and
     * west properties in radians.
     * @param {Number} description.x The tile x coordinate.
     * @param {Number} description.y The tile y coordinate.
     * @param {Number} description.zoom The tile zoom level.
     * @param {Ellipsoid} description.ellipsoid The ellipsoid whose surface the tile is on. Defaults to
     * a WGS84 ellipsoid.
     * @param {Tile} description.parent The parent of this tile in a tile tree system.
     *
     * @exception {DeveloperError} Either description.extent or both description.x and description.y is required.
     * @exception {DeveloperError} description.zoom is required.
     *
     * @see SingleTileProvider
     * @see ArcGISTileProvider
     * @see OpenStreetMapTileProvider
     * @see BingMapsTileProvider
     */
    function Tile(description) {
        if (!description) {
            throw new DeveloperError("description is required.", "description");
        }

        if (typeof description.extent === "undefined" &&
            (typeof description.x === "undefined" || typeof description.y === "undefined")) {
            throw new DeveloperError("Either description.extent is required or description.x and description.y are required.", "description");
        }

        if (typeof description.zoom === "undefined" || description.zoom < 0) {
            throw new DeveloperError("description.zoom is required an must be greater than zero.", "description.zoom");
        }

        /**
         * The ellipsoid whose surface this tile is on.
         *
         * @type Ellipsoid
         */
        this.ellipsoid = description.ellipsoid || Ellipsoid.getWgs84();

        /**
         * The cartographic extent of the tile, with north, south, east and
         * west properties in radians.
         *
         * @type Object
         */
        this.extent = null;

        /**
         * The x coordinate.
         *
         * @type Number
         */
        this.x = null;

        /**
         * The y coordinate.
         *
         * @type Number
         */
        this.y = null;

        /**
         * The zoom level.
         *
         * @type Number
         */
        this.zoom = null;

        /**
         * The parent of this tile in a tile tree system.
         *
         * @type Tile
         */
        this.parent = description.parent || null;

        /**
         * The children of this tile in a tile tree system.
         *
         * @type Array
         */
        this.children = null;

        this.zoom = description.zoom;
        if (description.extent) {
            this.extent = description.extent;
            var coords = Tile.extentToTileXY(this.extent, this.zoom);
            this.x = coords.x;
            this.y = coords.y;
        } else {
            this.x = description.x;
            this.y = description.y;

            if (this.x < 0 || this.y < 0) {
                throw new DeveloperError("description.x and description.y must be greater than zero.", "description");
            }

            this.extent = Tile.tileXYToExtent(this.x, this.y, this.zoom);
        }

        this._boundingSphere3D = null;
        this._occludeePoint = null;

        this._projection = null;
        this._boundingSphere2D = null;
        this._boundingRectangle = null;
    }

    /**
     * Converts an extent and zoom level into tile x, y coordinates.
     *
     * @memberof Tile
     *
     * @param {Object} extent The cartographic extent of the tile, with north, south, east and
     * west properties in radians.
     * @param {Number} zoom The tile zoom level.
     *
     * @return {Object} An object with x and y properties.
     */
    Tile.extentToTileXY = function(extent, zoom) {
        var result = {};

        var sinN = Math.sin(extent.north);
        var k = CesiumMath.TWO_PI - Math.log((1.0 + sinN) / (1.0 - sinN));
        result.y = k * (1 << zoom) / (4.0 * Math.PI);
        result.y = Math.round(result.y);

        k = 1.0 << (zoom - 1.0);
        result.x = (extent.west + Math.PI) * k / Math.PI;
        result.x = Math.round(result.x);

        return result;
    };

    /**
     * Converts tile x, y coordinates and zoom to a cartographic extent.
     *
     * @memberof Tile
     *
     * @param {Number} x The x coordinate.
     * @param {Number} y The y coordinate.
     * @param {Number} zoom The tile zoom level.
     *
     * @return {Object} The cartographic extent of the tile, with north, south, east and
     * west properties in radians.
     */
    Tile.tileXYToExtent = function(x, y, zoom) {
        var extent = {};

        // Lat
        var invZoom = 4.0 * Math.PI / (1 << zoom);
        var k = Math.exp(CesiumMath.TWO_PI - (y * invZoom));
        extent.north = Math.asin((k - 1.0) / (k + 1.0));
        k = Math.exp(CesiumMath.TWO_PI - ((y + 1) * invZoom));
        extent.south = Math.asin((k - 1.0) / (k + 1.0));

        // Lon
        invZoom = Math.PI / (1 << (zoom - 1.0));
        extent.west = x * invZoom - Math.PI;
        extent.east = (x + 1.0) * invZoom - Math.PI;

        return extent;
    };

    /**
     * Returns an array of tiles that would be at the next level of the tile tree.
     *
     * @memberof Tile
     *
     * @return {Array} The list of child tiles.
     */
    Tile.prototype.getChildren = function() {
        if (!this.children) {
            this.children = [];
            this.children.push(new Tile({
                x : this.x << 1,
                y : this.y << 1,
                zoom : this.zoom + 1,
                parent : this
            }));
            this.children.push(new Tile({
                x : this.x << 1 | 1,
                y : this.y << 1,
                zoom : this.zoom + 1,
                parent : this
            }));
            this.children.push(new Tile({
                x : this.x << 1,
                y : this.y << 1 | 1,
                zoom : this.zoom + 1,
                parent : this
            }));
            this.children.push(new Tile({
                x : this.x << 1 | 1,
                y : this.y << 1 | 1,
                zoom : this.zoom + 1,
                parent : this
            }));
        }
        return this.children;
    };

    Tile.prototype._compute3DBounds = function() {
        var positions = [];

        var lla = new Cartographic3(this.extent.west, this.extent.north, 0.0);
        positions.push(this.ellipsoid.toCartesian(lla));
        lla.longitude = this.extent.east;
        positions.push(this.ellipsoid.toCartesian(lla));
        lla.latitude = this.extent.south;
        positions.push(this.ellipsoid.toCartesian(lla));
        lla.longitude = this.extent.west;
        positions.push(this.ellipsoid.toCartesian(lla));

        if (this.extent.north < 0.0) {
            lla.latitude = this.extent.north;
        } else if (this.extent.south > 0.0) {
            lla.latitude = this.extent.south;
        } else {
            lla.latitude = 0.0;
        }

        for ( var i = 1; i < 8; ++i) {
            var temp = -Math.PI + i * CesiumMath.PI_OVER_TWO;
            if (this.extent.west < temp && temp < this.extent.east) {
                lla.longitude = temp;
                positions.push(this.ellipsoid.toCartesian(lla));
            }
        }

        if (lla.latitude === 0.0) {
            lla.longitude = this.extent.west;
            positions.push(this.ellipsoid.toCartesian(lla));
            lla.longitude = this.extent.east;
            positions.push(this.ellipsoid.toCartesian(lla));
        }

        this._boundingSphere3D = new BoundingSphere(positions);

        // TODO: get correct ellipsoid center
        var ellipsoidCenter = Cartesian3.getZero();
        if (!ellipsoidCenter.equals(this._boundingSphere3D.center)) {
            this._occludeePoint = Occluder.getOccludeePoint(new BoundingSphere(ellipsoidCenter, this.ellipsoid.getMinimumRadius()), this._boundingSphere3D.center, positions);
        } else {
            this._occludeePoint = {
                valid : false,
                occludeePoint : null
            };
        }
    };

    /**
     * The bounding sphere for the geometry.
     *
     * @memberof Tile
     *
     * @return {BoundingSphere} The bounding sphere for the geometry.
     */
    Tile.prototype.get3DBoundingSphere = function() {
        if (!this._boundingSphere3D) {
            this._compute3DBounds();
        }
        return this._boundingSphere3D;
    };

    /**
     * A point that when visible means the geometry for this tile is visible.
     *
     * @memberof Tile
     *
     * @return {Cartesian3} The occludee point or null.
     */
    Tile.prototype.getOccludeePoint = function() {
        if (!this._occludeePoint) {
            this._compute3DBounds();
        }
        return ((this._occludeePoint.valid) ? this._occludeePoint.occludeePoint : null);
    };

    Tile.prototype._compute2DBounds = function(projection) {
        if (projection && this._projection !== projection) {
            var lla = new Cartographic2(this.extent.west, this.extent.south);
            var lowerLeft = projection.project(lla);
            lla.longitude = this.extent.east;
            lla.latitude = this.extent.north;
            var upperRight = projection.project(lla);

            var diagonal = upperRight.subtract(lowerLeft);
            this._boundingRectangle = new Rectangle(lowerLeft.x, lowerLeft.y, diagonal.x, diagonal.y);

            this._boundingSphere2D = new BoundingSphere(new Cartesian3((lowerLeft.x + upperRight.x) * 0.5, (lowerLeft.y + upperRight.y) * 0.5, 0.0), Math.sqrt(diagonal.x * diagonal.x + diagonal.y *
                    diagonal.y) * 0.5);

            this._projection = projection;
        }
    };

    /**
     * DOC_TBA
     * @memberof Tile
     */
    Tile.prototype.get2DBoundingSphere = function(projection) {
        this._compute2DBounds(projection);
        return this._boundingSphere2D;
    };

    /**
     * DOC_TBA
     * @memberof Tile
     */
    Tile.prototype.get2DBoundingRectangle = function(projection) {
        this._compute2DBounds(projection);
        return this._boundingRectangle;
    };

    /**
     * Returns a unique id from the x, y coordinates and zoom level.
     *
     * @memberof Tile
     *
     * @return {String} The unique id.
     */
    Tile.prototype.getKey = function() {
        return 'x_' + this.x + '_y_' + this.y + '_z_' + this.zoom;
    };

    return Tile;
});
/*global define*/
define('Scene/TileState',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * @private
     */
    var TileState = {
        READY : new Enumeration(0, "READY"),
        IMAGE_LOADING : new Enumeration(1, "IMAGE_LOADING"),
        IMAGE_LOADED : new Enumeration(2, "IMAGE_LOADED"),
        IMAGE_FAILED : new Enumeration(3, "IMAGE_FAILED"),
        IMAGE_INVALID : new Enumeration(4, "IMAGE_INVALID"),
        REPROJECTING : new Enumeration(5, "REPROJECTING"),
        REPROJECTED : new Enumeration(6, "REPROJECTED"),
        TEXTURE_LOADING : new Enumeration(7, "TEXTURE_LOADING"),
        TEXTURE_LOADED : new Enumeration(8, "TEXTURE_LOADED")
    };

    return TileState;
});
/*global define*/
define('Scene/VectorForce',[
        '../Core/DeveloperError',
        '../Core/Cartesian3'
    ], function(
        DeveloperError,
        Cartesian3) {
    

    /**
     * DOC_TBA
     * @name VectorForce
     * @constructor
     */
    function VectorForce(template) {
        template = template || {};
        template.vector = template.vector || Cartesian3.getUnitZ().negate();

        if (!template.particle) {
            throw new DeveloperError("template.particle is required.", "template");
        }

        this.vector = new Cartesian3(template.vector.x, template.vector.y, template.vector.z);
        this.particle = template.particle;
    }

    /**
     * DOC_TBA
     * @memberof VectorForce
     */
    VectorForce.prototype.apply = function(particles) {
        var particle = this.particle;
        particle.force = particle.force.add(this.vector);
    };

    return VectorForce;
});
/*global define*/
define('Scene/VerticalOrigin',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * The vertical location of an origin relative to an object, e.g., a {@link Billboard}.
     * For example, the vertical origin is used to display a billboard above or below (in
     * screen space) of the actual position.
     *
     * @exports VerticalOrigin
     *
     * @see Billboard#setVerticalOrigin
     */
    var VerticalOrigin = {
        /**
         * The origin is at the vertical center of the object.
         *
         * @constant
         * @type {Enumeration}
         */
        CENTER : new Enumeration(0, "CENTER"),
        /**
         * The origin is at the bottom of the object.
         *
         * @constant
         * @type {Enumeration}
         */
        BOTTOM : new Enumeration(1, "BOTTOM"),
        /**
         * The origin is at the top of the object.
         *
         * @constant
         * @type {Enumeration}
         */
        TOP : new Enumeration(-1, "TOP")
    };

    return VerticalOrigin;
});
/*global define*/
define('Scene/Billboard',[
        '../Core/DeveloperError',
        '../Core/shallowEquals',
        '../Core/Cartesian2',
        '../Core/Cartesian3',
        '../Core/Cartesian4',
        './HorizontalOrigin',
        './VerticalOrigin'
    ], function(
        DeveloperError,
        shallowEquals,
        Cartesian2,
        Cartesian3,
        Cartesian4,
        HorizontalOrigin,
        VerticalOrigin) {
    

    /**
     * A viewport-aligned image positioned in the 3D scene, that is created
     * and rendered using a {@link BillboardCollection}.  A billboard is created and its initial
     * properties are set by calling {@link BillboardCollection#add}.  Any of the billboard's
     * properties can be changed at any time by calling the billboard's corresponding
     * <code>set</code> function, e.g., {@link Billboard#setShow}.
     * <br /><br />
     * <div align="center">
     * <img src="images/Billboard.png" width="400" height="300" /><br />
     * Example billboards
     * </div>
     *
     * @name Billboard
     *
     * @performance Calling any <code>get</code> function, e.g., {@link Billboard#getShow}, is constant time.
     * Calling a <code>set</code> function, e.g., {@link Billboard#setShow}, is constant time but results in
     * CPU to GPU traffic when {@link BillboardCollection#update} is called.  The per-billboard traffic is
     * the same regardless of how many properties were updated.  If most billboards in a collection need to be
     * updated, it may be more efficient to clear the collection with {@link BillboardCollection#removeAll}
     * and add new billboards instead of modifying each one.
     *
     * @see BillboardCollection
     * @see BillboardCollection#add
     * @see Label
     *
     * @internalConstructor
     */
    function Billboard(billboardTemplate, collection) {
        var b = billboardTemplate || {};
        var color = b.color || {
            red : 1.0,
            green : 1.0,
            blue : 1.0,
            alpha : 1.0
        };

        var position = b.position ? new Cartesian3(b.position.x, b.position.y, b.position.z) : Cartesian3.getZero();

        this._show = (typeof b.show === "undefined") ? true : b.show;
        this._position = position;
        this._actualPosition = position.clone(); // For columbus view and 2D
        this._pixelOffset = b.pixelOffset ? new Cartesian2(b.pixelOffset.x, b.pixelOffset.y) : Cartesian2.getZero();
        this._eyeOffset = b.eyeOffset ? new Cartesian3(b.eyeOffset.x, b.eyeOffset.y, b.eyeOffset.z) : Cartesian3.getZero();
        this._horizontalOrigin = b.horizontalOrigin || HorizontalOrigin.CENTER;
        this._verticalOrigin = b.verticalOrigin || VerticalOrigin.CENTER;
        this._scale = (typeof b.scale === "undefined") ? 1.0 : b.scale;
        this._imageIndex = b.imageIndex || 0;
        this._color = {
            red : color.red,
            green : color.green,
            blue : color.blue,
            alpha : color.alpha
        };
        this._pickId = undefined;
        this._pickIdThis = b._pickIdThis;

        this._collection = collection;
        this._dirty = false;
    }

    var SHOW_INDEX = Billboard.SHOW_INDEX = 0;
    var POSITION_INDEX = Billboard.POSITION_INDEX = 1;
    var PIXEL_OFFSET_INDEX = Billboard.PIXEL_OFFSET_INDEX = 2;
    var EYE_OFFSET_INDEX = Billboard.EYE_OFFSET_INDEX = 3;
    var HORIZONTAL_ORIGIN_INDEX = Billboard.HORIZONTAL_ORIGIN_INDEX = 4;
    var VERTICAL_ORIGIN_INDEX = Billboard.VERTICAL_ORIGIN_INDEX = 5;
    var SCALE_INDEX = Billboard.SCALE_INDEX = 6;
    var IMAGE_INDEX_INDEX = Billboard.IMAGE_INDEX_INDEX = 7;
    var COLOR_INDEX = Billboard.COLOR_INDEX = 8;
    var NUMBER_OF_PROPERTIES = Billboard.NUMBER_OF_PROPERTIES = 9;

    Billboard.prototype._isDirty = function() {
        return this._dirty;
    };

    Billboard.prototype._clean = function() {
        this._dirty = false;
    };

    Billboard.prototype._makeDirty = function(propertyChanged) {
        var c = this._collection;
        if (c) {
            c._updateBillboard(this, propertyChanged);
            this._dirty = true;
        }
    };

    Billboard.prototype.getPickId = function(context) {
        this._pickId = this._pickId || context.createPickId(this._pickIdThis || this);
        return this._pickId;
    };

    Billboard.prototype._getCollection = function() {
        return this._collection;
    };

    /**
     * Returns true if this billboard will be shown.  Call {@link Billboard#setShow}
     * to hide or show a billboard, instead of removing it and re-adding it to the collection.
     *
     * @memberof Billboard
     *
     * @return {Boolean} <code>true</code> if this billboard will be shown; otherwise, <code>false</code>.
     *
     * @see Billboard#setShow
     */
    Billboard.prototype.getShow = function() {
        return this._show;
    };

    /**
     * Determines if this billboard will be shown.  Call this to hide or show a billboard, instead
     * of removing it and re-adding it to the collection.
     *
     * @memberof Billboard
     *
     * @param {Boolean} value Indicates if this billboard will be shown.
     *
     * @see Billboard#getShow
     */
    Billboard.prototype.setShow = function(value) {
        if ((typeof value !== "undefined") && (this._show !== value)) {
            this._show = value;
            this._makeDirty(SHOW_INDEX);
        }
    };

    /**
     * Returns the Cartesian position of this billboard.
     *
     * @memberof Billboard
     *
     * @return {Cartesian3} The Cartesian position of this billboard.
     *
     * @see Billboard#setPosition
     */
    Billboard.prototype.getPosition = function() {
        return this._position;
    };

    /**
     * Sets the Cartesian position of this billboard.
     * <br /><br />
     * As shown in the examples, <code>value</code> can be either a {@link Cartesian3}
     * or an object literal with <code>x</code>, <code>y</code>, and <code>z</code> properties.
     * A copy of <code>value</code> is made, so changing it after calling <code>setPosition</code>
     * does not affect the billboard's position; an explicit call to <code>setPosition</code> is required.
     *
     * @memberof Billboard
     *
     * @param {Cartesian3} value The Cartesian position.
     *
     * @see Billboard#getPosition
     *
     * @example
     * // Example 1. Set a billboard's position using a Cartesian3.
     * b.setPosition(new Cartesian3(1.0, 2.0, 3.0));
     *
     * //////////////////////////////////////////////////////////////////
     *
     * // Example 2. Set a billboard's position using an object literal.
     * b.setPosition({
     *   x : 1.0,
     *   y : 2.0,
     *   z : 3.0});
     */
    Billboard.prototype.setPosition = function(value) {
        var p = this._position;

        if ((typeof value !== "undefined") && ((p.x !== value.x) || (p.y !== value.y) || (p.z !== value.z))) {
            p.x = value.x;
            p.y = value.y;
            p.z = value.z;

            var actualP = this._actualPosition;
            actualP.x = value.x;
            actualP.y = value.y;
            actualP.z = value.z;

            this._makeDirty(POSITION_INDEX);
        }
    };

    Billboard.prototype._getActualPosition = function() {
        return this._actualPosition;
    };

    Billboard.prototype._setActualPosition = function(value) {
        var actualP = this._actualPosition;
        actualP.x = value.x;
        actualP.y = value.y;
        actualP.z = value.z;

        this._makeDirty(POSITION_INDEX);
    };

    /**
     * Returns the pixel offset from the origin of this billboard.
     *
     * @memberof Billboard
     *
     * @return {Cartesian2} The pixel offset of this billboard.
     *
     * @see Billboard#setPixelOffset
     */
    Billboard.prototype.getPixelOffset = function() {
        return this._pixelOffset;
    };

    /**
     * Sets the pixel offset in screen space from the origin of this billboard.  This is commonly used
     * to align multiple billboards and labels at the same position, e.g., an image and text.  The
     * screen space origin is the bottom, left corner of the canvas; <code>x</code> increases from
     * left to right, and <code>y</code> increases from bottom to top.
     * <br /><br />
     * <code>value</code> can be either a {@link Cartesian2}  or an object literal with
     * <code>x</code> and <code>y</code> properties.  A copy of <code>value</code> is made, so
     * changing it after calling <code>setPixelOffset</code> does not affect the billboard's pixel
     * offset; an explicit call to <code>setPixelOffset</code> is required.
     * <br /><br />
     * <div align="center">
     * <table border="0" cellpadding="5"><tr>
     * <td align="center"><code>default</code><br/><img src="images/Billboard.setPixelOffset.default.png" width="250" height="188" /></td>
     * <td align="center"><code>b.setPixelOffset({ x : 50, y : -25 });</code><br/><img src="images/Billboard.setPixelOffset.x50y-25.png" width="250" height="188" /></td>
     * </tr></table>
     * The billboard's origin is indicated by the yellow point.
     * </div>
     *
     * @memberof Billboard
     *
     * @param {Cartesian2} value The 2D Cartesian pixel offset.
     *
     * @see Billboard#getPixelOffset
     * @see Label#setPixelOffset
     */
    Billboard.prototype.setPixelOffset = function(value) {
        var p = this._pixelOffset;

        if ((typeof value !== "undefined") && ((p.x !== value.x) || (p.y !== value.y))) {
            p.x = value.x;
            p.y = value.y;
            this._makeDirty(PIXEL_OFFSET_INDEX);
        }
    };

    /**
     * Returns the 3D Cartesian offset applied to this billboard in eye coordinates.
     *
     * @memberof Billboard
     *
     * @return {Cartesian3} The 3D Cartesian offset applied to this billboard in eye coordinates.
     *
     * @see Billboard#setEyeOffset
     */
    Billboard.prototype.getEyeOffset = function() {
        return this._eyeOffset;
    };

    /**
     * Sets the 3D Cartesian offset applied to this billboard in eye coordinates.  Eye coordinates is a left-handed
     * coordinate system, where <code>x</code> points towards the viewer's right, <code>y</code> points up, and
     * <code>z</code> points into the screen.  Eye coordinates use the same scale as world and model coordinates,
     * which is typically meters.
     * <br /><br />
     * An eye offset is commonly used to arrange multiple billboards or objects at the same position, e.g., to
     * arrange a billboard above its corresponding 3D model.
     * <br /><br />
     * <code>value</code> can be either a {@link Cartesian3} or an object literal with <code>x</code>,
     * <code>y</code>, and <code>z</code> properties.  A copy of <code>value</code> is made, so changing it after
     * calling <code>setEyeOffset</code> does not affect the billboard's eye offset; an explicit call to
     * <code>setEyeOffset</code> is required.
     * <br /><br />
     * Below, the billboard is positioned at the center of the Earth but an eye offset makes it always
     * appear on top of the Earth regardless of the viewer's or Earth's orientation.
     * <br /><br />
     * <div align="center">
     * <table border="0" cellpadding="5"><tr>
     * <td align="center"><img src="images/Billboard.setEyeOffset.one.png" width="250" height="188" /></td>
     * <td align="center"><img src="images/Billboard.setEyeOffset.two.png" width="250" height="188" /></td>
     * </tr></table>
     * <code>b.setEyeOffset({ x : 0.0, y : 8000000.0, z : 0.0 });</code><br /><br />
     * </div>
     *
     * @memberof Billboard
     *
     * @param {Cartesian3} value The 3D Cartesian offset in eye coordinates.
     *
     * @see Billboard#getEyeOffset
     */
    Billboard.prototype.setEyeOffset = function(value) {
        var e = this._eyeOffset;

        if ((typeof value !== "undefined") && ((e.x !== value.x) || (e.y !== value.y) || (e.z !== value.z))) {
            e.x = value.x;
            e.y = value.y;
            e.z = value.z;
            this._makeDirty(EYE_OFFSET_INDEX);
        }
    };

    /**
     * Returns the horizontal origin of this billboard.
     *
     * @memberof Billboard
     *
     * @return {HorizontalOrigin} The horizontal origin of this billboard.
     *
     * @see Billboard#setHorizontalOrigin
     */
    Billboard.prototype.getHorizontalOrigin = function() {
        return this._horizontalOrigin;
    };

    /**
     * Sets the horizontal origin of this billboard, which determines if the billboard is
     * to the left, center, or right of its position.
     * <br /><br />
     * <div align="center">
     * <img src="images/Billboard.setHorizontalOrigin.png" width="400" height="300" /><br />
     * </div>
     *
     * @memberof Billboard
     *
     * @param {HorizontalOrigin} value The horizontal origin.
     *
     * @see Billboard#getHorizontalOrigin
     * @see Billboard#setVerticalOrigin
     *
     * @example
     * // Use a bottom, left origin
     * b.setHorizontalOrigin(HorizontalOrigin.LEFT);
     * b.setVerticalOrigin(VerticalOrigin.BOTTOM);
     */
    Billboard.prototype.setHorizontalOrigin = function(value) {
        if ((typeof value !== "undefined") && (this._horizontalOrigin !== value)) {
            this._horizontalOrigin = value;
            this._makeDirty(HORIZONTAL_ORIGIN_INDEX);
        }
    };

    /**
     * Returns the vertical origin of this billboard.
     *
     * @memberof Billboard
     *
     * @return {VerticalOrigin} The vertical origin of this billboard.
     *
     * @see Billboard#setVerticalOrigin
     */
    Billboard.prototype.getVerticalOrigin = function() {
        return this._verticalOrigin;
    };

    /**
     * Sets the vertical origin of this billboard, which determines if the billboard is
     * to the above, below, or at the center of its position.
     * <br /><br />
     * <div align="center">
     * <img src="images/Billboard.setVerticalOrigin.png" width="400" height="300" /><br />
     * </div>
     *
     * @memberof Billboard
     *
     * @param {VerticalOrigin} value The vertical origin.
     *
     * @see Billboard#getVerticalOrigin
     * @see Billboard#setHorizontalOrigin
     *
     * @example
     * // Use a bottom, left origin
     * b.setHorizontalOrigin(HorizontalOrigin.LEFT);
     * b.setVerticalOrigin(VerticalOrigin.BOTTOM);
     */
    Billboard.prototype.setVerticalOrigin = function(value) {
        if ((typeof value !== "undefined") && (this._verticalOrigin !== value)) {
            this._verticalOrigin = value;
            this._makeDirty(VERTICAL_ORIGIN_INDEX);
        }
    };

    /**
     * Returns the uniform scale that is multiplied with the billboard's image size in pixels.
     *
     * @memberof Billboard
     *
     * @return {Number} The scale used to size the billboard.
     *
     * @see Billboard#setScale
     */
    Billboard.prototype.getScale = function() {
        return this._scale;
    };

    /**
     * Sets the uniform scale that is multiplied with the billboard's image size in pixels.
     * A scale of <code>1.0</code> does not change the size of the billboard; a scale greater than
     * <code>1.0</code> enlarges the billboard; a positive scale less than <code>1.0</code> shrinks
     * the billboard.
     * <br /><br />
     * <div align="center">
     * <img src="images/Billboard.setScale.png" width="400" height="300" /><br/>
     * From left to right in the above image, the scales are <code>0.5</code>, <code>1.0</code>,
     * and <code>2.0</code>.
     * </div>
     *
     * @memberof Billboard
     *
     * @param {Number} value The scale used to size the billboard.
     *
     * @see Billboard#getScale
     * @see Billboard#setImageIndex
     */
    Billboard.prototype.setScale = function(value) {
        if ((typeof value !== "undefined") && (this._scale !== value)) {
            this._scale = value;
            this._makeDirty(SCALE_INDEX);
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof Billboard
     *
     * @see Billboard#setImageIndex
     * @see BillboardCollection#setTextureAtlas
     */
    Billboard.prototype.getImageIndex = function() {
        return this._imageIndex;
    };

    /**
     * DOC_TBA
     *
     * @memberof Billboard
     *
     * @see Billboard#getImageIndex
     * @see BillboardCollection#setTextureAtlas
     */
    Billboard.prototype.setImageIndex = function(value) {
        if ((typeof value !== "undefined") && (this._imageIndex !== value)) {
            this._imageIndex = value;
            this._makeDirty(IMAGE_INDEX_INDEX);
        }
    };

    /**
     * Returns the color that is multiplied with the billboard's texture.  The red, green, blue, and alpha values
     * are indicated by the returned object's <code>red</code>, <code>green</code>, <code>blue</code>, and <code>alpha</code>
     * properties, which range from <code>0</code> (no intensity) to <code>1.0</code> (full intensity).
     *
     * @memberof Billboard
     *
     * @return {Number} The color that is multiplied with the billboard's texture.
     *
     * @see Billboard#setColor
     */
    Billboard.prototype.getColor = function() {
        return this._color;
    };

    /**
     * Sets the color that is multiplied with the billboard's texture.  This has two common use cases.  First,
     * the same white texture may be used by many different billboards, each with a different color, to create
     * colored billboards.  Second, the color's alpha component can be used to make the billboard translucent as shown below.
     * An alpha of <code>0.0</code> makes the billboard transparent, and <code>1.0</code> makes the billboard opaque.
     * <br /><br />
     * <div align="center">
     * <table border="0" cellpadding="5"><tr>
     * <td align="center"><code>default</code><br/><img src="images/Billboard.setColor.Alpha255.png" width="250" height="188" /></td>
     * <td align="center"><code>alpha : 0.5</code><br/><img src="images/Billboard.setColor.Alpha127.png" width="250" height="188" /></td>
     * </tr></table>
     * </div>
     * <br />
     * The red, green, blue, and alpha values are indicated by <code>value</code>'s <code>red</code>, <code>green</code>,
     * <code>blue</code>, and <code>alpha</code> properties as shown in Example 1.  These components range from <code>0.0</code>
     * (no intensity) to <code>1.0</code> (full intensity).
     *
     * @memberof Billboard
     *
     * @param {Object} value The color's red, green, blue, and alpha components.
     *
     * @see Billboard#getColor
     *
     * @example
     *
     * // Example 1. Assign yellow.
     * b.setColor({
     *   red   : 1.0,
     *   green : 1.0,
     *   blue  : 0.0,
     *   alpha : 1.0 });
     *
     * //////////////////////////////////////////////////////////////////
     *
     * // Example 2. Make a billboard 50% translucent.
     * b.setColor({
     *   red   : 1.0,
     *   green : 1.0,
     *   blue  : 1.0,
     *   alpha : 0.5 });
     */
    Billboard.prototype.setColor = function(value) {
        var c = this._color;

        if ((typeof value !== "undefined") &&
            ((c.red !== value.red) || (c.green !== value.green) || (c.blue !== value.blue) || (c.alpha !== value.alpha))) {

            c.red = value.red;
            c.green = value.green;
            c.blue = value.blue;
            c.alpha = value.alpha;
            this._makeDirty(COLOR_INDEX);
        }
    };

    Billboard._computeScreenSpacePosition = function(modelMatrix, position, eyeOffset, pixelOffset, uniformState) {
        // This function is basically a stripped-down JavaScript version of BillboardCollectionVS.glsl

        // Model to eye coordinates
        var mv = uniformState.getView().multiplyWithMatrix(modelMatrix);
        var positionEC = mv.multiplyWithVector(new Cartesian4(position.x, position.y, position.z, 1.0));

        // Apply eye offset, e.g., agi_eyeOffset
        var zEyeOffset = eyeOffset.multiplyComponents(positionEC.normalize());
        positionEC.x += eyeOffset.x + zEyeOffset.x;
        positionEC.y += eyeOffset.y + zEyeOffset.y;
        positionEC.z += zEyeOffset.z;

        // Eye to window coordinates, e.g., agi_eyeToWindowCoordinates
        var q = uniformState.getProjection().multiplyWithVector(positionEC); // clip coordinates
        q.x /= q.w; // normalized device coordinates
        q.y /= q.w;
        q.z /= q.w;
        var positionWC = uniformState.getViewportTransformation().multiplyWithVector(new Cartesian4(q.x, q.y, q.z, 1.0)); // window coordinates

        // Apply pixel offset
        var po = pixelOffset.multiplyWithScalar(uniformState.getHighResolutionSnapScale());
        positionWC.x += po.x;
        positionWC.y += po.y;

        return new Cartesian2(positionWC.x, positionWC.y);
    };

    /**
     * Computes the screen-space position of the billboard's origin, taking into account eye and pixel offsets.
     * The screen space origin is the bottom, left corner of the canvas; <code>x</code> increases from
     * left to right, and <code>y</code> increases from bottom to top.
     *
     * @memberof Billboard
     *
     * @param {UniformState} uniformState The same state object passed to {@link BillboardCollection#render}.
     *
     * @return {Cartesian2} The screen-space position of the billboard.
     *
     * @exception {DeveloperError} Billboard must be in a collection.
     * @exception {DeveloperError} uniformState is required.
     *
     * @see Billboard#setEyeOffset
     * @see Billboard#setPixelOffset
     * @see BillboardCollection#render
     *
     * @example
     * console.log(b.computeScreenSpacePosition(scene.getUniformState()).toString());
     */
    Billboard.prototype.computeScreenSpacePosition = function(uniformState) {
        if (!this._collection) {
            throw new DeveloperError("Billboard must be in a collection.  Was it removed?");
        }

        if (!uniformState) {
            throw new DeveloperError("uniformState is required.", "uniformState");
        }

        return Billboard._computeScreenSpacePosition(this._collection.modelMatrix, this._actualPosition, this._eyeOffset, this._pixelOffset, uniformState);
    };

    /**
    * Determines if this billboard equals another billboard.  Billboards are equal if all their properties
    * are equal.  Billboards in different collections can be equal.
    *
    * @memberof Billboard
    *
    * @param {Billboard} other The billboard to compare for equality.
    *
    * @return {Boolean} <code>true</code> if the billboards are equal; otherwise, <code>false</code>.
     */
    Billboard.prototype.equals = function(other) {
        return other &&
               (this._show === other._show) &&
               (this._position.equals(other._position)) &&
               (this._pixelOffset.equals(other._pixelOffset)) &&
               (this._eyeOffset.equals(other._eyeOffset)) &&
               (this._horizontalOrigin.value === other._horizontalOrigin.value) &&
               (this._verticalOrigin.value === other._verticalOrigin.value) &&
               (this._scale === other._scale) &&
               (this._imageIndex === other._imageIndex) &&
               (shallowEquals(this._color, other._color));
    };

    Billboard.prototype._destroy = function() {
        this._pickId = this._pickId && this._pickId.destroy();
        this._collection = null;
    };

    return Billboard;
});
/*global define*/
define('Scene/ViscousDrag',[],function() {
    

    function ViscousDrag(coefficientOfDrag) {
        // TODO:  throw if coefficient is negative?  Zero (no drag) is OK, I guess.
        this.coefficientOfDrag = coefficientOfDrag || 1.0;
    }

    ViscousDrag.prototype.apply = function(particles) {
        if (particles) {
            var negativeCoefficientOfDrag = -this.coefficientOfDrag;
            var length = particles.length;
            for ( var i = 0; i < length; ++i) {
                var particle = particles[i];

                particle.force = particle.force.add(particle.velocity.multiplyWithScalar(negativeCoefficientOfDrag)); // f = -(kd)(v)
            }
        }
    };

    return ViscousDrag;
});
/*global define*/
define('Scene/combineMaterials',[],function() {
    

    /**
     * DOC_TBA
     */
    function combineMaterials() {
        var unforms = {};
        var concatenatedSource = "";
        var duplicateUniforms = {};

        var length = arguments.length;
        for ( var i = 0; i < length; ++i) {
            var material = arguments[i].material;
            var materialSource = material._getShaderSource();
            var materialUniforms = material._uniforms;

            for ( var name in materialUniforms) {
                if (materialUniforms.hasOwnProperty(name)) {
                    if (unforms[name]) {
                        // Rename uniform
                        var count = duplicateUniforms[name] || 1;
                        var uniqueName = "_agi_" + name + count.toString();

                        // PERFORMANCE_IDEA:  We could cache the RegExp for duplicate uniforms
                        // or see if a pure JavaScript search-and-replace is faster.

                        // This could rename other things like GLSL comments and other identifiers
                        // with the same name.
                        materialSource = materialSource.replace(new RegExp(name, "g"), uniqueName);
                        unforms[uniqueName] = materialUniforms[name];

                        duplicateUniforms[name] = count + 1;
                    } else {
                        unforms[name] = materialUniforms[name];
                    }
                }
            }

            if (arguments[i].sourceTransform) {
                materialSource = arguments[i].sourceTransform(materialSource);
            }

            concatenatedSource += "#line 0\n" + materialSource;
        }

        return {
            _uniforms : unforms,
            _getShaderSource : function() {
                return concatenatedSource;
            }
        };
    }

    return combineMaterials;
});

/*global define*/
define('Shaders/BillboardCollectionFS',[],function() {
  
  return "uniform sampler2D u_atlas;\n" +
"varying vec2 v_textureCoordinates;\n" +
"varying vec4 v_color;\n" +
"varying vec4 v_pickColor;\n" +
"void main()\n" +
"{\n" +
"vec4 color = texture2D(u_atlas, v_textureCoordinates) * v_color;\n" +
"if (color.a == 0.0)\n" +
"{\n" +
"discard;\n" +
"}\n" +
"#ifdef RENDER_FOR_PICK\n" +
"gl_FragColor = v_pickColor;\n" +
"#else\n" +
"gl_FragColor = color;\n" +
"#endif\n" +
"}\n" +
"";
});

/*global define*/
define('Shaders/BillboardCollectionVS',[],function() {
  
  return "attribute vec3 position;\n" +
"attribute vec2 direction;\n" +
"attribute vec4 textureCoordinatesAndImageSize;\n" +
"attribute vec4 color;\n" +
"attribute vec3 originAndShow;\n" +
"attribute vec2 pixelOffset;\n" +
"attribute vec4 eyeOffsetAndScale;\n" +
"attribute vec4 pickColor;\n" +
"uniform vec2 u_atlasSize;\n" +
"const vec2 agi_highResolutionSnapScale = vec2(1.0, 1.0);\n" +
"varying vec2 v_textureCoordinates;\n" +
"varying vec4 v_color;\n" +
"varying vec4 v_pickColor;\n" +
"void main()\n" +
"{\n" +
"vec3 eyeOffset = eyeOffsetAndScale.xyz;\n" +
"float scale = eyeOffsetAndScale.w;\n" +
"vec2 textureCoordinates = textureCoordinatesAndImageSize.xy;\n" +
"vec2 imageSize = textureCoordinatesAndImageSize.zw;\n" +
"vec2 origin = originAndShow.xy;\n" +
"float show = originAndShow.z;\n" +
"vec4 positionEC = agi_modelView * vec4(position, 1.0);\n" +
"positionEC = agi_eyeOffset(positionEC, eyeOffset);\n" +
"positionEC.xyz *= show;\n" +
"vec4 positionWC = agi_eyeToWindowCoordinates(positionEC);\n" +
"vec2 halfSize = u_atlasSize * imageSize * 0.5 * scale * agi_highResolutionSnapScale;\n" +
"halfSize *= ((direction * 2.0) - 1.0);\n" +
"positionWC.xy += (origin * abs(halfSize)) + halfSize;\n" +
"positionWC.xy += (pixelOffset * agi_highResolutionSnapScale);\n" +
"gl_Position = agi_viewportOrthographic * vec4(positionWC.xy, -positionWC.z, 1.0);\n" +
"v_textureCoordinates = textureCoordinates;\n" +
"v_color = color;\n" +
"v_pickColor = pickColor;\n" +
"}\n" +
"";
});
/*global define*/
define('Scene/BillboardCollection',[
        '../Core/DeveloperError',
        '../Core/combine',
        '../Core/destroyObject',
        '../Core/Math',
        '../Core/Cartesian3',
        '../Core/Cartesian4',
        '../Core/Matrix4',
        '../Core/ComponentDatatype',
        '../Core/IndexDatatype',
        '../Core/PrimitiveType',
        '../Renderer/BlendingState',
        '../Renderer/BufferUsage',
        '../Renderer/VertexArrayFacade',
        './SceneMode',
        './Billboard',
        '../Shaders/BillboardCollectionVS',
        '../Shaders/BillboardCollectionFS'
    ], function(
        DeveloperError,
        combine,
        destroyObject,
        CesiumMath,
        Cartesian3,
        Cartesian4,
        Matrix4,
        ComponentDatatype,
        IndexDatatype,
        PrimitiveType,
        BlendingState,
        BufferUsage,
        VertexArrayFacade,
        SceneMode,
        Billboard,
        BillboardCollectionVS,
        BillboardCollectionFS) {
    
    /*global Uint8Array,Uint16Array,Uint32Array*/

    var SHOW_INDEX = Billboard.SHOW_INDEX;
    var POSITION_INDEX = Billboard.POSITION_INDEX;
    var PIXEL_OFFSET_INDEX = Billboard.PIXEL_OFFSET_INDEX;
    var EYE_OFFSET_INDEX = Billboard.EYE_OFFSET_INDEX;
    var HORIZONTAL_ORIGIN_INDEX = Billboard.HORIZONTAL_ORIGIN_INDEX;
    var VERTICAL_ORIGIN_INDEX = Billboard.VERTICAL_ORIGIN_INDEX;
    var SCALE_INDEX = Billboard.SCALE_INDEX;
    var IMAGE_INDEX_INDEX = Billboard.IMAGE_INDEX_INDEX;
    var COLOR_INDEX = Billboard.COLOR_INDEX;
    var NUMBER_OF_PROPERTIES = Billboard.NUMBER_OF_PROPERTIES;

    // PERFORMANCE_IDEA:  Use vertex compression so we don't run out of
    // vec4 attributes (WebGL minimum: 8)
    var attributeIndices = {
        position : 0,
        pixelOffset : 1,
        eyeOffsetAndScale : 2,
        textureCoordinatesAndImageSize : 3,
        pickColor : 4,
        color : 5,
        originAndShow : 6,
        direction : 7
    };

    /**
     * A renderable collection of billboards.  Billboards are viewport-aligned
     * images positioned in the 3D scene.
     * <br /><br />
     * <div align="center">
     * <img src="images/Billboard.png" width="400" height="300" /><br />
     * Example billboards
     * </div>
     * <br /><br />
     * Billboards are added and removed from the collection using {@link BillboardCollection#add}
     * and {@link BillboardCollection#remove}.  All billboards in a collection reference images
     * from the same texture atlas, which is assigned using {@link BillboardCollection#setTextureAtlas}.
     *
     * @name BillboardCollection
     * @constructor
     *
     * @performance For best performance, prefer a few collections, each with many billboards, to
     * many collections with only a few billboards each.  Organize collections so that billboards
     * with the same update frequency are in the same collection, i.e., billboards that do not
     * change should be in one collection; billboards that change every frame should be in another
     * collection; and so on.
     *
     * @see BillboardCollection#add
     * @see BillboardCollection#remove
     * @see BillboardCollection#setTextureAtlas
     * @see Billboard
     * @see TextureAtlas
     * @see LabelCollection
     *
     * @example
     * // Create a billboard collection with two billboards
     * var atlas = scene.getContext().createTextureAtlas(images);
     * var billboards = new BillboardCollection();
     * billboards.setTextureAtlas(atlas);
     * billboards.add({
     *   position : { x : 1.0, y : 2.0, z : 3.0 }
     * });
     * billboards.add({
     *   position : { x : 4.0, y : 5.0, z : 6.0 }
     * });
     */
    function BillboardCollection() {
        this._textureAtlas = undefined;
        this._destroyTextureAtlas = true;
        this._sp = undefined;
        this._rs = undefined;
        this._vaf = undefined;
        this._rsPick = undefined;
        this._spPick = undefined;

        this._billboards = [];
        this._billboardsToUpdate = [];
        this._billboardsRemoved = false;
        this._createVertexArray = false;

        this._propertiesChanged = new Uint32Array(NUMBER_OF_PROPERTIES);

        /**
         * The 4x4 transformation matrix that transforms each billboard in this collection from model to world coordinates.
         * When this is the identity matrix, the billboards are drawn in world coordinates, i.e., Earth's WGS84 coordinates.
         * Local reference frames can be used by providing a different transformation matrix, like that returned
         * by {@link Transforms.eastNorthUpToFixedFrame}.  This matrix is available to GLSL vertex and fragment
         * shaders via {@link agi_model} and derived uniforms.
         *
         * @type Matrix4
         *
         * @see Transforms.eastNorthUpToFixedFrame
         * @see agi_model
         *
         * @example
         * var center = ellipsoid.cartographicDegreesToCartesian(new Cartographic2(-75.59777, 40.03883));
         * billboards.modelMatrix = Transforms.eastNorthUpToFixedFrame(center);
         * billboards.add({ position : new Cartesian3(0.0, 0.0, 0.0) }); // center
         * billboards.add({ position : new Cartesian3(1000000.0, 0.0, 0.0) }); // east
         * billboards.add({ position : new Cartesian3(0.0, 1000000.0, 0.0) }); // north
         * billboards.add({ position : new Cartesian3(0.0, 0.0, 1000000.0) }); // up
         * ]);
         */
        this.modelMatrix = Matrix4.getIdentity();
        this._modelMatrix = Matrix4.getIdentity();

        /**
         * DOC_TBA
         *
         * @type Number
         */
        this.morphTime = 0.0;

        this._mode = SceneMode.SCENE3D;
        this._projection = undefined;

        // The buffer usage for each attribute is determined based on the usage of the attribute over time.
        this._buffersUsage = [
                              BufferUsage.STATIC_DRAW, // SHOW_INDEX
                              BufferUsage.STATIC_DRAW, // POSITION_INDEX
                              BufferUsage.STATIC_DRAW, // PIXEL_OFFSET_INDEX
                              BufferUsage.STATIC_DRAW, // EYE_OFFSET_INDEX
                              BufferUsage.STATIC_DRAW, // HORIZONTAL_ORIGIN_INDEX
                              BufferUsage.STATIC_DRAW, // VERTICAL_ORIGIN_INDEX
                              BufferUsage.STATIC_DRAW, // SCALE_INDEX
                              BufferUsage.STATIC_DRAW, // IMAGE_INDEX_INDEX
                              BufferUsage.STATIC_DRAW // COLOR_INDEX
                          ];

        var that = this;
        var uniforms = {
            u_atlas : function() {
                return that._textureAtlas.getTexture();
            },
            u_atlasSize : function() {
                return that._textureAtlas.getTexture().getDimensions();
            }
        };

        this._uniforms3D = combine(uniforms, {
            u_model : function() {
                return that.modelMatrix;
            }
        });
        this._uniforms2D = combine(uniforms, {
            u_model : function() {
                return Matrix4.getIdentity();
            }
        });
        this._uniforms = undefined;
    }

    /**
     * Creates and adds a billboard with the specified initial properties to the collection.
     * The added billboard is returned so it can be modified or removed from the collection later.
     *
     * @memberof BillboardCollection
     *
     * @param {Object}[billboard=undefined] A template describing the billboard's properties as shown in Example 1.
     *
     * @return {Billboard} The billboard that was added to the collection.
     *
     * @performance Calling <code>add</code> is expected constant time.  However, when
     * {@link BillboardCollection#update} is called, the collection's vertex buffer
     * is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.  For
     * best performance, add as many billboards as possible before calling <code>update</code>.
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see BillboardCollection#remove
     * @see BillboardCollection#removeAll
     * @see BillboardCollection#update
     *
     * @example
     * // Example 1:  Add a billboard, specifying all the default values.
     * var b = billboards.add({
     *   show : true,
     *   position : new Cartesian3(0.0, 0.0, 0.0),
     *   pixelOffset : new Cartesian2(0.0, 0.0),
     *   eyeOffset : new Cartesian3(0.0, 0.0, 0.0),
     *   horizontalOrigin : HorizontalOrigin.CENTER,
     *   verticalOrigin : VerticalOrigin.CENTER,
     *   scale : 1.0,
     *   imageIndex : 0,
     *   color : { red : 1.0, green : 1.0, blue : 1.0, alpha : 1.0 }
     * });
     *
     * // Example 2:  Specify only the billboard's cartographic position.
     * var b = billboards.add({
     *   position : ellipsoid.toCartesian(
     *     CesiumMath.cartographic3ToRadians(
     *       new Cartographic3(longitude, latitude, height)))
     * });
     */
    BillboardCollection.prototype.add = function(billboard) {
        var b = new Billboard(billboard, this);
        b._index = this._billboards.length;

        this._billboards.push(b);
        this._createVertexArray = true;

        return b;
    };

    /**
     * Removes a billboard from the collection.
     *
     * @memberof BillboardCollection
     *
     * @param {Billboard} billboard The billboard to remove.
     *
     * @return {Boolean} <code>true</code> if the billboard was removed; <code>false</code> if the billboard was not found in the collection.
     *
     * @performance Calling <code>remove</code> is expected constant time.  However, when
     * {@link BillboardCollection#update} is called, the collection's vertex buffer
     * is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.  For
     * best performance, remove as many billboards as possible before calling <code>update</code>.
     * If you intend to temporarily hide a billboard, it is usually more efficient to call
     * {@link Billboard#setShow} instead of removing and re-adding the billboard.
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see BillboardCollection#add
     * @see BillboardCollection#removeAll
     * @see BillboardCollection#update
     * @see Billboard#setShow
     *
     * @example
     * var b = billboards.add(...);
     * billboards.remove(b);  // Returns true
     */
    BillboardCollection.prototype.remove = function(billboard) {
        if (this.contains(billboard)) {
            this._billboards[billboard._index] = null; // Removed later
            this._billboardsRemoved = true;
            this._createVertexArray = true;
            billboard._destroy();
            return true;
        }

        return false;
    };

    /**
     * Removes all billboards from the collection.
     *
     * @performance <code>O(n)</code>.  It is more efficient to remove all the billboards
     * from a collection and then add new ones than to create a new collection entirely.
     *
     * @memberof BillboardCollection
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see BillboardCollection#add
     * @see BillboardCollection#remove
     * @see BillboardCollection#update
     *
     * @example
     * billboards.add(...);
     * billboards.add(...);
     * billboards.removeAll();
     */
    BillboardCollection.prototype.removeAll = function() {
        this._destroyBillboards();
        this._billboards = [];
        this._billboardsToUpdate = [];
        this._billboardsRemoved = false;

        this._createVertexArray = true;
    };

    BillboardCollection.prototype._removeBillboards = function() {
        if (this._billboardsRemoved) {
            this._billboardsRemoved = false;

            var billboards = [];

            var length = this._billboards.length;
            for ( var i = 0, j = 0; i < length; ++i) {
                var billboard = this._billboards[i];
                if (billboard) {
                    billboard._index = j++;
                    billboards.push(billboard);
                }
            }

            this._billboards = billboards;
        }
    };

    BillboardCollection.prototype._updateBillboard = function(billboard, propertyChanged) {
        if (!billboard._isDirty()) {
            this._billboardsToUpdate.push(billboard);
        }

        ++this._propertiesChanged[propertyChanged];
    };

    /**
     * DOC_TBA
     *
     * @memberof BillboardCollection
     *
     * @param {Object} billboard DOC_TBA
     *
     * @see BillboardCollection#get
     */
    BillboardCollection.prototype.contains = function(billboard) {
        return (billboard && (billboard._getCollection() === this));
    };

    /**
     * Returns the billboard in the collection at the specified index.  Indices are zero-based
     * and increase as billboards are added.  Removing a billboard shifts all billboards after
     * it to the left, changing their indices.  This function is commonly used with
     * {@link BillboardCollection#getLength} to iterate over all the billboards
     * in the collection.
     *
     * @memberof BillboardCollection
     *
     * @param {Number} index The zero-based index of the billboard.
     *
     * @return {Billboard} The billboard at the specified index.
     *
     * @performance Expected constant time.  If billboards were removed from the collection and
     * {@link BillboardCollection#update} was not called, an implicit <code>O(n)</code>
     * operation is performed.
     *
     * @exception {DeveloperError} index is required.
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see BillboardCollection#getLength
     *
     * @example
     * // Toggle the show property of every billboard in the collection
     * var len = billboards.getLength();
     * for (var i = 0; i < len; ++i) {
     *   var b = billboards.get(i);
     *   b.setShow(!b.getShow());
     * }
     */
    BillboardCollection.prototype.get = function(index) {
        if (typeof index === "undefined") {
            throw new DeveloperError("index is required.", "index");
        }

        this._removeBillboards();
        return this._billboards[index];
    };

    /**
     * Returns the number of billboards in this collection.  This is commonly used with
     * {@link BillboardCollection#get} to iterate over all the billboards
     * in the collection.
     *
     * @memberof BillboardCollection
     *
     * @return {Number} The number of billboards in this collection.
     *
     * @performance Expected constant time.  If billboards were removed from the collection and
     * {@link BillboardCollection#update} was not called, an implicit <code>O(n)</code>
     * operation is performed.
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see BillboardCollection#get
     *
     * @example
     * // Toggle the show property of every billboard in the collection
     * var len = billboards.getLength();
     * for (var i = 0; i < len; ++i) {
     *   var b = billboards.get(i);
     *   b.setShow(!b.getShow());
     * }
     */
    BillboardCollection.prototype.getLength = function() {
        this._removeBillboards();
        return this._billboards.length;
    };

    /**
     * DOC_TBA
     *
     * @memberof BillboardCollection
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see BillboardCollection#setTextureAtlas
     * @see Billboard#setImageIndex
     */
    BillboardCollection.prototype.getTextureAtlas = function() {
        return this._textureAtlas;
    };

    /**
     * DOC_TBA
     *
     * @memberof BillboardCollection
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see BillboardCollection#getTextureAtlas
     * @see Billboard#setImageIndex
     *
     * @example
     * // Assigns a texture atlas with two images to a billboard collection.
     * // Two billboards, each referring to one of the images, are then
     * // added to the collection.
     * var billboards = new BillboardCollection();
     * billboards.setTextureAtlas(
     *   scene.getContext().createTextureAtlas([image0, image1]));
     * billboards.add({
     *   // ...
     *   imageIndex : 0
     * });
     * billboards.add({
     *   // ...
     *   imageIndex : 1
     * });
     */
    BillboardCollection.prototype.setTextureAtlas = function(value) {
        if (this._textureAtlas !== value) {
            this._textureAtlas = this._destroyTextureAtlas && this._textureAtlas && this._textureAtlas.destroy();
            this._textureAtlas = value;
            this._createVertexArray = true; // New per-billboard texture coordinates
        }
    };

    /**
     * Returns <code>true</code> if the texture atlas is destroyed when the collection is
     * destroyed; otherwise, <code>false</code>.
     *
     * @memberof BillboardCollection
     *
     * @return <code>true</code> if the texture atlas is destroyed when the collection is
     * destroyed; otherwise, <code>false</code>.
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see BillboardCollection#setDestroyTextureAtlas
     */
    BillboardCollection.prototype.getDestroyTextureAtlas = function() {
        return this._destroyTextureAtlas;
    };

    /**
     * Determines if the texture atlas is destroyed when the collection is destroyed.  If the texture
     * atlas is used by more than one collection, set this to <code>false</code>, and explicitly
     * destroy the atlas to avoid attempting to destroy it multiple times.
     *
     * @memberof BillboardCollection
     *
     * @param {Boolean} value Indicates if the texture atlas is destroyed when the collection is destroyed.
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see BillboardCollection#getDestroyTextureAtlas
     * @see BillboardCollection#setTextureAtlas
     * @see BillboardCollection#destroy
     *
     * @example
     * // Destroy a billboard collection but not its texture atlas.
     * var atlas = scene.getContext().createTextureAtlas(...);
     * billboards.setTextureAtlas(atlas);
     * billboards.setDestroyTextureAtlas(false);
     * billboards = billboards.destroy();
     * console.log(atlas.isDestroyed()); // False
     */
    BillboardCollection.prototype.setDestroyTextureAtlas = function(value) {
        this._destroyTextureAtlas = value;
    };

    BillboardCollection._getDirectionsVertexBuffer = function(context) {
        var sixteenK = 16 * 1024;

        // Per-context cache for billboard collections
        context._primitivesCache = context._primitivesCache || {};
        var primitivesCache = context._primitivesCache;
        primitivesCache._billboardCollection = primitivesCache._billboardCollection || {};
        var c = primitivesCache._billboardCollection;

        if (c.directionsVertexBuffer) {
            return c.directionsVertexBuffer;
        }

        c.directionsVertexBuffer = c.directionsVertexBuffer && c.directionsVertexBuffer.destroy();

        var directions = new Uint8Array(sixteenK * 4 * 2);
        for ( var i = 0, j = 0; i < sixteenK; ++i) {
            directions[j++] = 0;
            directions[j++] = 0;

            directions[j++] = 255;
            directions[j++] = 0.0;

            directions[j++] = 255;
            directions[j++] = 255;

            directions[j++] = 0.0;
            directions[j++] = 255;
        }

        // PERFORMANCE_IDEA:  Should we reference count billboard collections, and eventually delete this?
        // Is this too much memory to allocate up front?  Should we dynamically grow it?
        c.directionsVertexBuffer = context.createVertexBuffer(directions, BufferUsage.STATIC_DRAW);
        c.directionsVertexBuffer.setVertexArrayDestroyable(false);
        return c.directionsVertexBuffer;
    };

    BillboardCollection._getIndexBuffer = function(context) {
        var sixteenK = 16 * 1024;

        // Per-context cache for billboard collections
        context._primitivesCache = context._primitivesCache || {};
        var primitivesCache = context._primitivesCache;
        primitivesCache._billboardCollection = primitivesCache._billboardCollection || {};
        var c = primitivesCache._billboardCollection;

        if (c.indexBuffer) {
            return c.indexBuffer;
        }

        var length = sixteenK * 6;
        var indices = new Uint16Array(length);
        for ( var i = 0, j = 0; i < length; i += 6, j += 4) {
            indices[i + 0] = j + 0;
            indices[i + 1] = j + 1;
            indices[i + 2] = j + 2;

            indices[i + 3] = j + 0;
            indices[i + 4] = j + 2;
            indices[i + 5] = j + 3;
        }

        // PERFORMANCE_IDEA:  Should we reference count billboard collections, and eventually delete this?
        // Is this too much memory to allocate up front?  Should we dynamically grow it?
        c.indexBuffer = context.createIndexBuffer(indices, BufferUsage.STATIC_DRAW, IndexDatatype.UNSIGNED_SHORT);
        c.indexBuffer.setVertexArrayDestroyable(false);
        return c.indexBuffer;
    };

    /**
     * Renders the billboards.  In order for changes to properties to be realized,
     * {@link BillboardCollection#update} must be called before <code>render</code>.
     * <br /><br />
     * A texture atlas must be assigned to the billboard collection using
     * {@link BillboardCollection#setTextureAtlas}, otherwise no billboards will be rendered.
     * <br /><br />
     * Billboards are rendered in a single pass using an uber-shader.
     *
     * @memberof BillboardCollection
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see BillboardCollection#update
     * @see BillboardCollection#setTextureAtlas
     */
    BillboardCollection.prototype.render = function(context) {
        if (this._vaf && this._vaf.va && this._textureAtlas) {
            var va = this._vaf.va;
            var length = va.length;
            for ( var i = 0; i < length; ++i) {
                context.draw({
                    primitiveType : PrimitiveType.TRIANGLES,
                    count : va[i].indicesCount,
                    shaderProgram : this._sp,
                    uniformMap : this._uniforms,
                    vertexArray : va[i].va,
                    renderState : this._rs
                });
            }
        }
    };

    /**
     * DOC_TBA
     * @memberof BillboardCollection
     */
    BillboardCollection.prototype.renderForPick = function(context, framebuffer) {
        if (this._vaf && this._vaf.va && this._textureAtlas) {
            var va = this._vaf.va;
            var length = va.length;
            for ( var i = 0; i < length; ++i) {
                context.draw({
                    primitiveType : PrimitiveType.TRIANGLES,
                    count : va[i].indicesCount,
                    shaderProgram : this._spPick,
                    uniformMap : this._uniforms,
                    vertexArray : va[i].va,
                    renderState : this._rsPick,
                    framebuffer : framebuffer
                });
            }
        }
    };

    /**
     * @private
     */
    BillboardCollection.prototype.update = function(context, sceneState) {
        // First update:  create render state and shader program
        this._rs = context.createRenderState({
            depthTest : {
                enabled : true
            },
            blending : BlendingState.ALPHA_BLEND
        });

        this._sp = context.getShaderCache().getShaderProgram(BillboardCollectionVS, BillboardCollectionFS, attributeIndices);

        this._update(context, sceneState);
        this.update = this._update;
    };

    BillboardCollection.prototype.computeNewBuffersUsage = function() {
        var buffersUsage = this._buffersUsage;
        var usageChanged = false;

        // PERFORMANCE_IDEA: Better heuristic to avoid ping-ponging.  What about DYNAMIC_STREAM?
        var properties = this._propertiesChanged;
        for ( var k = 0; k < NUMBER_OF_PROPERTIES; ++k) {
            var newUsage = (properties[k] === 0) ? BufferUsage.STATIC_DRAW : BufferUsage.STREAM_DRAW;
            usageChanged = usageChanged || (buffersUsage[k] !== newUsage);
            buffersUsage[k] = newUsage;
        }

        return usageChanged;
    };

    BillboardCollection._createVAF = function(context, numberOfBillboards, buffersUsage) {
        // Different billboard collections share the same vertex buffer for directions.
        var directionVertexBuffer = BillboardCollection._getDirectionsVertexBuffer(context);

        return new VertexArrayFacade(context, [{
            index : attributeIndices.position,
            componentsPerAttribute : 3,
            componentDatatype : ComponentDatatype.FLOAT,
            usage : buffersUsage[POSITION_INDEX]
        }, {
            index : attributeIndices.pixelOffset,
            componentsPerAttribute : 2,
            componentDatatype : ComponentDatatype.FLOAT,
            usage : buffersUsage[PIXEL_OFFSET_INDEX]
        }, {
            index : attributeIndices.eyeOffsetAndScale,
            componentsPerAttribute : 4,
            componentDatatype : ComponentDatatype.FLOAT,
            usage : buffersUsage[SCALE_INDEX] // buffersUsage[EYE_OFFSET_INDEX] ignored
        }, {
            index : attributeIndices.textureCoordinatesAndImageSize,
            componentsPerAttribute : 4,
            normalize : true,
            componentDatatype : ComponentDatatype.UNSIGNED_SHORT,
            usage : buffersUsage[IMAGE_INDEX_INDEX]
        }, {
            index : attributeIndices.pickColor,
            componentsPerAttribute : 4,
            normalize : true,
            componentDatatype : ComponentDatatype.UNSIGNED_BYTE,
            usage : BufferUsage.STATIC_DRAW
        }, {
            index : attributeIndices.color,
            componentsPerAttribute : 4,
            normalize : true,
            componentDatatype : ComponentDatatype.UNSIGNED_BYTE,
            usage : buffersUsage[COLOR_INDEX]
        }, {
            index : attributeIndices.originAndShow,
            componentsPerAttribute : 3,
            componentDatatype : ComponentDatatype.BYTE,
            usage : buffersUsage[SHOW_INDEX] // buffersUsage[HORIZONTAL_ORIGIN_INDEX] and buffersUsage[VERTICAL_ORIGIN_INDEX] ignored
        }, {
            index : attributeIndices.direction,
            vertexBuffer : directionVertexBuffer,
            componentsPerAttribute : 2,
            normalize : true,
            componentDatatype : ComponentDatatype.UNSIGNED_BYTE
        }], 4 * numberOfBillboards); // 4 vertices per billboard
    };

    ///////////////////////////////////////////////////////////////////////////

    // Four vertices per billboard.  Each has the same position, etc., but a different screen-space direction vector.

    // PERFORMANCE_IDEA:  Save memory if a property is the same for all billboards, use a latched attribute state,
    // instead of storing it in a vertex buffer.

    BillboardCollection.prototype._writePosition = function(context, textureAtlasCoordinates, vafWriters, billboard) {
        var i = (billboard._index * 4);
        var position = billboard._getActualPosition();

        vafWriters[attributeIndices.position](i + 0, position.x, position.y, position.z);
        vafWriters[attributeIndices.position](i + 1, position.x, position.y, position.z);
        vafWriters[attributeIndices.position](i + 2, position.x, position.y, position.z);
        vafWriters[attributeIndices.position](i + 3, position.x, position.y, position.z);
    };

    BillboardCollection.prototype._writePixelOffset = function(context, textureAtlasCoordinates, vafWriters, billboard) {
        var i = (billboard._index * 4);
        var pixelOffset = billboard.getPixelOffset();

        vafWriters[attributeIndices.pixelOffset](i + 0, pixelOffset.x, pixelOffset.y);
        vafWriters[attributeIndices.pixelOffset](i + 1, pixelOffset.x, pixelOffset.y);
        vafWriters[attributeIndices.pixelOffset](i + 2, pixelOffset.x, pixelOffset.y);
        vafWriters[attributeIndices.pixelOffset](i + 3, pixelOffset.x, pixelOffset.y);
    };

    BillboardCollection.prototype._writeEyeOffsetAndScale = function(context, textureAtlasCoordinates, vafWriters, billboard) {
        var i = (billboard._index * 4);
        var eyeOffset = billboard.getEyeOffset();
        var scale = billboard.getScale();

        vafWriters[attributeIndices.eyeOffsetAndScale](i + 0, eyeOffset.x, eyeOffset.y, eyeOffset.z, scale);
        vafWriters[attributeIndices.eyeOffsetAndScale](i + 1, eyeOffset.x, eyeOffset.y, eyeOffset.z, scale);
        vafWriters[attributeIndices.eyeOffsetAndScale](i + 2, eyeOffset.x, eyeOffset.y, eyeOffset.z, scale);
        vafWriters[attributeIndices.eyeOffsetAndScale](i + 3, eyeOffset.x, eyeOffset.y, eyeOffset.z, scale);
    };

    BillboardCollection.prototype._writePickColor = function(context, textureAtlasCoordinates, vafWriters, billboard) {
        var i = (billboard._index * 4);
        var pickColor = billboard.getPickId(context).unnormalizedRgb;

        vafWriters[attributeIndices.pickColor](i + 0, pickColor.red, pickColor.green, pickColor.blue, 255);
        vafWriters[attributeIndices.pickColor](i + 1, pickColor.red, pickColor.green, pickColor.blue, 255);
        vafWriters[attributeIndices.pickColor](i + 2, pickColor.red, pickColor.green, pickColor.blue, 255);
        vafWriters[attributeIndices.pickColor](i + 3, pickColor.red, pickColor.green, pickColor.blue, 255);
    };

    BillboardCollection.prototype._writeColor = function(context, textureAtlasCoordinates, vafWriters, billboard) {
        var i = (billboard._index * 4);
        var color = billboard.getColor();

        vafWriters[attributeIndices.color](i + 0, color.red * 255, color.green * 255, color.blue * 255, color.alpha * 255);
        vafWriters[attributeIndices.color](i + 1, color.red * 255, color.green * 255, color.blue * 255, color.alpha * 255);
        vafWriters[attributeIndices.color](i + 2, color.red * 255, color.green * 255, color.blue * 255, color.alpha * 255);
        vafWriters[attributeIndices.color](i + 3, color.red * 255, color.green * 255, color.blue * 255, color.alpha * 255);
    };

    BillboardCollection.prototype._writeOriginAndShow = function(context, textureAtlasCoordinates, vafWriters, billboard) {
        var i = (billboard._index * 4);
        var horizontalOrigin = billboard.getHorizontalOrigin().value;
        var verticalOrigin = billboard.getVerticalOrigin().value;
        var show = billboard.getShow();

        vafWriters[attributeIndices.originAndShow](i + 0, horizontalOrigin, verticalOrigin, show);
        vafWriters[attributeIndices.originAndShow](i + 1, horizontalOrigin, verticalOrigin, show);
        vafWriters[attributeIndices.originAndShow](i + 2, horizontalOrigin, verticalOrigin, show);
        vafWriters[attributeIndices.originAndShow](i + 3, horizontalOrigin, verticalOrigin, show);
    };

    BillboardCollection.prototype._writeTextureCoordinatesAndImageSize = function(context, textureAtlasCoordinates, vafWriters, billboard) {
        var i = (billboard._index * 4);
        var imageRectangle = textureAtlasCoordinates[billboard.getImageIndex()];
        var imageSize = {
            x : imageRectangle.x1 - imageRectangle.x0,
            y : imageRectangle.y1 - imageRectangle.y0
        };

        vafWriters[attributeIndices.textureCoordinatesAndImageSize](i + 0, imageRectangle.x0 * 65535, imageRectangle.y0 * 65535, imageSize.x * 65535, imageSize.y * 65535); // Lower Left
        vafWriters[attributeIndices.textureCoordinatesAndImageSize](i + 1, imageRectangle.x1 * 65535, imageRectangle.y0 * 65535, imageSize.x * 65535, imageSize.y * 65535); // Lower Right
        vafWriters[attributeIndices.textureCoordinatesAndImageSize](i + 2, imageRectangle.x1 * 65535, imageRectangle.y1 * 65535, imageSize.x * 65535, imageSize.y * 65535); // Upper Right
        vafWriters[attributeIndices.textureCoordinatesAndImageSize](i + 3, imageRectangle.x0 * 65535, imageRectangle.y1 * 65535, imageSize.x * 65535, imageSize.y * 65535); // Upper Left
    };

    BillboardCollection.prototype._writeBillboard = function(context, textureAtlasCoordinates, vafWriters, billboard) {
        this._writePosition(context, textureAtlasCoordinates, vafWriters, billboard);
        this._writePixelOffset(context, textureAtlasCoordinates, vafWriters, billboard);
        this._writeEyeOffsetAndScale(context, textureAtlasCoordinates, vafWriters, billboard);
        this._writePickColor(context, textureAtlasCoordinates, vafWriters, billboard);
        this._writeColor(context, textureAtlasCoordinates, vafWriters, billboard);
        this._writeOriginAndShow(context, textureAtlasCoordinates, vafWriters, billboard);
        this._writeTextureCoordinatesAndImageSize(context, textureAtlasCoordinates, vafWriters, billboard);
    };

    ///////////////////////////////////////////////////////////////////////////

    BillboardCollection.prototype._syncMorphTime = function(mode) {
        switch (mode) {
        case SceneMode.SCENE3D:
            this.morphTime = 1.0;
            break;

        case SceneMode.SCENE2D:
        case SceneMode.COLUMBUS_VIEW:
            this.morphTime = 0.0;
            break;

        // MORPHING - don't change it
        }
    };

    BillboardCollection.prototype._updateScene2D = function(projection, billboards) {
        var length = billboards.length;

        for ( var i = 0; i < length; ++i) {
            var b = billboards[i];
            var p = this.modelMatrix.multiplyWithVector(new Cartesian4(b.getPosition().x, b.getPosition().y, b.getPosition().z, 1.0));
            var projectedPoint = projection.project(projection.getEllipsoid().toCartographic3(new Cartesian3(p.x, p.y, p.z)));
            b._setActualPosition({
                x : 0.0,
                y : projectedPoint.x,
                z : projectedPoint.y
            });
        }
    };

    BillboardCollection.prototype._updateColumbusView = function(projection, billboards) {
        var length = billboards.length;

        for ( var i = 0; i < length; ++i) {
            var b = billboards[i];
            var p = this.modelMatrix.multiplyWithVector(new Cartesian4(b.getPosition().x, b.getPosition().y, b.getPosition().z, 1.0));
            var projectedPoint = projection.project(projection.getEllipsoid().toCartographic3(new Cartesian3(p.x, p.y, p.z)));
            b._setActualPosition({
                x : projectedPoint.z,
                y : projectedPoint.x,
                z : projectedPoint.y
            });
        }
    };

    BillboardCollection.prototype._updateMode = function(sceneState) {
        var mode = sceneState.mode;
        var projection = sceneState.scene2D.projection;
        this._syncMorphTime(mode);

        var billboards;
        var length;
        var i;
        var b;

        if ((this._mode !== mode) ||
            (this._projection !== projection) ||
            (mode !== SceneMode.SCENE3D) &&
            (!this._modelMatrix.equals(this.modelMatrix))) {

            this._mode = mode;
            this._projection = projection;
            this._modelMatrix = this.modelMatrix.clone();

            billboards = this._billboards;
            length = billboards.length;

            switch (mode) {
            case SceneMode.SCENE3D:
                for (i = 0; i < length; ++i) {
                    b = billboards[i];
                    b._setActualPosition(b.getPosition());
                }
                break;

            case SceneMode.SCENE2D:
                this._updateScene2D(projection, this._billboards);
                break;

            case SceneMode.COLUMBUS_VIEW:
                this._updateColumbusView(projection, this._billboards);
                break;
            }
        } else if (mode === SceneMode.MORPHING) {
            billboards = this._billboards;
            length = billboards.length;

            for (i = 0; i < length; ++i) {
                b = billboards[i];
                var p = b.getPosition();
                var projectedPoint = projection.project(projection.getEllipsoid().toCartographic3(p));

                b._setActualPosition({
                    x : CesiumMath.lerp(projectedPoint.z, p.x, this.morphTime),
                    y : CesiumMath.lerp(projectedPoint.x, p.y, this.morphTime),
                    z : CesiumMath.lerp(projectedPoint.y, p.z, this.morphTime)
                });
            }
        } else if (mode === SceneMode.SCENE2D) {
            this._updateScene2D(projection, this._billboardsToUpdate);
        } else if (mode === SceneMode.COLUMBUS_VIEW) {
            this._updateColumbusView(projection, this._billboardsToUpdate);
        }
    };

    BillboardCollection.prototype._update = function(context, sceneState) {
        if (!this._textureAtlas) {
            // Can't write billboard vertices until we have texture coordinates
            // provided by a texture atlas
            return;
        }

        this._removeBillboards();

        this._updateMode(sceneState);

        var billboards = this._billboards;
        var length = billboards.length;
        var properties = this._propertiesChanged;

        var textureAtlasCoordinates = this._textureAtlas.getTextureCoordinates();
        var vafWriters;

        // PERFORMANCE_IDEA: Round robin multiple buffers.

        if (this._createVertexArray || this.computeNewBuffersUsage()) {
            this._createVertexArray = false;

            this._vaf = this._vaf && this._vaf.destroy();

            if (length > 0) {
                // PERFORMANCE_IDEA:  Instead of creating a new one, resize like std::vector.
                this._vaf = BillboardCollection._createVAF(context, billboards.length, this._buffersUsage);
                vafWriters = this._vaf.writers;

                // Rewrite entire buffer if billboards were added or removed.
                for ( var i = 0; i < length; ++i) {
                    var billboard = this._billboards[i];
                    billboard._clean(); // In case it needed an update.
                    this._writeBillboard(context, textureAtlasCoordinates, vafWriters, billboard);
                }

                // Different billboard collections share the same index buffer.
                this._vaf.commit(BillboardCollection._getIndexBuffer(context));
            }

            this._billboardsToUpdate = [];
        } else {
            // Billboards were modified, but none were added or removed.

            var billboardsToUpdate = this._billboardsToUpdate;
            var updateLength = billboardsToUpdate.length;

            if (updateLength) {
                var writers = [];

                if (properties[POSITION_INDEX]) {
                    writers.push(this._writePosition);
                }

                if (properties[PIXEL_OFFSET_INDEX]) {
                    writers.push(this._writePixelOffset);
                }

                if (properties[EYE_OFFSET_INDEX] || properties[SCALE_INDEX]) {
                    writers.push(this._writeEyeOffsetAndScale);
                }

                if (properties[IMAGE_INDEX_INDEX]) {
                    writers.push(this._writeTextureCoordinatesAndImageSize);
                }

                if (properties[COLOR_INDEX]) {
                    writers.push(this._writeColor);
                }

                if (properties[HORIZONTAL_ORIGIN_INDEX] || properties[VERTICAL_ORIGIN_INDEX] || properties[SHOW_INDEX]) {
                    writers.push(this._writeOriginAndShow);
                }

                vafWriters = this._vaf.writers;

                if ((updateLength / length) > 0.1) {
                    // If more than 10% of billboard change, rewrite the entire buffer.

                    // PERFORMANCE_IDEA:  I totally made up 10% :).

                    for ( var m = 0; m < updateLength; ++m) {
                        var b = billboardsToUpdate[m];
                        b._clean();

                        for ( var n = 0; n < writers.length; ++n) {
                            writers[n](context, textureAtlasCoordinates, vafWriters, b);
                        }
                    }
                    this._vaf.commit(BillboardCollection._getIndexBuffer(context));
                } else {
                    for ( var h = 0; h < updateLength; ++h) {
                        var bb = billboardsToUpdate[h];
                        bb._clean();

                        for ( var o = 0; o < writers.length; ++o) {
                            writers[o](context, textureAtlasCoordinates, vafWriters, bb);
                        }
                        this._vaf.subCommit(bb._index * 4, 4);
                    }
                    this._vaf.endSubCommits();
                }

                this._billboardsToUpdate = [];
            }
        }

        for ( var k = 0; k < NUMBER_OF_PROPERTIES; ++k) {
            properties[k] = 0;
        }

        this._uniforms = (sceneState.mode === SceneMode.SCENE3D) ? this._uniforms3D : this._uniforms2D;
    };

    /**
     * @private
     */
    BillboardCollection.prototype.updateForPick = function(context) {
        // First update:  create render state and shader program
        this._rsPick = context.createRenderState({
            depthTest : {
                enabled : true
            }
        });

        this._spPick = context.getShaderCache().getShaderProgram(
                BillboardCollectionVS,
                "#define RENDER_FOR_PICK 1\n" + BillboardCollectionFS,
                attributeIndices);

        this.updateForPick = function(context) {
        };
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof BillboardCollection
     *
     * @return {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     *
     * @see BillboardCollection#destroy
     */
    BillboardCollection.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>null</code>) to the object as done in the example.
     *
     * @memberof BillboardCollection
     *
     * @return {null}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see BillboardCollection#isDestroyed
     *
     * @example
     * billboards = billboards && billboards.destroy();
     */
    BillboardCollection.prototype.destroy = function() {
        this._textureAtlas = this._destroyTextureAtlas && this._textureAtlas && this._textureAtlas.destroy();
        this._sp = this._sp && this._sp.release();
        this._spPick = this._spPick && this._spPick.release();
        this._vaf = this._vaf && this._vaf.destroy();
        this._destroyBillboards();

        return destroyObject(this);
    };

    BillboardCollection.prototype._destroyBillboards = function() {
        var billboards = this._billboards;
        var length = billboards.length;
        for ( var i = 0; i < length; ++i) {
            if (billboards[i]) {
                billboards[i]._destroy();
            }
        }
    };

    return BillboardCollection;
});

/*global define*/
define('Shaders/BlobMaterial',[],function() {
  
  return "uniform vec4 u_lightColor;\n" +
"uniform vec4 u_darkColor;\n" +
"uniform float u_repeat;\n" +
"vec4 agi_getMaterialColor(float zDistance, vec2 st, vec3 str)\n" +
"{\n" +
"vec2 F = agi_cellular(st * u_repeat);\n" +
"float t = 1.0 - F.x*F.x;\n" +
"return mix(u_lightColor, u_darkColor, t);\n" +
"}\n" +
"";
});

/*global define*/
define('Shaders/BuiltinFunctions',[],function() {
  
  return "const float agi_infinity = 5906376272000.0;\n" +
"const float agi_epsilon1 = 0.1;\n" +
"const float agi_epsilon2 = 0.01;\n" +
"const float agi_epsilon3 = 0.001;\n" +
"const float agi_epsilon4 = 0.0001;\n" +
"const float agi_epsilon5 = 0.00001;\n" +
"const float agi_epsilon6 = 0.000001;\n" +
"const float agi_epsilon7 = 0.0000001;\n" +
"bool agi_equalsEpsilon(float left, float right, float epsilon) {\n" +
"return (abs(left - right) <= epsilon);\n" +
"}\n" +
"bool agi_equalsEpsilon(float left, float right) {\n" +
"return (abs(left - right) <= agi_epsilon7);\n" +
"}\n" +
"mat2 agi_transpose(mat2 matrix)\n" +
"{\n" +
"return mat2(\n" +
"matrix[0][0], matrix[1][0],\n" +
"matrix[0][1], matrix[1][1]);\n" +
"}\n" +
"mat3 agi_transpose(mat3 matrix)\n" +
"{\n" +
"return mat3(\n" +
"matrix[0][0], matrix[1][0], matrix[2][0],\n" +
"matrix[0][1], matrix[1][1], matrix[2][1],\n" +
"matrix[0][2], matrix[1][2], matrix[2][2]);\n" +
"}\n" +
"mat4 agi_transpose(mat4 matrix)\n" +
"{\n" +
"return mat4(\n" +
"matrix[0][0], matrix[1][0], matrix[2][0], matrix[3][0],\n" +
"matrix[0][1], matrix[1][1], matrix[2][1], matrix[3][1],\n" +
"matrix[0][2], matrix[1][2], matrix[2][2], matrix[3][2],\n" +
"matrix[0][3], matrix[1][3], matrix[2][3], matrix[3][3]);\n" +
"}\n" +
"vec4 agi_modelToWindowCoordinates(vec4 position)\n" +
"{\n" +
"vec4 q = agi_modelViewProjection * position;\n" +
"q.xyz /= q.w;\n" +
"q.xyz = (agi_viewportTransformation * vec4(q.xyz, 1.0)).xyz;\n" +
"return q;\n" +
"}\n" +
"vec4 agi_eyeToWindowCoordinates(vec4 positionEC)\n" +
"{\n" +
"vec4 q = agi_projection * positionEC;\n" +
"q.xyz /= q.w;\n" +
"q.xyz = (agi_viewportTransformation * vec4(q.xyz, 1.0)).xyz;\n" +
"return q;\n" +
"}\n" +
"vec4 agi_eyeOffset(vec4 positionEC, vec3 eyeOffset)\n" +
"{\n" +
"vec4 p = positionEC;\n" +
"vec4 zEyeOffset = normalize(p) * eyeOffset.z;\n" +
"p.xy += eyeOffset.xy + zEyeOffset.xy;\n" +
"p.z += zEyeOffset.z;\n" +
"return p;\n" +
"}\n" +
"vec3 agi_geodeticSurfaceNormal(vec3 positionOnEllipsoid, vec3 ellipsoidCenter, vec3 oneOverEllipsoidRadiiSquared)\n" +
"{\n" +
"return normalize((positionOnEllipsoid - ellipsoidCenter) * oneOverEllipsoidRadiiSquared);\n" +
"}\n" +
"vec2 agi_ellipsoidWgs84TextureCoordinates(vec3 normal)\n" +
"{\n" +
"return vec2(atan(normal.y, normal.x) * agi_oneOverTwoPi + 0.5, asin(normal.z) * agi_oneOverPi + 0.5);\n" +
"}\n" +
"bool agi_isBackFacing(vec3 positionOnEllipsoidEC, vec3 oneOverEllipsoidRadiiSquared)\n" +
"{\n" +
"if (oneOverEllipsoidRadiiSquared != vec3(0.0))\n" +
"{\n" +
"vec3 n = agi_geodeticSurfaceNormal(positionOnEllipsoidEC, agi_view[3].xyz, oneOverEllipsoidRadiiSquared);\n" +
"return (dot(normalize(positionOnEllipsoidEC), n) > 0.0);\n" +
"}\n" +
"return false;\n" +
"}\n" +
"mat3 agi_eastNorthUpToEyeCoordinates(vec3 positionMC, vec3 normalEC)\n" +
"{\n" +
"vec3 tangentMC = normalize(vec3(-positionMC.y, positionMC.x, 0.0));\n" +
"vec3 tangentEC = normalize(agi_normal * tangentMC);\n" +
"vec3 bitangentEC = normalize(cross(normalEC, tangentEC));\n" +
"return mat3(\n" +
"tangentEC.x,   tangentEC.y,   tangentEC.z,\n" +
"bitangentEC.x, bitangentEC.y, bitangentEC.z,\n" +
"normalEC.x,    normalEC.y,    normalEC.z);\n" +
"}\n" +
"float agi_lightIntensity(vec3 normal, vec3 toLight, vec3 toEye)\n" +
"{\n" +
"vec4 diffuseSpecularAmbientShininess = vec4(0.8, 0.1, 0.1, 10.0);\n" +
"vec3 toReflectedLight = reflect(-toLight, normal);\n" +
"float diffuse = max(dot(toLight, normal), 0.0);\n" +
"float specular = max(dot(toReflectedLight, toEye), 0.0);\n" +
"specular = pow(specular, diffuseSpecularAmbientShininess.w);\n" +
"return (diffuseSpecularAmbientShininess.x * diffuse) +\n" +
"(diffuseSpecularAmbientShininess.y * specular) +\n" +
"diffuseSpecularAmbientShininess.z;\n" +
"}\n" +
"float agi_twoSidedLightIntensity(vec3 normal, vec3 toLight, vec3 toEye)\n" +
"{\n" +
"vec4 diffuseSpecularAmbientShininess = vec4(0.8, 0.1, 0.1, 10.0);\n" +
"vec3 toReflectedLight = reflect(-toLight, normal);\n" +
"float diffuse = abs(dot(toLight, normal));\n" +
"float specular = abs(dot(toReflectedLight, toEye));\n" +
"specular = pow(specular, diffuseSpecularAmbientShininess.w);\n" +
"return (diffuseSpecularAmbientShininess.x * diffuse) +\n" +
"(diffuseSpecularAmbientShininess.y * specular) +\n" +
"diffuseSpecularAmbientShininess.z;\n" +
"}\n" +
"vec3 agi_multiplyWithColorBalance(vec3 left, vec3 right)\n" +
"{\n" +
"const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n" +
"vec3 target = left * right;\n" +
"float leftLuminance = dot(left, W);\n" +
"float rightLumiance = dot(right, W);\n" +
"float targetLumiance = dot(target, W);\n" +
"return ((leftLuminance + rightLumiance) / (2.0 * targetLumiance)) * target;\n" +
"}\n" +
"vec4 agi_columbusViewMorph(vec3 position2D, vec3 position3D, float time)\n" +
"{\n" +
"vec3 p = mix(position2D, position3D, time);\n" +
"return vec4(p, 1.0);\n" +
"}\n" +
"";
});
/*global define*/
define('Renderer/Context',[
        '../Core/DeveloperError',
        '../Core/RuntimeError',
        '../Core/destroyObject',
        '../Core/IndexDatatype',
        '../Shaders/BuiltinFunctions',
        './Buffer',
        './BufferUsage',
        './BlendEquation',
        './BlendFunction',
        './CubeMap',
        './CullFace',
        './DepthFunction',
        './Framebuffer',
        './FrontFace',
        './MipmapHint',
        './PixelDatatype',
        './PixelFormat',
        './PickFramebuffer',
        './Renderbuffer',
        './RenderbufferFormat',
        './ShaderCache',
        './ShaderProgram',
        './StencilFunction',
        './StencilOperation',
        './Texture',
        './TextureAtlas',
        './TextureMagnificationFilter',
        './TextureMinificationFilter',
        './TextureWrap',
        './UniformState',
        './VertexArray',
        './VertexLayout'
    ], function(
        DeveloperError,
        RuntimeError,
        destroyObject,
        IndexDatatype,
        ShadersBuiltinFunctions,
        Buffer,
        BufferUsage,
        BlendEquation,
        BlendFunction,
        CubeMap,
        CullFace,
        DepthFunction,
        Framebuffer,
        FrontFace,
        MipmapHint,
        PixelDatatype,
        PixelFormat,
        PickFramebuffer,
        Renderbuffer,
        RenderbufferFormat,
        ShaderCache,
        ShaderProgram,
        StencilFunction,
        StencilOperation,
        Texture,
        TextureAtlas,
        TextureMagnificationFilter,
        TextureMinificationFilter,
        TextureWrap,
        UniformState,
        VertexArray,
        VertexLayout) {
    
    /*global window,Uint8Array,Uint16Array,ArrayBuffer*/

    function _errorToString(gl, error) {
        var message = "OpenGL Error:  ";
        switch (error) {
        case gl.INVALID_ENUM:
            message += "Invalid enumeration";
            break;
        case gl.INVALID_VALUE:
            message += "Invalid value";
            break;
        case gl.INVALID_OPERATION:
            message += "Invalid operation";
            break;
        case gl.OUT_OF_MEMORY:
            message += "Out of memory";
            break;
        case gl.CONTEXT_LOST_WEBGL:
            message += "Context lost";
            break;
        default:
            message += "Unknown";
        }

        return message;
    }

    function _createErrorMessage(gl, glFunc, glFuncArguments, error) {
        var message = _errorToString(gl, error) + ": " + glFunc.name + "(";

        for ( var i = 0; i < glFuncArguments.length; ++i) {
            if (i !== 0) {
                message += ", ";
            }
            message += glFuncArguments[i];
        }
        message += ");";

        return message;
    }

    function throwOnError(gl, glFunc, glFuncArguments) {
        var error = gl.getError();
        if (error !== gl.NO_ERROR) {
            throw new RuntimeError(_createErrorMessage(gl, glFunc, glFuncArguments, error));
        }
    }

    function wrapGL(gl, logFunc) {
        if (!logFunc) {
            return gl;
        }

        function wrapFunction(property) {
            return function() {
                var result = property.apply(gl, arguments);
                logFunc(gl, property, arguments);
                return result;
            };
        }

        var glWrapper = {};

        /*jslint forin: true*/
        /*jshint forin: false*/
        // JSLint normally demands that a for..in loop must directly contain an if,
        // but in our loop below, we actually intend to iterate all properties, including
        // those in the prototype.
        for ( var propertyName in gl) {
            var property = gl[propertyName];

            // wrap any functions we encounter, otherwise just copy the property to the wrapper.
            if (typeof property === "function") {
                glWrapper[propertyName] = wrapFunction(property);
            } else {
                glWrapper[propertyName] = property;
            }
        }

        return glWrapper;
    }

    /**
     * DOC_TBA
     *
     * @name Context
     * @constructor
     *
     * @exception {RuntimeError} The browser does not support WebGL.  Visit http://get.webgl.org.
     * @exception {RuntimeError} The browser supports WebGL, but initialization failed.
     * @exception {DeveloperError} canvas is required.
     */
    function Context(canvas, options) {
        if (!window.WebGLRenderingContext) {
            throw new RuntimeError("The browser does not support WebGL.  Visit http://get.webgl.org.");
        }

        if (!canvas) {
            throw new DeveloperError("canvas is required.", "canvas");
        }

        this._canvas = canvas;

        if (typeof options === 'undefined') {
            options = {};
        }
        if (typeof options.stencil === 'undefined') {
            options.stencil = true;
        }
        if (typeof options.alpha === 'undefined') {
            options.alpha = false;
        }

        this._originalGLContext = canvas.getContext("webgl", options) || canvas.getContext("experimental-webgl", options);

        if (!this._originalGLContext) {
            throw new RuntimeError("The browser supports WebGL, but initialization failed.");
        }

        // Validation and logging disabled by default for speed.
        this._validateFB = false;
        this._validateSP = false;
        this._logShaderCompilation = false;
        this._throwOnWebGLError = false;

        // TODO:  Also need point_size and point_size_enable for ColladaFX
        // TODO:  Also need sample_alpha_to_coverage_enable for ColladaFX
        this._shaderCache = new ShaderCache(this);

        var gl = this._gl = this._originalGLContext;

        this._version = gl.getParameter(gl.VERSION);
        this._shadingLanguageVersion = gl.getParameter(gl.SHADING_LANGUAGE_VERSION);
        this._vendor = gl.getParameter(gl.VENDOR);
        this._renderer = gl.getParameter(gl.RENDERER);
        this._redBits = gl.getParameter(gl.RED_BITS);
        this._greenBits = gl.getParameter(gl.GREEN_BITS);
        this._blueBits = gl.getParameter(gl.BLUE_BITS);
        this._alphaBits = gl.getParameter(gl.ALPHA_BITS);
        this._depthBits = gl.getParameter(gl.DEPTH_BITS);
        this._stencilBits = gl.getParameter(gl.STENCIL_BITS);
        this._maximumCombinedTextureImageUnits = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS); // min: 8
        this._maximumCubeMapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE); // min: 16
        this._maximumFragmentUniformVectors = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS); // min: 16
        this._maximumTextureImageUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS); // min: 8
        this._maximumRenderbufferSize = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE); // min: 1
        this._maximumTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE); // min: 64
        this._maximumVaryingVectors = gl.getParameter(gl.MAX_VARYING_VECTORS); // min: 8
        this._maximumVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS); // min: 8
        this._maximumVertexTextureImageUnits = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS); // min: 0
        this._maximumVertexUniformVectors = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS); // min: 128
        this._aliasedLineWidthRange = gl.getParameter(gl.ALIASED_LINE_WIDTH_RANGE); // must include 1
        this._aliasedPointSizeRange = gl.getParameter(gl.ALIASED_POINT_SIZE_RANGE); // must include 1
        this._maximumViewportDimensions = gl.getParameter(gl.MAX_VIEWPORT_DIMS);
        this._viewport = gl.getParameter(gl.VIEWPORT);

        // Query and initialize extensions
        var textureFilterAnisotropic = gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic");

        this._standardDerivatives = gl.getExtension("OES_standard_derivatives");
        this._textureFilterAnisotropic = textureFilterAnisotropic;
        this._maximumTextureFilterAnisotropy = textureFilterAnisotropic ? gl.getParameter(textureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1.0;

        var cc = gl.getParameter(gl.COLOR_CLEAR_VALUE);
        this._clearColor = {
            red : cc[0],
            green : cc[1],
            blue : cc[2],
            alpha : cc[3]
        };
        this._clearDepth = gl.getParameter(gl.DEPTH_CLEAR_VALUE);
        this._clearStencil = gl.getParameter(gl.STENCIL_CLEAR_VALUE);
        this._defaultClearColor = {
            red : cc[0],
            green : cc[1],
            blue : cc[2],
            alpha : cc[3]
        };
        this._defaultClearDepth = this._clearDepth;
        this._defaultClearStencil = this._clearStencil;

        this._us = new UniformState(this);
        this._currentFramebuffer = undefined;
        this._currentSp = undefined;
    }

    Context.prototype._enableOrDisable = function(glEnum, enable) {
        if (enable) {
            this._gl.enable(glEnum);
        } else {
            this._gl.disable(glEnum);
        }
    };

    Context.prototype._applyFrontFace = function(frontFace) {
        this._gl.frontFace(frontFace.value);
    };

    Context.prototype._applyCull = function(cull) {
        var gl = this._gl;
        var enabled = cull.enabled;

        this._enableOrDisable(gl.CULL_FACE, enabled);

        if (enabled) {
            gl.cullFace(cull.face.value);
        }
    };

    Context.prototype._applyLineWidth = function(lineWidth) {
        this._gl.lineWidth(lineWidth);
    };

    Context.prototype._applyPolygonOffset = function(polygonOffset) {
        var gl = this._gl;
        var enabled = polygonOffset.enabled;

        this._enableOrDisable(gl.POLYGON_OFFSET_FILL, enabled);

        if (enabled) {
            gl.polygonOffset(polygonOffset.factor, polygonOffset.units);
        }
    };

    Context.prototype._applyScissorTest = function(scissorTest) {
        var gl = this._gl;
        var enabled = scissorTest.enabled;

        this._enableOrDisable(gl.SCISSOR_TEST, enabled);

        if (enabled) {
            var newRectangle = scissorTest.rectangle;
            gl.scissor(newRectangle.x, newRectangle.y, newRectangle.width, newRectangle.height);
        }
    };

    Context.prototype._applyDepthRange = function(depthRange) {
        var near = depthRange.near;
        var far = depthRange.far;
        this._gl.depthRange(near, far);
    };

    Context.prototype._applyDepthTest = function(depthTest) {
        var gl = this._gl;
        var enabled = depthTest.enabled;

        this._enableOrDisable(gl.DEPTH_TEST, enabled);

        if (enabled) {
            gl.depthFunc(depthTest.func.value);
        }
    };

    Context.prototype._applyColorMask = function(colorMask) {
        this._gl.colorMask(colorMask.red, colorMask.green, colorMask.blue, colorMask.alpha);
    };

    Context.prototype._applyDepthMask = function(depthMask) {
        this._gl.depthMask(depthMask);
    };

    Context.prototype._applyStencilMask = function(stencilMask) {
        this._gl.stencilMask(stencilMask);
    };

    Context.prototype._applyBlending = function(blending) {
        var gl = this._gl;
        var enabled = blending.enabled;

        this._enableOrDisable(gl.BLEND, enabled);

        if (enabled) {
            var color = blending.color;
            var equationRgb = blending.equationRgb;
            var equationAlpha = blending.equationAlpha;
            var functionSourceRgb = blending.functionSourceRgb;
            var functionDestinationRgb = blending.functionDestinationRgb;
            var functionSourceAlpha = blending.functionSourceAlpha;
            var functionDestinationAlpha = blending.functionDestinationAlpha;

            gl.blendColor(color.red, color.green, color.blue, color.alpha);
            gl.blendEquationSeparate(equationRgb.value, equationAlpha.value);
            gl.blendFuncSeparate(functionSourceRgb.value, functionDestinationRgb.value, functionSourceAlpha.value, functionDestinationAlpha.value);
        }
    };

    Context.prototype._applyStencilTest = function(stencilTest) {
        var gl = this._gl;
        var enabled = stencilTest.enabled;

        this._enableOrDisable(gl.STENCIL_TEST, enabled);

        if (enabled) {
            var frontFunction = stencilTest.frontFunction;
            var backFunction = stencilTest.backFunction;
            var reference = stencilTest.reference;
            var mask = stencilTest.mask;

            // Section 6.8 of the WebGL spec requires the reference and masks to be the same for
            // front- and back-face tests.  This call prevents invalid operation errors when calling
            // stencilFuncSeparate on Firefox.  Perhaps they should delay validation to avoid requiring this.
            gl.stencilFunc(stencilTest.frontFunction.value, stencilTest.reference, stencilTest.mask);
            gl.stencilFuncSeparate(gl.BACK, backFunction.value, reference, mask);
            gl.stencilFuncSeparate(gl.FRONT, frontFunction.value, reference, mask);

            var frontOperation = stencilTest.frontOperation;
            var frontOperationFail = frontOperation.fail;
            var frontOperationZFail = frontOperation.zFail;
            var frontOperationZPass = frontOperation.zPass;

            gl.stencilOpSeparate(gl.FRONT, frontOperationFail.value, frontOperationZFail.value, frontOperationZPass.value);

            var backOperation = stencilTest.backOperation;
            var backOperationFail = backOperation.fail;
            var backOperationZFail = backOperation.zFail;
            var backOperationZPass = backOperation.zPass;

            gl.stencilOpSeparate(gl.BACK, backOperationFail.value, backOperationZFail.value, backOperationZPass.value);
        }
    };

    Context.prototype._applySampleCoverage = function(sampleCoverage) {
        var gl = this._gl;
        var enabled = sampleCoverage.enabled;

        this._enableOrDisable(gl.SAMPLE_COVERAGE, enabled);

        if (enabled) {
            gl.sampleCoverage(sampleCoverage.value, sampleCoverage.invert);
        }
    };

    Context.prototype._applyDither = function(dither) {
        this._enableOrDisable(this._gl.DITHER, dither);
    };

    Context.prototype._applyRenderState = function(state) {
        this._applyFrontFace(state.frontFace);
        this._applyCull(state.cull);
        this._applyLineWidth(state.lineWidth);
        this._applyPolygonOffset(state.polygonOffset);
        this._applyScissorTest(state.scissorTest);
        this._applyDepthRange(state.depthRange);
        this._applyDepthTest(state.depthTest);
        this._applyColorMask(state.colorMask);
        this._applyDepthMask(state.depthMask);
        this._applyStencilMask(state.stencilMask);
        this._applyBlending(state.blending);
        this._applyStencilTest(state.stencilTest);
        this._applySampleCoverage(state.sampleCoverage);
        this._applyDither(state.dither);
    };

    /**
     * Returns the canvas assoicated with this context.
     *
     * @memberof Context
     *
     * @returns {HTMLCanvasElement} The canvas assoicated with this context.
     */
    Context.prototype.getCanvas = function() {
        return this._canvas;
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     *
     * @see Context#createShaderProgram
     */
    Context.prototype.getShaderCache = function() {
        return this._shaderCache;
    };

    /**
     * DOC_TBA
     * @memberof Context
     */
    Context.prototype.getUniformState = function() {
        return this._us;
    };

    /**
     * Returns the viewport, which determines the rectangular region of the canvas that is rendered to.  The viewport contains four
     * properties: <code>x</code> and <code>y</code>, which define the lower left corner of the viewport in window coordinates
     * (relative to the canvas), and its <code>width</code> and <code>height</code> in pixels.
     *
     * @memberof Context
     *
     * @returns The viewport defined by its <code>x</code> and <code>y</code> window coordinates and its <code>width</code> and <code>height</code>.
     *
     * @see Context#setViewport
     * @see Context#getCanvas
     * @see agi_viewport
     *
     * @example
     * var viewport = context.getViewport();
     * console.log(viewport.x);
     * console.log(viewport.y);
     * console.log(viewport.width);
     * console.log(viewport.height);
     */
    Context.prototype.getViewport = function() {
        var v = this._viewport;
        return {
            x : v[0],
            y : v[1],
            width : v[2],
            height : v[3]
        };
    };

    /**
     * Sets the viewport, which determines the rectangular region of the canvas that is rendered to.  The viewport contains four
     * properties: <code>x</code> and <code>y</code>, which define the lower left corner of the viewport in window coordinates
     * (relative to the canvas), and its <code>width</code> and <code>height</code> in pixels.
     *
     * @memberof Context
     *
     * @param {Object} viewport The new viewport defined by its <code>x</code> and <code>y</code> window coordinates and its <code>width</code> and <code>height</code>.
     *
     * @exception {RuntimeError} viewport.width must be less than or equal to the maximum viewport width.
     * @exception {RuntimeError} viewport.height must be less than or equal to the maximum viewport height.
     *
     * @exception {DeveloperError} A viewport with x, y, width, and height properties is required.
     * @exception {DeveloperError} viewport.width must be greater than or equal to zero.
     * @exception {DeveloperError} viewport.height must be greater than or equal to zero.
     *
     * @see Context#getViewport
     * @see Context#getMaximumViewportWidth
     * @see Context#getMaximumViewportHeight
     * @see Context#getCanvas
     * @see agi_viewport
     *
     * @example
     * context.setViewport({
     *     x      : 0,
     *     y      : 0,
     *     width  : 640,
     *     height : 480
     * });
     */
    Context.prototype.setViewport = function(viewport) {
        if ((typeof viewport === "undefined") ||
            (typeof viewport.x === "undefined") ||
            (typeof viewport.y === "undefined") ||
            (typeof viewport.width === "undefined") ||
            (typeof viewport.height === "undefined")) {
            throw new DeveloperError("A viewport with x, y, width, and height properties is required.", "viewport");
        }

        var x = viewport.x;
        var y = viewport.y;
        var w = viewport.width;
        var h = viewport.height;

        if (w < 0) {
            throw new DeveloperError("viewport.width must be greater than or equal to zero.", "viewport");
        }

        if (w > this.getMaximumViewportWidth()) {
            throw new RuntimeError("viewport.width must be less than or equal to the maximum viewport width (" + this.getMaximumViewportWidth().toString() + ").  Check getMaximumViewportWidth().", "viewport");
        }

        if (h < 0) {
            throw new DeveloperError("viewport.height must be greater than or equal to zero.", "viewport");
        }

        if (h > this.getMaximumViewportHeight()) {
            throw new RuntimeError("viewport.height must be less than or equal to the maximum viewport height (" + this.getMaximumViewportHeight().toString() + ").  Check getMaximumViewportHeight().", "viewport");
        }

        var v = this._viewport;
        if ((x !== v[0]) || (y !== v[1]) || (w !== v[2]) || (h !== v[3])) {
            v[0] = x;
            v[1] = y;
            v[2] = w;
            v[3] = h;
            this._gl.viewport(viewport.x, viewport.y, w, h);
        }
    };

    /**
     * Returns the WebGL version or release number of the form &lt;WebGL&gt;&lt;space&gt;&lt;version number&gt;&lt;space&gt;&lt;vendor-specific information&gt;.
     *
     * @memberof Context
     *
     * @returns {String} The WebGL version or release number.
     * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGetString.xml">glGetString</a> with <code>VERSION</code>.
     */
    Context.prototype.getVersion = function() {
        return this._version;
    };

    /**
     * Returns the version or release number for the shading language of the form WebGL&lt;space&gt;GLSL&lt;space&gt;ES&lt;space&gt;&lt;version number&gt;&lt;space&gt;&lt;vendor-specific information&gt;.
     *
     * @memberof Context
     *
     * @returns {String} The version or release number for the shading language.
     * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGetString.xml">glGetString</a> with <code>SHADING_LANGUAGE_VERSION</code>.
     */
    Context.prototype.getShadingLanguageVersion = function() {
        return this._shadingLanguageVersion;
    };

    /**
     * Returns the company responsible for the WebGL implementation.
     *
     * @memberof Context
     *
     * @returns {String} The company responsible for the WebGL implementation.
     * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGetString.xml">glGetString</a> with <code>VENDOR</code>.
     */
    Context.prototype.getVendor = function() {
        return this._vendor;
    };

    /**
     * Returns the name of the renderer/configuration/hardware platform. For example, this may be the model of the
     * video card, e.g., "GeForce 8800 GTS/PCI/SSE2", or the browser-dependent name of the GL implementation, e.g.
     * "Mozilla" or "ANGLE."
     *
     * @memberof Context
     *
     * @returns {String} The name of the renderer.
     *
     * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGetString.xml">glGetString</a> with <code>RENDERER</code>.
     * @see <a href="http://code.google.com/p/angleproject/">ANGLE</a>
     */
    Context.prototype.getRenderer = function() {
        return this._renderer;
    };

    /**
     * Returns the number of red bits per component in the default framebuffer's color buffer.  The minimum is eight.
     *
     * @memberof Context
     *
     * @returns {Number} The number of red bits per component in the color buffer.
     * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml">glGet</a> with <code>RED_BITS</code>.
     */
    Context.prototype.getRedBits = function() {
        return this._redBits;
    };

    /**
     * Returns the number of green bits per component in the default framebuffer's color buffer.  The minimum is eight.
     *
     * @memberof Context
     *
     * @returns {Number} The number of green bits per component in the color buffer.
     * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml">glGet</a> with <code>GREEN_BITS</code>.
     */
    Context.prototype.getGreenBits = function() {
        return this._greenBits;
    };

    /**
     * Returns the number of blue bits per component in the default framebuffer's color buffer.  The minimum is eight.
     *
     * @memberof Context
     *
     * @returns {Number} The number of blue bits per component in the color buffer.
     * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml">glGet</a> with <code>BLUE_BITS</code>.
     */
    Context.prototype.getBlueBits = function() {
        return this._blueBits;
    };

    /**
     * Returns the number of alpha bits per component in the default framebuffer's color buffer.  The minimum is eight.
     * <br /><br />
     * The alpha channel is used for GL destination alpha operations and by the HTML compositor to combine the color buffer
     * with the rest of the page.
     *
     * @memberof Context
     *
     * @returns {Number} The number of alpha bits per component in the color buffer.
     * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml">glGet</a> with <code>ALPHA_BITS</code>.
     */
    Context.prototype.getAlphaBits = function() {
        return this._alphaBits;
    };

    /**
     * Returns the number of depth bits per pixel in the default bound framebuffer.  The minimum is 16 bits; most
     * implementations will have 24 bits.
     *
     * @memberof Context
     *
     * @returns {Number} The number of depth bits per pixel in the default bound framebuffer.
     * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml">glGet</a> with <code>DEPTH_BITS</code>.
     */
    Context.prototype.getDepthBits = function() {
        return this._depthBits;
    };

    /**
     * Returns the number of stencil bits per pixel in the default bound framebuffer.  The minimum is eight bits.
     *
     * @memberof Context
     *
     * @returns {Number} The number of stencil bits per pixel in the default bound framebuffer.
     * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml">glGet</a> with <code>STENCIL_BITS</code>.
     */
    Context.prototype.getStencilBits = function() {
        return this._stencilBits;
    };

    /**
     * Returns the maximum number of texture units that can be used from the vertex and fragment
     * shader with this WebGL implementation.  The minimum is eight.  If both shaders access the
     * same texture unit, this counts as two texture units.
     *
     * @memberof Context
     *
     * @returns {Number} The maximum supported texture image units.
     *
     * @see Context#getMaximumTextureImageUnits
     * @see Context#getMaximumVertexTextureImageUnits
     * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml">glGet</a> with <code>MAX_COMBINED_TEXTURE_IMAGE_UNITS</code>.
     */
    Context.prototype.getMaximumCombinedTextureImageUnits = function() {
        return this._maximumCombinedTextureImageUnits;
    };

    /**
     * Returns the approximate maximum cube mape width and height supported by this WebGL implementation.
     * The minimum is 16, but most desktop and laptop implementations will support much larger sizes like 8,192.
     *
     * @memberof Context
     *
     * @returns {Number} The approximate maximum cube mape width and height.
     *
     * @see Context#createCubeMap
     * @see Context#getMaximumTextureSize
     * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml">glGet</a> with <code>MAX_CUBE_MAP_TEXTURE_SIZE</code>.
     */
    Context.prototype.getMaximumCubeMapSize = function() {
        return this._maximumCubeMapSize;
    };

    /**
     * Returns the maximum number of <code>vec4</code>, <code>ivec4</code>, and <code>bvec4</code>
     * uniforms that can be used by a fragment shader with this WebGL implementation.  The minimum is 16.
     *
     * @memberof Context
     *
     * @returns {Number} The maximum number of <code>vec4</code>, <code>ivec4</code>, and <code>bvec4</code> uniforms that can be used by a fragment shader.
     *
     * @see Context#getMaximumVertexUniformVectors
     * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml">glGet</a> with <code>MAX_FRAGMENT_UNIFORM_VECTORS</code>.
     */
    Context.prototype.getMaximumFragmentUniformVectors = function() {
        return this._maximumFragmentUniformVectors;
    };

    /**
     * Returns the maximum number of texture units that can be used from the fragment shader with this WebGL implementation.  The minimum is eight.
     *
     * @memberof Context
     *
     * @returns {Number} The maximum number of texture units that can be used from the fragment shader.
     *
     * @see Context#getMaximumCombinedTextureImageUnits
     * @see Context#getMaximumVertexTextureImageUnits
     * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml">glGet</a> with <code>MAX_TEXTURE_IMAGE_UNITS</code>.
     */
    Context.prototype.getMaximumTextureImageUnits = function() {
        return this._maximumTextureImageUnits;
    };

    /**
     * Returns the maximum renderbuffer width and height supported by this WebGL implementation.
     * The minimum is 16, but most desktop and laptop implementations will support much larger sizes like 8,192.
     *
     * @memberof Context
     *
     * @returns {Number} The maximum renderbuffer width and height.
     *
     * @see Context#createRenderbuffer
     * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml">glGet</a> with <code>MAX_RENDERBUFFER_SIZE</code>.
     */
    Context.prototype.getMaximumRenderbufferSize = function() {
        return this._maximumRenderbufferSize;
    };

    /**
     * Returns the approximate maximum texture width and height supported by this WebGL implementation.
     * The minimum is 64, but most desktop and laptop implementations will support much larger sizes like 8,192.
     *
     * @memberof Context
     *
     * @returns {Number} The approximate maximum texture width and height.
     *
     * @see Context#createTexture2D
     * @see Context#getMaximumCubeMapSize
     * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml">glGet</a> with <code>MAX_TEXTURE_SIZE</code>.
     */
    Context.prototype.getMaximumTextureSize = function() {
        return this._maximumTextureSize;
    };

    /**
     * Returns the maximum number of <code>vec4</code> varying variables supported by this WebGL implementation.
     * The minimum is eight.  Matrices and arrays count as multiple <code>vec4</code>s.
     *
     * @memberof Context
     *
     * @returns {Number} Returns the maximum number of <code>vec4</code> varying variables.
     *
     * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml">glGet</a> with <code>MAX_VARYING_VECTORS</code>.
     */
    Context.prototype.getMaximumVaryingVectors = function() {
        return this._maximumVaryingVectors;
    };

    /**
     * Returns the maximum number of <code>vec4</code> vertex attributes supported by this WebGL implementation.  The minimum is eight.
     *
     * @memberof Context
     *
     * @returns {Number} The maximum number of <code>vec4</code> vertex attributes.
     *
     * @see Context#createVertexArray
     * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml">glGet</a> with <code>MAX_VERTEX_ATTRIBS</code>.
     */
    Context.prototype.getMaximumVertexAttributes = function() {
        return this._maximumVertexAttributes;
    };

    /**
     * Returns the maximum number of texture units that can be used from the vertex shader with this WebGL implementation.
     * The minimum is zero, which means the GL does not support vertex texture fetch.
     *
     * @memberof Context
     *
     * @returns {Number} The maximum number of texture units that can be used from the vertex shader.
     *
     * @see Context#getMaximumCombinedTextureImageUnits
     * @see Context#getMaximumTextureImageUnits
     * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml">glGet</a> with <code>MAX_VERTEX_TEXTURE_IMAGE_UNITS</code>.
     */
    Context.prototype.getMaximumVertexTextureImageUnits = function() {
        return this._maximumVertexTextureImageUnits;
    };

    /**
     * Returns the maximum number of <code>vec4</code>, <code>ivec4</code>, and <code>bvec4</code>
     * uniforms that can be used by a vertex shader with this WebGL implementation.  The minimum is 16.
     *
     * @memberof Context
     *
     * @returns {Number} The maximum number of <code>vec4</code>, <code>ivec4</code>, and <code>bvec4</code> uniforms that can be used by a vertex shader.
     *
     * @see Context#getMaximumFragmentUniformVectors
     * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml">glGet</a> with <code>MAX_VERTEX_UNIFORM_VECTORS</code>.
     */
    Context.prototype.getMaximumVertexUniformVectors = function() {
        return this._maximumVertexUniformVectors;
    };

    /**
     * Returns the minimum aliased line width, in pixels, supported by this WebGL implementation.  It will be at most one.
     *
     * @memberof Context
     *
     * @returns {Number} The minimum aliased line in pixels.
     *
     * @see Context#getMaximumAliasedLineWidth
     * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml">glGet</a> with <code>ALIASED_LINE_WIDTH_RANGE</code>.
     */
    Context.prototype.getMinimumAliasedLineWidth = function() {
        return this._aliasedLineWidthRange[0];
    };

    /**
     * Returns the maximum aliased line width, in pixels, supported by this WebGL implementation.  It will be at least one.
     *
     * @memberof Context
     *
     * @returns {Number} The maximum aliased line in pixels.
     *
     * @see Context#getMinimumAliasedLineWidth
     * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml">glGet</a> with <code>ALIASED_LINE_WIDTH_RANGE</code>.
     */
    Context.prototype.getMaximumAliasedLineWidth = function() {
        return this._aliasedLineWidthRange[1];
    };

    /**
     * Returns the minimum aliased point size, in pixels, supported by this WebGL implementation.  It will be at most one.
     *
     * @memberof Context
     *
     * @returns {Number} The minimum aliased point size in pixels.
     *
     * @see Context#getMaximumAliasedPointSize
     * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml">glGet</a> with <code>ALIASED_POINT_SIZE_RANGE</code>.
     */
    Context.prototype.getMinimumAliasedPointSize = function() {
        return this._aliasedPointSizeRange[0];
    };

    /**
     * Returns the maximum aliased point size, in pixels, supported by this WebGL implementation.  It will be at least one.
     *
     * @memberof Context
     *
     * @returns {Number} The maximum aliased point size in pixels.
     *
     * @see Context#getMinimumAliasedPointSize
     * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml">glGet</a> with <code>ALIASED_POINT_SIZE_RANGE</code>.
     */
    Context.prototype.getMaximumAliasedPointSize = function() {
        return this._aliasedPointSizeRange[1];
    };

    /**
     * Returns the maximum supported width of the viewport.  It will be at least as large as the visible width of the associated canvas.
     *
     * @memberof Context
     *
     * @returns {Number} The maximum supported width of the viewport.
     *
     * @see Context#getMaximumViewportHeight
     * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml">glGet</a> with <code>MAX_VIEWPORT_DIMS</code>.
     */
    Context.prototype.getMaximumViewportWidth = function() {
        return this._maximumViewportDimensions[0];
    };

    /**
     * Returns the maximum supported height of the viewport.  It will be at least as large as the visible height of the associated canvas.
     *
     * @memberof Context
     *
     * @returns {Number} The maximum supported height of the viewport.
     *
     * @see Context#getMaximumViewportHeight
     * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml">glGet</a> with <code>MAX_VIEWPORT_DIMS</code>.
     */
    Context.prototype.getMaximumViewportHeight = function() {
        return this._maximumViewportDimensions[1];
    };

    /**
     * Returns <code>true</code> if the OES_standard_derivatives extension is supported.  This
     * extension provides access to <code>dFdx<code>, <code>dFdy<code>, and <code>fwidth<code>
     * functions from GLSL.  A shader using these functions still needs to explicitly enable the
     * extension with <code>#extension GL_OES_standard_derivatives : enable</code>.
     *
     * @memberof Context
     *
     * @returns {Boolean} <code>true</code> if OES_standard_derivatives is supported; otherwise, <code>false</code>.
     *
     * @see <a href="http://www.khronos.org/registry/gles/extensions/OES/OES_standard_derivatives.txt">OES_standard_derivatives</a>
     */
    Context.prototype.getStandardDerivatives = function() {
        return !!this._standardDerivatives;
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     *
     * @returns {Boolean} <code>true</code> if EXT_texture_filter_anisotropic is supported; otherwise, <code>false</code>.
     *
     * @see <a href="http://www.khronos.org/registry/webgl/extensions/EXT_texture_filter_anisotropic/">EXT_texture_filter_anisotropic</a>
     */
    Context.prototype.getTextureFilterAnisotropic = function() {
        return !!this._textureFilterAnisotropic;
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     *
     * @see Context#getTextureFilterAnisotropic
     */
    Context.prototype.getMaximumTextureFilterAnisotropy = function() {
        return this._maximumTextureFilterAnisotropy;
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     *
     * @see Context#setValidateFramebuffer
     */
    Context.prototype.getValidateFramebuffer = function() {
        return this._validateFB;
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     *
     * @performance DOC_TBA: slow.
     *
     * @see Context#setValidateShaderProgram
     * @see Context#getValidateFramebuffer
     */
    Context.prototype.setValidateFramebuffer = function(value) {
        this._validateFB = value;
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     *
     * @see Context#setValidateShaderProgram
     */
    Context.prototype.getValidateShaderProgram = function() {
        return this._validateSP;
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     *
     * @performance DOC_TBA: slow.
     *
     * @see Context#setValidateFramebuffer
     * @see Context#getValidateShaderProgram
     */
    Context.prototype.setValidateShaderProgram = function(value) {
        this._validateSP = value;
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     *
     * @see Context#setThrowOnWebGLError
     */
    Context.prototype.getThrowOnWebGLError = function() {
        return this._throwOnWebGLError;
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     *
     * @performance DOC_TBA: slow.
     *
     * @see Context#setValidateFramebuffer
     * @see Context#setValidateShaderProgram
     * @see Context#getThrowOnWebGLError
     */
    Context.prototype.setThrowOnWebGLError = function(value) {
        this._throwOnWebGLError = value;
        this._gl = wrapGL(this._originalGLContext, value ? throwOnError : null);
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     *
     * @see Context#setLogShaderCompilation
     */
    Context.prototype.getLogShaderCompilation = function() {
        return this._logShaderCompilation;
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     *
     * @see Context#getLogShaderCompilation
     */
    Context.prototype.setLogShaderCompilation = function(value) {
        this._logShaderCompilation = value;
    };

    /**
     * Creates a shader program given the GLSL source for a vertex and fragment shader.
     * <br /><br />
     * The vertex and fragment shader are individually compiled, and then linked together
     * to create a shader program.  An exception is thrown if any errors are encountered,
     * as described below.
     * <br /><br />
     * The program's active uniforms and attributes are queried and can be accessed using
     * the returned shader program.  The caller can explicitly define the vertex
     * attribute indices using the optional <code>attributeLocations</code> argument as
     * shown in example two below.
     *
     * @memberof Context
     *
     * @param {String} vertexShaderSource The GLSL source for the vertex shader.
     * @param {String} fragmentShaderSource The GLSL source for the fragment shader.
     * @param {Object} [attributeLocations=undefined] An optional object that maps vertex attribute names to indices for use with vertex arrays.
     *
     * @return {ShaderProgram} The compiled and linked shader program, ready for use in a draw call.
     *
     * @exception {RuntimeError} Vertex shader failed to compile.
     * @exception {RuntimeError} Fragment shader failed to compile.
     * @exception {RuntimeError} Program failed to link.
     *
     * @see Context#draw
     * @see Context#createVertexArray
     * @see Context#getShaderCache
     * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glCreateShader.xml">glCreateShader</a>
     * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glShaderSource.xml">glShaderSource</a>
     * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glCompileShader.xml">glCompileShader</a>
     * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glCreateProgram.xml">glCreateProgram</a>
     * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glAttachShader.xml">glAttachShader</a>
     * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glLinkProgram.xml">glLinkProgram</a>
     * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGetShaderiv.xml">glGetShaderiv</a>
     * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGetActiveUniform.xml">glGetActiveUniform</a>
     * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGetUniformLocation.xml">glGetUniformLocation</a>
     * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGetUniform.xml">glGetUniform</a>
     * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glBindAttribLocation.xml">glBindAttribLocation</a>
     * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGetActiveAttrib.xml">glGetActiveAttrib</a>
     * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGetAttribLocation.xml">glGetAttribLocation</a>
     *
     * @example
     * // Example 1. Create a shader program allowing the GL to determine
     * // attribute indices.
     * var vs = "attribute vec4 position; void main() { gl_Position = position; }";
     * var fs = "void main() { gl_FragColor = vec4(1.0); }";
     * var sp = context.createShaderProgram(vs, fs);
     *
     * ////////////////////////////////////////////////////////////////////////////////
     *
     * // Example 2. Create a shader program with explicit attribute indices.
     * var vs = "attribute vec4 position;" +
     *          "attribute vec3 normal;" +
     *          "void main() { ... }";
     * var fs = "void main() { gl_FragColor = vec4(1.0); }";
     * var attributes = {
     *     position : 0,
     *     normal   : 1
     * };
     * sp = context.createShaderProgram(vs, fs, attributes);            *
     */
    Context.prototype.createShaderProgram = function(vertexShaderSource, fragmentShaderSource, attributeLocations) {
        return new ShaderProgram(this._gl, this._logShaderCompilation, ShadersBuiltinFunctions, vertexShaderSource, fragmentShaderSource, attributeLocations);
    };

    Context.prototype._createBuffer = function(gl, bufferTarget, arrayViewOrSizeInBytes, usage) {
        var sizeInBytes;

        if (typeof arrayViewOrSizeInBytes === "object") {
            sizeInBytes = arrayViewOrSizeInBytes.byteLength;
        } else {
            sizeInBytes = arrayViewOrSizeInBytes;
        }

        if (sizeInBytes <= 0) {
            throw new DeveloperError("The size in bytes must be greater than zero.", "arrayViewOrSizeInBytes");
        }

        var glUsage = usage.value;
        if ((glUsage !== gl.STATIC_DRAW) &&
            (glUsage !== gl.STREAM_DRAW) &&
            (glUsage !== gl.DYNAMIC_DRAW)) {
            throw new DeveloperError("Invalid usage.", "usage");
        }

        var buffer = gl.createBuffer();
        gl.bindBuffer(bufferTarget, buffer);
        gl.bufferData(bufferTarget, arrayViewOrSizeInBytes, glUsage);
        gl.bindBuffer(bufferTarget, null);

        return new Buffer(gl, bufferTarget, sizeInBytes, usage, buffer);
    };

    /**
     * Creates a vertex buffer, which contains untyped vertex data in GPU-controlled memory.
     * <br /><br />
     * A vertex array defines the actual makeup of a vertex, e.g., positions, normals, texture coordinates,
     * etc., by interpreting the raw data in one or more vertex buffers.
     *
     * @memberof Context
     *
     * @param {} arrayViewOrSizeInBytes An <code>ArrayBuffer</code> containing the data to copy to the buffer, or a <code>Number</code> defining the size of the buffer in bytes.
     * @param {BufferUsage} usage Specifies the expected usage pattern of the buffer.  On some GL implementations, this can significantly affect performance.  See {@link BufferUsage}.
     *
     * @return {VertexBuffer} The vertex buffer, ready to be attached to a vertex array.
     *
     * @exception {DeveloperError} The size in bytes must be greater than zero.
     * @exception {DeveloperError} Invalid <code>usage</code>.
     *
     * @see Context#createVertexArray
     * @see Context#createIndexBuffer
     * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGenBuffer.xml">glGenBuffer</a>
     * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glBindBuffer.xml">glBindBuffer</a> with <code>ARRAY_BUFFER</code>
     * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glBufferData.xml">glBufferData</a> with <code>ARRAY_BUFFER</code>
     *
     * @example
     * // Example 1. Create a dynamic vertex buffer 16 bytes in size.
     * var buffer = context.createVertexBuffer(16, BufferUsage.DYNAMIC_DRAW);
     *
     * ////////////////////////////////////////////////////////////////////////////////
     *
     * // Example 2. Create a dynamic vertex buffer from three floating-point values.
     * // The data copied to the vertex buffer is considered raw bytes until it is
     * // interpreted as vertices using a vertex array.
     * var positionBuffer = context.createVertexBuffer(new Float32Array([0, 0, 0]),
     *     BufferUsage.STATIC_DRAW);
     */
    Context.prototype.createVertexBuffer = function(arrayViewOrSizeInBytes, usage) {
        return this._createBuffer(this._gl, this._gl.ARRAY_BUFFER, arrayViewOrSizeInBytes, usage);
    };

    /**
     * Creates an index buffer, which contains typed indices in GPU-controlled memory.
     * <br /><br />
     * An index buffer can be attached to a vertex array to select vertices for rendering.
     * <code>Context.draw</code> can render using the entire index buffer or a subset
     * of the index buffer defined by an offset and count.
     *
     * @memberof Context
     *
     * @param {} arrayViewOrSizeInBytes An <code>ArrayBuffer</code> containing the data to copy to the buffer, or a <code>Number</code> defining the size of the buffer in bytes.
     * @param {BufferUsage} usage Specifies the expected usage pattern of the buffer.  On some GL implementations, this can significantly affect performance.  See {@link BufferUsage}.
     * @param {IndexDatatype} indexDatatype The datatype of indices in the buffer.
     *
     * @return {IndexBuffer} The index buffer, ready to be attached to a vertex array.
     *
     * @exception {DeveloperError} The size in bytes must be greater than zero.
     * @exception {DeveloperError} Invalid <code>usage</code>.
     * @exception {DeveloperError} Invalid <code>indexDatatype</code>.
     *
     * @see Context#createVertexArray
     * @see Context#createVertexBuffer
     * @see Context#draw
     * @see VertexArray
     * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glGenBuffer.xml">glGenBuffer</a>
     * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glBindBuffer.xml">glBindBuffer</a> with <code>ELEMENT_ARRAY_BUFFER</code>
     * @see <a href="http://www.khronos.org/opengles/sdk/2.0/docs/man/glBufferData.xml">glBufferData</a> with <code>ELEMENT_ARRAY_BUFFER</code>
     *
     * @example
     * // Example 1. Create a stream index buffer of unsigned shorts that is
     * // 16 bytes in size.
     * var buffer = context.createIndexBuffer(16, BufferUsage.STREAM_DRAW,
     *     IndexType.unsignedShort);
     *
     * ////////////////////////////////////////////////////////////////////////////////
     *
     * // Example 2. Create a static index buffer containing three unsigned shorts.
     * var buffer = context.createIndexBuffer(new Uint16Array([0, 1, 2]),
     *     BufferUsage.STATIC_DRAW, IndexType.unsignedShort)
     */
    Context.prototype.createIndexBuffer = function(arrayViewOrSizeInBytes, usage, indexDatatype) {
        var gl = this._gl;
        var bytesPerIndex;

        var glIndexDatatype = indexDatatype.value;
        if (glIndexDatatype === gl.UNSIGNED_BYTE) {
            bytesPerIndex = Uint8Array.BYTES_PER_ELEMENT;
        } else if (glIndexDatatype === gl.UNSIGNED_SHORT) {
            bytesPerIndex = Uint16Array.BYTES_PER_ELEMENT;
        } else {
            throw new DeveloperError("Invalid indexDatatype.", "indexDatatype");
        }

        var buffer = this._createBuffer(gl, gl.ELEMENT_ARRAY_BUFFER, arrayViewOrSizeInBytes, usage);
        var numberOfIndices = buffer.getSizeInBytes() / bytesPerIndex;

        buffer.getIndexDatatype = function() {
            return indexDatatype;
        };

        buffer.getBytesPerIndex = function() {
            return bytesPerIndex;
        };

        buffer.getNumberOfIndices = function() {
            return numberOfIndices;
        };

        return buffer;
    };

    /**
     * Creates a vertex array, which defines the attributes making up a vertex, and contains an optional index buffer
     * to select vertices for rendering.  Attributes are defined using object literals as shown in Example 1 below.
     *
     * @memberof Context
     *
     * @param {Array} [attributes=undefined] An optional array of attributes.
     * @param {IndexBuffer} [indexBuffer=undefined] An optional index buffer.
     *
     * @return {VertexArray} The vertex array, ready for use with drawing.
     *
     * @exception {DeveloperError} Attribute must have a <code>vertexBuffer</code>.
     * @exception {DeveloperError} Attribute must have a <code>componentsPerAttribute</code>.
     * @exception {DeveloperError} Attribute must have a valid <code>componentDatatype</code> or not specify it.
     * @exception {DeveloperError} Attribute must have a <code>strideInBytes</code> less than or equal to 255 or not specify it.
     * @exception {DeveloperError} Index n is used by more than one attribute.
     *
     * @see Context#createVertexArrayFromMesh
     * @see Context#createVertexBuffer
     * @see Context#createIndexBuffer
     * @see Context#draw
     *
     * @example
     * // Example 1. Create a vertex array with vertices made up of three floating point
     * // values, e.g., a position, from a single vertex buffer.  No index buffer is used.
     * var positionBuffer = context.createVertexBuffer(12, BufferUsage.STATIC_DRAW);
     * var attributes = [
     *     {
     *         index                  : 0,
     *         enabled                : true,
     *         vertexBuffer           : positionBuffer,
     *         componentsPerAttribute : 3,
     *         componentDatatype      : ComponentDatatype.FLOAT,
     *         normalize              : false,
     *         offsetInBytes          : 0,
     *         strideInBytes          : 0 // tightly packed
     *     }
     * ];
     * var va = context.createVertexArray(attributes);
     *
     * ////////////////////////////////////////////////////////////////////////////////
     *
     * // Example 2. Create a vertex array with vertices from two different vertex buffers.
     * // Each vertex has a three-component position and three-component normal.
     * var positionBuffer = context.createVertexBuffer(12, BufferUsage.STATIC_DRAW);
     * var normalBuffer = context.createVertexBuffer(12, BufferUsage.STATIC_DRAW);
     * var attributes = [
     *     {
     *         index                  : 0,
     *         vertexBuffer           : positionBuffer,
     *         componentsPerAttribute : 3,
     *         componentDatatype      : ComponentDatatype.FLOAT
     *     },
     *     {
     *         index                  : 1,
     *         vertexBuffer           : normalBuffer,
     *         componentsPerAttribute : 3,
     *         componentDatatype      : ComponentDatatype.FLOAT
     *     }
     * ];
     * var va = context.createVertexArray(attributes);
     *
     * ////////////////////////////////////////////////////////////////////////////////
     *
     * // Example 3. Creates the same vertex layout as Example 2 using a single
     * // vertex buffer, instead of two.
     * var buffer = context.createVertexBuffer(24, BufferUsage.STATIC_DRAW);
     * var attributes = [
     *     {
     *         vertexBuffer           : buffer,
     *         componentsPerAttribute : 3,
     *         componentDatatype      : ComponentDatatype.FLOAT,
     *         offsetInBytes          : 0,
     *         strideInBytes          : 24
     *     },
     *     {
     *         vertexBuffer           : buffer,
     *         componentsPerAttribute : 3,
     *         componentDatatype      : ComponentDatatype.FLOAT,
     *         normalize              : true,
     *         offsetInBytes          : 12,
     *         strideInBytes          : 24
     *     }
     * ];
     * var va = context.createVertexArray(attributes);
     */
    Context.prototype.createVertexArray = function(attributes, indexBuffer) {
        return new VertexArray(this._gl, attributes, indexBuffer);
    };

    /**
     * DOC_TBA.
     *
     * description.source can be {ImageData}, {HTMLImageElement}, {HTMLCanvasElement}, or {HTMLVideoElement}.
     *
     * @memberof Context
     *
     * @return {Texture} DOC_TBA.
     *
     * @exception {DeveloperError} description is required.
     * @exception {DeveloperError} description requires a source field to create an initialized texture or width and height fields to create a blank texture.
     * @exception {DeveloperError} Width must be greater than zero.
     * @exception {DeveloperError} Width must be less than or equal to the maximum texture size.
     * @exception {DeveloperError} Height must be greater than zero.
     * @exception {DeveloperError} Height must be less than or equal to the maximum texture size.
     * @exception {DeveloperError} Invalid description.pixelFormat.
     * @exception {DeveloperError} Invalid description.pixelDatatype.
     *
     * @see Context#createTexture2DFromFramebuffer
     * @see Context#createCubeMap
     * @see Context#createSampler
     */
    Context.prototype.createTexture2D = function(description) {
        if (!description) {
            throw new DeveloperError("description is required.", "description");
        }

        var source = description.source;
        var width = source ? source.width : description.width;
        var height = source ? source.height : description.height;

        if (!source && (typeof width === "undefined" || typeof height === "undefined")) {
            throw new DeveloperError("description requires a source field to create an initialized texture or width and height fields to create a blank texture.", "description");
        }

        if (width <= 0) {
            throw new DeveloperError("Width must be greater than zero.", "description");
        }

        if (width > this._maximumTextureSize) {
            throw new DeveloperError("Width must be less than or equal to the maximum texture size (" + this._maximumTextureSize + ").  Check getMaximumTextureSize().", "description");
        }

        if (height <= 0) {
            throw new DeveloperError("Height must be greater than zero.", "description");
        }

        if (height > this._maximumTextureSize) {
            throw new DeveloperError("Height must be less than or equal to the maximum texture size (" + this._maximumTextureSize + ").  Check getMaximumTextureSize().", "description");
        }

        var gl = this._gl;
        var pixelFormat = description.pixelFormat || PixelFormat.RGBA;
        var glPixelFormat = pixelFormat.value;
        if ((glPixelFormat !== gl.ALPHA) &&
            (glPixelFormat !== gl.RGB) &&
            (glPixelFormat !== gl.RGBA) &&
            (glPixelFormat !== gl.LUMINANCE) &&
            (glPixelFormat !== gl.LUMINANCE_ALPHA)) {
            throw new DeveloperError("Invalid description.pixelFormat.", "description");
        }

        var pixelDatatype = description.pixelDatatype || PixelDatatype.UNSIGNED_BYTE;
        var glPixelDatatype = pixelDatatype.value;
        if ((glPixelDatatype !== gl.UNSIGNED_BYTE) &&
            (glPixelDatatype !== gl.UNSIGNED_SHORT_5_6_5) &&
            (glPixelDatatype !== gl.UNSIGNED_SHORT_4_4_4_4) &&
            (glPixelDatatype !== gl.UNSIGNED_SHORT_5_5_5_1)) {
            throw new DeveloperError("Invalid description.pixelDatatype.", "description");
        }

        // Use premultiplied alpha for opaque textures should perform better on Chrome:
        // http://media.tojicode.com/webglCamp4/#20
        var preMultiplyAlpha = description.preMultiplyAlpha || ((glPixelFormat === gl.RGB) || (glPixelFormat === gl.LUMINANCE));

        var textureTarget = gl.TEXTURE_2D;
        var texture = gl.createTexture();

        // TODO: _gl.pixelStorei(_gl._UNPACK_ALIGNMENT, 4);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, preMultiplyAlpha);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(textureTarget, texture);

        if (source) {
            if (source.arrayBufferView) {
                // Source: typed array
                gl.texImage2D(textureTarget, 0, glPixelFormat, width, height, 0, glPixelFormat, glPixelDatatype, source.arrayBufferView);
            } else {
                // Source: ImageData, HTMLImageElement, HTMLCanvasElement, or HTMLVideoElement
                gl.texImage2D(textureTarget, 0, glPixelFormat, glPixelFormat, glPixelDatatype, source);
            }
        } else {
            gl.texImage2D(textureTarget, 0, glPixelFormat, width, height, 0, glPixelFormat, glPixelDatatype, null);
        }
        gl.bindTexture(textureTarget, null);

        return new Texture(gl, this._textureFilterAnisotropic, textureTarget, texture, pixelFormat, pixelDatatype, width, height, preMultiplyAlpha);
    };

    /**
     * DOC_TBA.
     *
     * @memberof Context
     *
     * @param {PixelFormat} pixelFormat optional.
     * @param {PixelFormat} framebufferXOffset optional.
     * @param {PixelFormat} framebufferYOffset optional.
     * @param {PixelFormat} width optional.
     * @param {PixelFormat} height optional.
     *
     * @return {Texture} DOC_TBA.
     *
     * @exception {DeveloperError} Invalid pixelFormat.
     * @exception {DeveloperError} framebufferXOffset must be greater than or equal to zero.
     * @exception {DeveloperError} framebufferYOffset must be greater than or equal to zero.
     * @exception {DeveloperError} framebufferXOffset + width must be less than or equal to getCanvas().clientWidth.
     * @exception {DeveloperError} framebufferYOffset + height must be less than or equal to getCanvas().clientHeight.
     *
     * @see Context#createTexture2D
     * @see Context#createCubeMap
     * @see Context#createSampler
     */
    Context.prototype.createTexture2DFromFramebuffer = function(pixelFormat, framebufferXOffset, framebufferYOffset, width, height) {
        var gl = this._gl;
        pixelFormat = pixelFormat || PixelFormat.RGB;
        var glPixelFormat = pixelFormat.value;
        if (!glPixelFormat ||
            (glPixelFormat !== gl.ALPHA) &&
            (glPixelFormat !== gl.RGB) &&
            (glPixelFormat !== gl.RGBA) &&
            (glPixelFormat !== gl.LUMINANCE) &&
            (glPixelFormat !== gl.LUMINANCE_ALPHA)) {
            throw new DeveloperError("Invalid pixelFormat.", "pixelFormat");
        }

        if (framebufferXOffset < 0) {
            throw new DeveloperError("framebufferXOffset must be greater than or equal to zero.", "framebufferXOffset");
        }

        if (framebufferYOffset < 0) {
            throw new DeveloperError("framebufferYOffset must be greater than or equal to zero.", "framebufferYOffset");
        }

        if (framebufferXOffset + width > this._canvas.clientWidth) {
            throw new DeveloperError("framebufferXOffset + width must be less than or equal to getCanvas().clientWidth");
        }

        if (framebufferYOffset + height > this._canvas.clientHeight) {
            throw new DeveloperError("framebufferYOffset + height must be less than or equal to getCanvas().clientHeight.");
        }

        framebufferXOffset = framebufferXOffset || 0;
        framebufferYOffset = framebufferYOffset || 0;
        width = width || this._canvas.clientWidth;
        height = height || this._canvas.clientHeight;

        var textureTarget = gl.TEXTURE_2D;
        var texture = gl.createTexture();

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(textureTarget, texture);
        gl.copyTexImage2D(textureTarget, 0, glPixelFormat, framebufferXOffset, framebufferYOffset, width, height, 0);
        gl.bindTexture(textureTarget, null);

        return new Texture(gl, this._textureFilterAnisotropic, textureTarget, texture, pixelFormat, undefined, width, height);
    };

    /**
     * DOC_TBA
     */
    Context.prototype.createTextureAtlas = function(images, pixelFormat, borderWidthInPixels) {
        return new TextureAtlas(this, images, pixelFormat, borderWidthInPixels);
    };

    /**
     * DOC_TBA.
     *
     * description.source can be {ImageData}, {HTMLImageElement}, {HTMLCanvasElement}, or {HTMLVideoElement}.
     *
     * @memberof Context
     *
     * @return {CubeMap} DOC_TBA.
     *
     * @exception {DeveloperError} description is required.
     * @exception {DeveloperError} description.source requires positiveX, negativeX, positiveY, negativeY, positiveZ, and negativeZ faces.
     * @exception {DeveloperError} Each face in description.sources must have the same width and height.
     * @exception {DeveloperError} description requires a source field to create an initialized cube map or width and height fields to create a blank cube map.
     * @exception {DeveloperError} Width must equal height.
     * @exception {DeveloperError} Width and height must be greater than zero.
     * @exception {DeveloperError} Width and height must be less than or equal to the maximum cube map size.
     * @exception {DeveloperError} Invalid description.pixelFormat.
     * @exception {DeveloperError} Invalid description.pixelDatatype.
     *
     * @see Context#createTexture2D
     * @see Context#createTexture2DFromFramebuffer
     * @see Context#createSampler
     */
    Context.prototype.createCubeMap = function(description) {
        if (!description) {
            throw new DeveloperError("description is required.", "description");
        }

        var source = description.source;
        var width;
        var height;

        if (source) {
            var faces = [source.positiveX, source.negativeX, source.positiveY, source.negativeY, source.positiveZ, source.negativeZ];

            if (!faces[0] || !faces[1] || !faces[2] || !faces[3] || !faces[4] || !faces[5]) {
                throw new DeveloperError("description.source requires positiveX, negativeX, positiveY, negativeY, positiveZ, and negativeZ faces.", "description");
            }

            width = faces[0].width;
            height = faces[0].height;

            for ( var i = 1; i < 6; ++i) {
                if ((Number(faces[i].width) !== width) || (Number(faces[i].height) !== height)) {
                    throw new DeveloperError("Each face in description.source must have the same width and height.", "description");
                }
            }
        } else {
            width = description.width;
            height = description.height;
        }

        if (typeof width === "undefined" || typeof height === "undefined") {
            throw new DeveloperError("description requires a source field to create an initialized cube map or width and height fields to create a blank cube map.", "description");
        }

        if (width !== height) {
            throw new DeveloperError("Width must equal height.", "description");
        }

        var size = width;

        if (size <= 0) {
            throw new DeveloperError("Width and height must be greater than zero.", "description");
        }

        if (size > this._maximumCubeMapSize) {
            throw new DeveloperError("Width and height must be less than or equal to the maximum cube map size (" + this._maximumCubeMapSize + ").  Check getMaximumCubeMapSize().", "description");
        }

        var gl = this._gl;
        var pixelFormat = description.pixelFormat || PixelFormat.RGBA;
        var glPixelFormat = pixelFormat.value;
        if ((glPixelFormat !== gl.ALPHA) &&
            (glPixelFormat !== gl.RGB) &&
            (glPixelFormat !== gl.RGBA) &&
            (glPixelFormat !== gl.LUMINANCE) &&
            (glPixelFormat !== gl.LUMINANCE_ALPHA)) {
            throw new DeveloperError("Invalid description.pixelFormat.", "description");
        }

        var pixelDatatype = description.pixelDatatype || PixelDatatype.UNSIGNED_BYTE;
        var glPixelDatatype = pixelDatatype.value;
        if ((glPixelDatatype !== gl.UNSIGNED_BYTE) &&
            (glPixelDatatype !== gl.UNSIGNED_SHORT_5_6_5) &&
            (glPixelDatatype !== gl.UNSIGNED_SHORT_4_4_4_4) &&
            (glPixelDatatype !== gl.UNSIGNED_SHORT_5_5_5_1)) {
            throw new DeveloperError("Invalid description.pixelDatatype.", "description");
        }

        // Use premultiplied alpha for opaque textures should perform better on Chrome:
        // http://media.tojicode.com/webglCamp4/#20
        var preMultiplyAlpha = description.preMultiplyAlpha || ((glPixelFormat === gl.RGB) || (glPixelFormat === gl.LUMINANCE));

        var textureTarget = gl.TEXTURE_CUBE_MAP;
        var texture = gl.createTexture();

        // TODO: _gl.pixelStorei(_gl._UNPACK_ALIGNMENT, 4);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, preMultiplyAlpha);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(textureTarget, texture);

        function createFace(target, sourceFace) {
            if (sourceFace.arrayBufferView) {
                gl.texImage2D(target, 0, glPixelFormat, size, size, 0, glPixelFormat, glPixelDatatype, sourceFace.arrayBufferView);
            } else {
                gl.texImage2D(target, 0, glPixelFormat, glPixelFormat, glPixelDatatype, sourceFace);
            }
        }

        if (source) {
            createFace(gl.TEXTURE_CUBE_MAP_POSITIVE_X, source.positiveX);
            createFace(gl.TEXTURE_CUBE_MAP_NEGATIVE_X, source.negativeX);
            createFace(gl.TEXTURE_CUBE_MAP_POSITIVE_Y, source.positiveY);
            createFace(gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, source.negativeY);
            createFace(gl.TEXTURE_CUBE_MAP_POSITIVE_Z, source.positiveZ);
            createFace(gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, source.negativeZ);
        } else {
            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glPixelFormat, size, size, 0, glPixelFormat, glPixelDatatype, null);
            gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glPixelFormat, size, size, 0, glPixelFormat, glPixelDatatype, null);
            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glPixelFormat, size, size, 0, glPixelFormat, glPixelDatatype, null);
            gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glPixelFormat, size, size, 0, glPixelFormat, glPixelDatatype, null);
            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glPixelFormat, size, size, 0, glPixelFormat, glPixelDatatype, null);
            gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glPixelFormat, size, size, 0, glPixelFormat, glPixelDatatype, null);
        }
        gl.bindTexture(textureTarget, null);

        return new CubeMap(gl, this._textureFilterAnisotropic, textureTarget, texture, pixelFormat, pixelDatatype, size, preMultiplyAlpha);
    };

    /**
     * DOC_TBA.
     *
     * @memberof Context
     *
     * @param {Object} description optional.
     *
     * @return {Framebuffer} DOC_TBA.
     *
     * @exception {DeveloperError} Cannot have both a depth and depth-stencil renderbuffer.
     * @exception {DeveloperError} Cannot have both a stencil and depth-stencil renderbuffer.
     * @exception {DeveloperError} Cannot have both a depth and stencil renderbuffer.
     *
     * @see Context#createTexture2D
     * @see Context#createCubeMap
     * @see Context#createRenderbuffer
     */
    Context.prototype.createFramebuffer = function(description) {
        if (description) {
            if (description.depthRenderbuffer && description.depthStencilRenderbuffer) {
                throw new DeveloperError("Cannot have both a depth and depth-stencil attachment.", "description");
            }

            if (description.stencilRenderbuffer && description.depthStencilRenderbuffer) {
                throw new DeveloperError("Cannot have both a stencil and depth-stencil attachment.", "description");
            }

            if (description.depthRenderbuffer && description.stencilRenderbuffer) {
                throw new DeveloperError("Cannot have both a depth and stencil attachment.", "description");
            }
        }
        return new Framebuffer(this._gl, description);
    };

    /**
     * DOC_TBA.
     *
     * @memberof Context
     *
     * @param {Object} description optional.
     *
     * @return {createRenderbuffer} DOC_TBA.
     *
     * @exception {DeveloperError} Invalid format.
     * @exception {DeveloperError} Width must be greater than zero.
     * @exception {DeveloperError} Width must be less than or equal to the maximum renderbuffer size.
     * @exception {DeveloperError} Height must be greater than zero.
     * @exception {DeveloperError} Height must be less than or equal to the maximum renderbuffer size.
     *
     * @see Context#createFramebuffer
     */
    Context.prototype.createRenderbuffer = function(description) {
        description = description || {};
        var format = description.format || RenderbufferFormat.RGBA4;
        var width = (typeof description.width === "undefined") ? this._canvas.clientWidth : description.width;
        var height = (typeof description.height === "undefined") ? this._canvas.clientHeight : description.height;

        var gl = this._gl;
        var glFormat = format.value;
        if ((glFormat !== gl.RGBA4) &&
            (glFormat !== gl.RGB5_A1) &&
            (glFormat !== gl.RGB565) &&
            (glFormat !== gl.DEPTH_COMPONENT16) &&
            (glFormat !== gl.STENCIL_INDEX8) &&
            (glFormat !== gl.DEPTH_STENCIL)) {
            throw new DeveloperError("Invalid format.", "description");
        }

        if (width <= 0) {
            throw new DeveloperError("Width must be greater than zero.", "description");
        }

        if (width > this.getMaximumRenderbufferSize()) {
            throw new DeveloperError("Width must be less than or equal to the maximum renderbuffer size (" + this.getMaximumRenderbufferSize() + ").  Check getMaximumRenderbufferSize().", "description");
        }

        if (height <= 0) {
            throw new DeveloperError("Height must be greater than zero.", "description");
        }

        if (height > this.getMaximumRenderbufferSize()) {
            throw new DeveloperError("Height must be less than or equal to the maximum renderbuffer size (" + this.getMaximumRenderbufferSize() + ").  Check getMaximumRenderbufferSize().", "description");
        }

        return new Renderbuffer(gl, format, width, height);
    };

    /**
     * DOC_TBA.
     *
     * Validates and adds defaults for missing states.
     *
     * @memberof Context
     *
     * @exception {RuntimeError} renderState.lineWidth is out of range.
     * @exception {DeveloperError} Invalid renderState.frontFace.
     * @exception {DeveloperError} Invalid renderState.cull.face.
     * @exception {DeveloperError} scissorTest.rectangle.width and scissorTest.rectangle.height must be greater than or equal to zero.
     * @exception {DeveloperError} renderState.depthRange.near can't be greater than renderState.depthRange.far.
     * @exception {DeveloperError} renderState.depthRange.near must be greater than or equal to zero.
     * @exception {DeveloperError} renderState.depthRange.far must be less than or equal to zero.
     * @exception {DeveloperError} Invalid renderState.depthTest.func.
     * @exception {DeveloperError} renderState.blending.color components must be greater than or equal to zero and less than or equal to one
     * @exception {DeveloperError} Invalid renderState.blending.equationRgb.
     * @exception {DeveloperError} Invalid renderState.blending.equationAlpha.
     * @exception {DeveloperError} Invalid renderState.blending.functionSourceRgb.
     * @exception {DeveloperError} Invalid renderState.blending.functionSourceAlpha.
     * @exception {DeveloperError} Invalid renderState.blending.functionDestinationRgb.
     * @exception {DeveloperError} Invalid renderState.blending.functionDestinationAlpha.
     * @exception {DeveloperError} Invalid renderState.stencilTest.frontFunction.
     * @exception {DeveloperError} Invalid renderState.stencilTest.backFunction.
     * @exception {DeveloperError} Invalid renderState.stencilTest.frontOperation.fail.
     * @exception {DeveloperError} Invalid renderState.stencilTest.frontOperation.zFail.
     * @exception {DeveloperError} Invalid renderState.stencilTest.frontOperation.zPass.
     * @exception {DeveloperError} Invalid renderState.stencilTest.backOperation.fail.
     * @exception {DeveloperError} Invalid renderState.stencilTest.backOperation.zFail.
     * @exception {DeveloperError} Invalid renderState.stencilTest.backOperation.zPass.
     */
    Context.prototype.createRenderState = function(renderState) {
        var rs = renderState || {};
        var cull = rs.cull || {};
        var polygonOffset = rs.polygonOffset || {};
        var scissorTest = rs.scissorTest || {};
        var scissorTestRectangle = scissorTest.rectangle || {};
        var depthRange = rs.depthRange || {};
        var depthTest = rs.depthTest || {};
        var colorMask = rs.colorMask || {};
        var blending = rs.blending || {};
        var blendingColor = blending.color || {};
        var stencilTest = rs.stencilTest || {};
        var stencilTestFrontOperation = stencilTest.frontOperation || {};
        var stencilTestBackOperation = stencilTest.backOperation || {};
        var sampleCoverage = rs.sampleCoverage || {};

        var r = {
            frontFace : (typeof rs.frontFace === "undefined") ? FrontFace.COUNTER_CLOCKWISE : rs.frontFace,
            cull : {
                enabled : (typeof cull.enabled === "undefined") ? false : cull.enabled,
                face : (typeof cull.face === "undefined") ? CullFace.BACK : cull.face
            },
            lineWidth : (typeof rs.lineWidth === "undefined") ? 1 : rs.lineWidth,
            polygonOffset : {
                enabled : (typeof polygonOffset.enabled === "undefined") ? false : polygonOffset.enabled,
                factor : (typeof polygonOffset.factor === "undefined") ? 0 : polygonOffset.factor,
                units : (typeof polygonOffset.units === "undefined") ? 0 : polygonOffset.units
            },
            scissorTest : {
                enabled : (typeof scissorTest.enabled === "undefined") ? false : scissorTest.enabled,
                rectangle : {
                    x : (typeof scissorTestRectangle.x === "undefined") ? 0 : scissorTestRectangle.x,
                    y : (typeof scissorTestRectangle.y === "undefined") ? 0 : scissorTestRectangle.y,
                    width : (typeof scissorTestRectangle.width === "undefined") ? 0 : scissorTestRectangle.width,
                    height : (typeof scissorTestRectangle.height === "undefined") ? 0 : scissorTestRectangle.height
                }
            },
            depthRange : {
                near : (typeof depthRange.near === "undefined") ? 0 : depthRange.near,
                far : (typeof depthRange.far === "undefined") ? 1 : depthRange.far
            },
            depthTest : {
                enabled : (typeof depthTest.enabled === "undefined") ? false : depthTest.enabled,
                func : (typeof depthTest.func === "undefined") ? DepthFunction.LESS : depthTest.func // func, because function is a JavaScript keyword
            },
            colorMask : {
                red : (typeof colorMask.red === "undefined") ? true : colorMask.red,
                green : (typeof colorMask.green === "undefined") ? true : colorMask.green,
                blue : (typeof colorMask.blue === "undefined") ? true : colorMask.blue,
                alpha : (typeof colorMask.alpha === "undefined") ? true : colorMask.alpha
            },
            depthMask : (typeof rs.depthMask === "undefined") ? true : rs.depthMask,
            stencilMask : (typeof rs.stencilMask === "undefined") ? ~0 : rs.stencilMask,
            blending : {
                enabled : (typeof blending.enabled === "undefined") ? false : blending.enabled,
                color : {
                    red : (typeof blendingColor.red === "undefined") ? 0 : blendingColor.red,
                    green : (typeof blendingColor.green === "undefined") ? 0 : blendingColor.green,
                    blue : (typeof blendingColor.blue === "undefined") ? 0 : blendingColor.blue,
                    alpha : (typeof blendingColor.alpha === "undefined") ? 0 : blendingColor.alpha
                },
                equationRgb : (typeof blending.equationRgb === "undefined") ? BlendEquation.ADD : blending.equationRgb,
                equationAlpha : (typeof blending.equationAlpha === "undefined") ? BlendEquation.ADD : blending.equationAlpha,
                functionSourceRgb : (typeof blending.functionSourceRgb === "undefined") ? BlendFunction.ONE : blending.functionSourceRgb,
                functionSourceAlpha : (typeof blending.functionSourceAlpha === "undefined") ? BlendFunction.ONE : blending.functionSourceAlpha,
                functionDestinationRgb : (typeof blending.functionDestinationRgb === "undefined") ? BlendFunction.ZERO : blending.functionDestinationRgb,
                functionDestinationAlpha : (typeof blending.functionDestinationAlpha === "undefined") ? BlendFunction.ZERO : blending.functionDestinationAlpha
            },
            stencilTest : {
                enabled : (typeof stencilTest.enabled === "undefined") ? false : stencilTest.enabled,
                frontFunction : (typeof stencilTest.frontFunction === "undefined") ? StencilFunction.ALWAYS : stencilTest.frontFunction,
                backFunction : (typeof stencilTest.backFunction === "undefined") ? StencilFunction.ALWAYS : stencilTest.backFunction,
                reference : (typeof stencilTest.reference === "undefined") ? 0 : stencilTest.reference,
                mask : (typeof stencilTest.mask === "undefined") ? ~0 : stencilTest.mask,
                frontOperation : {
                    fail : (typeof stencilTestFrontOperation.fail === "undefined") ? StencilOperation.KEEP : stencilTestFrontOperation.fail,
                    zFail : (typeof stencilTestFrontOperation.zFail === "undefined") ? StencilOperation.KEEP : stencilTestFrontOperation.zFail,
                    zPass : (typeof stencilTestFrontOperation.zPass === "undefined") ? StencilOperation.KEEP : stencilTestFrontOperation.zPass
                },
                backOperation : {
                    fail : (typeof stencilTestBackOperation.fail === "undefined") ? StencilOperation.KEEP : stencilTestBackOperation.fail,
                    zFail : (typeof stencilTestBackOperation.zFail === "undefined") ? StencilOperation.KEEP : stencilTestBackOperation.zFail,
                    zPass : (typeof stencilTestBackOperation.zPass === "undefined") ? StencilOperation.KEEP : stencilTestBackOperation.zPass
                }
            },
            // TODO:  Also need point_size and point_size_enable for ColladaFX
            // TODO:  Also need sample_alpha_to_coverage_enable for ColladaFX
            sampleCoverage : {
                enabled : (typeof sampleCoverage.enabled === "undefined") ? false : sampleCoverage.enabled,
                value : (typeof sampleCoverage.value === "undefined") ? 1.0 : sampleCoverage.value,
                invert : (typeof sampleCoverage.invert === "undefined") ? false : sampleCoverage.invert
            },
            dither : (typeof rs.dither === "undefined") ? true : rs.dither
        };

        // Validate

        if ((r.frontFace.value !== FrontFace.CLOCKWISE.value) &&
            (r.frontFace.value !== FrontFace.COUNTER_CLOCKWISE.value)) {
            throw new DeveloperError("Invalid renderState.frontFace.", "renderState");
        }

        if ((r.cull.face.value !== CullFace.FRONT.value) &&
            (r.cull.face.value !== CullFace.BACK.value) &&
            (r.cull.face.value !== CullFace.FRONT_AND_BACK.value)) {
            throw new DeveloperError("Invalid renderState.cull.face.", "renderState");
        }

        if ((r.lineWidth < this._aliasedLineWidthRange[0]) ||
            (r.lineWidth > this._aliasedLineWidthRange[1])) {
            throw new RuntimeError("renderState.lineWidth is out of range.  Check getMinimumAliasedLineWidth() and getMaximumAliasedLineWidth().", "renderState");
        }

        if ((r.scissorTest.rectangle.width < 0) ||
            (r.scissorTest.rectangle.height < 0)) {
            throw new DeveloperError("renderState.scissorTest.rectangle.width and renderState.scissorTest.rectangle.height must be greater than or equal to zero.", "renderState");
        }

        if (r.depthRange.near > r.depthRange.far) {
            // WebGL specific - not an error in GL ES
            throw new DeveloperError("renderState.depthRange.near can't be greater than renderState.depthRange.far.", "renderState");
        }

        if (r.depthRange.near < 0) {
            // Would be clamped by GL
            throw new DeveloperError("renderState.depthRange.near must be greater than or equal to zero.", "renderState");
        }

        if (r.depthRange.far > 1) {
            // Would be clamped by GL
            throw new DeveloperError("renderState.depthRange.far must be less than or equal to one.", "renderState");
        }

        if ((r.depthTest.func.value !== DepthFunction.NEVER.value) &&
            (r.depthTest.func.value !== DepthFunction.LESS.value) &&
            (r.depthTest.func.value !== DepthFunction.EQUAL.value) &&
            (r.depthTest.func.value !== DepthFunction.LESS_OR_EQUAL.value) &&
            (r.depthTest.func.value !== DepthFunction.GREATER.value) &&
            (r.depthTest.func.value !== DepthFunction.NOT_EQUAL.value) &&
            (r.depthTest.func.value !== DepthFunction.GREATER_OR_EQUAL.value) &&
            (r.depthTest.func.value !== DepthFunction.ALWAYS.value)) {
            throw new DeveloperError("Invalid renderState.depthTest.func.", "renderState");
        }

        if ((r.blending.color.red < 0.0) || (r.blending.color.red > 1.0) ||
            (r.blending.color.green < 0.0) || (r.blending.color.green > 1.0) ||
            (r.blending.color.blue < 0.0) || (r.blending.color.blue > 1.0) ||
            (r.blending.color.alpha < 0.0) || (r.blending.color.alpha > 1.0)) {
            // Would be clamped by GL
            throw new DeveloperError("renderState.blending.color components must be greater than or equal to zero and less than or equal to one.", "renderState");
        }

        if ((r.blending.equationRgb.value !== BlendEquation.ADD.value) &&
            (r.blending.equationRgb.value !== BlendEquation.SUBTRACT.value) &&
            (r.blending.equationRgb.value !== BlendEquation.REVERSE_SUBTRACT.value)) {
            throw new DeveloperError("Invalid renderState.blending.equationRgb.", "renderState");
        }

        if ((r.blending.equationAlpha.value !== BlendEquation.ADD.value) &&
            (r.blending.equationAlpha.value !== BlendEquation.SUBTRACT.value) &&
            (r.blending.equationAlpha.value !== BlendEquation.REVERSE_SUBTRACT.value)) {
            throw new DeveloperError("Invalid renderState.blending.equationAlpha.", "renderState");
        }

        var functions = {};
        functions[BlendFunction.ZERO.value] = true;
        functions[BlendFunction.ONE.value] = true;
        functions[BlendFunction.SOURCE_COLOR.value] = true;
        functions[BlendFunction.ONE_MINUS_SOURCE_COLOR.value] = true;
        functions[BlendFunction.DESTINATION_COLOR.value] = true;
        functions[BlendFunction.ONE_MINUS_DESTINATION_COLOR.value] = true;
        functions[BlendFunction.SOURCE_ALPHA.value] = true;
        functions[BlendFunction.ONE_MINUS_SOURCE_ALPHA.value] = true;
        functions[BlendFunction.DESTINATION_ALPHA.value] = true;
        functions[BlendFunction.ONE_MINUS_DESTINATION_ALPHA.value] = true;
        functions[BlendFunction.CONSTANT_COLOR.value] = true;
        functions[BlendFunction.ONE_MINUS_CONSTANT_COLOR.value] = true;
        functions[BlendFunction.CONSTANT_ALPHA.value] = true;
        functions[BlendFunction.ONE_MINUS_CONSTANT_ALPHA.value] = true;
        functions[BlendFunction.SOURCE_ALPHA_SATURATE.value] = true;

        if (!functions[r.blending.functionSourceRgb.value]) {
            throw new DeveloperError("Invalid renderState.blending.functionSourceRgb.", "renderState");
        }

        if (!functions[r.blending.functionSourceAlpha.value]) {
            throw new DeveloperError("Invalid renderState.blending.functionSourceAlpha.", "renderState");
        }

        if (!functions[r.blending.functionDestinationRgb.value]) {
            throw new DeveloperError("Invalid renderState.blending.functionDestinationRgb.", "renderState");
        }

        if (!functions[r.blending.functionDestinationAlpha.value]) {
            throw new DeveloperError("Invalid renderState.blending.functionDestinationAlpha.", "renderState");
        }

        if ((r.stencilTest.frontFunction.value !== StencilFunction.NEVER.value) &&
            (r.stencilTest.frontFunction.value !== StencilFunction.LESS.value) &&
            (r.stencilTest.frontFunction.value !== StencilFunction.EQUAL.value) &&
            (r.stencilTest.frontFunction.value !== StencilFunction.LESS_OR_EQUAL.value) &&
            (r.stencilTest.frontFunction.value !== StencilFunction.GREATER.value) &&
            (r.stencilTest.frontFunction.value !== StencilFunction.NOT_EQUAL.value) &&
            (r.stencilTest.frontFunction.value !== StencilFunction.GREATER_OR_EQUAL.value) &&
            (r.stencilTest.frontFunction.value !== StencilFunction.ALWAYS.value)) {
            throw new DeveloperError("Invalid renderState.stencilTest.frontFunction.", "renderState");
        }

        if ((r.stencilTest.backFunction.value !== StencilFunction.NEVER.value) &&
            (r.stencilTest.backFunction.value !== StencilFunction.LESS.value) &&
            (r.stencilTest.backFunction.value !== StencilFunction.EQUAL.value) &&
            (r.stencilTest.backFunction.value !== StencilFunction.LESS_OR_EQUAL.value) &&
            (r.stencilTest.backFunction.value !== StencilFunction.GREATER.value) &&
            (r.stencilTest.backFunction.value !== StencilFunction.NOT_EQUAL.value) &&
            (r.stencilTest.backFunction.value !== StencilFunction.GREATER_OR_EQUAL.value) &&
            (r.stencilTest.backFunction.value !== StencilFunction.ALWAYS.value)) {
            throw new DeveloperError("Invalid renderState.stencilTest.backFunction.", "renderState");
        }

        var operations = {};
        operations[StencilOperation.ZERO.value] = true;
        operations[StencilOperation.KEEP.value] = true;
        operations[StencilOperation.REPLACE.value] = true;
        operations[StencilOperation.INCREMENT.value] = true;
        operations[StencilOperation.DECREMENT.value] = true;
        operations[StencilOperation.INVERT.value] = true;
        operations[StencilOperation.INCREMENT_WRAP.value] = true;
        operations[StencilOperation.DECREMENT_WRAP.value] = true;

        if (!operations[r.stencilTest.frontOperation.fail.value]) {
            throw new DeveloperError("Invalid renderState.stencilTest.frontOperation.fail.", "renderState");
        }

        if (!operations[r.stencilTest.frontOperation.zFail.value]) {
            throw new DeveloperError("Invalid renderState.stencilTest.frontOperation.zFail.", "renderState");
        }

        if (!operations[r.stencilTest.frontOperation.zPass.value]) {
            throw new DeveloperError("Invalid renderState.stencilTest.frontOperation.zPass.", "renderState");
        }

        if (!operations[r.stencilTest.backOperation.fail.value]) {
            throw new DeveloperError("Invalid renderState.stencilTest.backOperation.fail.", "renderState");
        }

        if (!operations[r.stencilTest.backOperation.zFail.value]) {
            throw new DeveloperError("Invalid renderState.stencilTest.backOperation.zFail.", "renderState");
        }

        if (!operations[r.stencilTest.backOperation.zPass.value]) {
            throw new DeveloperError("Invalid renderState.stencilTest.backOperation.zPass.", "renderState");
        }

        return r;
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     *
     * @exception {DeveloperError} Invalid sampler.wrapS.
     * @exception {DeveloperError} Invalid sampler.wrapT.
     * @exception {DeveloperError} Invalid sampler.minificationFilter.
     * @exception {DeveloperError} Invalid sampler.magnificationFilter.
     *
     * @see Context#createTexture2D
     * @see Context#createCubeMap
     */
    Context.prototype.createSampler = function(sampler) {
        var s = {
            wrapS : sampler.wrapS || TextureWrap.CLAMP,
            wrapT : sampler.wrapT || TextureWrap.CLAMP,
            minificationFilter : sampler.minificationFilter || TextureMinificationFilter.LINEAR,
            magnificationFilter : sampler.magnificationFilter || TextureMagnificationFilter.LINEAR,
            maximumAnisotropy : (typeof sampler.maximumAnisotropy !== "undefined") ? sampler.maximumAnisotropy : 1.0
        };

        var gl = this._gl;
        var wrapS = s.wrapS.value;
        if ((wrapS !== gl.CLAMP_TO_EDGE) &&
            (wrapS !== gl.REPEAT) &&
            (wrapS !== gl.MIRRORED_REPEAT)) {
            throw new DeveloperError("Invalid sampler.wrapS.", "sampler");
        }

        var wrapT = s.wrapT.value;
        if ((wrapT !== gl.CLAMP_TO_EDGE) &&
            (wrapT !== gl.REPEAT) &&
            (wrapT !== gl.MIRRORED_REPEAT)) {
            throw new DeveloperError("Invalid sampler.wrapT.", "sampler");
        }

        var minificationFilter = s.minificationFilter.value;
        if ((minificationFilter !== gl.NEAREST) &&
            (minificationFilter !== gl.LINEAR) &&
            (minificationFilter !== gl.NEAREST_MIPMAP_NEAREST) &&
            (minificationFilter !== gl.LINEAR_MIPMAP_NEAREST) &&
            (minificationFilter !== gl.NEAREST_MIPMAP_LINEAR) &&
            (minificationFilter !== gl.LINEAR_MIPMAP_LINEAR)) {
            throw new DeveloperError("Invalid sampler.minificationFilter.", "sampler");
        }

        var magnificationFilter = s.magnificationFilter.value;
        if ((magnificationFilter !== gl.NEAREST) &&
            (magnificationFilter !== gl.LINEAR)) {
            throw new DeveloperError("Invalid sampler.magnificationFilter.", "sampler");
        }

        if (s.maximumAnisotropy < 1.0) {
            throw new DeveloperError("sampler.maximumAnisotropy must be greater than or equal to one.", "sampler");
        }

        return s;
    };

    /**
     * DOC_TBA.
     *
     * @memberof Context
     *
     * Validates and adds defaults for missing states.
     *
     * @exception {DeveloperError} clearState.scissorTest.rectangle.width and clearState.scissorTest.rectangle.height must be greater than or equal to zero.
     *
     * @see Context#clear
     */
    Context.prototype.createClearState = function(clearState) {
        var cs = clearState || {};
        var scissorTest = cs.scissorTest || {};
        var scissorTestRectangle = scissorTest.rectangle || {};
        var colorMask = cs.colorMask || {};

        var color = cs.color;
        var depth = cs.depth;
        var stencil = cs.stencil;

        // Clear everything if nothing is specified
        if ((typeof color === "undefined") && (typeof depth === "undefined") && (typeof stencil === "undefined")) {
            color = this._defaultClearColor;
            depth = this._defaultClearDepth;
            stencil = this._defaultClearStencil;
        }

        var c = {
            scissorTest : {
                enabled : (typeof scissorTest.enabled === "undefined") ? false : scissorTest.enabled,
                rectangle : {
                    x : (typeof scissorTestRectangle.x === "undefined") ? 0 : scissorTestRectangle.x,
                    y : (typeof scissorTestRectangle.y === "undefined") ? 0 : scissorTestRectangle.y,
                    width : (typeof scissorTestRectangle.width === "undefined") ? 0 : scissorTestRectangle.width,
                    height : (typeof scissorTestRectangle.height === "undefined") ? 0 : scissorTestRectangle.height
                }
            },
            colorMask : {
                red : (typeof colorMask.red === "undefined") ? true : colorMask.red,
                green : (typeof colorMask.green === "undefined") ? true : colorMask.green,
                blue : (typeof colorMask.blue === "undefined") ? true : colorMask.blue,
                alpha : (typeof colorMask.alpha === "undefined") ? true : colorMask.alpha
            },
            depthMask : (typeof cs.depthMask === "undefined") ? true : cs.depthMask,
            stencilMask : (typeof cs.stencilMask === "undefined") ? ~0 : cs.stencilMask,
            dither : (typeof cs.dither === "undefined") ? true : cs.dither,

            framebuffer : cs.framebuffer,

            color : {
                red : color.red,
                green : color.green,
                blue : color.blue,
                alpha : color.alpha
            },
            depth : depth,
            stencil : stencil
        };

        if ((c.scissorTest.rectangle.width < 0) || (c.scissorTest.rectangle.height < 0)) {
            throw new DeveloperError("clearState.scissorTest.rectangle.width and clearState.scissorTest.rectangle.height must be greater than or equal to zero.", "clearState");
        }

        return c;
    };

    Context.prototype._validateFramebuffer = function(framebuffer) {
        if (this._validateFB) {
            var gl = this._gl;
            var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

            if (status !== gl.FRAMEBUFFER_COMPLETE) {
                var message;

                switch (status) {
                case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                    message = "Framebuffer is not complete.  Incomplete attachment: at least one attachment point with a renderbuffer or texture attached has its attached object no longer in existence or has an attached image with a width or height of zero, or the color attachment point has a non-color-renderable image attached, or the depth attachment point has a non-depth-renderable image attached, or the stencil attachment point has a non-stencil-renderable image attached.  Color-renderable formats include GL_RGBA4, GL_RGB5_A1, and GL_RGB565. GL_DEPTH_COMPONENT16 is the only depth-renderable format. GL_STENCIL_INDEX8 is the only stencil-renderable format.";
                    break;
                case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                    message = "Framebuffer is not complete.  Incomplete dimensions: not all attached images have the same width and height.";
                    break;
                case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                    message = "Framebuffer is not complete.  Missing attachment: no images are attached to the framebuffer.";
                    break;
                case gl.FRAMEBUFFER_UNSUPPORTED:
                    message = "Framebuffer is not complete.  Unsupported: the combination of internal formats of the attached images violates an implementation-dependent set of restrictions.";
                    break;
                }

                throw new DeveloperError(message);
            }
        }
    };

    /**
     * DOC_TBA.
     *
     * clearState is optional.
     *
     * @memberof Context
     *
     * @see Context#createClearState
     */
    Context.prototype.clear = function(clearState) {
        var gl = this._gl;
        var bitmask = 0;

        clearState = clearState || this.createClearState();
        var c = clearState.color;
        var d = clearState.depth;
        var s = clearState.stencil;

        if (typeof c !== "undefined") {
            if (c.red !== this._clearColor.red ||
                c.green !== this._clearColor.green ||
                c.blue !== this._clearColor.blue ||
                c.alpha !== this._clearColor.alpha) {
                this._clearColor.red = c.red;
                this._clearColor.green = c.green;
                this._clearColor.blue = c.blue;
                this._clearColor.alpha = c.alpha;

                gl.clearColor(c.red, c.green, c.blue, c.alpha);
            }
            bitmask |= gl.COLOR_BUFFER_BIT;
        }

        if (typeof d !== "undefined") {
            if (d !== this._clearDepth) {
                this._clearDepth = d;
                gl.clearDepth(d);
            }
            bitmask |= gl.DEPTH_BUFFER_BIT;
        }

        if (typeof s !== "undefined") {
            if (s !== this._clearStencil) {
                this._clearStencil = s;
                gl.clearStencil(s);
            }
            bitmask |= gl.STENCIL_BUFFER_BIT;
        }

        this._applyScissorTest(clearState.scissorTest);
        this._applyColorMask(clearState.colorMask);
        this._applyDepthMask(clearState.depthMask);
        this._applyStencilMask(clearState.stencilMask);
        this._applyDither(clearState.dither);

        var framebuffer = clearState.framebuffer;

        if (framebuffer) {
            framebuffer._bind();
            this._validateFramebuffer(framebuffer);
        }

        gl.clear(bitmask);

        if (framebuffer) {
            framebuffer._unBind();
        }
    };

    Context.prototype._validateShaderProgram = function(sp) {
        if (this._validateSP) {
            var gl = this._gl;
            var program = sp._getProgram();
            gl.validateProgram(program);

            if (!gl.getProgramParameter(program, gl.VALIDATE_STATUS)) {
                throw new DeveloperError("Program validation failed.  Link log: " + gl.getProgramInfoLog(program));
            }
        }
    };

    /**
     * DOC_TBA.
     *
     * @memberof Context
     *
     * @exception {DeveloperError} drawArguments is required.
     * @exception {DeveloperError} drawArguments.primitiveType is required and must be valid.
     * @exception {DeveloperError} drawArguments.shaderProgram is required.
     * @exception {DeveloperError} drawArguments.vertexArray is required.
     * @exception {DeveloperError} drawArguments.offset must be omitted or greater than or equal to zero.
     * @exception {DeveloperError} Program validation failed.
     * @exception {DeveloperError} Framebuffer is not complete.
     *
     * @see Context#createShaderProgram
     * @see Context#createVertexArray
     * @see Context#createFramebuffer
     * @see Context#createRenderState
     *
     * @example
     * // Example 1.  Draw a single triangle specifying only required arguments
     * context.draw({
     *     primitiveType : PrimitiveType.TRIANGLES,
     *     shaderProgram : sp,
     *     vertexArray   : va,
     * });
     *
     * ////////////////////////////////////////////////////////////////////////////////
     *
     * // Example 2.  Draw a single triangle specifying every argument
     * context.draw({
     *     primitiveType : PrimitiveType.TRIANGLES,
     *     offset        : 0,
     *     count         : 3,
     *     framebuffer   : fb,
     *     shaderProgram : sp,
     *     vertexArray   : va,
     *     renderState   : rs
     * });
     */
    Context.prototype.draw = function(drawArguments) {
        this.beginDraw(drawArguments);
        this.continueDraw(drawArguments);
        this.endDraw();
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     */
    Context.prototype.beginDraw = function(drawArguments) {
        if (typeof drawArguments === "undefined") {
            throw new DeveloperError("drawArguments is required.", "drawArguments");
        }

        if (!drawArguments.shaderProgram) {
            throw new DeveloperError("drawArguments.shaderProgram is required.", "drawArguments");
        }

        var framebuffer = drawArguments.framebuffer;
        var sp = drawArguments.shaderProgram;
        var rs = drawArguments.renderState || this.createRenderState();

        if (framebuffer && rs.depthTest) {
            if (rs.depthTest.enabled &&
                !framebuffer.getDepthRenderbuffer() &&
                !framebuffer.getDepthStencilRenderbuffer()) {
                throw new DeveloperError("The depth test can't be enabled (drawArguments.renderState.depthTest.enabled) because the framebuffer (drawArguments.framebuffer) doesn't have a depth or depth-stencil renderbuffer.", "drawArguments");
            }
        }

        ///////////////////////////////////////////////////////////////////////

        this._applyRenderState(rs);
        if (framebuffer) {
            framebuffer._bind();
            this._validateFramebuffer(framebuffer);
        }
        sp._bind();

        this._currentFramebuffer = framebuffer;
        this._currentSp = sp;
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     */
    Context.prototype.continueDraw = function(drawArguments) {
        var sp = this._currentSp;
        if (typeof sp === "undefined") {
            throw new DeveloperError("beginDraw must be called before continueDraw.");
        }

        if (typeof drawArguments === "undefined") {
            throw new DeveloperError("drawArguments is required.", "drawArguments");
        }

        var primitiveType = drawArguments.primitiveType;

        if (typeof primitiveType === "undefined") {
            throw new DeveloperError("drawArguments.primitiveType is required and must be valid.", "drawArguments");
        }

        var gl = this._gl;
        var glPrimitiveType = primitiveType.value;
        if ((glPrimitiveType !== gl.POINTS) &&
            (glPrimitiveType !== gl.LINES) &&
            (glPrimitiveType !== gl.LINE_LOOP) &&
            (glPrimitiveType !== gl.LINE_STRIP) &&
            (glPrimitiveType !== gl.TRIANGLES) &&
            (glPrimitiveType !== gl.TRIANGLE_STRIP) &&
            (glPrimitiveType !== gl.TRIANGLE_FAN)) {
            throw new DeveloperError("drawArguments.primitiveType is required and must be valid.", "drawArguments");
        }

        if (!drawArguments.vertexArray) {
            throw new DeveloperError("drawArguments.vertexArray is required.", "drawArguments");
        }

        var va = drawArguments.vertexArray;
        var indexBuffer = va.getIndexBuffer();

        var offset = drawArguments.offset;
        var count = drawArguments.count;

        if (indexBuffer) {
            offset = (offset || 0) * indexBuffer.getBytesPerIndex(); // in bytes
            count = count || indexBuffer.getNumberOfIndices();
        } else {
            offset = offset || 0; // in vertices
            count = count || va._getNumberOfVertices();
        }

        if (offset < 0) {
            throw new DeveloperError("drawArguments.offset must be omitted or greater than or equal to zero.", "drawArguments");
        }

        if (count > 0) {
            sp._setUniforms(drawArguments.uniformMap, this._us);
            this._validateShaderProgram(sp);

            va._bind();

            if (indexBuffer) {
                gl.drawElements(glPrimitiveType, count, indexBuffer.getIndexDatatype().value, offset);
            } else {
                gl.drawArrays(glPrimitiveType, offset, count);
            }

            va._unBind();
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     */
    Context.prototype.endDraw = function(drawArguments) {
        if (this._currentFramebuffer) {
            this._currentFramebuffer._unBind();
            this._currentFramebuffer = undefined;
        }
        this._currentSp._unBind();
        this._currentSp = undefined;
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     *
     * @exception {DeveloperError} readState.width must be greater than zero.
     * @exception {DeveloperError} readState.height must be greater than zero.
     */
    Context.prototype.readPixels = function(readState) {
        readState = readState || {};
        var x = Math.max(readState.x || 0, 0);
        var y = Math.max(readState.y || 0, 0);
        var width = readState.width || this._canvas.clientWidth;
        var height = readState.height || this._canvas.clientHeight;
        var framebuffer = readState.framebuffer || null;

        if (width <= 0) {
            throw new DeveloperError("readState.width must be greater than zero.", "readState");
        }

        if (height <= 0) {
            throw new DeveloperError("readState.height must be greater than zero.", "readState");
        }

        var pixels = new Uint8Array(4 * width * height);

        if (framebuffer) {
            framebuffer._bind();
            this._validateFramebuffer(framebuffer);
        }

        var gl = this._gl;
        gl.readPixels(x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);

        if (framebuffer) {
            framebuffer._unBind();
        }

        return pixels;
    };

    //////////////////////////////////////////////////////////////////////////////////////////

    Context.prototype._interleaveAttributes = function(attributes) {
        function computeNumberOfVertices(attribute) {
            return attribute.values.length / attribute.componentsPerAttribute;
        }

        function computeAttributeSizeInBytes(attribute) {
            return attribute.componentDatatype.sizeInBytes * attribute.componentsPerAttribute;
        }

        var j;
        var name;
        var attribute;

        // Extract attribute names.
        var names = [];
        for (name in attributes) {
            // Attribute needs to have per-vertex values; not a constant value for all vertices.
            if (attributes.hasOwnProperty(name) && attributes[name].values) {
                names.push(name);
            }
        }

        // Validation.  Compute number of vertices.
        var numberOfVertices;
        var namesLength = names.length;

        if (namesLength > 0) {
            numberOfVertices = computeNumberOfVertices(attributes[names[0]]);

            for (j = 1; j < namesLength; ++j) {
                var currentNumberOfVertices = computeNumberOfVertices(attributes[names[j]]);

                if (currentNumberOfVertices !== numberOfVertices) {
                    throw new RuntimeError(
                        "Each attribute list must have the same number of vertices.  " +
                        "Attribute '" + names[j] + "' has a different number of vertices " +
                        "(" + currentNumberOfVertices.toString() + ")" +
                        " than attribute '" + names[0] +
                        "' (" + numberOfVertices.toString() + ").");
                }
            }
        }

        // Sort attributes by the size of their components.  From left to right, a vertex stores floats, shorts, and then bytes.
        names.sort(function(left, right) {
            return attributes[right].componentDatatype.sizeInBytes - attributes[left].componentDatatype.sizeInBytes;
        });

        // Compute sizes and strides.
        var vertexSizeInBytes = 0;
        var offsetsInBytes = {};

        for (j = 0; j < namesLength; ++j) {
            name = names[j];
            attribute = attributes[name];

            offsetsInBytes[name] = vertexSizeInBytes;
            vertexSizeInBytes += computeAttributeSizeInBytes(attribute);
        }

        if (vertexSizeInBytes > 0) {
            // Pad each vertex to be a multiple of the largest component datatype so each
            // attribute can be addressed using typed arrays.
            var maxComponentSizeInBytes = attributes[names[0]].componentDatatype.sizeInBytes; // Sorted large to small
            var remainder = vertexSizeInBytes % maxComponentSizeInBytes;
            if (remainder !== 0) {
                vertexSizeInBytes += (maxComponentSizeInBytes - remainder);
            }

            // Total vertex buffer size in bytes, including per-vertex padding.
            var vertexBufferSizeInBytes = numberOfVertices * vertexSizeInBytes;

            // Create array for interleaved vertices.  Each attribute has a different view (pointer) into the array.
            var buffer = new ArrayBuffer(vertexBufferSizeInBytes);
            var views = {};

            for (j = 0; j < namesLength; ++j) {
                name = names[j];
                var sizeInBytes = attributes[name].componentDatatype.sizeInBytes;

                views[name] = {
                    pointer : attributes[name].componentDatatype.toTypedArray(buffer),
                    index : offsetsInBytes[name] / sizeInBytes, // Offset in ComponentType
                    strideInComponentType : vertexSizeInBytes / sizeInBytes
                };
            }

            // Copy attributes into one interleaved array.
            // PERFORMANCE_IDEA:  Can we optimize these loops?
            for (j = 0; j < numberOfVertices; ++j) {
                for ( var n = 0; n < namesLength; ++n) {
                    name = names[n];
                    attribute = attributes[name];
                    var values = attribute.values;
                    var view = views[name];
                    var pointer = view.pointer;

                    var numberOfComponents = attribute.componentsPerAttribute;
                    for ( var k = 0; k < numberOfComponents; ++k) {
                        pointer[view.index + k] = values[(j * numberOfComponents) + k];
                    }

                    view.index += view.strideInComponentType;
                }
            }

            return {
                buffer : buffer,
                offsetsInBytes : offsetsInBytes,
                vertexSizeInBytes : vertexSizeInBytes
            };
        }

        // No attributes to interleave.
        return undefined;
    };

    Context.prototype._createVertexArrayAttributes = function(creationArguments) {
        var ca = creationArguments || {};
        var mesh = ca.mesh || {};
        var attributeIndices = ca.attributeIndices || {};
        var bufferUsage = ca.bufferUsage || BufferUsage.DYNAMIC_DRAW;
        var interleave = ca.vertexLayout && (ca.vertexLayout.value === VertexLayout.INTERLEAVED.value);

        var name;
        var attribute;
        var vaAttributes = [];
        var attributes = mesh.attributes;

        if (interleave) {
            // Use a single vertex buffer with interleaved vertices.
            var interleavedAttributes = this._interleaveAttributes(attributes);
            if (interleavedAttributes) {
                var vertexBuffer = this.createVertexBuffer(interleavedAttributes.buffer, bufferUsage);
                var offsetsInBytes = interleavedAttributes.offsetsInBytes;
                var strideInBytes = interleavedAttributes.vertexSizeInBytes;

                for (name in attributes) {
                    if (attributes.hasOwnProperty(name)) {
                        attribute = attributes[name];

                        if (attribute.values) {
                            // Common case: per-vertex attributes
                            vaAttributes.push({
                                index : attributeIndices[name],
                                vertexBuffer : vertexBuffer,
                                componentDatatype : attribute.componentDatatype,
                                componentsPerAttribute : attribute.componentsPerAttribute,
                                normalize : attribute.normalize,
                                offsetInBytes : offsetsInBytes[name],
                                strideInBytes : strideInBytes
                            });
                        } else {
                            // Constant attribute for all vertices
                            vaAttributes.push({
                                index : attributeIndices[name],
                                value : attribute.value,
                                componentDatatype : attribute.componentDatatype,
                                normalize : attribute.normalize
                            });
                        }
                    }
                }
            }
        } else {
            // One vertex buffer per attribute.
            for (name in attributes) {
                if (attributes.hasOwnProperty(name)) {
                    attribute = attributes[name];
                    vaAttributes.push({
                        index : attributeIndices[name],
                        vertexBuffer : attribute.values ? this.createVertexBuffer(attribute.componentDatatype.toTypedArray(attribute.values), bufferUsage) : undefined,
                        value : attribute.value ? attribute.value : undefined,
                        componentDatatype : attribute.componentDatatype,
                        componentsPerAttribute : attribute.componentsPerAttribute,
                        normalize : attribute.normalize
                    });
                }
            }
        }

        return this.createVertexArray(vaAttributes);
    };

    /**
     * Creates a vertex array from a mesh.  A mesh contains vertex attributes and optional index data
     * in system memory, whereas a vertex array contains vertex buffers and an optional index buffer in WebGL
     * memory for use with rendering.
     * <br /><br />
     * The <code>mesh</code> argument should use the standard layout like the mesh returned by {@link BoxTessellator}.
     * <br /><br />
     * <code>creationArguments</code> can have four properties:
     * <ul>
     *   <li><code>mesh</code>:  The source mesh containing data used to create the vertex array.</li>
     *   <li><code>attributeIndices</code>:  An object that maps mesh attribute names to vertex shader attribute indices.</li>
     *   <li><code>bufferUsage</code>:  The expected usage pattern of the vertex array's buffers.  On some WebGL implementations, this can significantly affect performance.  See {@link BufferUsage}.  Default: <code>BufferUsage.DYNAMIC_DRAW</code>.</li>
     *   <li><code>vertexLayout</code>:  Determines if all attributes are interleaved in a single vertex buffer or if each attribute is stored in a separate vertex buffer.  Default: <code>VertexLayout.SEPARATE</code>.</li>
     * </ul>
     * <br />
     * If <code>creationArguments</code> is not specified or the <code>mesh</code> contains no data, the returned vertex array is empty.
     *
     * @memberof Context
     *
     * @param {Object} [creationArguments=undefined] An object defining the mesh, attribute indices, buffer usage, and vertex layout used to create the vertex array.
     *
     * @exception {RuntimeError} Each attribute list must have the same number of vertices.
     * @exception {DeveloperError} The mesh must have zero or one index lists.
     * @exception {DeveloperError} Index n is used by more than one attribute.
     *
     * @see Context#createVertexArray
     * @see Context#createVertexBuffer
     * @see Context#createIndexBuffer
     * @see MeshFilters.createAttributeIndices
     * @see ShaderProgram
     * @see BoxTessellator
     *
     * @example
     * // Example 1. Creates a vertex array for rendering a box.  The default dynamic draw
     * // usage is used for the created vertex and index buffer.  The attributes are not
     * // interleaved by default.
     * var mesh = BoxTessellator.compute();
     * var va = context.createVertexArrayFromMesh({
     *     mesh             : mesh,
     *     attributeIndices : MeshFilters.createAttributeIndices(mesh),
     * });
     *
     * ////////////////////////////////////////////////////////////////////////////////
     *
     * // Example 2. Creates a vertex array with interleaved attributes in a
     * // single vertex buffer.  The vertex and index buffer have static draw usage.
     * var va = context.createVertexArrayFromMesh({
     *     mesh             : mesh,
     *     attributeIndices : MeshFilters.createAttributeIndices(mesh),
     *     bufferUsage      : BufferUsage.STATIC_DRAW,
     *     vertexLayout     : VertexLayout.INTERLEAVED
     * });
     *
     * ////////////////////////////////////////////////////////////////////////////////
     *
     * // Example 3.  When the caller destroys the vertex array, it also destroys the
     * // attached vertex buffer(s) and index buffer.
     * va = va.destroy();
     */
    Context.prototype.createVertexArrayFromMesh = function(creationArguments) {
        var ca = creationArguments || {};
        var mesh = ca.mesh || {};
        var bufferUsage = ca.bufferUsage || BufferUsage.DYNAMIC_DRAW;
        var indexLists;

        if (mesh.indexLists) {
            indexLists = mesh.indexLists;
            if (indexLists.length !== 1) {
                throw new DeveloperError("The mesh must have zero or one index lists.  This mesh has " + indexLists.length.toString() + " index lists.");
            }
        }

        var va = this._createVertexArrayAttributes(creationArguments);

        if (indexLists) {
            va.setIndexBuffer(this.createIndexBuffer(new Uint16Array(indexLists[0].values), bufferUsage, IndexDatatype.UNSIGNED_SHORT));
        }

        return va;
    };

    /*
     * DOC_TBA
     *
     * @memberof Context
     *
     * @see Context#pick
     */
    Context.prototype.createPickFramebuffer = function() {
        return new PickFramebuffer(this);
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     *
     * @see Context#createPickId
     */
    Context.prototype.getObjectByPickId = function(pickId) {
        return undefined;
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     *
     * @see Context#getObjectByPickId
     */
    Context.prototype.createPickId = function(object) {
        var objects = {};
        var nextRgb = {
            red : 0,
            green : 0,
            blue : 0
        };

        function rgbToObjectIndex(unnormalizedRgb) {
            // TODO:  Use alpha?
            var index = "r" + unnormalizedRgb.red + "g" + unnormalizedRgb.green + "b" + unnormalizedRgb.blue;
            return index;
        }

        function _createPickId(object) {
            // TODO:  Use alpha?
            if (++nextRgb.blue === 256) {
                nextRgb.blue = 0;

                if (++nextRgb.green === 256) {
                    nextRgb.green = 0;

                    if (++nextRgb.red === 256) {
                        throw new RuntimeError("Out of unique Rgb colors.");
                    }
                }
            }

            var pickId = {
                unnormalizedRgb : {
                    red : nextRgb.red,
                    green : nextRgb.green,
                    blue : nextRgb.blue
                },
                normalizedRgba : {
                    red : nextRgb.red / 255.0,
                    green : nextRgb.green / 255.0,
                    blue : nextRgb.blue / 255.0,
                    alpha : 1.0
                },
                destroy : function() {
                    // TODO: Remove from objects
                    return null;
                }
            };

            objects[rgbToObjectIndex(pickId.unnormalizedRgb)] = object;

            return pickId;
        }

        function _getObjectByPickId(unnormalizedRgb) {
            return objects[rgbToObjectIndex(unnormalizedRgb)];
        }

        this.createPickId = _createPickId;
        this.getObjectByPickId = _getObjectByPickId;

        return _createPickId(object);
    };

    Context.prototype.isDestroyed = function() {
        return false;
    };

    Context.prototype.destroy = function() {
        this._shaderCache = this._shaderCache.destroy();
        return destroyObject(this);
    };

    return Context;
});
/*!
 * Atmosphere code:
 *
 * Copyright (c) 2000-2005, Sean O'Neil (s_p_oneil@hotmail.com)
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * * Neither the name of the project nor the names of its contributors may be
 *   used to endorse or promote products derived from this software without
 *   specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Modifications made by Analytical Graphics, Inc.
 */
/*global define*/
define('Shaders/CentralBodyFS',[],function() {
  
  return "#ifdef SHOW_TERMINATOR\n" +
"#ifdef GL_OES_standard_derivatives\n" +
"#extension GL_OES_standard_derivatives : enable\n" +
"#endif\n" +
"#endif\n" +
"uniform sampler2D u_dayTexture;\n" +
"uniform sampler2D u_nightTexture;\n" +
"uniform sampler2D u_specularMap;\n" +
"uniform sampler2D u_cloudMap;\n" +
"uniform sampler2D u_bumpMap;\n" +
"uniform float u_dayNightBlendDelta;\n" +
"uniform vec2 u_bumpMapResoltuion;\n" +
"uniform float u_bumpMapNormalZ;\n" +
"uniform float u_nightIntensity;\n" +
"uniform float u_dayIntensity;\n" +
"varying vec3 v_positionMC;\n" +
"varying vec3 v_positionEC;\n" +
"varying vec3 v_rayleighColor;\n" +
"varying vec3 v_mieColor;\n" +
"varying vec2 v_textureCoordinates;\n" +
"bool isCloud(float cloudCover)\n" +
"{\n" +
"return cloudCover > 0.7;\n" +
"}\n" +
"vec3 dayColor(vec3 normalEC, vec2 txCoord, float cloudCover)\n" +
"{\n" +
"#ifdef SHOW_GROUND_ATMOSPHERE\n" +
"vec4 diffuseSpecularAmbientShininess = vec4(0.35, 0.5, u_dayIntensity, 10.0);\n" +
"#else\n" +
"vec4 diffuseSpecularAmbientShininess = vec4(0.75, 0.5, u_dayIntensity, 10.0);\n" +
"#endif\n" +
"#ifdef SHOW_DAY\n" +
"vec3 dayColor = texture2D(u_dayTexture, v_textureCoordinates).rgb;\n" +
"#else\n" +
"vec3 dayColor = vec3(1.0);\n" +
"#endif\n" +
"#ifdef SHOW_SPECULAR\n" +
"float specularWeight = texture2D(u_specularMap, txCoord).r;\n" +
"#else\n" +
"float specularWeight = 1.0;\n" +
"#endif\n" +
"float intensity = diffuseSpecularAmbientShininess.z;\n" +
"float diffuse = max(dot(agi_sunDirectionEC, normalEC), 0.0);\n" +
"#ifdef SHOW_BUMPS\n" +
"float center = texture2D(u_bumpMap, txCoord).r;\n" +
"float right = texture2D(u_bumpMap, txCoord + vec2(u_bumpMapResoltuion.x, 0.0)).r;\n" +
"float top = texture2D(u_bumpMap, txCoord + vec2(0.0, u_bumpMapResoltuion.y)).r;\n" +
"vec3 perturbedNormalTC = normalize(vec3(center - right, center - top, u_bumpMapNormalZ));\n" +
"vec3 perturbedNormalEC = agi_eastNorthUpToEyeCoordinates(v_positionMC, normalEC) * perturbedNormalTC;\n" +
"perturbedNormalEC = normalize(perturbedNormalEC);\n" +
"float perturbedDiffuse = max(dot(agi_sunDirectionEC, perturbedNormalEC), 0.0);\n" +
"#else\n" +
"float perturbedDiffuse = diffuse;\n" +
"#endif\n" +
"intensity += (diffuseSpecularAmbientShininess.x * perturbedDiffuse);\n" +
"if (specularWeight != 0.0)\n" +
"{\n" +
"vec3 positionToEyeEC = normalize(-v_positionEC);\n" +
"vec3 toReflectedLight = reflect(-agi_sunDirectionEC, normalEC);\n" +
"float specular = max(dot(toReflectedLight, normalize(positionToEyeEC)), 0.0);\n" +
"specular = pow(specular, diffuseSpecularAmbientShininess.w);\n" +
"specular *= specularWeight;\n" +
"intensity += (diffuseSpecularAmbientShininess.y * specular);\n" +
"}\n" +
"vec3 earthColor = vec3(intensity) * dayColor;\n" +
"vec3 cloudColor = vec3(cloudCover * diffuse);\n" +
"vec3 earthUnderCloudColor = mix(earthColor, cloudColor, cloudCover);\n" +
"#ifdef SHOW_CLOUD_SHADOWS\n" +
"if (diffuse > 0.0)\n" +
"{\n" +
"if (!isCloud(texture2D(u_cloudMap, txCoord).r))\n" +
"{\n" +
"mat3 eyeToEastNorthUp = agi_transpose(agi_eastNorthUpToEyeCoordinates(v_positionMC, normalEC));\n" +
"vec3 positionToSunTC = eyeToEastNorthUp * agi_sunDirectionEC;\n" +
"float scale = (1.0 - positionToSunTC.z) * 0.005;\n" +
"float shadowCloudCover = texture2D(u_cloudMap, txCoord + (scale * positionToSunTC.xy)).r;\n" +
"float cloudBehind = texture2D(u_cloudMap, txCoord - (scale * positionToSunTC.xy)).r;\n" +
"float viewDistance = length(v_positionEC) * 10.0E-8;\n" +
"viewDistance = min(1.0, viewDistance);\n" +
"if (isCloud(shadowCloudCover))\n" +
"{\n" +
"if(isCloud(cloudBehind))\n" +
"{\n" +
"return mix(earthUnderCloudColor, vec3(0.1), shadowCloudCover * viewDistance);\n" +
"}\n" +
"return mix(earthUnderCloudColor, vec3(0.1), viewDistance);\n" +
"}\n" +
"else\n" +
"{\n" +
"scale = scale * 1.25;\n" +
"shadowCloudCover = texture2D(u_cloudMap, txCoord + (scale * positionToSunTC.xy)).r;\n" +
"if(isCloud(shadowCloudCover))\n" +
"{\n" +
"return mix(earthUnderCloudColor, vec3(0.1), shadowCloudCover * viewDistance);\n" +
"}\n" +
"}\n" +
"}\n" +
"}\n" +
"#endif\n" +
"return earthUnderCloudColor;\n" +
"}\n" +
"vec3 nightColor(vec2 txCoord, float cloudCover)\n" +
"{\n" +
"return u_nightIntensity * texture2D(u_nightTexture, txCoord).rgb * (1.0 - cloudCover);\n" +
"}\n" +
"void main()\n" +
"{\n" +
"vec3 normalMC = normalize(agi_geodeticSurfaceNormal(v_positionMC, vec3(0.0), vec3(1.0)));\n" +
"vec3 normalEC = normalize(agi_normal * normalMC);\n" +
"float diffuse = dot(agi_sunDirectionEC, normalEC);\n" +
"#ifdef SHOW_TERMINATOR\n" +
"float absDiffuse = abs(diffuse);\n" +
"#ifdef GL_OES_standard_derivatives\n" +
"if ((absDiffuse < abs(dFdx(diffuse)) * 1.0) ||\n" +
"(absDiffuse < abs(dFdy(diffuse)) * 1.0))\n" +
"{\n" +
"gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n" +
"return;\n" +
"}\n" +
"#else\n" +
"if (absDiffuse < 0.005)\n" +
"{\n" +
"gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n" +
"return;\n" +
"}\n" +
"#endif\n" +
"#endif\n" +
"vec2 txCoord = agi_ellipsoidWgs84TextureCoordinates(normalMC);\n" +
"#ifdef SHOW_CLOUDS\n" +
"float cloudCover = texture2D(u_cloudMap, txCoord).r;\n" +
"#else\n" +
"float cloudCover = 0.0;\n" +
"#endif\n" +
"vec3 rgb;\n" +
"#ifdef SHOW_NIGHT\n" +
"if (diffuse > u_dayNightBlendDelta)\n" +
"{\n" +
"rgb = dayColor(normalEC, txCoord, cloudCover);\n" +
"}\n" +
"else if (diffuse < -u_dayNightBlendDelta)\n" +
"{\n" +
"rgb = nightColor(txCoord, cloudCover);\n" +
"}\n" +
"else\n" +
"{\n" +
"rgb = mix(\n" +
"nightColor(txCoord, cloudCover),\n" +
"dayColor(normalEC, txCoord, cloudCover),\n" +
"(diffuse + u_dayNightBlendDelta) / (2.0 * u_dayNightBlendDelta));\n" +
"}\n" +
"#else\n" +
"rgb = dayColor(normalEC, txCoord, cloudCover);\n" +
"#endif\n" +
"#ifdef SHOW_GROUND_ATMOSPHERE\n" +
"const float fExposure = 2.0;\n" +
"vec3 color = v_mieColor + rgb * v_rayleighColor;\n" +
"gl_FragColor = vec4(vec3(1.0) - exp(-fExposure * color), 1.0);\n" +
"#else\n" +
"gl_FragColor = vec4(rgb, 1.0);\n" +
"#endif\n" +
"}\n" +
"";
});

/*global define*/
define('Shaders/CentralBodyFSDepth',[],function() {
  
  return "varying vec4 positionEC;\n" +
"void main()\n" +
"{\n" +
"agi_ellipsoid ellipsoid = agi_getWgs84EllipsoidEC();\n" +
"vec3 direction = normalize(positionEC.xyz);\n" +
"agi_ray ray = agi_ray(vec3(0.0, 0.0, 0.0), direction);\n" +
"agi_raySegment intersection = agi_rayEllipsoidIntersectionInterval(ray, ellipsoid);\n" +
"if (!agi_isEmpty(intersection))\n" +
"{\n" +
"gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);\n" +
"}\n" +
"else\n" +
"{\n" +
"discard;\n" +
"}\n" +
"}\n" +
"";
});

/*global define*/
define('Shaders/CentralBodyFSFilter',[],function() {
  
  return "#define KERNEL_SIZE 7\n" +
"uniform sampler2D u_texture;\n" +
"varying vec2 v_textureCoordinates[KERNEL_SIZE];\n" +
"void main()\n" +
"{\n" +
"float kernel[KERNEL_SIZE];\n" +
"kernel[0] = 8.0;\n" +
"kernel[1] = 28.0;\n" +
"kernel[2] = 56.0;\n" +
"kernel[3] = 70.0;\n" +
"kernel[4] = 56.0;\n" +
"kernel[5] = 28.0;\n" +
"kernel[6] = 8.0;\n" +
"vec4 color = texture2D(u_texture, v_textureCoordinates[KERNEL_SIZE / 2]);\n" +
"if (color.w == 0.0) {\n" +
"vec4 startColor = texture2D(u_texture, v_textureCoordinates[0]);\n" +
"vec4 endColor = texture2D(u_texture, v_textureCoordinates[KERNEL_SIZE - 1]);\n" +
"if (startColor.w != 0.0 && endColor.w != 0.0) {\n" +
"float startWeight = kernel[0];\n" +
"float endWeight = kernel[KERNEL_SIZE - 1];\n" +
"color = startWeight * startColor + endWeight * endColor;\n" +
"float sum = startWeight + endWeight;\n" +
"for (int i = 1; i < KERNEL_SIZE - 1; i++) {\n" +
"if (i != KERNEL_SIZE / 2) {\n" +
"float weight = kernel[i];\n" +
"vec4 tex = texture2D(u_texture, v_textureCoordinates[i]);\n" +
"color += tex.a * weight * tex;\n" +
"sum += tex.a * weight;\n" +
"}\n" +
"}\n" +
"color /= sum;\n" +
"}\n" +
"}\n" +
"gl_FragColor = color;\n" +
"}\n" +
"";
});
/*!
 * Atmosphere code:
 *
 * Copyright (c) 2000-2005, Sean O'Neil (s_p_oneil@hotmail.com)
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * * Neither the name of the project nor the names of its contributors may be
 *   used to endorse or promote products derived from this software without
 *   specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Modifications made by Analytical Graphics, Inc.
 */
/*global define*/
define('Shaders/CentralBodyVS',[],function() {
  
  return "attribute vec3 position3D;\n" +
"attribute vec2 textureCoordinates;\n" +
"attribute vec2 position2D;\n" +
"uniform float u_morphTime;\n" +
"uniform vec3 v3InvWavelength;\n" +
"uniform float fCameraHeight;\n" +
"uniform float fCameraHeight2;\n" +
"uniform float fOuterRadius;\n" +
"uniform float fOuterRadius2;\n" +
"uniform float fInnerRadius;\n" +
"uniform float fInnerRadius2;\n" +
"uniform float fKrESun;\n" +
"uniform float fKmESun;\n" +
"uniform float fKr4PI;\n" +
"uniform float fKm4PI;\n" +
"uniform float fScale;\n" +
"uniform float fScaleDepth;\n" +
"uniform float fScaleOverScaleDepth;\n" +
"uniform float fMinGroundFromAtmosphereHeight;\n" +
"uniform float fstartFadeGroundFromAtmosphere;\n" +
"uniform vec3 u_center3D;\n" +
"uniform vec2 u_center2D;\n" +
"uniform mat4 u_modifiedModelView;\n" +
"varying vec3 v_positionMC;\n" +
"varying vec3 v_positionEC;\n" +
"varying vec3 v_rayleighColor;\n" +
"varying vec3 v_mieColor;\n" +
"varying vec2 v_textureCoordinates;\n" +
"struct AtmosphereColor\n" +
"{\n" +
"vec3 mie;\n" +
"vec3 rayleigh;\n" +
"};\n" +
"#ifdef SHOW_GROUND_ATMOSPHERE\n" +
"const int nSamples = 2;\n" +
"const float fSamples = 2.0;\n" +
"float scale(float fCos)\n" +
"{\n" +
"float x = 1.0 - fCos;\n" +
"return fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\n" +
"}\n" +
"AtmosphereColor computeGroundAtmosphereFromSpace(vec3 v3Pos)\n" +
"{\n" +
"vec3 v3Ray = v3Pos - agi_viewerPositionWC;\n" +
"float fFar = length(v3Ray);\n" +
"v3Ray /= fFar;\n" +
"#ifdef SHOW_GROUND_ATMOSPHERE_FROM_SPACE\n" +
"float B = 2.0 * dot(agi_viewerPositionWC, v3Ray);\n" +
"float C = fCameraHeight2 - fOuterRadius2;\n" +
"float fDet = max(0.0, B*B - 4.0 * C);\n" +
"float fNear = 0.5 * (-B - sqrt(fDet));\n" +
"vec3 v3Start = agi_viewerPositionWC + v3Ray * fNear;\n" +
"fFar -= fNear;\n" +
"float fDepth = exp((fInnerRadius - fOuterRadius) / fScaleDepth);\n" +
"#else\n" +
"vec3 v3Start = agi_viewerPositionWC;\n" +
"float fDepth = exp((fInnerRadius - fCameraHeight) / fScaleDepth);\n" +
"#endif\n" +
"float fCameraAngle = dot(-v3Ray, v3Pos) / length(v3Pos);\n" +
"float fLightAngle = dot(agi_sunDirectionWC, v3Pos) / length(v3Pos);\n" +
"float fCameraScale = scale(fCameraAngle);\n" +
"float fLightScale = scale(fLightAngle);\n" +
"float fCameraOffset = fDepth*fCameraScale;\n" +
"float fTemp = (fLightScale + fCameraScale);\n" +
"float fSampleLength = fFar / fSamples;\n" +
"float fScaledLength = fSampleLength * fScale;\n" +
"vec3 v3SampleRay = v3Ray * fSampleLength;\n" +
"vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\n" +
"vec3 v3FrontColor = vec3(0.0);\n" +
"vec3 v3Attenuate = vec3(0.0);\n" +
"for(int i=0; i<nSamples; i++)\n" +
"{\n" +
"float fHeight = length(v3SamplePoint);\n" +
"float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));\n" +
"float fScatter = fDepth*fTemp - fCameraOffset;\n" +
"v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));\n" +
"v3FrontColor += v3Attenuate * (fDepth * fScaledLength);\n" +
"v3SamplePoint += v3SampleRay;\n" +
"}\n" +
"vec3 mie = v3FrontColor * (v3InvWavelength * fKrESun + fKmESun);\n" +
"vec3 rayleigh = v3Attenuate;\n" +
"float fade = clamp((fCameraHeight - fMinGroundFromAtmosphereHeight) / fstartFadeGroundFromAtmosphere, 0.0, 1.0);\n" +
"AtmosphereColor color;\n" +
"color.mie = mix(vec3(0.0), mie,fade);\n" +
"color.rayleigh = rayleigh;\n" +
"return color;\n" +
"}\n" +
"#else\n" +
"AtmosphereColor computeGroundAtmosphereFromSpace(vec3 v3Pos)\n" +
"{\n" +
"AtmosphereColor color;\n" +
"color.mie = vec3(0.0);\n" +
"color.rayleigh = vec3(1.0);\n" +
"return color;\n" +
"}\n" +
"#endif\n" +
"void main()\n" +
"{\n" +
"vec3 position3DWC = position3D + u_center3D;\n" +
"if (u_morphTime == 1.0) {\n" +
"v_positionEC = (u_modifiedModelView * vec4(position3D, 1.0)).xyz;\n" +
"gl_Position = agi_projection * (u_modifiedModelView * vec4(position3D, 1.0));\n" +
"}\n" +
"else if (u_morphTime == 0.0) {\n" +
"v_positionEC = (agi_modelView * vec4(position3DWC, 1.0)).xyz;\n" +
"gl_Position = agi_projection * (u_modifiedModelView * vec4(0.0, position2D.x, position2D.y, 1.0));\n" +
"}\n" +
"else {\n" +
"vec3 position2DWC = vec3(0.0, position2D.x + u_center2D.x, position2D.y + u_center2D.y);\n" +
"v_positionEC = (agi_modelView * vec4(position3DWC, 1.0)).xyz;\n" +
"vec4 position = agi_columbusViewMorph(position2DWC, position3DWC, u_morphTime);\n" +
"gl_Position = agi_modelViewProjection * position;\n" +
"}\n" +
"AtmosphereColor atmosphereColor = computeGroundAtmosphereFromSpace(position3DWC);\n" +
"v_positionMC = position3DWC;\n" +
"v_mieColor = atmosphereColor.mie;\n" +
"v_rayleighColor = atmosphereColor.rayleigh;\n" +
"v_textureCoordinates = textureCoordinates;\n" +
"}\n" +
"";
});

/*global define*/
define('Shaders/CentralBodyVSDepth',[],function() {
  
  return "attribute vec4 position;\n" +
"varying vec4 positionEC;\n" +
"void main()\n" +
"{\n" +
"positionEC = agi_modelView * position;\n" +
"gl_Position = agi_projection * positionEC;\n" +
"}\n" +
"";
});

/*global define*/
define('Shaders/CentralBodyVSFilter',[],function() {
  
  return "#define KERNEL_SIZE 7\n" +
"attribute vec4 position;\n" +
"attribute vec2 textureCoordinates;\n" +
"#ifdef VERTICAL\n" +
"uniform float u_height;\n" +
"#else\n" +
"uniform float u_width;\n" +
"#endif\n" +
"varying vec2 v_textureCoordinates[KERNEL_SIZE];\n" +
"void main()\n" +
"{\n" +
"#ifdef VERTICAL\n" +
"float stepSize = 1.0 / u_height;\n" +
"#else\n" +
"float stepSize = 1.0 / u_width;\n" +
"#endif\n" +
"const int center = KERNEL_SIZE / 2;\n" +
"for (int i = 0; i < KERNEL_SIZE; ++i) {\n" +
"#ifdef VERTICAL\n" +
"vec2 offset = vec2(0.0, stepSize * float(i - center));\n" +
"#else\n" +
"vec2 offset = vec2(stepSize * float(i - center), 0.0);\n" +
"#endif\n" +
"v_textureCoordinates[i] = textureCoordinates + offset;\n" +
"}\n" +
"gl_Position = agi_viewportOrthographic * position;\n" +
"}\n" +
"";
});

/*global define*/
define('Shaders/CheckerboardMaterial',[],function() {
  
  return "uniform vec4 u_lightColor;\n" +
"uniform vec4 u_darkColor;\n" +
"uniform vec2 u_repeat;\n" +
"vec4 agi_getMaterialColor(float zDistance, vec2 st, vec3 str)\n" +
"{\n" +
"float b = mod(floor(u_repeat.s * st.s) + floor(u_repeat.t * st.t), 2.0);\n" +
"return mix(u_lightColor, u_darkColor, b);\n" +
"}\n" +
"";
});
/*global define*/
define('Scene/CheckerboardMaterial',['../Shaders/CheckerboardMaterial'], function(ShadersCheckerboardMaterial) {
    

    /**
     * DOC_TBA
     *
     * @name CheckerboardMaterial
     * @constructor
     */
    function CheckerboardMaterial(template) {
        var t = template || {};

        /**
         * DOC_TBA
         */
        this.lightColor = t.lightColor || {
            red : 1.0,
            green : 1.0,
            blue : 1.0,
            alpha : 0.5
        };

        /**
         * DOC_TBA
         */
        this.darkColor = t.darkColor || {
            red : 0.0,
            green : 0.0,
            blue : 0.0,
            alpha : 0.5
        };

        /**
         * DOC_TBA
         *
         * @type Number
         */
        this.sRepeat = t.sRepeat || 10.0;

        /**
         * DOC_TBA
         *
         * @type Number
         */
        this.tRepeat = t.tRepeat || 10.0;

        var that = this;
        this._uniforms = {
            u_lightColor : function() {
                return that.lightColor;
            },
            u_darkColor : function() {
                return that.darkColor;
            },
            u_repeat : function() {
                return {
                    x : that.sRepeat,
                    y : that.tRepeat
                };
            }
        };
    }

    CheckerboardMaterial.prototype._getShaderSource = function() {
        return "#line 0\n" + ShadersCheckerboardMaterial;
    };

    return CheckerboardMaterial;
});

/*global define*/
define('Shaders/ColorMaterial',[],function() {
  
  return "uniform vec4 u_color;\n" +
"vec4 agi_getMaterialColor(float zDistance, vec2 st, vec3 str)\n" +
"{\n" +
"return u_color;\n" +
"}\n" +
"";
});
/*global define*/
define('Scene/ColorMaterial',['../Shaders/ColorMaterial'], function(ShadersColorMaterial) {
    

    /**
     * DOC_TBA
     *
     * @name ColorMaterial
     * @constructor
     */
    function ColorMaterial(template) {
        var t = template || {};

        /**
         * DOC_TBA
         */
        this.color = t.color || {
            red : 1.0,
            green : 0.0,
            blue : 0.0,
            alpha : 0.5
        };

        var that = this;
        this._uniforms = {
            u_color : function() {
                return that.color;
            }
        };
    }

    ColorMaterial.prototype._getShaderSource = function() {
        return "#line 0\n" + ShadersColorMaterial;
    };

    return ColorMaterial;
});

/*global define*/
define('Shaders/ComplexConicSensorVolumeFS',[],function() {
  
  return "#ifdef GL_OES_standard_derivatives\n" +
"#extension GL_OES_standard_derivatives : enable\n" +
"#endif\n" +
"uniform float u_sensorRadius;\n" +
"uniform float u_outerHalfAngle;\n" +
"uniform float u_innerHalfAngle;\n" +
"uniform float u_maximumClockAngle;\n" +
"uniform float u_minimumClockAngle;\n" +
"uniform bool u_showIntersection;\n" +
"uniform vec4 u_pickColor;\n" +
"varying vec3 v_positionEC;\n" +
"varying vec3 v_sensorVertexWC;\n" +
"varying vec3 v_sensorVertexEC;\n" +
"varying vec3 v_sensorAxisEC;\n" +
"#ifndef RENDER_FOR_PICK\n" +
"vec4 getOuterColor(float sensorRadius, vec3 pointEC)\n" +
"{\n" +
"sensorErode(sensorRadius, pointEC);\n" +
"vec3 pointMC = (agi_inverseModelView * vec4(pointEC, 1.0)).xyz;\n" +
"float zDistance = pointMC.z;\n" +
"vec2 st = sensor2dTextureCoordinates(sensorRadius, pointMC);\n" +
"vec3 str = pointMC / sensorRadius;\n" +
"return agi_getOuterMaterialColor(zDistance, st, str);\n" +
"}\n" +
"vec4 getInnerColor(float sensorRadius, vec3 pointEC)\n" +
"{\n" +
"sensorErode(sensorRadius, pointEC);\n" +
"vec3 pointMC = (agi_inverseModelView * vec4(pointEC, 1.0)).xyz;\n" +
"float zDistance = pointMC.z;\n" +
"vec2 st = sensor2dTextureCoordinates(sensorRadius, pointMC);\n" +
"vec3 str = pointMC / sensorRadius;\n" +
"return agi_getInnerMaterialColor(zDistance, st, str);\n" +
"}\n" +
"vec4 getCapColor(float sensorRadius, vec3 pointEC)\n" +
"{\n" +
"sensorErode(sensorRadius, pointEC);\n" +
"vec3 pointMC = (agi_inverseModelView * vec4(pointEC, 1.0)).xyz;\n" +
"float zDistance = pointMC.z;\n" +
"vec2 st = sensor2dTextureCoordinates(sensorRadius, pointMC);\n" +
"vec3 str = pointMC / sensorRadius;\n" +
"return agi_getCapMaterialColor(zDistance, st, str);\n" +
"}\n" +
"vec4 getSilhouetteColor(float sensorRadius, vec3 pointEC)\n" +
"{\n" +
"sensorErode(sensorRadius, pointEC);\n" +
"vec3 pointMC = (agi_inverseModelView * vec4(pointEC, 1.0)).xyz;\n" +
"float zDistance = pointMC.z;\n" +
"vec2 st = sensor2dTextureCoordinates(sensorRadius, pointMC);\n" +
"vec3 str = pointMC / sensorRadius;\n" +
"return agi_getSilhouetteMaterialColor(zDistance, st, str);\n" +
"}\n" +
"#endif\n" +
"bool agi_isOnOrNear(float d, agi_raySegment interval, float epsilon)\n" +
"{\n" +
"bool answer = (agi_equalsEpsilon(d, interval.start, epsilon) || agi_equalsEpsilon(d, interval.stop, epsilon));\n" +
"return answer;\n" +
"}\n" +
"bool agi_isOnOrNear(float d, agi_raySegmentCollection coneIntervals, float epsilon)\n" +
"{\n" +
"bool answer = (coneIntervals.count > 0 && (agi_isOnOrNear(d, coneIntervals.intervals[0], epsilon)))\n" +
"|| (coneIntervals.count > 1 && (agi_isOnOrNear(d, coneIntervals.intervals[1], epsilon)));\n" +
"return answer;\n" +
"}\n" +
"bool agi_isOnOrNearSensor(float d, agi_raySegmentCollection outerIntervals, agi_raySegmentCollection innerIntervals, float epsilon)\n" +
"{\n" +
"bool answer = agi_isOnOrNear(d, outerIntervals, epsilon) || agi_isOnOrNear(d, innerIntervals, epsilon);\n" +
"return answer;\n" +
"}\n" +
"bool ellipsoidSensorIntersection(agi_raySegment sphereInterval,\n" +
"agi_raySegmentCollection outerIntervals, agi_raySegmentCollection innerIntervals,\n" +
"agi_raySegmentCollection clockIntervals,\n" +
"agi_raySegment ellipsoidInterval, agi_raySegment silhouetteHalfspaceInterval, agi_raySegmentCollection solid)\n" +
"{\n" +
"if (agi_isEmpty(ellipsoidInterval))\n" +
"{\n" +
"return false;\n" +
"}\n" +
"float t = ellipsoidInterval.start;\n" +
"#ifdef GL_OES_standard_derivatives\n" +
"float epsilon = max(abs(dFdx(t)), abs(dFdy(t)));\n" +
"#else\n" +
"float epsilon = t / 500.0;\n" +
"#endif\n" +
"float width = 2.0;\n" +
"epsilon *= width;\n" +
"if (solid.count > 0)\n" +
"{\n" +
"float d = solid.intervals[0].start;\n" +
"if (d == ellipsoidInterval.start\n" +
"&& (agi_isOnOrNear(d, silhouetteHalfspaceInterval, epsilon)\n" +
"|| agi_isOnOrNear(d, sphereInterval, epsilon)\n" +
"|| agi_isOnOrNear(d, clockIntervals, epsilon)\n" +
"|| agi_isOnOrNearSensor(d, outerIntervals, innerIntervals, epsilon))) return true;\n" +
"d = solid.intervals[0].stop;\n" +
"if (d == ellipsoidInterval.start\n" +
"&& (agi_isOnOrNear(d, silhouetteHalfspaceInterval, epsilon)\n" +
"|| agi_isOnOrNear(d, sphereInterval, epsilon)\n" +
"|| agi_isOnOrNear(d, clockIntervals, epsilon)\n" +
"|| agi_isOnOrNearSensor(d, outerIntervals, innerIntervals, epsilon))) return true;\n" +
"if (solid.count > 1)\n" +
"{\n" +
"d = solid.intervals[1].start;\n" +
"if (d == ellipsoidInterval.start\n" +
"&& (agi_isOnOrNear(d, silhouetteHalfspaceInterval, epsilon)\n" +
"|| agi_isOnOrNear(d, sphereInterval, epsilon)\n" +
"|| agi_isOnOrNear(d, clockIntervals, epsilon)\n" +
"|| agi_isOnOrNearSensor(d, outerIntervals, innerIntervals, epsilon))) return true;\n" +
"d = solid.intervals[1].stop;\n" +
"if (d == ellipsoidInterval.start\n" +
"&& (agi_isOnOrNear(d, silhouetteHalfspaceInterval, epsilon)\n" +
"|| agi_isOnOrNear(d, sphereInterval, epsilon)\n" +
"|| agi_isOnOrNear(d, clockIntervals, epsilon)\n" +
"|| agi_isOnOrNearSensor(d, outerIntervals, innerIntervals, epsilon))) return true;\n" +
"}\n" +
"return false;\n" +
"}\n" +
"else\n" +
"{\n" +
"false;\n" +
"}\n" +
"}\n" +
"vec4 shade(\n" +
"agi_ray ray,\n" +
"float nearestRayTime,\n" +
"agi_sphere sphere,\n" +
"agi_cone outerCone,\n" +
"agi_cone innerCone,\n" +
"agi_halfspace maxClock,\n" +
"agi_halfspace minClock,\n" +
"agi_ellipsoidSilhouetteCone silhouetteCone,\n" +
"agi_ellipsoidSilhouetteHalfspace silhouetteHalfspace,\n" +
"agi_raySegment sphereInterval,\n" +
"agi_raySegmentCollection outerConeInterval,\n" +
"agi_raySegmentCollection innerConeInterval,\n" +
"agi_raySegment maxClockInterval,\n" +
"agi_raySegment minClockInterval,\n" +
"agi_raySegmentCollection clockIntervals,\n" +
"agi_raySegment silhouetteConeInterval,\n" +
"agi_raySegment silhouetteHalfspaceInterval,\n" +
"agi_raySegment ellipsoidInterval,\n" +
"agi_raySegmentCollection intervals)\n" +
"{\n" +
"#ifdef RENDER_FOR_PICK\n" +
"return u_pickColor;\n" +
"#else\n" +
"vec3 nearestPoint = agi_pointAlongRay(ray, nearestRayTime);\n" +
"if (u_showIntersection && ellipsoidSensorIntersection(sphereInterval,\n" +
"outerConeInterval, innerConeInterval, clockIntervals,\n" +
"ellipsoidInterval, silhouetteHalfspaceInterval, intervals))\n" +
"{\n" +
"return getIntersectionColor(u_sensorRadius, nearestPoint);\n" +
"}\n" +
"vec3 positionToEyeEC = -ray.direction;\n" +
"vec3 agi_sunDirectionEC = agi_sunDirectionEC;\n" +
"for (int i = 0; i < agi_raySegmentCollectionCapacity; ++i)\n" +
"{\n" +
"if (i < outerConeInterval.count &&\n" +
"((nearestRayTime == outerConeInterval.intervals[i].start) ||\n" +
"(nearestRayTime == outerConeInterval.intervals[i].stop)))\n" +
"{\n" +
"vec4 color = getOuterColor(u_sensorRadius, nearestPoint);\n" +
"vec3 normal = agi_coneNormal(outerCone, nearestPoint);\n" +
"normal = mix(normal, -normal, step(normal.z, 0.0));\n" +
"float intensity = agi_twoSidedLightIntensity(normal, agi_sunDirectionEC, positionToEyeEC);\n" +
"return vec4(color.rgb * intensity, color.a);\n" +
"}\n" +
"}\n" +
"for (int i = 0; i < agi_raySegmentCollectionCapacity; ++i)\n" +
"{\n" +
"if (i < innerConeInterval.count &&\n" +
"((nearestRayTime == innerConeInterval.intervals[i].start) ||\n" +
"(nearestRayTime == innerConeInterval.intervals[i].stop)))\n" +
"{\n" +
"vec4 color = getInnerColor(u_sensorRadius, nearestPoint);\n" +
"vec3 normal = -agi_coneNormal(innerCone, nearestPoint);\n" +
"normal = mix(normal, -normal, step(normal.z, 0.0));\n" +
"float intensity = agi_twoSidedLightIntensity(normal, agi_sunDirectionEC, positionToEyeEC);\n" +
"return vec4(color.rgb * intensity, color.a);\n" +
"}\n" +
"}\n" +
"if ((nearestRayTime == sphereInterval.start) ||\n" +
"(nearestRayTime == sphereInterval.stop))\n" +
"{\n" +
"vec4 color = getCapColor(u_sensorRadius, nearestPoint);\n" +
"vec3 normal = agi_sphereNormal(sphere, nearestPoint);\n" +
"normal = mix(normal, -normal, step(normal.z, 0.0));\n" +
"float intensity = agi_twoSidedLightIntensity(normal, agi_sunDirectionEC, positionToEyeEC);\n" +
"return vec4(color.rgb * intensity, color.a);\n" +
"}\n" +
"if ((nearestRayTime == maxClockInterval.start) ||\n" +
"(nearestRayTime == maxClockInterval.stop))\n" +
"{\n" +
"vec4 color = getOuterColor(u_sensorRadius, nearestPoint);\n" +
"vec3 normal = maxClock.normal;\n" +
"normal = mix(normal, -normal, step(normal.z, 0.0));\n" +
"float intensity = agi_lightIntensity(normal, agi_sunDirectionEC, positionToEyeEC);\n" +
"return vec4(color.rgb * intensity, color.a);\n" +
"}\n" +
"if ((nearestRayTime == minClockInterval.start) ||\n" +
"(nearestRayTime == minClockInterval.stop))\n" +
"{\n" +
"vec4 color = getOuterColor(u_sensorRadius, nearestPoint);\n" +
"vec3 normal = minClock.normal;\n" +
"normal = mix(normal, -normal, step(normal.z, 0.0));\n" +
"float intensity = agi_lightIntensity(normal, agi_sunDirectionEC, positionToEyeEC);\n" +
"return vec4(color.rgb * intensity, color.a);\n" +
"}\n" +
"if ((nearestRayTime == silhouetteConeInterval.start) ||\n" +
"(nearestRayTime == silhouetteConeInterval.stop))\n" +
"{\n" +
"vec4 color = getSilhouetteColor(u_sensorRadius, nearestPoint);\n" +
"vec3 normal = agi_ellipsoidSilhouetteConeNormal(silhouetteCone, nearestPoint);\n" +
"normal = mix(normal, -normal, step(normal.z, 0.0));\n" +
"float intensity = agi_twoSidedLightIntensity(normal, agi_sunDirectionEC, positionToEyeEC);\n" +
"return vec4(color.rgb * intensity, color.a);\n" +
"}\n" +
"return vec4(1.0, 0.0, 0.0, 1.0);\n" +
"#endif\n" +
"}\n" +
"vec4 shade(\n" +
"agi_ray ray,\n" +
"float nearestRayTime,\n" +
"agi_sphere sphere,\n" +
"agi_cone outerCone,\n" +
"agi_cone innerCone,\n" +
"agi_halfspace maxClock,\n" +
"agi_halfspace minClock,\n" +
"agi_raySegment sphereInterval,\n" +
"agi_raySegmentCollection outerConeInterval,\n" +
"agi_raySegmentCollection innerConeInterval,\n" +
"agi_raySegment maxClockInterval,\n" +
"agi_raySegment minClockInterval,\n" +
"agi_raySegmentCollection intervals)\n" +
"{\n" +
"#ifdef RENDER_FOR_PICK\n" +
"return u_pickColor;\n" +
"#else\n" +
"vec3 nearestPoint = agi_pointAlongRay(ray, nearestRayTime);\n" +
"vec3 positionToEyeEC = -ray.direction;\n" +
"for (int i = 0; i < agi_raySegmentCollectionCapacity; ++i)\n" +
"{\n" +
"if (i < outerConeInterval.count &&\n" +
"((nearestRayTime == outerConeInterval.intervals[i].start) ||\n" +
"(nearestRayTime == outerConeInterval.intervals[i].stop)))\n" +
"{\n" +
"vec4 color = getOuterColor(u_sensorRadius, nearestPoint);\n" +
"vec3 normal = agi_coneNormal(outerCone, nearestPoint);\n" +
"normal = mix(normal, -normal, step(normal.z, 0.0));\n" +
"float intensity = agi_twoSidedLightIntensity(normal, agi_sunDirectionEC, positionToEyeEC);\n" +
"return vec4(color.rgb * intensity, color.a);\n" +
"}\n" +
"}\n" +
"for (int i = 0; i < agi_raySegmentCollectionCapacity; ++i)\n" +
"{\n" +
"if (i < innerConeInterval.count &&\n" +
"((nearestRayTime == innerConeInterval.intervals[i].start) ||\n" +
"(nearestRayTime == innerConeInterval.intervals[i].stop)))\n" +
"{\n" +
"vec4 color = getInnerColor(u_sensorRadius, nearestPoint);\n" +
"vec3 normal = -agi_coneNormal(innerCone, nearestPoint);\n" +
"normal = mix(normal, -normal, step(normal.z, 0.0));\n" +
"float intensity = agi_twoSidedLightIntensity(normal, agi_sunDirectionEC, positionToEyeEC);\n" +
"return vec4(color.rgb * intensity, color.a);\n" +
"}\n" +
"}\n" +
"if ((nearestRayTime == sphereInterval.start) ||\n" +
"(nearestRayTime == sphereInterval.stop))\n" +
"{\n" +
"vec4 color = getCapColor(u_sensorRadius, nearestPoint);\n" +
"vec3 normal = agi_sphereNormal(sphere, nearestPoint);\n" +
"normal = mix(normal, -normal, step(normal.z, 0.0));\n" +
"float intensity = agi_twoSidedLightIntensity(normal, agi_sunDirectionEC, positionToEyeEC);\n" +
"return vec4(color.rgb * intensity, color.a);\n" +
"}\n" +
"if ((nearestRayTime == maxClockInterval.start) ||\n" +
"(nearestRayTime == maxClockInterval.stop))\n" +
"{\n" +
"vec4 color = getOuterColor(u_sensorRadius, nearestPoint);\n" +
"vec3 normal = maxClock.normal;\n" +
"normal = mix(normal, -normal, step(normal.z, 0.0));\n" +
"float intensity = agi_lightIntensity(normal, agi_sunDirectionEC, positionToEyeEC);\n" +
"return vec4(color.rgb * intensity, color.a);\n" +
"}\n" +
"if ((nearestRayTime == minClockInterval.start) ||\n" +
"(nearestRayTime == minClockInterval.stop))\n" +
"{\n" +
"vec4 color = getOuterColor(u_sensorRadius, nearestPoint);\n" +
"vec3 normal = minClock.normal;\n" +
"normal = mix(normal, -normal, step(normal.z, 0.0));\n" +
"float intensity = agi_lightIntensity(normal, agi_sunDirectionEC, positionToEyeEC);\n" +
"return vec4(color.rgb * intensity, color.a);\n" +
"}\n" +
"return vec4(1.0, 0.0, 0.0, 1.0);\n" +
"#endif\n" +
"}\n" +
"void main()\n" +
"{\n" +
"agi_ray ray = agi_ray(vec3(0.0), normalize(v_positionEC));\n" +
"agi_sphere sphere = agi_sphere(v_sensorVertexEC, u_sensorRadius);\n" +
"agi_raySegment sphereInterval = agi_raySphereIntersectionInterval(ray, sphere);\n" +
"if (agi_isEmpty(sphereInterval))\n" +
"{\n" +
"discard;\n" +
"}\n" +
"vec3 coneAxisEC = normalize(v_sensorAxisEC);\n" +
"agi_cone outerCone = agi_coneNew(v_sensorVertexEC, coneAxisEC, u_outerHalfAngle);\n" +
"agi_raySegmentCollection outerConeInterval = agi_rayConeIntersectionInterval(ray, outerCone);\n" +
"if (outerConeInterval.count == 0)\n" +
"{\n" +
"discard;\n" +
"}\n" +
"agi_cone innerCone = agi_coneNew(v_sensorVertexEC, coneAxisEC, u_innerHalfAngle);\n" +
"agi_raySegmentCollection innerConeInterval = agi_rayConeIntersectionInterval(ray, innerCone);\n" +
"agi_raySegmentCollection difference = (innerConeInterval.count == 0) ? outerConeInterval : agi_subtraction(outerConeInterval, innerConeInterval);\n" +
"if (difference.count == 0)\n" +
"{\n" +
"discard;\n" +
"}\n" +
"agi_raySegmentCollection capped = agi_intersection(difference, sphereInterval);\n" +
"if (capped.count == 0)\n" +
"{\n" +
"discard;\n" +
"}\n" +
"vec3 maxNormal = normalize((agi_modelView * vec4(-sin(u_maximumClockAngle), cos(u_maximumClockAngle), 0.0, 0.0)).xyz);\n" +
"agi_halfspace maxClock = agi_halfspace(v_sensorVertexEC, maxNormal);\n" +
"agi_raySegment maxClockInterval = agi_rayHalfspaceIntersectionInterval(ray, maxClock);\n" +
"vec3 minNormal = normalize((agi_modelView * vec4(sin(u_minimumClockAngle), -cos(u_minimumClockAngle), 0.0, 0.0)).xyz);\n" +
"agi_halfspace minClock = agi_halfspace(v_sensorVertexEC, minNormal);\n" +
"agi_raySegment minClockInterval = agi_rayHalfspaceIntersectionInterval(ray, minClock);\n" +
"agi_raySegmentCollection clockIntervals = ((u_maximumClockAngle - u_minimumClockAngle) > agi_pi)\n" +
"? (agi_isEmpty(maxClockInterval)\n" +
"? (agi_isEmpty(minClockInterval) ? agi_raySegmentCollectionNew() : agi_raySegmentCollectionNew(minClockInterval))\n" +
": (agi_isEmpty(minClockInterval) ? agi_raySegmentCollectionNew(maxClockInterval) : agi_union(maxClockInterval, minClockInterval)))\n" +
": ((agi_isEmpty(maxClockInterval) || agi_isEmpty(minClockInterval)) ? agi_raySegmentCollectionNew() : agi_raySegmentCollectionNew(agi_intersection(maxClockInterval, minClockInterval)));\n" +
"agi_raySegmentCollection sensor = (clockIntervals.count == 0) ? agi_raySegmentCollectionNew() : agi_intersection(capped, clockIntervals);\n" +
"if (sensor.count == 0)\n" +
"{\n" +
"discard;\n" +
"}\n" +
"agi_ellipsoid ellipsoid = agi_getWgs84EllipsoidEC();\n" +
"agi_ellipsoidSilhouetteCone silhouetteCone = agi_ellipsoidSilhouetteConeNew(ellipsoid, v_sensorVertexEC);\n" +
"agi_raySegment silhouetteConeInterval = agi_rayEllipsoidSilhouetteConeIntersectionInterval(ray, silhouetteCone);\n" +
"if (agi_isEmpty(silhouetteConeInterval))\n" +
"{\n" +
"gl_FragColor = shade(ray, sensor.intervals[0].start,\n" +
"sphere, outerCone, innerCone, maxClock, minClock,\n" +
"sphereInterval, outerConeInterval, innerConeInterval, maxClockInterval, minClockInterval,\n" +
"sensor);\n" +
"}\n" +
"else\n" +
"{\n" +
"agi_ellipsoidSilhouetteHalfspace silhouetteHalfspace = agi_ellipsoidSilhouetteHalfspaceNew(ellipsoid, v_sensorVertexEC);\n" +
"agi_raySegment silhouetteHalfspaceInterval = agi_rayEllipsoidSilhouetteHalfspaceIntersectionInterval(ray, silhouetteHalfspace);\n" +
"agi_raySegment temp = (agi_isEmpty(silhouetteHalfspaceInterval)) ? agi_emptyRaySegment : agi_intersection(silhouetteConeInterval, silhouetteHalfspaceInterval);\n" +
"agi_raySegmentCollection stuff = (agi_isEmpty(temp)) ? sensor : agi_subtraction(sensor, temp);\n" +
"if (stuff.count == 0)\n" +
"{\n" +
"discard;\n" +
"}\n" +
"agi_raySegment ellipsoidInterval = agi_rayEllipsoidIntersectionInterval(ray, ellipsoid);\n" +
"agi_raySegmentCollection result = (agi_isEmpty(ellipsoidInterval)) ? stuff : agi_subtraction(stuff, ellipsoidInterval);\n" +
"if ((result.count == 0)\n" +
"|| (!agi_isEmpty(ellipsoidInterval) && (result.intervals[0].start > ellipsoidInterval.start)))\n" +
"{\n" +
"discard;\n" +
"}\n" +
"gl_FragColor = shade(ray, result.intervals[0].start,\n" +
"sphere, outerCone, innerCone, maxClock, minClock,\n" +
"silhouetteCone, silhouetteHalfspace,\n" +
"sphereInterval, outerConeInterval, innerConeInterval, maxClockInterval, minClockInterval, clockIntervals,\n" +
"silhouetteConeInterval, silhouetteHalfspaceInterval, ellipsoidInterval,\n" +
"result);\n" +
"}\n" +
"}\n" +
"";
});

/*global define*/
define('Shaders/ComplexConicSensorVolumeVS',[],function() {
  
  return "attribute vec4 position;\n" +
"varying vec3 v_positionEC;\n" +
"varying vec3 v_sensorVertexWC;\n" +
"varying vec3 v_sensorVertexEC;\n" +
"varying vec3 v_sensorAxisEC;\n" +
"void main()\n" +
"{\n" +
"gl_Position = agi_modelViewInfiniteProjection * position;\n" +
"v_positionEC = (agi_modelView * position).xyz;\n" +
"vec4 sensorVertexMC = vec4(0.0, 0.0, 0.0, 1.0);\n" +
"v_sensorVertexWC = (agi_model * sensorVertexMC).xyz;\n" +
"v_sensorVertexEC = (agi_modelView * sensorVertexMC).xyz;\n" +
"v_sensorAxisEC = agi_normal * vec3(0.0, 0.0, 1.0);\n" +
"}\n" +
"";
});

/*global define*/
define('Shaders/ConstructiveSolidGeometry',[],function() {
  
  return "float _agi_addWithCancellationCheck(float left, float right, float tolerance)\n" +
"{\n" +
"float difference = left + right;\n" +
"if ((sign(left) != sign(right)) && abs(difference / max(abs(left), abs(right))) < tolerance)\n" +
"{\n" +
"return 0.0;\n" +
"}\n" +
"else\n" +
"{\n" +
"return difference;\n" +
"}\n" +
"}\n" +
"struct agi_quadraticRoots\n" +
"{\n" +
"int numberOfRoots;\n" +
"float root0;\n" +
"float root1;\n" +
"};\n" +
"agi_quadraticRoots agi_quadraticRealPolynomialRealRoots(float a, float b, float c)\n" +
"{\n" +
"const float tolerance = agi_epsilon7;\n" +
"if (a == 0.0)\n" +
"{\n" +
"if (b == 0.0)\n" +
"{\n" +
"agi_quadraticRoots r = agi_quadraticRoots(0, 0.0, 0.0);\n" +
"return r;\n" +
"}\n" +
"else\n" +
"{\n" +
"agi_quadraticRoots r = agi_quadraticRoots(1, -c / b, 0.0);\n" +
"return r;\n" +
"}\n" +
"}\n" +
"else if (b == 0.0)\n" +
"{\n" +
"if (c == 0.0)\n" +
"{\n" +
"agi_quadraticRoots r = agi_quadraticRoots(2, 0.0, 0.0);\n" +
"return r;\n" +
"}\n" +
"else\n" +
"{\n" +
"float cMagnitude = abs(c);\n" +
"float aMagnitude = abs(a);\n" +
"if ((cMagnitude < aMagnitude) && (cMagnitude / aMagnitude < tolerance))\n" +
"{\n" +
"agi_quadraticRoots r = agi_quadraticRoots(2, 0.0, 0.0);\n" +
"return r;\n" +
"}\n" +
"else if ((cMagnitude > aMagnitude) && (aMagnitude / cMagnitude < tolerance))\n" +
"{\n" +
"agi_quadraticRoots r = agi_quadraticRoots(0, 0.0, 0.0);\n" +
"return r;\n" +
"}\n" +
"else\n" +
"{\n" +
"float ratio = -c / a;\n" +
"if (ratio < 0.0)\n" +
"{\n" +
"agi_quadraticRoots r = agi_quadraticRoots(0, 0.0, 0.0);\n" +
"return r;\n" +
"}\n" +
"else\n" +
"{\n" +
"float root = sqrt(ratio);\n" +
"agi_quadraticRoots r = agi_quadraticRoots(2, -root, root);\n" +
"return r;\n" +
"}\n" +
"}\n" +
"}\n" +
"}\n" +
"else if (c == 0.0)\n" +
"{\n" +
"float ratio = -b / a;\n" +
"if (ratio < 0.0)\n" +
"{\n" +
"agi_quadraticRoots r = agi_quadraticRoots(2, ratio, 0.0);\n" +
"return r;\n" +
"}\n" +
"else\n" +
"{\n" +
"agi_quadraticRoots r = agi_quadraticRoots(2, 0.0, ratio);\n" +
"return r;\n" +
"}\n" +
"}\n" +
"else\n" +
"{\n" +
"float b2 = b * b;\n" +
"float four_ac = 4.0 * a * c;\n" +
"float radicand = _agi_addWithCancellationCheck(b2, -four_ac, tolerance);\n" +
"if (radicand < 0.0)\n" +
"{\n" +
"agi_quadraticRoots r = agi_quadraticRoots(0, 0.0, 0.0);\n" +
"return r;\n" +
"}\n" +
"else\n" +
"{\n" +
"float q = -0.5 * _agi_addWithCancellationCheck(b, sign(b) * sqrt(radicand), tolerance);\n" +
"if (b > 0.0)\n" +
"{\n" +
"agi_quadraticRoots r = agi_quadraticRoots(2, q / a, c / q);\n" +
"return r;\n" +
"}\n" +
"else\n" +
"{\n" +
"agi_quadraticRoots r = agi_quadraticRoots(2, c / q, q / a);\n" +
"return r;\n" +
"}\n" +
"}\n" +
"}\n" +
"}\n" +
"struct agi_sphere\n" +
"{\n" +
"vec3 center;\n" +
"float radius;\n" +
"};\n" +
"agi_raySegment agi_raySphereIntersectionInterval(agi_ray ray, agi_sphere sphere)\n" +
"{\n" +
"vec3 l = sphere.center - ray.origin;\n" +
"float s = dot(l, ray.direction);\n" +
"float l2 = dot(l, l);\n" +
"float r2 = sphere.radius * sphere.radius;\n" +
"if ((s < 0.0)\n" +
"&& (l2 > r2))\n" +
"{\n" +
"return agi_emptyRaySegment;\n" +
"}\n" +
"float s2 = s * s;\n" +
"float m2 = l2 - s2;\n" +
"if (m2 > r2)\n" +
"{\n" +
"return agi_emptyRaySegment;\n" +
"}\n" +
"float q = sqrt(r2 - m2);\n" +
"if (agi_equalsEpsilon(q, 0.0))\n" +
"{\n" +
"return agi_raySegment(s, s);\n" +
"}\n" +
"if (l2 > r2)\n" +
"{\n" +
"agi_raySegment i = agi_raySegment(s - q, s + q);\n" +
"return i;\n" +
"}\n" +
"else if (l2 < r2)\n" +
"{\n" +
"agi_raySegment i = agi_raySegment(0.0, s + q);\n" +
"return i;\n" +
"}\n" +
"else if (s > 0.0)\n" +
"{\n" +
"agi_raySegment i = agi_raySegment(0.0, s + q);\n" +
"return i;\n" +
"}\n" +
"else\n" +
"{\n" +
"return agi_emptyRaySegment;\n" +
"}\n" +
"}\n" +
"vec3 agi_sphereNormal(agi_sphere sphere, vec3 pointOnSphere)\n" +
"{\n" +
"return normalize(pointOnSphere - sphere.center);\n" +
"}\n" +
"struct agi_ellipsoid\n" +
"{\n" +
"vec3 center;\n" +
"vec3 radii;\n" +
"vec3 inverseRadii;\n" +
"vec3 inverseRadiiSquared;\n" +
"};\n" +
"agi_ellipsoid agi_ellipsoidNew(vec3 center, vec3 radii)\n" +
"{\n" +
"vec3 inverseRadii = vec3(1.0 / radii.x, 1.0 / radii.y, 1.0 / radii.z);\n" +
"vec3 inverseRadiiSquared = inverseRadii * inverseRadii;\n" +
"agi_ellipsoid temp = agi_ellipsoid(center, radii, inverseRadii, inverseRadiiSquared);\n" +
"return temp;\n" +
"}\n" +
"bool agi_ellipsoidContainsPoint(agi_ellipsoid ellipsoid, vec3 point)\n" +
"{\n" +
"vec3 scaled = ellipsoid.inverseRadii * (agi_inverseView * vec4(point, 1.0)).xyz;\n" +
"return (dot(scaled, scaled) <= 1.0);\n" +
"}\n" +
"vec3 agi_ellipsoidNormal(agi_ellipsoid ellipsoid, vec3 pointOnEllipsoid)\n" +
"{\n" +
"vec3 n = ellipsoid.inverseRadiiSquared * (agi_inverseView * vec4(pointOnEllipsoid, 1.0)).xyz;\n" +
"vec3 rotated = (agi_view * vec4(n, 0.0)).xyz;\n" +
"return normalize(rotated);\n" +
"}\n" +
"agi_raySegment agi_rayEllipsoidIntersectionInterval(agi_ray ray, agi_ellipsoid ellipsoid)\n" +
"{\n" +
"vec3 q = ellipsoid.inverseRadii * (agi_inverseView * vec4(ray.origin, 1.0)).xyz;\n" +
"vec3 w = ellipsoid.inverseRadii * (agi_inverseView * vec4(ray.direction, 0.0)).xyz;\n" +
"float q2 = dot(q, q);\n" +
"float qw = dot(q, w);\n" +
"if (q2 > 1.0)\n" +
"{\n" +
"if (qw >= 0.0)\n" +
"{\n" +
"return agi_emptyRaySegment;\n" +
"}\n" +
"else\n" +
"{\n" +
"float qw2 = qw * qw;\n" +
"float difference = q2 - 1.0;\n" +
"float w2 = dot(w, w);\n" +
"float product = w2 * difference;\n" +
"if (qw2 < product)\n" +
"{\n" +
"return agi_emptyRaySegment;\n" +
"}\n" +
"else if (qw2 > product)\n" +
"{\n" +
"float discriminant = qw * qw - product;\n" +
"float temp = -qw + sqrt(discriminant);\n" +
"float root0 = temp / w2;\n" +
"float root1 = difference / temp;\n" +
"if (root0 < root1)\n" +
"{\n" +
"agi_raySegment i = agi_raySegment(root0, root1);\n" +
"return i;\n" +
"}\n" +
"else\n" +
"{\n" +
"agi_raySegment i = agi_raySegment(root1, root0);\n" +
"return i;\n" +
"}\n" +
"}\n" +
"else\n" +
"{\n" +
"float root = sqrt(difference / w2);\n" +
"agi_raySegment i = agi_raySegment(root, root);\n" +
"return i;\n" +
"}\n" +
"}\n" +
"}\n" +
"else if (q2 < 1.0)\n" +
"{\n" +
"float difference = q2 - 1.0;\n" +
"float w2 = dot(w, w);\n" +
"float product = w2 * difference;\n" +
"if (qw < 0.0)\n" +
"{\n" +
"float discriminant = qw * qw - product;\n" +
"float temp = qw - sqrt(discriminant);\n" +
"agi_raySegment i = agi_raySegment(0.0, difference / temp);\n" +
"return i;\n" +
"}\n" +
"else if (qw > 0.0)\n" +
"{\n" +
"float discriminant = qw * qw - product;\n" +
"float temp = qw + sqrt(discriminant);\n" +
"agi_raySegment i = agi_raySegment(0.0, temp / w2);\n" +
"return i;\n" +
"}\n" +
"else\n" +
"{\n" +
"float temp = sqrt(-product);\n" +
"agi_raySegment i = agi_raySegment(0.0, temp / w2);\n" +
"return i;\n" +
"}\n" +
"}\n" +
"else\n" +
"{\n" +
"if (qw < 0.0)\n" +
"{\n" +
"float w2 = dot(w, w);\n" +
"agi_raySegment i = agi_raySegment(0.0, -qw / w2);\n" +
"return i;\n" +
"}\n" +
"else\n" +
"{\n" +
"return agi_emptyRaySegment;\n" +
"}\n" +
"}\n" +
"}\n" +
"agi_ellipsoid agi_getWgs84EllipsoidEC()\n" +
"{\n" +
"return agi_ellipsoidNew(\n" +
"vec3(agi_view[3].x, agi_view[3].y, agi_view[3].z),\n" +
"vec3(6378137.0, 6378137.0, 6356752.314245));\n" +
"}\n" +
"struct agi_cone\n" +
"{\n" +
"vec3 vertex;\n" +
"vec3 axis;\n" +
"float halfAperture;\n" +
"float cosineOfHalfAperture;\n" +
"float cosineSquaredOfHalfAperture;\n" +
"float sineOfHalfAperture;\n" +
"float sineSquaredOfHalfAperture;\n" +
"mat3 intersectionMatrix;\n" +
"};\n" +
"agi_cone agi_coneNew(vec3 vertex, vec3 axis, float halfAperture)\n" +
"{\n" +
"float cosineOfHalfAperture = cos(halfAperture);\n" +
"float cosineSquaredOfHalfAperture = cosineOfHalfAperture * cosineOfHalfAperture;\n" +
"float sineOfHalfAperture = sin(halfAperture);\n" +
"float sineSquaredOfHalfAperture = sineOfHalfAperture * sineOfHalfAperture;\n" +
"float x2 = axis.x * axis.x;\n" +
"float y2 = axis.y * axis.y;\n" +
"float z2 = axis.z * axis.z;\n" +
"float xy = axis.x * axis.y;\n" +
"float yz = axis.y * axis.z;\n" +
"float zx = axis.z * axis.x;\n" +
"mat3 intersectionMatrix = mat3(\n" +
"cosineSquaredOfHalfAperture - x2, -xy,                              -zx,\n" +
"-xy,                              cosineSquaredOfHalfAperture - y2, -yz,\n" +
"-zx,                              -yz,                              cosineSquaredOfHalfAperture - z2);\n" +
"agi_cone temp = agi_cone(vertex, axis, halfAperture,\n" +
"cosineOfHalfAperture, cosineSquaredOfHalfAperture,\n" +
"sineOfHalfAperture, sineSquaredOfHalfAperture, intersectionMatrix);\n" +
"return temp;\n" +
"}\n" +
"bool agi_coneContainsPoint(agi_cone cone, vec3 point)\n" +
"{\n" +
"vec3 n = normalize(point - cone.vertex);\n" +
"return (dot(n, cone.axis) >= cone.cosineOfHalfAperture);\n" +
"}\n" +
"bool _agi_rayIntersectsReflectedCone(agi_ray ray, agi_cone cone, float time, float cosine)\n" +
"{\n" +
"vec3 s = ray.origin + (time * ray.direction) - cone.vertex;\n" +
"vec3 sUnit = normalize(s);\n" +
"float c = dot(sUnit, cone.axis);\n" +
"return (sign(c) != sign(cosine));\n" +
"}\n" +
"agi_raySegmentCollection agi_rayConeIntersectionInterval(agi_ray ray, agi_cone cone)\n" +
"{\n" +
"vec3 temp = ray.origin - cone.vertex;\n" +
"float t2 = dot(temp, temp);\n" +
"float cosineNu = dot(ray.direction, cone.axis);\n" +
"if (t2 == 0.0)\n" +
"{\n" +
"if (cosineNu >= cone.cosineOfHalfAperture)\n" +
"{\n" +
"return agi_raySegmentCollectionNew(agi_fullRaySegment);\n" +
"}\n" +
"else\n" +
"{\n" +
"return agi_raySegmentCollectionNew();\n" +
"}\n" +
"}\n" +
"else\n" +
"{\n" +
"float projection = dot(normalize(temp), cone.axis);\n" +
"if (projection == cone.cosineOfHalfAperture)\n" +
"{\n" +
"vec3 u = ray.direction;\n" +
"mat3 crossProductMatrix = mat3(0.0, -u.z, u.y,\n" +
"u.z, 0.0, -u.x,\n" +
"-u.y, u.x, 0.0);\n" +
"if (length(crossProductMatrix * temp) == 0.0)\n" +
"{\n" +
"if (dot(temp, u) > 0.0)\n" +
"{\n" +
"return agi_raySegmentCollectionNew(agi_fullRaySegment);\n" +
"}\n" +
"else\n" +
"{\n" +
"agi_raySegment i = agi_raySegment(0.0, length(temp));\n" +
"return agi_raySegmentCollectionNew(i);\n" +
"}\n" +
"}\n" +
"else\n" +
"{\n" +
"return agi_raySegmentCollectionNew();\n" +
"}\n" +
"}\n" +
"else\n" +
"{\n" +
"vec3 t = normalize(temp);\n" +
"float cosineAlpha2 = cone.cosineOfHalfAperture * cone.cosineOfHalfAperture;\n" +
"float cosineTau = dot(t, cone.axis);\n" +
"float cosineDelta = dot(t, ray.direction);\n" +
"float cosineNu2 = cosineNu * cosineNu;\n" +
"float cosineTau2 = cosineTau * cosineTau;\n" +
"float stuff = cosineTau * cosineNu;\n" +
"float positiveTerm = cosineNu2 + cosineTau2;\n" +
"float negativeTerm = (cosineDelta * cosineDelta - 1.0) * cosineAlpha2;\n" +
"float signedTerm = -2.0 * stuff * cosineDelta;\n" +
"if (signedTerm > 0.0)\n" +
"{\n" +
"positiveTerm = positiveTerm + signedTerm;\n" +
"}\n" +
"else if (signedTerm < 0.0)\n" +
"{\n" +
"negativeTerm = negativeTerm + signedTerm;\n" +
"}\n" +
"float d = 4.0 * cosineAlpha2 * (positiveTerm + negativeTerm);\n" +
"if (d < 0.0)\n" +
"{\n" +
"if (cone.cosineOfHalfAperture < 0.0)\n" +
"{\n" +
"return agi_raySegmentCollectionNew(agi_fullRaySegment);\n" +
"}\n" +
"else\n" +
"{\n" +
"return agi_raySegmentCollectionNew();\n" +
"}\n" +
"}\n" +
"else if (d > 0.0)\n" +
"{\n" +
"float a = cosineNu2 - cosineAlpha2;\n" +
"float c = cosineTau2 - cosineAlpha2;\n" +
"float b = 2.0 * (stuff - cosineDelta * cosineAlpha2);\n" +
"float s = (b == 0.0) ? 1.0 : sign(b);\n" +
"float q = -(b + s * sqrt(d)) / 2.0;\n" +
"float first = q / a;\n" +
"float second = c / q;\n" +
"if (second < first)\n" +
"{\n" +
"float thing = first;\n" +
"first = second;\n" +
"second = thing;\n" +
"}\n" +
"bool firstTest = (first >= 0.0) && !(sign(dot(t + first * ray.direction, cone.axis)) == -sign(cone.cosineOfHalfAperture));\n" +
"bool secondTest = (second >= 0.0) && !(sign(dot(t + second * ray.direction, cone.axis)) == -sign(cone.cosineOfHalfAperture));\n" +
"float m = sqrt(t2);\n" +
"if (cosineTau > cone.cosineOfHalfAperture)\n" +
"{\n" +
"if (firstTest && secondTest)\n" +
"{\n" +
"agi_raySegment one = agi_raySegment(0.0, m * first);\n" +
"agi_raySegment two = agi_raySegment(m * second, agi_infinity);\n" +
"return agi_raySegmentCollectionNew(one, two);\n" +
"}\n" +
"else if (firstTest)\n" +
"{\n" +
"agi_raySegment i = agi_raySegment(0.0, m * first);\n" +
"return agi_raySegmentCollectionNew(i);\n" +
"}\n" +
"else if (secondTest)\n" +
"{\n" +
"agi_raySegment i = agi_raySegment(0.0, m * second);\n" +
"return agi_raySegmentCollectionNew(i);\n" +
"}\n" +
"else\n" +
"{\n" +
"return agi_raySegmentCollectionNew(agi_fullRaySegment);\n" +
"}\n" +
"}\n" +
"else\n" +
"{\n" +
"if (firstTest && secondTest)\n" +
"{\n" +
"agi_raySegment i = agi_raySegment(m * first, m * second);\n" +
"return agi_raySegmentCollectionNew(i);\n" +
"}\n" +
"else if (firstTest)\n" +
"{\n" +
"agi_raySegment i = agi_raySegment(m * first, agi_infinity);\n" +
"return agi_raySegmentCollectionNew(i);\n" +
"}\n" +
"else if (secondTest)\n" +
"{\n" +
"agi_raySegment i = agi_raySegment(m * second, agi_infinity);\n" +
"return agi_raySegmentCollectionNew(i);\n" +
"}\n" +
"else\n" +
"{\n" +
"return agi_raySegmentCollectionNew();\n" +
"}\n" +
"}\n" +
"}\n" +
"else\n" +
"{\n" +
"if (cone.cosineOfHalfAperture == 0.0)\n" +
"{\n" +
"if (cosineTau >= 0.0)\n" +
"{\n" +
"if (cosineNu >= 0.0)\n" +
"{\n" +
"return agi_raySegmentCollectionNew(agi_fullRaySegment);\n" +
"}\n" +
"else\n" +
"{\n" +
"agi_raySegment i = agi_raySegment(0.0, -sqrt(t2) * cosineTau / cosineNu);\n" +
"return agi_raySegmentCollectionNew(i);\n" +
"}\n" +
"}\n" +
"else\n" +
"{\n" +
"if (cosineNu <= 0.0)\n" +
"{\n" +
"return agi_raySegmentCollectionNew();\n" +
"}\n" +
"else\n" +
"{\n" +
"agi_raySegment i = agi_raySegment(-sqrt(t2) * cosineTau / cosineNu, agi_infinity);\n" +
"return agi_raySegmentCollectionNew(i);\n" +
"}\n" +
"}\n" +
"}\n" +
"else\n" +
"{\n" +
"float a = cosineNu2 - cosineAlpha2;\n" +
"float c = cosineTau2 - cosineAlpha2;\n" +
"float b = 2.0 * (stuff - cosineDelta * cosineAlpha2);\n" +
"float root = (a == 0.0) ? -sign(b) * agi_infinity : (-sign(b) / sign(a)) * sqrt(c / a);\n" +
"bool rootTest = (root >= 0.0) && !(sign(dot(t + root * ray.direction, cone.axis)) == -sign(cone.cosineOfHalfAperture));\n" +
"float m = sqrt(t2);\n" +
"if (cosineTau > cone.cosineOfHalfAperture)\n" +
"{\n" +
"if (rootTest)\n" +
"{\n" +
"agi_raySegment i = agi_raySegment(0.0, m * root);\n" +
"return agi_raySegmentCollectionNew(i);\n" +
"}\n" +
"else\n" +
"{\n" +
"return agi_raySegmentCollectionNew(agi_fullRaySegment);\n" +
"}\n" +
"}\n" +
"else\n" +
"{\n" +
"if (rootTest)\n" +
"{\n" +
"if (c < 0.0)\n" +
"{\n" +
"float thing = m * root;\n" +
"agi_raySegment i = agi_raySegment(thing, thing);\n" +
"return agi_raySegmentCollectionNew(i);\n" +
"}\n" +
"else\n" +
"{\n" +
"float thing = m * root;\n" +
"agi_raySegment i = agi_raySegment(thing, agi_infinity);\n" +
"return agi_raySegmentCollectionNew(i);\n" +
"}\n" +
"}\n" +
"else\n" +
"{\n" +
"return agi_raySegmentCollectionNew();\n" +
"}\n" +
"}\n" +
"}\n" +
"}\n" +
"}\n" +
"}\n" +
"}\n" +
"vec3 agi_coneNormal(agi_cone cone, vec3 pointOnCone)\n" +
"{\n" +
"vec3 s = pointOnCone - cone.vertex;\n" +
"vec3 sUnit = normalize(s);\n" +
"return normalize((cone.cosineOfHalfAperture * sUnit - cone.axis) / cone.sineOfHalfAperture);\n" +
"}\n" +
"struct agi_ellipsoidSilhouetteCone\n" +
"{\n" +
"agi_ellipsoid ellipsoid;\n" +
"vec3 pointOutsideEllipsoid;\n" +
"agi_cone coneInScaledSpace;\n" +
"};\n" +
"vec3 agi_ellipsoidSilhouetteConeNormal(agi_ellipsoidSilhouetteCone cone, vec3 pointOnCone)\n" +
"{\n" +
"vec3 pointOnScaledCone = cone.ellipsoid.inverseRadii * (agi_inverseView * vec4(pointOnCone, 1.0)).xyz;\n" +
"vec3 scaledNormal = agi_coneNormal(cone.coneInScaledSpace, pointOnScaledCone);\n" +
"vec3 temp = -normalize((agi_view * vec4(cone.ellipsoid.radii * scaledNormal, 0.0)).xyz);\n" +
"return temp;\n" +
"}\n" +
"agi_ellipsoidSilhouetteCone agi_ellipsoidSilhouetteConeNew(agi_ellipsoid ellipsoid, vec3 pointOutsideEllipsoid)\n" +
"{\n" +
"vec3 q = ellipsoid.inverseRadii * (agi_inverseView * vec4(pointOutsideEllipsoid, 1.0)).xyz;\n" +
"vec3 axis = -normalize(q);\n" +
"float q2 = dot(q, q);\n" +
"float sineSquaredOfHalfAperture = 1.0 / q2;\n" +
"float sineOfHalfAperture = sqrt(sineSquaredOfHalfAperture);\n" +
"float cosineSquaredOfHalfAperture = 1.0 - sineSquaredOfHalfAperture;\n" +
"float cosineOfHalfAperture = sqrt(cosineSquaredOfHalfAperture);\n" +
"float halfAperture = atan(sineOfHalfAperture / cosineOfHalfAperture);\n" +
"float x2 = axis.x * axis.x;\n" +
"float y2 = axis.y * axis.y;\n" +
"float z2 = axis.z * axis.z;\n" +
"float xy = axis.x * axis.y;\n" +
"float yz = axis.y * axis.z;\n" +
"float zx = axis.z * axis.x;\n" +
"mat3 intersectionMatrix = mat3(\n" +
"cosineSquaredOfHalfAperture - x2, -xy,                              -zx,\n" +
"-xy,                              cosineSquaredOfHalfAperture - y2, -yz,\n" +
"-zx,                              -yz,                              cosineSquaredOfHalfAperture - z2);\n" +
"agi_cone coneInScaledSpace = agi_cone(q, axis, halfAperture,\n" +
"cosineOfHalfAperture, cosineSquaredOfHalfAperture,\n" +
"sineOfHalfAperture, sineSquaredOfHalfAperture, intersectionMatrix);\n" +
"agi_ellipsoidSilhouetteCone temp = agi_ellipsoidSilhouetteCone(ellipsoid, pointOutsideEllipsoid, coneInScaledSpace);\n" +
"return temp;\n" +
"}\n" +
"agi_raySegment agi_rayEllipsoidSilhouetteConeIntersectionInterval(agi_ray ray, agi_ellipsoidSilhouetteCone cone)\n" +
"{\n" +
"vec3 origin = cone.ellipsoid.inverseRadii * (agi_inverseView * vec4(ray.origin, 1.0)).xyz;\n" +
"vec3 direction = normalize(cone.ellipsoid.inverseRadii * (agi_inverseView * vec4(ray.direction, 0.0)).xyz);\n" +
"agi_ray rayInScaledSpace = agi_ray(origin, direction);\n" +
"agi_raySegmentCollection collection = agi_rayConeIntersectionInterval(rayInScaledSpace, cone.coneInScaledSpace);\n" +
"if (collection.count == 0)\n" +
"{\n" +
"return agi_emptyRaySegment;\n" +
"}\n" +
"else\n" +
"{\n" +
"agi_raySegment interval = collection.intervals[0];\n" +
"float start = interval.start;\n" +
"if (start != 0.0)\n" +
"{\n" +
"vec3 temp = (agi_view * vec4(cone.ellipsoid.radii * agi_pointAlongRay(rayInScaledSpace, start), 1.0)).xyz;\n" +
"start = dot(temp, ray.direction);\n" +
"}\n" +
"float stop = interval.stop;\n" +
"if (stop != agi_infinity)\n" +
"{\n" +
"vec3 temp = (agi_view * vec4(cone.ellipsoid.radii * agi_pointAlongRay(rayInScaledSpace, stop), 1.0)).xyz;\n" +
"stop = dot(temp, ray.direction);\n" +
"}\n" +
"return agi_raySegment(start, stop);\n" +
"}\n" +
"}\n" +
"struct agi_halfspace\n" +
"{\n" +
"vec3 center;\n" +
"vec3 normal;\n" +
"};\n" +
"agi_raySegment agi_rayHalfspaceIntersectionInterval(agi_ray ray, agi_halfspace halfspace)\n" +
"{\n" +
"float numerator = dot(halfspace.center - ray.origin, halfspace.normal);\n" +
"float denominator = dot(ray.direction, halfspace.normal);\n" +
"if (numerator > 0.0)\n" +
"{\n" +
"if (denominator > 0.0)\n" +
"{\n" +
"return agi_raySegment(0.0, numerator / denominator);\n" +
"}\n" +
"else\n" +
"{\n" +
"return agi_fullRaySegment;\n" +
"}\n" +
"}\n" +
"else if (numerator < 0.0)\n" +
"{\n" +
"if (denominator < 0.0 )\n" +
"{\n" +
"return agi_raySegment(numerator / denominator, agi_infinity);\n" +
"}\n" +
"else\n" +
"{\n" +
"return agi_emptyRaySegment;\n" +
"}\n" +
"}\n" +
"else\n" +
"{\n" +
"if (denominator < 0.0 )\n" +
"{\n" +
"return agi_fullRaySegment;\n" +
"}\n" +
"else\n" +
"{\n" +
"return agi_emptyRaySegment;\n" +
"}\n" +
"}\n" +
"}\n" +
"struct agi_ellipsoidSilhouetteHalfspace\n" +
"{\n" +
"agi_ellipsoid ellipsoid;\n" +
"vec3 pointOutsideEllipsoid;\n" +
"agi_halfspace halfspaceInScaledSpace;\n" +
"};\n" +
"agi_ellipsoidSilhouetteHalfspace agi_ellipsoidSilhouetteHalfspaceNew(agi_ellipsoid ellipsoid, vec3 pointOutsideEllipsoid)\n" +
"{\n" +
"vec3 q = ellipsoid.inverseRadii * (agi_inverseView * vec4(pointOutsideEllipsoid, 1.0)).xyz;\n" +
"float magnitude = 1.0 / length(q);\n" +
"vec3 normal = normalize(q);\n" +
"vec3 center = magnitude * normal;\n" +
"agi_halfspace halfspaceInScaledSpace = agi_halfspace(center, normal);\n" +
"agi_ellipsoidSilhouetteHalfspace temp = agi_ellipsoidSilhouetteHalfspace(ellipsoid, pointOutsideEllipsoid, halfspaceInScaledSpace);\n" +
"return temp;\n" +
"}\n" +
"agi_raySegment agi_rayEllipsoidSilhouetteHalfspaceIntersectionInterval(agi_ray ray, agi_ellipsoidSilhouetteHalfspace halfspace)\n" +
"{\n" +
"vec3 origin = halfspace.ellipsoid.inverseRadii * (agi_inverseView * vec4(ray.origin, 1.0)).xyz;\n" +
"vec3 direction = halfspace.ellipsoid.inverseRadii * (agi_inverseView * vec4(ray.direction, 0.0)).xyz;\n" +
"agi_ray rayInScaledSpace = agi_ray(origin, direction);\n" +
"agi_raySegment interval = agi_rayHalfspaceIntersectionInterval(rayInScaledSpace, halfspace.halfspaceInScaledSpace);\n" +
"if (agi_isEmpty(interval))\n" +
"{\n" +
"return interval;\n" +
"}\n" +
"else\n" +
"{\n" +
"float start = interval.start;\n" +
"if (start != 0.0)\n" +
"{\n" +
"vec3 temp = (agi_view * vec4(halfspace.ellipsoid.radii * agi_pointAlongRay(rayInScaledSpace, start), 1.0)).xyz;\n" +
"start = dot(temp, ray.direction);\n" +
"}\n" +
"float stop = interval.stop;\n" +
"if (stop != agi_infinity)\n" +
"{\n" +
"vec3 temp = (agi_view * vec4(halfspace.ellipsoid.radii * agi_pointAlongRay(rayInScaledSpace, stop), 1.0)).xyz;\n" +
"stop = dot(temp, ray.direction);\n" +
"}\n" +
"return agi_raySegment(start, stop);\n" +
"}\n" +
"}\n" +
"";
});

/*global define*/
define('Shaders/CustomSensorVolumeFS',[],function() {
  
  return "#ifdef GL_OES_standard_derivatives\n" +
"#extension GL_OES_standard_derivatives : enable\n" +
"#endif\n" +
"uniform bool u_showIntersection;\n" +
"uniform float u_sensorRadius;\n" +
"uniform vec4 u_pickColor;\n" +
"varying vec3 v_positionWC;\n" +
"varying vec3 v_positionEC;\n" +
"varying vec3 v_normalEC;\n" +
"varying vec3 v_sensorVertexWC;\n" +
"varying vec3 v_sensorVertexEC;\n" +
"#ifndef RENDER_FOR_PICK\n" +
"vec4 getColor(float sensorRadius, vec3 pointEC)\n" +
"{\n" +
"sensorErode(sensorRadius, pointEC);\n" +
"vec3 pointMC = (agi_inverseModelView * vec4(pointEC, 1.0)).xyz;\n" +
"float zDistance = pointMC.z;\n" +
"vec2 st = sensor2dTextureCoordinates(sensorRadius, pointMC);\n" +
"vec3 str = pointMC / sensorRadius;\n" +
"return agi_getMaterialColor(zDistance, st, str);\n" +
"}\n" +
"#endif\n" +
"bool ellipsoidSensorIntersection(agi_raySegment ellipsoidInterval)\n" +
"{\n" +
"if (agi_isEmpty(ellipsoidInterval))\n" +
"{\n" +
"return false;\n" +
"}\n" +
"float t = ellipsoidInterval.start;\n" +
"#ifdef GL_OES_standard_derivatives\n" +
"float epsilon = max(abs(dFdx(t)), abs(dFdy(t)));\n" +
"if (epsilon >= ellipsoidInterval.start)\n" +
"{\n" +
"return false;\n" +
"}\n" +
"#else\n" +
"float epsilon = t / 500.0;\n" +
"#endif\n" +
"float width = 2.0;\n" +
"epsilon *= width;\n" +
"return agi_equalsEpsilon(t, length(v_positionEC), epsilon);\n" +
"}\n" +
"vec4 shade(agi_raySegment ellipsoidInterval)\n" +
"{\n" +
"#ifdef RENDER_FOR_PICK\n" +
"return u_pickColor;\n" +
"#else\n" +
"if (u_showIntersection && ellipsoidSensorIntersection(ellipsoidInterval))\n" +
"{\n" +
"return getIntersectionColor(u_sensorRadius, v_positionEC);\n" +
"}\n" +
"vec3 positionToEyeEC = normalize(-v_positionEC);\n" +
"vec3 normal = normalize(v_normalEC);\n" +
"normal = mix(normal, -normal, step(normal.z, 0.0));\n" +
"vec4 color = getColor(u_sensorRadius, v_positionEC);\n" +
"float intensity = agi_twoSidedLightIntensity(normal, agi_sunDirectionEC, positionToEyeEC);\n" +
"return vec4(color.rgb * intensity, color.a);\n" +
"#endif\n" +
"}\n" +
"bool agi_pointInEllipsoid(agi_ellipsoid ellipsoid, vec3 point)\n" +
"{\n" +
"return (((point.x * point.x) / (ellipsoid.radii.x * ellipsoid.radii.x)) +\n" +
"((point.y * point.y) / (ellipsoid.radii.y * ellipsoid.radii.y)) +\n" +
"((point.z * point.z) / (ellipsoid.radii.z * ellipsoid.radii.z)) < 1.0);\n" +
"}\n" +
"void main()\n" +
"{\n" +
"agi_ellipsoid ellipsoid = agi_getWgs84EllipsoidEC();\n" +
"if (agi_pointInEllipsoid(ellipsoid, v_positionWC))\n" +
"{\n" +
"discard;\n" +
"}\n" +
"if (inSensorShadow(v_sensorVertexWC, ellipsoid, v_positionEC))\n" +
"{\n" +
"discard;\n" +
"}\n" +
"if (distance(v_positionEC, v_sensorVertexEC) > u_sensorRadius)\n" +
"{\n" +
"discard;\n" +
"}\n" +
"agi_ray ray = agi_ray(vec3(0.0), normalize(v_positionEC));\n" +
"agi_raySegment ellipsoidInterval = agi_rayEllipsoidIntersectionInterval(ray, ellipsoid);\n" +
"gl_FragColor = shade(ellipsoidInterval);\n" +
"}\n" +
"";
});

/*global define*/
define('Shaders/CustomSensorVolumeVS',[],function() {
  
  return "attribute vec4 position;\n" +
"attribute vec3 normal;\n" +
"varying vec3 v_positionWC;\n" +
"varying vec3 v_positionEC;\n" +
"varying vec3 v_normalEC;\n" +
"varying vec3 v_sensorVertexWC;\n" +
"varying vec3 v_sensorVertexEC;\n" +
"void main()\n" +
"{\n" +
"gl_Position = agi_modelViewProjection * position;\n" +
"v_positionWC = (agi_model * position).xyz;\n" +
"v_positionEC = (agi_modelView * position).xyz;\n" +
"v_normalEC = agi_normal * normal;\n" +
"vec4 sensorVertexMC = vec4(0.0, 0.0, 0.0, 1.0);\n" +
"v_sensorVertexWC = (agi_model * sensorVertexMC).xyz;\n" +
"v_sensorVertexEC = (agi_modelView * sensorVertexMC).xyz;\n" +
"}\n" +
"";
});

/*global define*/
define('Shaders/DistanceIntervalMaterial',[],function() {
  
  return "uniform vec4 u_colors[NUMBER_OF_DISTANCES];\n" +
"uniform float u_distances[NUMBER_OF_DISTANCES];\n" +
"vec4 agi_getMaterialColor(float zDistance, vec2 st, vec3 str)\n" +
"{\n" +
"vec4 color = vec4(0.0);\n" +
"for (int i = 0; i < NUMBER_OF_DISTANCES; ++i)\n" +
"{\n" +
"if (zDistance < u_distances[i])\n" +
"{\n" +
"color = u_colors[i];\n" +
"break;\n" +
"}\n" +
"}\n" +
"return color;\n" +
"}\n" +
"";
});
/*global define*/
define('Scene/DistanceIntervalMaterial',['../Shaders/DistanceIntervalMaterial'], function(ShadersDistanceIntervalMaterial) {
    

    /**
     * DOC_TBA
     *
     * @name DistanceIntervalMaterial
     * @constructor
     */
    function DistanceIntervalMaterial(template) {
        var t = template || {};

        /**
         * DOC_TBA
         */
        this.intervals = t.intervals || [];

        // TODO: Expose get/set - can change distance/color, but not number of intervals
        var distances = [];
        var colors = [];

        for ( var i = 0; i < this.intervals.length; ++i) {
            distances.push(this.intervals[i].distance);
            colors.push(this.intervals[i].color);
        }

        this._uniforms = {
            u_distances : function() {
                return distances;
            },
            u_colors : function() {
                return colors;
            }
        };
    }

    DistanceIntervalMaterial.prototype._getShaderSource = function() {
        return "#define NUMBER_OF_DISTANCES " + this.intervals.length.toString() + "\n" +
               "#line 0\n" + ShadersDistanceIntervalMaterial;
    };

    return DistanceIntervalMaterial;
});

/*global define*/
define('Shaders/DotMaterial',[],function() {
  
  return "uniform vec4 u_lightColor;\n" +
"uniform vec4 u_darkColor;\n" +
"uniform vec2 u_repeat;\n" +
"vec4 agi_getMaterialColor(float zDistance, vec2 st, vec3 str)\n" +
"{\n" +
"float b = smoothstep(0.3, 0.32, length(fract(u_repeat * st) - 0.5));\n" +
"return mix(u_lightColor, u_darkColor, b);\n" +
"}\n" +
"";
});
/*global define*/
define('Scene/DotMaterial',['../Shaders/DotMaterial'], function(ShadersDotMaterial) {
    

    /**
     * DOC_TBA
     *
     * @name DotMaterial
     * @constructor
     */
    function DotMaterial(template) {
        var t = template || {};

        /**
         * DOC_TBA
         */
        this.lightColor = t.lightColor || {
            red : 1.0,
            green : 1.0,
            blue : 1.0,
            alpha : 0.5
        };

        /**
         * DOC_TBA
         */
        this.darkColor = t.darkColor || {
            red : 0.0,
            green : 0.0,
            blue : 1.0,
            alpha : 0.5
        };

        /**
         * DOC_TBA
         *
         * @type Number
         */
        this.sRepeat = t.sRepeat || 10.0;

        /**
         * DOC_TBA
         *
         * @type Number
         */
        this.tRepeat = t.tRepeat || 10.0;

        var that = this;
        this._uniforms = {
            u_lightColor : function() {
                return that.lightColor;
            },
            u_darkColor : function() {
                return that.darkColor;
            },
            u_repeat : function() {
                return {
                    x : that.sRepeat,
                    y : that.tRepeat
                };
            }
        };
    }

    DotMaterial.prototype._getShaderSource = function() {
        return "#line 0\n" + ShadersDotMaterial;
    };

    return DotMaterial;
});

/*global define*/
define('Shaders/FacetMaterial',[],function() {
  
  return "uniform vec4 u_lightColor;\n" +
"uniform vec4 u_darkColor;\n" +
"uniform float u_repeat;\n" +
"vec4 agi_getMaterialColor(float zDistance, vec2 st, vec3 str)\n" +
"{\n" +
"vec2 F = agi_cellular(st * u_repeat);\n" +
"float t = 0.1 + (F.y - F.x);\n" +
"return mix(u_lightColor, u_darkColor, t);\n" +
"}\n" +
"";
});

/*global define*/
define('Shaders/HorizontalStripeMaterial',[],function() {
  
  return "uniform vec4 u_lightColor;\n" +
"uniform vec4 u_darkColor;\n" +
"uniform float u_offset;\n" +
"uniform float u_repeat;\n" +
"vec4 agi_getMaterialColor(float zDistance, vec2 st, vec3 str)\n" +
"{\n" +
"const float fuzz = 0.1;\n" +
"const float width = 0.5;\n" +
"float scaled = fract((st.t - u_offset) * (u_repeat * 0.5));\n" +
"float frac1 = clamp(scaled / fuzz, 0.0, 1.0);\n" +
"float frac2 = clamp((scaled - width) / fuzz, 0.0, 1.0);\n" +
"frac1 = frac1 * (1.0 - frac2);\n" +
"frac1 = frac1 * frac1 * (3.0 - (2.0 * frac1));\n" +
"return mix(u_lightColor, u_darkColor, frac1);\n" +
"}\n" +
"";
});
/*global define*/
define('Scene/HorizontalStripeMaterial',['../Shaders/HorizontalStripeMaterial'], function(ShadersHorizontalStripeMaterial) {
    

    /**
     * DOC_TBA
     *
     * @name HorizontalStripeMaterial
     * @constructor
     */
    function HorizontalStripeMaterial(template) {
        var t = template || {};

        /**
         * DOC_TBA
         */
        this.lightColor = t.lightColor || {
            red : 1.0,
            green : 1.0,
            blue : 1.0,
            alpha : 0.5
        };

        /**
         * DOC_TBA
         */
        this.darkColor = t.darkColor || {
            red : 0.0,
            green : 0.0,
            blue : 1.0,
            alpha : 0.5
        };

        /**
         * DOC_TBA
         *
         * @type Number
         */
        this.offset = t.offset || 0.0;

        /**
         * DOC_TBA
         *
         * @type Number
         */
        this.repeat = t.repeat || 10.0;

        var that = this;
        this._uniforms = {
            u_lightColor : function() {
                return that.lightColor;
            },
            u_darkColor : function() {
                return that.darkColor;
            },
            u_offset : function() {
                return that.offset;
            },
            u_repeat : function() {
                return that.repeat;
            }
        };
    }

    HorizontalStripeMaterial.prototype._getShaderSource = function() {
        return "#line 0\n" + ShadersHorizontalStripeMaterial;
    };

    return HorizontalStripeMaterial;
});
/*!
 * Description : Array and textureless GLSL 2D/3D/4D simplex 
 *               noise functions.
 *      Author : Ian McEwan, Ashima Arts.
 *  Maintainer : ijm
 *     Lastmod : 20110822 (ijm)
 *     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
 *               Distributed under the MIT License. See LICENSE file.
 *               https://github.com/ashima/webgl-noise
 */
/*!
 * Cellular noise ("Worley noise") in 2D in GLSL.
 * Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.
 * This code is released under the conditions of the MIT license.
 * See LICENSE file for details.
 */
/*global define*/
define('Shaders/Noise',[],function() {
  
  return "#ifndef AGI_NOISE\n" +
"#define AGI_NOISE 1\n" +
"vec4 _agi_mod289(vec4 x)\n" +
"{\n" +
"return x - floor(x * (1.0 / 289.0)) * 289.0;\n" +
"}\n" +
"vec3 _agi_mod289(vec3 x)\n" +
"{\n" +
"return x - floor(x * (1.0 / 289.0)) * 289.0;\n" +
"}\n" +
"vec2 _agi_mod289(vec2 x)\n" +
"{\n" +
"return x - floor(x * (1.0 / 289.0)) * 289.0;\n" +
"}\n" +
"float _agi_mod289(float x)\n" +
"{\n" +
"return x - floor(x * (1.0 / 289.0)) * 289.0;\n" +
"}\n" +
"vec4 _agi_permute(vec4 x)\n" +
"{\n" +
"return _agi_mod289(((x*34.0)+1.0)*x);\n" +
"}\n" +
"vec3 _agi_permute(vec3 x)\n" +
"{\n" +
"return _agi_mod289(((x*34.0)+1.0)*x);\n" +
"}\n" +
"float _agi_permute(float x)\n" +
"{\n" +
"return _agi_mod289(((x*34.0)+1.0)*x);\n" +
"}\n" +
"vec4 _agi_taylorInvSqrt(vec4 r)\n" +
"{\n" +
"return 1.79284291400159 - 0.85373472095314 * r;\n" +
"}\n" +
"float _agi_taylorInvSqrt(float r)\n" +
"{\n" +
"return 1.79284291400159 - 0.85373472095314 * r;\n" +
"}\n" +
"vec4 _agi_grad4(float j, vec4 ip)\n" +
"{\n" +
"const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n" +
"vec4 p,s;\n" +
"p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n" +
"p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n" +
"s = vec4(lessThan(p, vec4(0.0)));\n" +
"p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n" +
"return p;\n" +
"}\n" +
"float agi_snoise(vec2 v)\n" +
"{\n" +
"const vec4 C = vec4(0.211324865405187,\n" +
"0.366025403784439,\n" +
"-0.577350269189626,\n" +
"0.024390243902439);\n" +
"vec2 i  = floor(v + dot(v, C.yy) );\n" +
"vec2 x0 = v -   i + dot(i, C.xx);\n" +
"vec2 i1;\n" +
"i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n" +
"vec4 x12 = x0.xyxy + C.xxzz;\n" +
"x12.xy -= i1;\n" +
"i = _agi_mod289(i);\n" +
"vec3 p = _agi_permute( _agi_permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));\n" +
"vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n" +
"m = m*m ;\n" +
"m = m*m ;\n" +
"vec3 x = 2.0 * fract(p * C.www) - 1.0;\n" +
"vec3 h = abs(x) - 0.5;\n" +
"vec3 ox = floor(x + 0.5);\n" +
"vec3 a0 = x - ox;\n" +
"m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n" +
"vec3 g;\n" +
"g.x  = a0.x  * x0.x  + h.x  * x0.y;\n" +
"g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n" +
"return 130.0 * dot(m, g);\n" +
"}\n" +
"float agi_snoise(vec3 v)\n" +
"{\n" +
"const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n" +
"const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n" +
"vec3 i  = floor(v + dot(v, C.yyy) );\n" +
"vec3 x0 =   v - i + dot(i, C.xxx) ;\n" +
"vec3 g = step(x0.yzx, x0.xyz);\n" +
"vec3 l = 1.0 - g;\n" +
"vec3 i1 = min( g.xyz, l.zxy );\n" +
"vec3 i2 = max( g.xyz, l.zxy );\n" +
"vec3 x1 = x0 - i1 + C.xxx;\n" +
"vec3 x2 = x0 - i2 + C.yyy;\n" +
"vec3 x3 = x0 - D.yyy;\n" +
"i = _agi_mod289(i);\n" +
"vec4 p = _agi_permute( _agi_permute( _agi_permute(\n" +
"i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n" +
"+ i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n" +
"+ i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n" +
"float n_ = 0.142857142857;\n" +
"vec3  ns = n_ * D.wyz - D.xzx;\n" +
"vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n" +
"vec4 x_ = floor(j * ns.z);\n" +
"vec4 y_ = floor(j - 7.0 * x_ );\n" +
"vec4 x = x_ *ns.x + ns.yyyy;\n" +
"vec4 y = y_ *ns.x + ns.yyyy;\n" +
"vec4 h = 1.0 - abs(x) - abs(y);\n" +
"vec4 b0 = vec4( x.xy, y.xy );\n" +
"vec4 b1 = vec4( x.zw, y.zw );\n" +
"vec4 s0 = floor(b0)*2.0 + 1.0;\n" +
"vec4 s1 = floor(b1)*2.0 + 1.0;\n" +
"vec4 sh = -step(h, vec4(0.0));\n" +
"vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n" +
"vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n" +
"vec3 p0 = vec3(a0.xy,h.x);\n" +
"vec3 p1 = vec3(a0.zw,h.y);\n" +
"vec3 p2 = vec3(a1.xy,h.z);\n" +
"vec3 p3 = vec3(a1.zw,h.w);\n" +
"vec4 norm = _agi_taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n" +
"p0 *= norm.x;\n" +
"p1 *= norm.y;\n" +
"p2 *= norm.z;\n" +
"p3 *= norm.w;\n" +
"vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n" +
"m = m * m;\n" +
"return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n" +
"dot(p2,x2), dot(p3,x3) ) );\n" +
"}\n" +
"float agi_snoise(vec4 v)\n" +
"{\n" +
"const vec4  C = vec4( 0.138196601125011,\n" +
"0.276393202250021,\n" +
"0.414589803375032,\n" +
"-0.447213595499958);\n" +
"#define F4 0.309016994374947451\n" +
"vec4 i  = floor(v + dot(v, vec4(F4)) );\n" +
"vec4 x0 = v -   i + dot(i, C.xxxx);\n" +
"vec4 i0;\n" +
"vec3 isX = step( x0.yzw, x0.xxx );\n" +
"vec3 isYZ = step( x0.zww, x0.yyz );\n" +
"i0.x = isX.x + isX.y + isX.z;\n" +
"i0.yzw = 1.0 - isX;\n" +
"i0.y += isYZ.x + isYZ.y;\n" +
"i0.zw += 1.0 - isYZ.xy;\n" +
"i0.z += isYZ.z;\n" +
"i0.w += 1.0 - isYZ.z;\n" +
"vec4 i3 = clamp( i0, 0.0, 1.0 );\n" +
"vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n" +
"vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n" +
"vec4 x1 = x0 - i1 + C.xxxx;\n" +
"vec4 x2 = x0 - i2 + C.yyyy;\n" +
"vec4 x3 = x0 - i3 + C.zzzz;\n" +
"vec4 x4 = x0 + C.wwww;\n" +
"i = _agi_mod289(i);\n" +
"float j0 = _agi_permute( _agi_permute( _agi_permute( _agi_permute(i.w) + i.z) + i.y) + i.x);\n" +
"vec4 j1 = _agi_permute( _agi_permute( _agi_permute( _agi_permute (\n" +
"i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n" +
"+ i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n" +
"+ i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n" +
"+ i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n" +
"vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n" +
"vec4 p0 = _agi_grad4(j0,   ip);\n" +
"vec4 p1 = _agi_grad4(j1.x, ip);\n" +
"vec4 p2 = _agi_grad4(j1.y, ip);\n" +
"vec4 p3 = _agi_grad4(j1.z, ip);\n" +
"vec4 p4 = _agi_grad4(j1.w, ip);\n" +
"vec4 norm = _agi_taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n" +
"p0 *= norm.x;\n" +
"p1 *= norm.y;\n" +
"p2 *= norm.z;\n" +
"p3 *= norm.w;\n" +
"p4 *= _agi_taylorInvSqrt(dot(p4,p4));\n" +
"vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n" +
"vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n" +
"m0 = m0 * m0;\n" +
"m1 = m1 * m1;\n" +
"return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n" +
"+ dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n" +
"}\n" +
"vec3 _agi_permute289(vec3 x)\n" +
"{\n" +
"return mod((34.0 * x + 1.0) * x, 289.0);\n" +
"}\n" +
"vec2 agi_cellular(vec2 P)\n" +
"{\n" +
"#define K 0.142857142857\n" +
"#define Ko 0.428571428571\n" +
"#define jitter 1.0\n" +
"vec2 Pi = mod(floor(P), 289.0);\n" +
"vec2 Pf = fract(P);\n" +
"vec3 oi = vec3(-1.0, 0.0, 1.0);\n" +
"vec3 of = vec3(-0.5, 0.5, 1.5);\n" +
"vec3 px = _agi_permute289(Pi.x + oi);\n" +
"vec3 p = _agi_permute289(px.x + Pi.y + oi);\n" +
"vec3 ox = fract(p*K) - Ko;\n" +
"vec3 oy = mod(floor(p*K),7.0)*K - Ko;\n" +
"vec3 dx = Pf.x + 0.5 + jitter*ox;\n" +
"vec3 dy = Pf.y - of + jitter*oy;\n" +
"vec3 d1 = dx * dx + dy * dy;\n" +
"p = _agi_permute289(px.y + Pi.y + oi);\n" +
"ox = fract(p*K) - Ko;\n" +
"oy = mod(floor(p*K),7.0)*K - Ko;\n" +
"dx = Pf.x - 0.5 + jitter*ox;\n" +
"dy = Pf.y - of + jitter*oy;\n" +
"vec3 d2 = dx * dx + dy * dy;\n" +
"p = _agi_permute289(px.z + Pi.y + oi);\n" +
"ox = fract(p*K) - Ko;\n" +
"oy = mod(floor(p*K),7.0)*K - Ko;\n" +
"dx = Pf.x - 1.5 + jitter*ox;\n" +
"dy = Pf.y - of + jitter*oy;\n" +
"vec3 d3 = dx * dx + dy * dy;\n" +
"vec3 d1a = min(d1, d2);\n" +
"d2 = max(d1, d2);\n" +
"d2 = min(d2, d3);\n" +
"d1 = min(d1a, d2);\n" +
"d2 = max(d1a, d2);\n" +
"d1.xy = (d1.x < d1.y) ? d1.xy : d1.yx;\n" +
"d1.xz = (d1.x < d1.z) ? d1.xz : d1.zx;\n" +
"d1.yz = min(d1.yz, d2.yz);\n" +
"d1.y = min(d1.y, d1.z);\n" +
"d1.y = min(d1.y, d2.x);\n" +
"return sqrt(d1.xy);\n" +
"}\n" +
"#endif\n" +
"";
});
/*global define*/
define('Scene/BlobMaterial',[
        '../Shaders/Noise',
        '../Shaders/BlobMaterial'
    ], function(
        ShadersNoise,
        ShadersBlobMaterial) {
    

    /**
     * DOC_TBA
     *
     * @name BlobMaterial
     * @constructor
     */
    function BlobMaterial(template) {
        var t = template || {};

        /**
         * DOC_TBA
         */
        this.lightColor = t.lightColor || {
            red : 1.0,
            green : 1.0,
            blue : 1.0,
            alpha : 0.5
        };

        /**
         * DOC_TBA
         */
        this.darkColor = t.darkColor || {
            red : 0.0,
            green : 0.0,
            blue : 1.0,
            alpha : 0.5
        };

        /**
         * DOC_TBA
         *
         * @type Number
         */
        this.repeat = t.repeat || 20.0;

        var that = this;
        this._uniforms = {
            u_lightColor : function() {
                return that.lightColor;
            },
            u_darkColor : function() {
                return that.darkColor;
            },
            u_repeat : function() {
                return that.repeat;
            }
        };
    }

    BlobMaterial.prototype._getShaderSource = function() {
        return "#line 0\n" +
               ShadersNoise +
               "#line 0\n" +
               ShadersBlobMaterial;
    };

    return BlobMaterial;
});
/*global define*/
define('Scene/FacetMaterial',[
        '../Shaders/Noise',
        '../Shaders/FacetMaterial'
    ], function(
        ShadersNoise,
        ShadersFacetMaterial){
    

    /**
     * DOC_TBA
     *
     * @name FacetMaterial
     * @constructor
     */
    function FacetMaterial(template) {
        var t = template || {};

        /**
         * DOC_TBA
         */
        this.lightColor = t.lightColor || {
            red : 1.0,
            green : 1.0,
            blue : 1.0,
            alpha : 0.5
        };

        /**
         * DOC_TBA
         */
        this.darkColor = t.darkColor || {
            red : 0.0,
            green : 0.0,
            blue : 1.0,
            alpha : 0.5
        };

        /**
         * DOC_TBA
         *
         * @type Number
         */
        this.repeat = t.repeat || 20.0;

        var that = this;
        this._uniforms = {
            u_lightColor : function() {
                return that.lightColor;
            },
            u_darkColor : function() {
                return that.darkColor;
            },
            u_repeat : function() {
                return that.repeat;
            }
        };
    }

    FacetMaterial.prototype._getShaderSource = function() {
        return "#line 0\n" +
               ShadersNoise +
               "#line 0\n" +
               ShadersFacetMaterial;
    };

    return FacetMaterial;
});

/*global define*/
define('Shaders/PolygonFS',[],function() {
  
  return "uniform float u_erosion;\n" +
"varying vec3 v_positionMC;\n" +
"varying vec3 v_positionEC;\n" +
"varying vec2 v_textureCoordinates;\n" +
"#ifndef RENDER_FOR_PICK\n" +
"void erode(vec3 str)\n" +
"{\n" +
"if (u_erosion != 1.0)\n" +
"{\n" +
"float t = 0.5 + (0.5 * agi_snoise(str / (1.0 / 10.0)));\n" +
"if (t > u_erosion)\n" +
"{\n" +
"discard;\n" +
"}\n" +
"}\n" +
"}\n" +
"#endif\n" +
"vec4 getColor()\n" +
"{\n" +
"float zDistance = 0.0;\n" +
"vec2 st = v_textureCoordinates;\n" +
"vec3 str = vec3(st, 0.0);\n" +
"erode(str);\n" +
"return agi_getMaterialColor(zDistance, st, str);\n" +
"}\n" +
"void main()\n" +
"{\n" +
"vec3 normalEC = normalize(agi_normal * agi_geodeticSurfaceNormal(v_positionMC, vec3(0.0), vec3(1.0)));\n" +
"vec3 positionToEyeEC = normalize(-v_positionEC);\n" +
"float intensity = agi_lightIntensity(normalEC, agi_sunDirectionEC, positionToEyeEC);\n" +
"vec4 color = getColor();\n" +
"gl_FragColor = vec4(intensity * color.rgb, color.a);\n" +
"}\n" +
"";
});

/*global define*/
define('Shaders/PolygonFSPick',[],function() {
  
  return "uniform vec4 u_pickColor;\n" +
"void main()\n" +
"{\n" +
"gl_FragColor = u_pickColor;\n" +
"}\n" +
"";
});

/*global define*/
define('Shaders/PolygonVS',[],function() {
  
  return "attribute vec2 position2D;\n" +
"attribute vec3 position3D;\n" +
"attribute vec2 textureCoordinates;\n" +
"uniform float u_morphTime;\n" +
"uniform float u_height;\n" +
"varying vec3 v_positionMC;\n" +
"varying vec3 v_positionEC;\n" +
"varying vec2 v_textureCoordinates;\n" +
"void main()\n" +
"{\n" +
"vec4 p = agi_columbusViewMorph(vec3(u_height, position2D), position3D, u_morphTime);\n" +
"v_positionMC = position3D;\n" +
"v_positionEC = (agi_modelView * vec4(position3D, 1.0)).xyz;\n" +
"v_textureCoordinates = textureCoordinates;\n" +
"gl_Position = agi_modelViewProjection * p;\n" +
"}\n" +
"";
});

/*global define*/
define('Shaders/PolygonVSPick',[],function() {
  
  return "attribute vec2 position2D;\n" +
"attribute vec3 position3D;\n" +
"uniform float u_morphTime;\n" +
"uniform float u_height;\n" +
"void main()\n" +
"{\n" +
"vec4 p = agi_columbusViewMorph(vec3(u_height, position2D), position3D, u_morphTime);\n" +
"gl_Position = agi_modelViewProjection * p;\n" +
"}\n" +
"";
});

/*global define*/
define('Shaders/PolylineFS',[],function() {
  
  return "uniform vec4 u_color;\n" +
"void main()\n" +
"{\n" +
"gl_FragColor = u_color;\n" +
"}\n" +
"";
});

/*global define*/
define('Shaders/PolylineVS',[],function() {
  
  return "attribute vec3 position2D;\n" +
"attribute vec3 position3D;\n" +
"uniform float u_morphTime;\n" +
"void main()\n" +
"{\n" +
"#ifdef GROUND_TRACK\n" +
"vec4 p = agi_columbusViewMorph(vec3(0.0, position2D.xy), position3D, u_morphTime);\n" +
"#elif defined(HEIGHT_TRACK)\n" +
"vec4 p = agi_columbusViewMorph(vec3(position2D.z, position2D.x, 10000000.0), position3D, u_morphTime);\n" +
"#else\n" +
"vec4 p = agi_columbusViewMorph(position2D.zxy, position3D, u_morphTime);\n" +
"#endif\n" +
"gl_Position = agi_modelViewProjection * p;\n" +
"}\n" +
"";
});
/*global define*/
define('Scene/Polyline',[
        '../Core/combine',
        '../Core/destroyObject',
        '../Core/Cartesian3',
        '../Core/Cartesian4',
        '../Core/Matrix4',
        '../Core/ComponentDatatype',
        '../Core/IndexDatatype',
        '../Core/PrimitiveType',
        '../Core/PolylinePipeline',
        '../Renderer/BufferUsage',
        '../Renderer/BlendingState',
        '../Renderer/StencilFunction',
        '../Renderer/StencilOperation',
        './SceneMode',
        '../Shaders/PolylineVS',
        '../Shaders/PolylineFS'
    ], function(
        combine,
        destroyObject,
        Cartesian3,
        Cartesian4,
        Matrix4,
        ComponentDatatype,
        IndexDatatype,
        PrimitiveType,
        PolylinePipeline,
        BufferUsage,
        BlendingState,
        StencilFunction,
        StencilOperation,
        SceneMode,
        PolylineVS,
        PolylineFS) {
    
    /*global Float32Array,Uint16Array*/

    var attributeIndices = {
        position2D : 0,
        position3D : 1
    };

    function PositionVertices() {
        this._va = undefined;
        this._primitiveType = undefined;
    }

    PositionVertices.prototype.getVertexArray = function() {
        return this._va;
    };

    PositionVertices.prototype.getPrimitiveType = function() {
        return this._primitiveType;
    };

    PositionVertices.prototype.update3D = function(context, positions, bufferUsage) {
        var length = positions.length;
        var positionArray = new Float32Array(length * 3);

        var j = 0;
        for ( var i = 0; i < length; ++i) {
            var p = positions[i];

            positionArray[j + 0] = p.x;
            positionArray[j + 1] = p.y;
            positionArray[j + 2] = p.z;

            j += 3;
        }

        var attributes = [{
            index : attributeIndices.position3D,
            vertexBuffer : context.createVertexBuffer(positionArray, bufferUsage),
            componentsPerAttribute : 3,
            componentDatatype : ComponentDatatype.FLOAT
        }, {
            index : attributeIndices.position2D,
            value : [0.0, 0.0]
        }];

        this._va = context.createVertexArray(attributes);
        this._primitiveType = PrimitiveType.LINE_STRIP;
    };

    PositionVertices.prototype.update2D = function(context, positions, bufferUsage, projection) {
        var segments = PolylinePipeline.wrapLongitude(projection.getEllipsoid(), positions);

        var i = 0;
        var numberOfSegments = segments.length;
        var numberOfPositions = 0;
        for (i = 0; i < numberOfSegments; ++i) {
            var segmentLength = segments[i].length;
            numberOfPositions += ((i === 0) || (segmentLength === 2)) ? segmentLength : segmentLength - 1;
        }

        var positionArray = new Float32Array(numberOfPositions * 3);
        var indices = new Uint16Array((numberOfPositions - 1) * 2);

        var j = 0;
        var k = 0;
        var m = 0;
        for (i = 0; i < numberOfSegments; ++i) {
            var segment = segments[i];
            // Do not duplicate first point of this segment with last point of previous segment
            var startN = ((i === 0) || (segment.length === 2)) ? 0 : 1;
            for ( var n = startN; n < segment.length; ++n) {
                var p = projection.project(segment[n].cartographic);

                positionArray[j + 0] = p.x;
                positionArray[j + 1] = p.y;
                positionArray[j + 2] = p.z;

                if (n !== segment.length - 1) {
                    indices[m + 0] = k;
                    indices[m + 1] = k + 1;
                    m += 2;
                }

                j += 3;
                ++k;
            }
        }

        var attributes = [{
            index : attributeIndices.position2D,
            vertexBuffer : context.createVertexBuffer(positionArray, bufferUsage),
            componentsPerAttribute : 3,
            componentDatatype : ComponentDatatype.FLOAT
        }, {
            index : attributeIndices.position3D,
            value : [0.0, 0.0, 0.0]
        }];

        // TODO: Handle overflow unsigned short

        var va = context.createVertexArray(attributes);
        va.setIndexBuffer(context.createIndexBuffer(indices, bufferUsage, IndexDatatype.UNSIGNED_SHORT));

        this._va = va;
        this._primitiveType = PrimitiveType.LINES;
    };

    PositionVertices.prototype.updateMorphing = function(context, positions2D, positions3D, bufferUsage, projection) {
        var segments = PolylinePipeline.wrapLongitude(projection.getEllipsoid(), positions2D);

        var i = 0;
        var numberOfSegments = segments.length;
        var numberOfPositions = 0;
        for (i = 0; i < numberOfSegments; ++i) {
            var segmentLength = segments[i].length;
            numberOfPositions += ((i === 0) || (segmentLength === 2)) ? segmentLength : segmentLength - 1;
        }

        var positionArray = new Float32Array(numberOfPositions * 3);
        var wgs84PositionArray = new Float32Array(numberOfPositions * 3); // TODO: Interleave with facade

        var indices = new Uint16Array((numberOfPositions - 1) * 2);

        var j = 0;
        var k = 0;
        var m = 0;
        for (i = 0; i < numberOfSegments; ++i) {
            var segment = segments[i];
            // Do not duplicate first point of this segment with last point of previous segment
            var startN = ((i === 0) || (segment.length === 2)) ? 0 : 1;
            for ( var n = startN; n < segment.length; ++n) {
                var p = projection.project(segment[n].cartographic);

                positionArray[j + 0] = p.x;
                positionArray[j + 1] = p.y;
                positionArray[j + 2] = p.z;

                //wgs84PositionArray[j + 0] = segment[n].cartesian.x;
                //wgs84PositionArray[j + 1] = segment[n].cartesian.y;
                //wgs84PositionArray[j + 2] = segment[n].cartesian.z;
                wgs84PositionArray[j + 0] = positions3D[segment[n].index].x;
                wgs84PositionArray[j + 1] = positions3D[segment[n].index].y;
                wgs84PositionArray[j + 2] = positions3D[segment[n].index].z;

                if (n !== segment.length - 1) {
                    indices[m + 0] = k;
                    indices[m + 1] = k + 1;
                    m += 2;
                }

                j += 3;
                ++k;
            }
        }

        var attributes = [{
            index : attributeIndices.position2D,
            vertexBuffer : context.createVertexBuffer(positionArray, bufferUsage),
            componentsPerAttribute : 3,
            componentDatatype : ComponentDatatype.FLOAT
        }, {
            index : attributeIndices.position3D,
            vertexBuffer : context.createVertexBuffer(wgs84PositionArray, bufferUsage),
            componentsPerAttribute : 3,
            componentDatatype : ComponentDatatype.FLOAT
        }];

        // TODO: Handle overflow unsigned short

        var va = context.createVertexArray(attributes);
        va.setIndexBuffer(context.createIndexBuffer(indices, bufferUsage, IndexDatatype.UNSIGNED_SHORT));

        this._va = va;
        this._primitiveType = PrimitiveType.LINES;
    };

    PositionVertices.prototype.update = function(context, positions2D, positions3D, bufferUsage, mode, projection) {
        if (positions2D && positions3D) {
            var length = Math.min(positions2D.length, positions3D.length); // TODO: Depends on view

            // Initially create or recreate vertex array and buffers
            this._va = this._va && this._va.destroy();

            if (length > 0) {
                switch (mode) {
                case SceneMode.SCENE3D:
                    this.update3D(context, positions3D, bufferUsage);
                    break;

                case SceneMode.SCENE2D:
                case SceneMode.COLUMBUS_VIEW:
                    this.update2D(context, positions2D, bufferUsage, projection);
                    break;

                case SceneMode.MORPHING:
                    this.updateMorphing(context, positions2D, positions3D, bufferUsage, projection);
                    break;
                }
            }
        } else {
            this._va = this._va && this._va.destroy();
        }
    };

    PositionVertices.prototype.isDestroyed = function() {
        return false;
    };

    PositionVertices.prototype.destroy = function() {
        this._va = this._va && this._va.destroy();
        return destroyObject(this);
    };

    /**
     * DOC_TBA
     *
     * @name Polyline
     * @constructor
     *
     * @example
     * var polyline = new Polyline();
     * polyline.color = {
     *   red   : 1.0,
     *   green : 0.0,
     *   blue  : 0.0,
     *   alpha : 0.5
     * };
     * polyline.outlineColor = {
     *   red   : 1.0,
     *   green : 1.0,
     *   blue  : 0.0,
     *   alpha : 0.5
     * };
     * polyline.setPositions([
     *   ellipsoid.toCartesian(new Cartographic3(...)),
     *   ellipsoid.toCartesian(new Cartographic3(...)),
     *   ellipsoid.toCartesian(new Cartographic3(...))
     * ]);
     */
    function Polyline() {
        this._sp = undefined;
        this._spGroundTrack = undefined;
        this._spHeightTrack = undefined;
        this._rsOne = undefined;
        this._rsTwo = undefined;
        this._rsThree = undefined;
        this._rsPick = undefined;

        /**
         * DOC_TBA
         *
         * @type Number
         */
        this.morphTime = 0.0;

        this._mode = SceneMode.SCENE3D;
        this._projection = undefined;

        var that = this;

        var drawUniformsOne = {
            u_color : function() {
                return that.color; // Doesn't matter; doesn't write color
            },
            u_morphTime : function() {
                return that.morphTime;
            }
        };
        var drawUniformsTwo = {
            u_color : function() {
                return that.color;
            },
            u_morphTime : function() {
                return that.morphTime;
            }
        };
        var drawUniformsThree = {
            u_color : function() {
                return that.outlineColor;
            },
            u_morphTime : function() {
                return that.morphTime;
            }
        };
        var pickUniforms = {
            u_color : function() {
                return that._pickId.normalizedRgba;
            },
            u_morphTime : function() {
                return that.morphTime;
            }
        };

        this._drawUniformsOne3D = combine(drawUniformsOne, {
            u_model : function() {
                return that._getModelMatrix(that._mode);
            }
        });
        this._drawUniformsTwo3D = combine(drawUniformsTwo, {
            u_model : function() {
                return that._getModelMatrix(that._mode);
            }
        });
        this._drawUniformsThree3D = combine(drawUniformsThree, {
            u_model : function() {
                return that._getModelMatrix(that._mode);
            }
        });
        this._pickUniforms3D = combine(pickUniforms, {
            u_model : function() {
                return that._getModelMatrix(that._mode);
            }
        });

        this._drawUniformsOne2D = combine(drawUniformsOne, {
            u_model : function() {
                return Matrix4.getIdentity();
            }
        });
        this._drawUniformsTwo2D = combine(drawUniformsTwo, {
            u_model : function() {
                return Matrix4.getIdentity();
            }
        });
        this._drawUniformsThree2D = combine(drawUniformsThree, {
            u_model : function() {
                return Matrix4.getIdentity();
            }
        });
        this._pickUniforms2D = combine(pickUniforms, {
            u_model : function() {
                return Matrix4.getIdentity();
            }
        });

        this._drawUniformsOne = undefined;
        this._drawUniformsTwo = undefined;
        this._drawUniformsThree = undefined;
        this._pickUniforms = undefined;

        this._positions = undefined;
        this._createVertexArray = false;

        this._vertices = new PositionVertices();
        this._pickId = undefined;

        /**
         * DOC_TBA
         * <br /><br />
         * The actual width used is clamped to the minimum and maximum width supported by the WebGL implementation.
         * These can be queried with {@link Context#getMinimumAliasedLineWidth} and
         * {@link Context#getMaximumAliasedLineWidth}.
         *
         * @type Number
         *
         * @see Polyline#outlineWidth
         * @see Context#getMinimumAliasedLineWidth
         * @see Context#getMaximumAliasedLineWidth
         *
         * @example
         * // 3 pixel total width, 1 pixel interior width
         * polyline.width = 1.0;
         * polyline.outlineWidth = 3.0;
         */
        this.width = 2;

        /**
         * DOC_TBA
         * <br /><br />
         * The actual width used is clamped to the minimum and maximum width supported by the WebGL implementation.
         * These can be queried with {@link Context#getMinimumAliasedLineWidth} and
         * {@link Context#getMaximumAliasedLineWidth}.
         *
         * @type Number
         *
         * @see Polyline#width
         * @see Context#getMinimumAliasedLineWidth
         * @see Context#getMaximumAliasedLineWidth
         *
         * @example
         * // 3 pixel total width, 1 pixel interior width
         * polyline.width = 1.0;
         * polyline.outlineWidth = 3.0;
         */
        this.outlineWidth = 5;

        /**
         * DOC_TBA
         *
         * @see Polyline#outlineColor
         */
        this.color = {
            red : 0.0,
            green : 0.0,
            blue : 1.0,
            alpha : 1.0
        };

        /**
         * DOC_TBA
         *
         * @see Polyline#color
         */
        this.outlineColor = {
            red : 1.0,
            green : 1.0,
            blue : 1.0,
            alpha : 1.0
        };

        /**
         * Determines if this polyline will be shown.
         *
         * @type Boolean
         */
        this.show = true;

        /**
         * Sets the 4x4 transformation matrix that transforms this polyline's positions from model to world coordinates.
         * When this is the identity matrix, the polyline is drawn in world coordinates, i.e., Earth's WGS84 coordinates.
         * Local reference frames can be used by providing a different transformation matrix, like that returned
         * by {@link Transforms.eastNorthUpToFixedFrame}.  This matrix is available to GLSL vertex and fragment
         * shaders via {@link agi_model} and derived uniforms.
         *
         * @type Matrix4
         *
         * @see Transforms.eastNorthUpToFixedFrame
         * @see agi_model
         *
         * @example
         * // The arrow points to the east, i.e., along the local x-axis.
         * var polyline = new Polyline();
         * var center = ellipsoid.cartographicDegreesToCartesian(new Cartographic2(-75.59777, 40.03883));
         * polyline.modelMatrix = Transforms.eastNorthUpToFixedFrame(center);
         * polyline.setPositions([
         *   new Cartesian3(0.0, 0.0, 0.0),
         *   new Cartesian3(1000000.0, 0.0, 0.0),
         *   new Cartesian3(900000.0, -100000.0, 0.0),
         *   new Cartesian3(900000.0, 100000.0, 0.0),
         *   new Cartesian3(1000000.0, 0.0, 0.0)
         * ]);
         */
        this.modelMatrix = Matrix4.getIdentity();
        this._modelMatrix = Matrix4.getIdentity();

        /**
         * The usage hint for the polyline's vertex buffer.
         *
         * @type BufferUsage
         *
         * @performance If <code>bufferUsage</code> changes, the next time
         * {@link Polyline#update} is called, the polyline's vertex buffer
         * is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.
         * For best performance, it is important to provide the proper usage hint.  If the polyline
         * will not change over several frames, use <code>BufferUsage.STATIC_DRAW</code>.
         * If the polyline will change every frame, use <code>BufferUsage.STREAM_DRAW</code>.
         */
        this.bufferUsage = BufferUsage.STATIC_DRAW;
        this._bufferUsage = undefined;

        /**
         * DOC_TBA
         */
        this.columbusView = {
            /**
             * DOC_TBA
             */
            track : {
                /**
                 * DOC_TBA
                 */
                show : true
            },

            /**
             * DOC_TBA
             */
            groundTrack : {
                /**
                 * DOC_TBA
                 */
                show : false
            },

            /**
             * DOC_TBA
             */
            heightTrack : {
                /**
                 * DOC_TBA
                 */
                show : false
            }
        };

        /**
         * DOC_TODO
         */
        this.scene3D = {
            /**
             * DOC_TODO
             */
            modelMatrix : undefined,

            /**
             * DOC_TODO
             */
            setPositions : function(value) {
                this._positions = value;
                that._createVertexArray = true;
            },

            /**
             * DOC_TODO
             */
            getPositions : function() {
                return this._positions;
            },

            _positions : undefined
        };

        /**
         * DOC_TODO
         */
        this.scene2D = {
            /**
             * DOC_TODO
             */
            modelMatrix : undefined,

            /**
             * DOC_TODO
             */
            setPositions : function(value) {
                this._positions = value;
                that._createVertexArray = true;
            },

            /**
             * DOC_TODO
             */
            getPositions : function() {
                return this._positions;
            },

            _positions : undefined
        };
    }

    Polyline.prototype._getModelMatrix = function(mode) {
        switch (mode) {
        case SceneMode.SCENE3D:
            return this.scene3D.modelMatrix || this.modelMatrix;

        case SceneMode.SCENE2D:
        case SceneMode.COLUMBUS_VIEW:
            return this.scene2D.modelMatrix || this.modelMatrix;

        case SceneMode.MORPHING:
            return Matrix4.getIdentity();
        }
    };

    Polyline.prototype._getPositions3D = function() {
        return this.scene3D._positions || this._positions;
    };

    Polyline.prototype._getPositions2D = function() {
        return this.scene2D._positions || this._positions;
    };

    /**
     * DOC_TBA
     *
     * @memberof Polyline
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see Polyline#setPositions
     */
    Polyline.prototype.getPositions = function() {
        return this._positions;
    };

    /**
     * DOC_TBA
     *
     * @memberof Polyline
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see Polyline#getPositions
     *
     * @example
     * polyline.setPositions([
     *   ellipsoid.toCartesian(new Cartographic3(...)),
     *   ellipsoid.toCartesian(new Cartographic3(...)),
     *   ellipsoid.toCartesian(new Cartographic3(...))
     * ]);
     */
    Polyline.prototype.setPositions = function(value) {
        this._positions = value;
        this._createVertexArray = true;
    };

    Polyline.prototype._clampWidth = function(context, value) {
        var min = context.getMinimumAliasedLineWidth();
        var max = context.getMaximumAliasedLineWidth();

        return Math.min(Math.max(value, min), max);
    };

    Polyline.prototype._isShown = function() {
        return this.show && (this.color.alpha !== 0);
    };

    Polyline.prototype._syncMorphTime = function(mode) {
        switch (mode) {
        case SceneMode.SCENE3D:
            this.morphTime = 1.0;
            break;

        case SceneMode.SCENE2D:
        case SceneMode.COLUMBUS_VIEW:
            this.morphTime = 0.0;
            break;

        // MORPHING - don't change it
        }
    };

    /**
     * Commits changes to properties before rendering by updating the object's WebGL resources.
     * This must be called before calling {@link Polyline#render} in order to realize
     * changes to polyline's positions and properties.
     *
     * @memberof Polyline
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see Polyline#render
     */
    Polyline.prototype.update = function(context, sceneState) {
        if (this._isShown()) {
            if (!this._sp) {
                this._sp = context.getShaderCache().getShaderProgram(PolylineVS, PolylineFS, attributeIndices);

                this._rsOne = context.createRenderState({
                    colorMask : {
                        red : false,
                        green : false,
                        blue : false,
                        alpha : false
                    },
                    lineWidth : 1,
                    blending : BlendingState.ALPHA_BLEND,
                    stencilTest : {
                        enabled : true,
                        frontFunction : StencilFunction.ALWAYS,
                        backFunction : StencilFunction.ALWAYS,
                        reference : 0,
                        mask : ~0,
                        frontOperation : {
                            fail : StencilOperation.REPLACE,
                            zFail : StencilOperation.REPLACE,
                            zPass : StencilOperation.REPLACE
                        },
                        backOperation : {
                            fail : StencilOperation.REPLACE,
                            zFail : StencilOperation.REPLACE,
                            zPass : StencilOperation.REPLACE
                        }
                    }
                });

                this._rsTwo = context.createRenderState({
                    lineWidth : 1,
                    depthMask : false,
                    blending : BlendingState.ALPHA_BLEND,
                    stencilTest : {
                        enabled : true,
                        frontFunction : StencilFunction.ALWAYS,
                        backFunction : StencilFunction.ALWAYS,
                        reference : 1,
                        mask : ~0,
                        frontOperation : {
                            fail : StencilOperation.KEEP,
                            zFail : StencilOperation.KEEP,
                            zPass : StencilOperation.REPLACE
                        },
                        backOperation : {
                            fail : StencilOperation.KEEP,
                            zFail : StencilOperation.KEEP,
                            zPass : StencilOperation.REPLACE
                        }
                    }
                });

                this._rsThree = context.createRenderState({
                    lineWidth : 1,
                    depthMask : false,
                    blending : BlendingState.ALPHA_BLEND,
                    stencilTest : {
                        enabled : true,
                        frontFunction : StencilFunction.NOT_EQUAL,
                        backFunction : StencilFunction.NOT_EQUAL,
                        reference : 1,
                        mask : ~0,
                        frontOperation : {
                            fail : StencilOperation.KEEP,
                            zFail : StencilOperation.KEEP,
                            zPass : StencilOperation.KEEP
                        },
                        backOperation : {
                            fail : StencilOperation.KEEP,
                            zFail : StencilOperation.KEEP,
                            zPass : StencilOperation.KEEP
                        }
                    }
                });
            }

            var mode = sceneState.mode;
            var projection = sceneState.scene2D.projection;
            this._syncMorphTime(mode);

            if (this.columbusView.groundTrack.show || (mode === SceneMode.SCENE2D)) {
                this._spGroundTrack =
                    this._spGroundTrack ||
                    context.getShaderCache().getShaderProgram(
                            "#define GROUND_TRACK\n" +
                            "#line 0\n" +
                            PolylineVS, PolylineFS, attributeIndices);
            } else {
                this._spGroundTrack = this._spGroundTrack && this._spGroundTrack.release();
            }

            if (this.columbusView.heightTrack.show) {
                this._spHeightTrack =
                    this._spHeightTrack ||
                    context.getShaderCache().getShaderProgram(
                            "#define HEIGHT_TRACK\n" +
                            "#line 0\n" +
                            PolylineVS, PolylineFS, attributeIndices);
            } else {
                this._spHeightTrack = this._spHeightTrack && this._spHeightTrack.release();
            }

            // Update render state if line width or depth test changed.
            var width = this._clampWidth(context, this.width);
            var outlineWidth = this._clampWidth(context, this.outlineWidth);

            // Enable depth testing during and after a morph.
            var useDepthTest = (this.morphTime !== 0.0);

            var rsOne = this._rsOne;
            rsOne.lineWidth = outlineWidth;
            rsOne.depthMask = !useDepthTest;
            rsOne.depthTest.enabled = useDepthTest;

            var rsTwo = this._rsTwo;
            rsTwo.lineWidth = width;
            rsTwo.depthTest.enabled = useDepthTest;

            var rsThree = this._rsThree;
            rsThree.lineWidth = outlineWidth;
            rsThree.depthTest.enabled = useDepthTest;

            var modelMatrix = this._getModelMatrix(mode);

            if (this._createVertexArray ||
                (this._bufferUsage !== this.bufferUsage) ||
                (this._mode !== mode) ||
                (this._projection !== projection) ||
                (mode !== SceneMode.SCENE3D) &&
                (!this._modelMatrix.equals(modelMatrix))) {
                this._createVertexArray = false;
                this._bufferUsage = this.bufferUsage;
                this._mode = mode;
                this._projection = projection;
                this._modelMatrix = modelMatrix.clone();

                var positions2D = this._getPositions2D();
                var positions3D = this._getPositions3D();

                if (mode === SceneMode.SCENE3D) {
                    this._drawUniformsOne = this._drawUniformsOne3D;
                    this._drawUniformsTwo = this._drawUniformsTwo3D;
                    this._drawUniformsThree = this._drawUniformsThree3D;
                    this._pickUniforms = this._pickUniforms3D;

                    this._vertices.update(context, positions2D, positions3D, this.bufferUsage, mode, projection);
                } else {
                    this._drawUniformsOne = this._drawUniformsOne2D;
                    this._drawUniformsTwo = this._drawUniformsTwo2D;
                    this._drawUniformsThree = this._drawUniformsThree2D;
                    this._pickUniforms = this._pickUniforms2D;

                    // TODO: This is slow and needs work.

                    // PERFORMANCE_IDEA: When the model matrix changes often, e.g., orbits that transform from CBI to CBF,
                    // we can consider moving this transform and the map projection into the vertex shader.  However,
                    // clipping will make it nontrivial.
                    var mv2D = this.scene2D.modelMatrix || this.modelMatrix;
                    var worldPositions2D = [];
                    var i, p;
                    if (typeof positions2D !== 'undefined') {
                        for (i = 0; i < positions2D.length; ++i) {
                            p = mv2D.multiplyWithVector(new Cartesian4(positions2D[i].x, positions2D[i].y, positions2D[i].z, 1.0));
                            worldPositions2D.push(new Cartesian3(p.x, p.y, p.z));
                        }
                    }

                    var mv3D = this.scene3D.modelMatrix || this.modelMatrix;
                    var worldPositions3D = [];
                    if (typeof positions3D !== 'undefined') {
                        for (i = 0; i < positions3D.length; ++i) {
                            p = mv3D.multiplyWithVector(new Cartesian4(positions3D[i].x, positions3D[i].y, positions3D[i].z, 1.0));
                            worldPositions3D.push(new Cartesian3(p.x, p.y, p.z));
                        }
                    }

                    this._vertices.update(context, worldPositions2D, worldPositions3D, this.bufferUsage, mode, projection);
                }
            }
        }
    };

    Polyline.prototype._render = function(context, sp) {
        var va = this._vertices.getVertexArray();
        var primitiveType = this._vertices.getPrimitiveType();

        context.draw({
            primitiveType : primitiveType,
            shaderProgram : sp,
            uniformMap : this._drawUniformsOne,
            vertexArray : va,
            renderState : this._rsOne
        });
        context.draw({
            primitiveType : primitiveType,
            shaderProgram : sp,
            uniformMap : this._drawUniformsTwo,
            vertexArray : va,
            renderState : this._rsTwo
        });
        context.draw({
            primitiveType : primitiveType,
            shaderProgram : sp,
            uniformMap : this._drawUniformsThree,
            vertexArray : va,
            renderState : this._rsThree
        });
    };

    /**
     * Renders the Polyline.  In order for changes to positions and properties to be realized,
     * {@link Polyline#update} must be called before <code>render</code>.
     * <br /><br />
     * Outlined polylines are rendered in three passes using the stencil buffer.
     *
     * @memberof Polyline
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see Polyline#update
     */
    Polyline.prototype.render = function(context) {
        var va = this._vertices.getVertexArray();

        if (this._isShown() && va) {
            if (this._mode === SceneMode.SCENE2D) {
                this._render(context, this._spGroundTrack);
            } else if ((this._mode === SceneMode.COLUMBUS_VIEW) || (this._mode === SceneMode.MORPHING)) {
                if (this.columbusView.track.show) {
                    this._render(context, this._sp);
                }

                if (this.columbusView.groundTrack.show) {
                    this._render(context, this._spGroundTrack);
                }

                if (this.columbusView.heightTrack.show) {
                    this._render(context, this._spHeightTrack);
                }
            } else {
                // PERFORMANCE_IDEA:  This can do this in a single pass by checking the distance
                // from a fragment to the line in a fragment shader.
                this._render(context, this._sp);
            }
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof Polyline
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     */
    Polyline.prototype.updateForPick = function(context) {
        if (this._isShown()) {
            this._pickId = this._pickId || context.createPickId(this);
            this._rsPick = this._rsPick || context.createRenderState();

            var outlineWidth = this._clampWidth(context, this.outlineWidth);
            // Enable depth testing during and after a morph.
            var useDepthTest = (this.morphTime !== 0.0);

            var rs = this._rsPick;
            rs.lineWidth = outlineWidth;
            rs.depthTest.enabled = useDepthTest;
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof Polyline
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     */
    Polyline.prototype.renderForPick = function(context, framebuffer) {
        var va = this._vertices.getVertexArray();

        // TODO:  Pick on ground track and height track

        if (this._isShown() && va) {
            context.draw({
                primitiveType : this._vertices.getPrimitiveType(),
                shaderProgram : this._sp,
                uniformMap : this._pickUniforms,
                vertexArray : va,
                renderState : this._rsPick,
                framebuffer : framebuffer
            });
        }
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof Polyline
     *
     * @return {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     *
     * @see Polyline#destroy
     */
    Polyline.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>null</code>) to the object as done in the example.
     *
     * @memberof Polyline
     *
     * @return {null}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see Polyline#isDestroyed
     *
     * @example
     * polyline = polyline && polyline.destroy();
     */
    Polyline.prototype.destroy = function() {
        this._sp = this._sp && this._sp.release();
        this._spGroundTrack = this._spGroundTrack && this._spGroundTrack.release();
        this._spHeightTrack = this._spHeightTrack && this._spHeightTrack.release();
        this._vertices = this._vertices.destroy();
        this._pickId = this._pickId && this._pickId.destroy();
        return destroyObject(this);
    };

    return Polyline;
});

/*global define*/
define('Shaders/Ray',[],function() {
  
  return "struct agi_ray\n" +
"{\n" +
"vec3 origin;\n" +
"vec3 direction;\n" +
"};\n" +
"vec3 agi_pointAlongRay(agi_ray ray, float time)\n" +
"{\n" +
"return ray.origin + (time * ray.direction);\n" +
"}\n" +
"struct agi_raySegment\n" +
"{\n" +
"float start;\n" +
"float stop;\n" +
"};\n" +
"const agi_raySegment agi_emptyRaySegment = agi_raySegment(-agi_infinity, -agi_infinity);\n" +
"const agi_raySegment agi_fullRaySegment = agi_raySegment(0.0, agi_infinity);\n" +
"bool agi_isEmpty(agi_raySegment interval)\n" +
"{\n" +
"return (interval.stop < 0.0);\n" +
"}\n" +
"bool agi_isFull(agi_raySegment interval)\n" +
"{\n" +
"return (interval.start == 0.0 && interval.stop == agi_infinity);\n" +
"}\n" +
"const int agi_raySegmentCollectionCapacity = 4;\n" +
"struct agi_raySegmentCollection\n" +
"{\n" +
"agi_raySegment intervals[agi_raySegmentCollectionCapacity];\n" +
"int count;\n" +
"};\n" +
"agi_raySegmentCollection agi_raySegmentCollectionNew()\n" +
"{\n" +
"agi_raySegment intervals[agi_raySegmentCollectionCapacity];\n" +
"agi_raySegmentCollection i = agi_raySegmentCollection(intervals, 0);\n" +
"return i;\n" +
"}\n" +
"agi_raySegmentCollection agi_raySegmentCollectionNew(agi_raySegment segment)\n" +
"{\n" +
"agi_raySegment intervals[agi_raySegmentCollectionCapacity];\n" +
"intervals[0] = segment;\n" +
"agi_raySegmentCollection i = agi_raySegmentCollection(intervals, 1);\n" +
"return i;\n" +
"}\n" +
"agi_raySegmentCollection agi_raySegmentCollectionNew(agi_raySegment first, agi_raySegment second)\n" +
"{\n" +
"agi_raySegment intervals[agi_raySegmentCollectionCapacity];\n" +
"intervals[0] = first;\n" +
"intervals[1] = second;\n" +
"agi_raySegmentCollection i = agi_raySegmentCollection(intervals, 2);\n" +
"return i;\n" +
"}\n" +
"void agi_removeAt(inout agi_raySegmentCollection collection, int index)\n" +
"{\n" +
"--collection.count;\n" +
"for (int i = 0; i < agi_raySegmentCollectionCapacity; ++i)\n" +
"{\n" +
"if (i >= index && i < collection.count)\n" +
"{\n" +
"collection.intervals[i] = collection.intervals[i + 1];\n" +
"}\n" +
"else if (i == collection.count)\n" +
"{\n" +
"break;\n" +
"}\n" +
"}\n" +
"}\n" +
"void agi_insertAt(inout agi_raySegmentCollection collection, agi_raySegment segment, int index)\n" +
"{\n" +
"for (int i = agi_raySegmentCollectionCapacity - 1; i >= 0; --i)\n" +
"{\n" +
"if (i <= collection.count && i > index)\n" +
"{\n" +
"collection.intervals[i] = collection.intervals[i - 1];\n" +
"}\n" +
"else if (i == index)\n" +
"{\n" +
"collection.intervals[i] = segment;\n" +
"}\n" +
"else if (i < index)\n" +
"{\n" +
"break;\n" +
"}\n" +
"}\n" +
"++collection.count;\n" +
"}\n" +
"void agi_insertAt(inout agi_raySegmentCollection collection, agi_raySegmentCollection segments, int index)\n" +
"{\n" +
"if (segments.count == 1)\n" +
"{\n" +
"agi_insertAt(collection, segments.intervals[0], index);\n" +
"}\n" +
"else\n" +
"{\n" +
"for (int i = agi_raySegmentCollectionCapacity - 1; i >= 0; --i)\n" +
"{\n" +
"if (i < segments.count)\n" +
"{\n" +
"agi_insertAt(collection, segments.intervals[i], index);\n" +
"}\n" +
"}\n" +
"}\n" +
"}\n" +
"void agi_complement(agi_raySegment segment, out agi_raySegmentCollection collection)\n" +
"{\n" +
"if (agi_isEmpty(segment))\n" +
"{\n" +
"collection = agi_raySegmentCollectionNew(agi_fullRaySegment);\n" +
"}\n" +
"else if (segment.stop == agi_infinity)\n" +
"{\n" +
"if (segment.start == 0.0)\n" +
"{\n" +
"collection = agi_raySegmentCollectionNew();\n" +
"}\n" +
"else\n" +
"{\n" +
"collection = agi_raySegmentCollectionNew(agi_raySegment(0.0, segment.start));\n" +
"}\n" +
"}\n" +
"else if (segment.start == 0.0)\n" +
"{\n" +
"collection = agi_raySegmentCollectionNew(agi_raySegment(segment.stop, agi_infinity));\n" +
"}\n" +
"else\n" +
"{\n" +
"agi_raySegment head = agi_raySegment(0.0, segment.start);\n" +
"agi_raySegment tail = agi_raySegment(segment.stop, agi_infinity);\n" +
"collection = agi_raySegmentCollectionNew(head, tail);\n" +
"}\n" +
"}\n" +
"agi_raySegmentCollection agi_complement(agi_raySegmentCollection collection)\n" +
"{\n" +
"if (collection.count == 0)\n" +
"{\n" +
"agi_raySegmentCollection result = agi_raySegmentCollectionNew(agi_fullRaySegment);\n" +
"return result;\n" +
"}\n" +
"else if (collection.count == 1)\n" +
"{\n" +
"agi_raySegmentCollection result;\n" +
"agi_complement(collection.intervals[0], result);\n" +
"return result;\n" +
"}\n" +
"agi_raySegmentCollection result = agi_raySegmentCollectionNew();\n" +
"for (int i = 0; i < agi_raySegmentCollectionCapacity; ++i)\n" +
"{\n" +
"if (i < collection.count)\n" +
"{\n" +
"float start = collection.intervals[i].stop;\n" +
"if (i < collection.count - 1)\n" +
"{\n" +
"float stop = collection.intervals[i + 1].start;\n" +
"result.intervals[i] = agi_raySegment(start, stop);\n" +
"++result.count;\n" +
"}\n" +
"else if (start != agi_infinity)\n" +
"{\n" +
"result.intervals[i] = agi_raySegment(start, agi_infinity);\n" +
"++result.count;\n" +
"}\n" +
"}\n" +
"else\n" +
"{\n" +
"break;\n" +
"}\n" +
"}\n" +
"if (collection.count > 0)\n" +
"{\n" +
"float stop = collection.intervals[0].start;\n" +
"if (stop != 0.0)\n" +
"{\n" +
"agi_insertAt(result, agi_raySegment(0.0, stop), 0);\n" +
"}\n" +
"}\n" +
"return result;\n" +
"}\n" +
"agi_raySegmentCollection agi_union(agi_raySegment left, agi_raySegment right)\n" +
"{\n" +
"if (agi_isFull(left) || agi_isFull(right))\n" +
"{\n" +
"agi_raySegmentCollection result = agi_raySegmentCollectionNew(agi_fullRaySegment);\n" +
"return result;\n" +
"}\n" +
"float stop = min(left.stop, right.stop);\n" +
"float start = max(left.start, right.start);\n" +
"if (stop < start)\n" +
"{\n" +
"agi_raySegmentCollection result = (left.start < right.start) ? agi_raySegmentCollectionNew(left, right) : agi_raySegmentCollectionNew(right, left);\n" +
"return result;\n" +
"}\n" +
"agi_raySegmentCollection result = agi_raySegmentCollectionNew(agi_raySegment(min(left.start, right.start), max(left.stop, right.stop)));\n" +
"return result;\n" +
"}\n" +
"agi_raySegment agi_intersection(agi_raySegment left, agi_raySegment right)\n" +
"{\n" +
"float stop = min(left.stop, right.stop);\n" +
"if (stop < 0.0)\n" +
"{\n" +
"return agi_emptyRaySegment;\n" +
"}\n" +
"float start = max(left.start, right.start);\n" +
"if (stop < start)\n" +
"{\n" +
"return agi_emptyRaySegment;\n" +
"}\n" +
"agi_raySegment s = agi_raySegment(start, stop);\n" +
"return s;\n" +
"}\n" +
"agi_raySegmentCollection agi_intersection(agi_raySegmentCollection left, agi_raySegment right)\n" +
"{\n" +
"if (left.count == 1)\n" +
"{\n" +
"agi_raySegment intersection = agi_intersection(left.intervals[0], right);\n" +
"if (agi_isEmpty(intersection))\n" +
"{\n" +
"agi_raySegmentCollection result = agi_raySegmentCollectionNew();\n" +
"return result;\n" +
"}\n" +
"else\n" +
"{\n" +
"agi_raySegmentCollection result = agi_raySegmentCollectionNew(intersection);\n" +
"return result;\n" +
"}\n" +
"}\n" +
"agi_raySegmentCollection result = agi_raySegmentCollectionNew();\n" +
"for (int leftIndex = 0; leftIndex < agi_raySegmentCollectionCapacity; ++leftIndex)\n" +
"{\n" +
"if (leftIndex < left.count)\n" +
"{\n" +
"agi_raySegment intersection = agi_intersection(left.intervals[leftIndex], right);\n" +
"if (!agi_isEmpty(intersection))\n" +
"{\n" +
"agi_insertAt(result, intersection, result.count);\n" +
"}\n" +
"}\n" +
"else\n" +
"{\n" +
"break;\n" +
"}\n" +
"}\n" +
"return result;\n" +
"}\n" +
"agi_raySegmentCollection agi_intersection(agi_raySegmentCollection left, agi_raySegmentCollection right)\n" +
"{\n" +
"if (right.count == 1)\n" +
"{\n" +
"if (left.count == 1)\n" +
"{\n" +
"agi_raySegment intersection = agi_intersection(left.intervals[0], right.intervals[0]);\n" +
"if (agi_isEmpty(intersection))\n" +
"{\n" +
"agi_raySegmentCollection result = agi_raySegmentCollectionNew();\n" +
"return result;\n" +
"}\n" +
"else\n" +
"{\n" +
"agi_raySegmentCollection result = agi_raySegmentCollectionNew(intersection);\n" +
"return result;\n" +
"}\n" +
"}\n" +
"else\n" +
"{\n" +
"agi_raySegmentCollection result = agi_intersection(left, right.intervals[0]);\n" +
"return result;\n" +
"}\n" +
"}\n" +
"agi_raySegmentCollection result = agi_raySegmentCollectionNew();\n" +
"if (left.count > 0 && right.count > 0)\n" +
"{\n" +
"for (int leftIndex = 0; leftIndex < agi_raySegmentCollectionCapacity; ++leftIndex)\n" +
"{\n" +
"if (leftIndex < left.count)\n" +
"{\n" +
"for (int rightIndex = 0; rightIndex < agi_raySegmentCollectionCapacity; ++rightIndex)\n" +
"{\n" +
"if (rightIndex <= right.count && left.intervals[leftIndex].stop >= right.intervals[rightIndex].start)\n" +
"{\n" +
"agi_raySegment intersection = agi_intersection(left.intervals[leftIndex], right.intervals[rightIndex]);\n" +
"if (!agi_isEmpty(intersection))\n" +
"{\n" +
"agi_insertAt(result, intersection, result.count);\n" +
"}\n" +
"}\n" +
"else\n" +
"{\n" +
"break;\n" +
"}\n" +
"}\n" +
"}\n" +
"else\n" +
"{\n" +
"break;\n" +
"}\n" +
"}\n" +
"}\n" +
"return result;\n" +
"}\n" +
"agi_raySegmentCollection agi_subtraction(agi_raySegment outer, agi_raySegment inner)\n" +
"{\n" +
"agi_raySegmentCollection i = agi_raySegmentCollectionNew();\n" +
"agi_raySegment intersection = agi_intersection(outer, inner);\n" +
"if (agi_isEmpty(intersection) || (intersection.start == intersection.stop))\n" +
"{\n" +
"i.count = 1;\n" +
"i.intervals[0] = outer;\n" +
"}\n" +
"else\n" +
"{\n" +
"if ((intersection.start == outer.start) && (intersection.stop == outer.stop))\n" +
"{\n" +
"i.count = 0;\n" +
"}\n" +
"else if (intersection.start == outer.start)\n" +
"{\n" +
"i.count = 1;\n" +
"i.intervals[0] = agi_raySegment(inner.stop, outer.stop);\n" +
"}\n" +
"else if (intersection.stop == outer.stop)\n" +
"{\n" +
"i.count = 1;\n" +
"i.intervals[0] = agi_raySegment(outer.start, inner.start);\n" +
"}\n" +
"else\n" +
"{\n" +
"i.count = 2;\n" +
"i.intervals[0] = agi_raySegment(outer.start, inner.start);\n" +
"i.intervals[1] = agi_raySegment(inner.stop, outer.stop);\n" +
"}\n" +
"}\n" +
"return i;\n" +
"}\n" +
"agi_raySegmentCollection agi_subtraction(agi_raySegmentCollection left, agi_raySegment right)\n" +
"{\n" +
"if (left.count == 1)\n" +
"{\n" +
"agi_raySegmentCollection result = agi_subtraction(left.intervals[0], right);\n" +
"return result;\n" +
"}\n" +
"agi_raySegmentCollection result = agi_raySegmentCollectionNew();\n" +
"for (int leftIndex = 0; leftIndex < agi_raySegmentCollectionCapacity; ++leftIndex)\n" +
"{\n" +
"if (leftIndex < left.count)\n" +
"{\n" +
"agi_raySegmentCollection segments = agi_subtraction(left.intervals[leftIndex], right);\n" +
"if (segments.count != 0)\n" +
"{\n" +
"agi_insertAt(result, segments, result.count);\n" +
"}\n" +
"}\n" +
"else\n" +
"{\n" +
"break;\n" +
"}\n" +
"}\n" +
"return result;\n" +
"}\n" +
"agi_raySegmentCollection agi_subtraction(agi_raySegmentCollection left, agi_raySegmentCollection right)\n" +
"{\n" +
"if (right.count == 1)\n" +
"{\n" +
"if (left.count == 1)\n" +
"{\n" +
"agi_raySegmentCollection result = agi_subtraction(left.intervals[0], right.intervals[0]);\n" +
"return result;\n" +
"}\n" +
"else\n" +
"{\n" +
"agi_raySegmentCollection result = agi_subtraction(left, right.intervals[0]);\n" +
"return result;\n" +
"}\n" +
"}\n" +
"agi_raySegmentCollection complement = agi_complement(right);\n" +
"agi_raySegmentCollection result = agi_intersection(left, complement);\n" +
"return result;\n" +
"}\n" +
"";
});

/*global define*/
define('Shaders/SensorVolume',[],function() {
  
  return "uniform float u_erosion;\n" +
"uniform vec4 u_intersectionColor;\n" +
"bool inSensorShadow(vec3 coneVertexWC, agi_ellipsoid ellipsoidEC, vec3 pointEC)\n" +
"{\n" +
"vec3 D = ellipsoidEC.inverseRadii;\n" +
"vec3 q = D * coneVertexWC;\n" +
"float qMagnitudeSquared = dot(q, q);\n" +
"float test = qMagnitudeSquared - 1.0;\n" +
"vec3 t = (agi_inverseView * vec4(pointEC, 1.0)).xyz;\n" +
"vec3 temp = D * t - q;\n" +
"float d = dot(temp, q);\n" +
"return (d < -test) && (d / length(temp) < -sqrt(test));\n" +
"}\n" +
"#ifndef RENDER_FOR_PICK\n" +
"void sensorErode(float sensorRadius, vec3 pointEC)\n" +
"{\n" +
"if (u_erosion != 1.0)\n" +
"{\n" +
"vec3 pointMC = (agi_inverseModelView * vec4(pointEC, 1.0)).xyz;\n" +
"pointMC /= sensorRadius;\n" +
"pointMC /= (1.0 / 10.0);\n" +
"float t = 0.5 + (0.5 * agi_snoise(pointMC));\n" +
"if (t > u_erosion)\n" +
"{\n" +
"discard;\n" +
"}\n" +
"}\n" +
"}\n" +
"vec4 getIntersectionColor(float sensorRadius, vec3 pointEC)\n" +
"{\n" +
"sensorErode(sensorRadius, pointEC);\n" +
"return u_intersectionColor;\n" +
"}\n" +
"vec2 sensor2dTextureCoordinates(float sensorRadius, vec3 pointMC)\n" +
"{\n" +
"float t = pointMC.z / sensorRadius;\n" +
"float s = 1.0 + (atan(pointMC.y, pointMC.x) / agi_twoPi);\n" +
"s = s - floor(s);\n" +
"return vec2(s, t);\n" +
"}\n" +
"#endif\n" +
"";
});
/*global define*/
define('Scene/ComplexConicSensorVolume',[
        '../Core/DeveloperError',
        '../Core/combine',
        '../Core/destroyObject',
        '../Core/FAR',
        '../Core/Math',
        '../Core/Cartesian3',
        '../Core/Matrix4',
        '../Core/ComponentDatatype',
        '../Core/PrimitiveType',
        '../Core/BoxTessellator',
        '../Renderer/BufferUsage',
        '../Renderer/CullFace',
        '../Renderer/BlendEquation',
        '../Renderer/BlendFunction',
        './ColorMaterial',
        './combineMaterials',
        '../Shaders/Noise',
        '../Shaders/Ray',
        '../Shaders/ConstructiveSolidGeometry',
        '../Shaders/SensorVolume',
        '../Shaders/ComplexConicSensorVolumeVS',
        '../Shaders/ComplexConicSensorVolumeFS'
    ], function(
        DeveloperError,
        combine,
        destroyObject,
        FAR,
        CesiumMath,
        Cartesian3,
        Matrix4,
        ComponentDatatype,
        PrimitiveType,
        BoxTessellator,
        BufferUsage,
        CullFace,
        BlendEquation,
        BlendFunction,
        ColorMaterial,
        combineMaterials,
        ShadersNoise,
        ShadersRay,
        ShadersConstructiveSolidGeometry,
        ShadersSensorVolume,
        ComplexConicSensorVolumeVS,
        ComplexConicSensorVolumeFS) {
    

    var attributeIndices = {
        position : 0
    };

    /**
     * DOC_TBA
     *
     * @name ComplexConicSensorVolume
     * @constructor
     *
     * @see SensorVolumeCollection#addComplexConic
     */
    function ComplexConicSensorVolume(template) {
        var t = template || {};

        this._va = undefined;
        this._sp = undefined;
        this._rs = undefined;

        this._spPick = undefined;
        this._pickId = undefined;

        /**
         * <code>true</code> if this sensor will be shown; otherwise, <code>false</code>
         *
         * @type Boolean
         */
        this.show = (typeof t.show === "undefined") ? true : t.show;

        /**
         * DOC_TBA
         *
         * @type Boolean
         */
        this.showIntersection = (typeof t.showIntersection === "undefined") ? true : t.showIntersection;

        /**
         * The 4x4 transformation matrix that transforms this sensor from model to world coordinates.  In it's model
         * coordinates, the sensor's principal direction is along the positive z-axis.  Minimum and maximum clock
         * angles are measured from the x-axis.  This matrix is available to GLSL vertex and fragment shaders via
         * {@link agi_model} and derived uniforms.
         * <br /><br />
         * <div align="center">
         * <img src="images/ComplexConicSensorVolume.setModelMatrix.png" width="400" height="258" /><br />
         * Model coordinate system for a conic sensor
         * </div>
         *
         * @type Matrix4
         *
         * @see agi_model
         *
         * @example
         * // The sensor's vertex is located on the surface at -75.59777 degrees longitude and 40.03883 degrees latitude.
         * // The sensor's cone opens upward, along the surface normal.
         * var center = ellipsoid.cartographicDegreesToCartesian(new Cartographic2(-75.59777, 40.03883));
         * sensor.modelMatrix = Transforms.eastNorthUpToFixedFrame(center);
         */
        this.modelMatrix = t.modelMatrix || Matrix4.getIdentity();

        /**
         * DOC_TBA
         *
         * @type Number
         *
         * @see ComplexConicSensorVolume#outerHalfAngle
         */
        this.innerHalfAngle = (typeof t.innerHalfAngle === "undefined") ? CesiumMath.PI_OVER_TWO : t.innerHalfAngle;

        /**
         * DOC_TBA
         *
         * @type Number
         *
         * @see ComplexConicSensorVolume#innerHalfAngle
         */
        this.outerHalfAngle = (typeof t.outerHalfAngle === "undefined") ? CesiumMath.PI_OVER_TWO : t.outerHalfAngle;
        this._outerHalfAngle = undefined;

        /**
         * DOC_TBA
         *
         * @type Number
         *
         * @see ComplexConicSensorVolume#innerHalfAngle
         */
        this.maximumClockAngle = (typeof t.maximumClockAngle === "undefined") ? Math.PI : t.maximumClockAngle;
        this._maximumClockAngle = undefined;

        /**
         * DOC_TBA
         *
         * @type Number
         *
         * @see ComplexConicSensorVolume#innerHalfAngle
         */
        this.minimumClockAngle = (typeof t.minimumClockAngle === "undefined") ? -Math.PI : t.minimumClockAngle;
        this._minimumClockAnglee = undefined;

        /**
         * DOC_TBA
         *
         * @type Number
         */
        this.radius = (typeof t.radius === "undefined") ? Number.POSITIVE_INFINITY : t.radius;
        this._radius = undefined;

        //        /**
        //         * DOC_TBA
        //         *
        //         * @type Number
        //         */
        //        this.minimumClockAngle = (typeof t.minimumClockAngle === "undefined") ? (-Math.PI / 4.0) : t.minimumClockAngle;

        //        /**
        //         * DOC_TBA
        //         *
        //         * @type Number
        //         */
        //        this.maximumClockAngle = (typeof t.maximumClockAngle === "undefined") ? (Math.PI / 4.0) : t.maximumClockAngle;

        /**
         * DOC_TBA
         */
        this.outerMaterial = t.outerMaterial || new ColorMaterial();
        this._outerMaterial = undefined;

        /**
         * DOC_TBA
         */
        this.innerMaterial = t.innerMaterial || new ColorMaterial();
        this._innerMaterial = undefined;

        /**
         * DOC_TBA
         */
        this.capMaterial = t.capMaterial || new ColorMaterial();
        this._capMaterial = undefined;

        /**
         * DOC_TBA
         */
        this.silhouetteMaterial = t.silhouetteMaterial || new ColorMaterial();
        this._silhouetteMaterial = undefined;

        /**
         * DOC_TBA
         */
        this.intersectionColor = t.intersectionColor || {
            red : 1.0,
            green : 1.0,
            blue : 0.0,
            alpha : 1.0
        };

        /**
         * DOC_TBA
         *
         * @type Number
         */
        this.erosion = (typeof t.erosion === "undefined") ? 1.0 : t.erosion;

        var that = this;
        this._uniforms = {
            u_model : function() {
                return that.modelMatrix;
            },
            u_sensorRadius : function() {
                return that.radius;
            },
            u_outerHalfAngle : function() {
                return that.outerHalfAngle;
            },
            u_innerHalfAngle : function() {
                return that.innerHalfAngle;
            },
            u_maximumClockAngle : function() {
                return that.maximumClockAngle;
            },
            u_minimumClockAngle : function() {
                return that.minimumClockAngle;
            },
            u_showIntersection : function() {
                return that.showIntersection;
            },
            u_intersectionColor : function() {
                return that.intersectionColor;
            },
            u_erosion : function() {
                return that.erosion;
            }
        };
        this._drawUniforms = null;
        this._pickUniforms = null;
    }

    ComplexConicSensorVolume.prototype._getBoundingVolume = function() {
        var r = isFinite(this.radius) ? this.radius : FAR;

        if (this.outerHalfAngle <= CesiumMath.toRadians(45.0)) {
            // Bound sensor with a frustum
            var l = Math.tan(this.outerHalfAngle) * r;

            return {
                attributes : {
                    position : {
                        componentDatatype : ComponentDatatype.FLOAT,
                        componentsPerAttribute : 3,
                        values : [
                                  0.0, 0.0, 0.0, // Sensor vertex
                                    l,  -l,   r, // Sensor cap: ( x, -y)
                                    l,   l,   r, // Sensor cap: ( x,  y)
                                   -l,   l,   r, // Sensor cap: (-x,  y)
                                   -l,  -l,   r // Sensor cap: (-x, -y)
                              ]
                    }
                },
                indexLists : [{
                    primitiveType : PrimitiveType.TRIANGLES,
                    values : [
                              0, 1, 4, // bottom side
                              0, 4, 3, // left side
                              0, 3, 2, // top side
                              0, 2, 1, // right side
                              1, 2, 3, // top
                              1, 3, 4
                          ]
                }]
            };
        } else if (this.outerHalfAngle <= CesiumMath.toRadians(90.0)) {
            // Bound sensor with box in the +z half-space
            return BoxTessellator.compute({
                minimumCorner : new Cartesian3(-r, -r, 0.0),
                maximumCorner : new Cartesian3(r, r, r)
            });
        }

        // Bound sensor with box
        return BoxTessellator.compute({
            minimumCorner : new Cartesian3(-r, -r, -r),
            maximumCorner : new Cartesian3(r, r, r)
        });
    };

    ComplexConicSensorVolume.prototype._combineMaterials = function() {
        // On older/mobile hardware, we could do one pass per material to avoid
        // going over the maximum uniform limit
        return combineMaterials({
            material : this.outerMaterial,
            sourceTransform : function(source) {
                return source.replace(new RegExp("agi_getMaterialColor", "g"), "agi_getOuterMaterialColor");
            }
        }, {
            material : this.innerMaterial,
            sourceTransform : function(source) {
                return source.replace(new RegExp("agi_getMaterialColor", "g"), "agi_getInnerMaterialColor");
            }
        }, {
            material : this.capMaterial,
            sourceTransform : function(source) {
                return source.replace(new RegExp("agi_getMaterialColor", "g"), "agi_getCapMaterialColor");
            }
        }, {
            material : this.silhouetteMaterial,
            sourceTransform : function(source) {
                return source.replace(new RegExp("agi_getMaterialColor", "g"), "agi_getSilhouetteMaterialColor");
            }
        });
    };

    /**
     * DOC_TBA
     *
     * @memberof ComplexConicSensorVolume
     *
     * @exception {DeveloperError} this.innerHalfAngle cannot be greater than this.outerHalfAngle.
     * @exception {DeveloperError} this.radius must be greater than or equal to zero.
     */
    ComplexConicSensorVolume.prototype.update = function(context, sceneState) {
        if (this.innerHalfAngle > this.outerHalfAngle) {
            throw new DeveloperError("this.innerHalfAngle cannot be greater than this.outerHalfAngle.");
        }

        if (this.radius < 0.0) {
            throw new DeveloperError("this.radius must be greater than or equal to zero.");
        }

        if (this.show) {
            // Recreate vertex array when proxy geometry needs to change
            if ((this._outerHalfAngle !== this.outerHalfAngle) || (this._radius !== this.radius)) {
                this._outerHalfAngle = this.outerHalfAngle;
                this._radius = this.radius;

                this._va = context.createVertexArrayFromMesh({
                    mesh : this._getBoundingVolume(),
                    attributeIndices : attributeIndices,
                    bufferUsage : BufferUsage.STATIC_DRAW
                });
            }

            // Recompile shader when material changes
            if ((!this._outerMaterial || (this._outerMaterial !== this.outerMaterial)) ||
                (!this._innerMaterial || (this._innerMaterial !== this.innerMaterial)) ||
                (!this._capMaterial || (this._capMaterial !== this.capMaterial)) ||
                (!this._silhouetteMaterial || (this._silhouetteMaterial !== this.silhouetteMaterial))) {

                this._outerMaterial = this.outerMaterial || new ColorMaterial();
                this._innerMaterial = this.innerMaterial || new ColorMaterial();
                this._capMaterial = this.capMaterial || new ColorMaterial();
                this._silhouetteMaterial = this.silhouetteMaterial || new ColorMaterial();

                var material = this._combineMaterials();
                this._drawUniforms = combine(this._uniforms, material._uniforms);

                var fsSource =
                    "#line 0\n" +
                    ShadersNoise +
                    "#line 0\n" +
                    ShadersRay +
                    "#line 0\n" +
                    ShadersConstructiveSolidGeometry +
                    "#line 0\n" +
                    ShadersSensorVolume +
                    "#line 0\n" +
                    material._getShaderSource() +
                    "#line 0\n" +
                    ComplexConicSensorVolumeFS;

                this._sp = this._sp && this._sp.release();
                this._sp = context.getShaderCache().getShaderProgram(ComplexConicSensorVolumeVS, fsSource, attributeIndices);
            }

            // Initial render state creation
            this._rs = this._rs || context.createRenderState({
                cull : {
                    enabled : true,
                    face : CullFace.FRONT
                },
                blending : {
                    enabled : true,
                    equationRgb : BlendEquation.ADD,
                    equationAlpha : BlendEquation.ADD,
                    functionSourceRgb : BlendFunction.SOURCE_ALPHA,
                    functionSourceAlpha : BlendFunction.SOURCE_ALPHA,
                    functionDestinationRgb : BlendFunction.ONE_MINUS_SOURCE_ALPHA,
                    functionDestinationAlpha : BlendFunction.ONE_MINUS_SOURCE_ALPHA
                }
            // Does not read or write depth
            });
        }
    };

    /**
     * DOC_TBA
     * @memberof ComplexConicSensorVolume
     */
    ComplexConicSensorVolume.prototype.render = function(context) {
        if (this.show) {
            context.draw({
                primitiveType : PrimitiveType.TRIANGLES,
                shaderProgram : this._sp,
                uniformMap : this._drawUniforms,
                vertexArray : this._va,
                renderState : this._rs
            });
        }
    };

    /**
     * DOC_TBA
     * @memberof ComplexConicSensorVolume
     */
    ComplexConicSensorVolume.prototype.updateForPick = function(context) {
        if (this.show) {
            // Since this ignores all other materials, if a material does discard, the sensor will still be picked.
            var fsSource =
                "#define RENDER_FOR_PICK 1\n" +
                "#line 0\n" +
                ShadersRay +
                "#line 0\n" +
                ShadersConstructiveSolidGeometry +
                "#line 0\n" +
                ShadersSensorVolume +
                "#line 0\n" +
                ComplexConicSensorVolumeFS;

            this._spPick = context.getShaderCache().getShaderProgram(ComplexConicSensorVolumeVS, fsSource, attributeIndices);
            this._pickId = context.createPickId(this);

            var that = this;
            this._pickUniforms = combine(this._uniforms, {
                u_pickColor : function() {
                    return that._pickId.normalizedRgba;
                }
            });

            this.updateForPick = function(context) {
            };
        }
    };

    /**
     * DOC_TBA
     * @memberof ComplexConicSensorVolume
     */
    ComplexConicSensorVolume.prototype.renderForPick = function(context, framebuffer) {
        if (this.show) {
            context.draw({
                primitiveType : PrimitiveType.TRIANGLES,
                shaderProgram : this._spPick,
                uniformMap : this._pickUniforms,
                vertexArray : this._va,
                renderState : this._rs,
                framebuffer : framebuffer
            });
        }
    };

    /**
     * DOC_TBA
     * @memberof ComplexConicSensorVolume
     */
    ComplexConicSensorVolume.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * DOC_TBA
     * @memberof ComplexConicSensorVolume
     */
    ComplexConicSensorVolume.prototype.destroy = function() {
        this._va = this._va && this._va.destroy();
        this._sp = this._sp && this._sp.release();
        this._spPick = this._spPick && this._spPick.release();
        this._pickId = this._pickId && this._pickId.destroy();
        return destroyObject(this);
    };

    return ComplexConicSensorVolume;
});

/*global define*/
define('Scene/CustomSensorVolume',[
        '../Core/DeveloperError',
        '../Core/combine',
        '../Core/destroyObject',
        '../Core/FAR',
        '../Core/Math',
        '../Core/Cartesian3',
        '../Core/Matrix4',
        '../Core/ComponentDatatype',
        '../Core/PrimitiveType',
        '../Renderer/BufferUsage',
        '../Renderer/BlendEquation',
        '../Renderer/BlendFunction',
        './ColorMaterial',
        '../Shaders/Noise',
        '../Shaders/Ray',
        '../Shaders/ConstructiveSolidGeometry',
        '../Shaders/SensorVolume',
        '../Shaders/CustomSensorVolumeVS',
        '../Shaders/CustomSensorVolumeFS'
    ], function(
        DeveloperError,
        combine,
        destroyObject,
        FAR,
        CesiumMath,
        Cartesian3,
        Matrix4,
        ComponentDatatype,
        PrimitiveType,
        BufferUsage,
        BlendEquation,
        BlendFunction,
        ColorMaterial,
        ShadersNoise,
        ShadersRay,
        ShadersConstructiveSolidGeometry,
        ShadersSensorVolume,
        CustomSensorVolumeVS,
        CustomSensorVolumeFS) {
    
    /*global Float32Array*/

    var attributeIndices = {
        position : 0,
        normal : 1
    };

    /**
     * DOC_TBA
     *
     * @name CustomSensorVolume
     * @constructor
     *
     * @see SensorVolumeCollection#addCustom
     */
    function CustomSensorVolume(template) {
        var t = template || {};

        this._va = undefined;
        this._sp = undefined;
        this._rs = undefined;

        this._spPick = undefined;
        this._pickId = undefined;
        this._pickIdThis = t._pickIdThis || this;

        /**
         * <code>true</code> if this sensor will be shown; otherwise, <code>false</code>
         *
         * @type Boolean
         *
         * @see CustomSensorVolume#showIntersection
         */
        this.show = (typeof t.show === "undefined") ? true : t.show;

        /**
         * DOC_TBA
         *
         * @type Boolean
         *
         * @see CustomSensorVolume#show
         */
        this.showIntersection = (typeof t.showIntersection === "undefined") ? true : t.showIntersection;

        /**
         * The 4x4 transformation matrix that transforms this sensor from model to world coordinates.  In it's model
         * coordinates, the sensor's principal direction is along the positive z-axis.  The clock angle, sometimes
         * called azimuth, is the angle in the sensor's X-Y plane measured from the positive X-axis toward the positive
         * Y-axis.  The cone angle, sometimes called elevation, is the angle out of the X-Y plane along the positive Z-axis.
         * This matrix is available to GLSL vertex and fragment shaders via
         * {@link agi_model} and derived uniforms.
         * <br /><br />
         * <div align="center">
         * <img src="images/CustomSensorVolume.setModelMatrix.png" /><br />
         * Model coordinate system for a custom sensor
         * </div>
         *
         * @type Matrix4
         *
         * @see agi_model
         *
         * @example
         * // The sensor's vertex is located on the surface at -75.59777 degrees longitude and 40.03883 degrees latitude.
         * // The sensor's opens upward, along the surface normal.
         * var center = ellipsoid.cartographicDegreesToCartesian(new Cartographic2(-75.59777, 40.03883));
         * sensor.modelMatrix = Transforms.eastNorthUpToFixedFrame(center);
         */
        this.modelMatrix = t.modelMatrix || Matrix4.getIdentity();

        /**
         * DOC_TBA
         *
         * @type BufferUsage
         */
        this.bufferUsage = t.bufferUsage || BufferUsage.STATIC_DRAW;
        this._bufferUsage = t.bufferUsage || BufferUsage.STATIC_DRAW;

        /**
         * DOC_TBA
         *
         * @type Number
         */
        this.radius = (typeof t.radius === "undefined") ? Number.POSITIVE_INFINITY : t.radius;

        this._directions = undefined;
        this._directionsDirty = false;
        this.setDirections(t.directions);

        /**
         * DOC_TBA
         */
        this.material = t.material || new ColorMaterial();
        this._material = undefined;

        /**
         * DOC_TBA
         */
        this.intersectionColor = t.intersectionColor || {
            red : 1.0,
            green : 1.0,
            blue : 0.0,
            alpha : 1.0
        };

        /**
         * DOC_TBA
         *
         * @type Number
         */
        this.erosion = (typeof t.erosion === "undefined") ? 1.0 : t.erosion;

        var that = this;
        this._uniforms = {
            u_model : function() {
                return that.modelMatrix;
            },
            u_showIntersection : function() {
                return that.showIntersection;
            },
            u_sensorRadius : function() {
                return that.radius;
            },
            u_intersectionColor : function() {
                return that.intersectionColor;
            },
            u_erosion : function() {
                return that.erosion;
            }
        };
        this._drawUniforms = null;
        this._pickUniforms = null;
    }

    /**
     * DOC_TBA
     *
     * @memberof CustomSensorVolume
     *
     * @see CustomSensorVolume#getDirections
     */
    CustomSensorVolume.prototype.setDirections = function(directions) {
        this._directions = directions;
        this._directionsDirty = true;
    };

    /**
     * DOC_TBA
     *
     * @memberof CustomSensorVolume
     *
     * @see CustomSensorVolume#setDirections
     */
    CustomSensorVolume.prototype.getDirections = function() {
        return this._directions;
    };

    CustomSensorVolume._toCartesian = function(direction) {
        var sinTheta = Math.sin(direction.cone);
        return new Cartesian3(
                sinTheta * Math.cos(direction.clock),
                sinTheta * Math.sin(direction.clock),
                Math.cos(direction.cone));
    };

    CustomSensorVolume._computePositions = function(directions, radius) {
        var length = directions.length;
        var positions = new Float32Array(3 * length);
        var r = isFinite(radius) ? radius : FAR;

        for ( var i = length - 2, j = length - 1, k = 0; k < length; i = j++, j = k++) {
            // PERFORMANCE_IDEA:  We can avoid redundant operations for adjacent edges.
            var n0 = CustomSensorVolume._toCartesian(directions[i]);
            var n1 = CustomSensorVolume._toCartesian(directions[j]);
            var n2 = CustomSensorVolume._toCartesian(directions[k]);

            // Extend position so the volume encompasses the sensor's radius.
            var theta = Math.max(CesiumMath.angleBetween(n0, n1), CesiumMath.angleBetween(n1, n2));
            var distance = r / Math.cos(theta * 0.5);
            var p = n1.multiplyWithScalar(distance);

            positions[(j * 3) + 0] = p.x;
            positions[(j * 3) + 1] = p.y;
            positions[(j * 3) + 2] = p.z;
        }

        return positions;
    };

    CustomSensorVolume._createVertexArray = function(context, directions, radius, bufferUsage) {
        var positions = this._computePositions(directions, radius);

        var length = directions.length;
        var vertices = new Float32Array(2 * 3 * 3 * length);

        var k = 0;
        for ( var i = length - 1, j = 0; j < length; i = j++) {
            var p0 = new Cartesian3(positions[(i * 3) + 0], positions[(i * 3) + 1], positions[(i * 3) + 2]);
            var p1 = new Cartesian3(positions[(j * 3) + 0], positions[(j * 3) + 1], positions[(j * 3) + 2]);
            var n = p1.cross(p0).normalize(); // Per-face normals

            vertices[k++] = 0.0; // Sensor vertex
            vertices[k++] = 0.0;
            vertices[k++] = 0.0;
            vertices[k++] = n.x;
            vertices[k++] = n.y;
            vertices[k++] = n.z;

            vertices[k++] = p1.x;
            vertices[k++] = p1.y;
            vertices[k++] = p1.z;
            vertices[k++] = n.x;
            vertices[k++] = n.y;
            vertices[k++] = n.z;

            vertices[k++] = p0.x;
            vertices[k++] = p0.y;
            vertices[k++] = p0.z;
            vertices[k++] = n.x;
            vertices[k++] = n.y;
            vertices[k++] = n.z;
        }

        var vertexBuffer = context.createVertexBuffer(new Float32Array(vertices), bufferUsage);
        var stride = 2 * 3 * Float32Array.BYTES_PER_ELEMENT;

        var attributes = [{
            index : attributeIndices.position,
            vertexBuffer : vertexBuffer,
            componentsPerAttribute : 3,
            componentDatatype : ComponentDatatype.FLOAT,
            offsetInBytes : 0,
            strideInBytes : stride
        }, {
            index : attributeIndices.normal,
            vertexBuffer : vertexBuffer,
            componentsPerAttribute : 3,
            componentDatatype : ComponentDatatype.FLOAT,
            offsetInBytes : 3 * Float32Array.BYTES_PER_ELEMENT,
            strideInBytes : stride
        }];

        return context.createVertexArray(attributes);
    };

    /**
     * DOC_TBA
     *
     * @memberof CustomSensorVolume
     *
     * @exception {DeveloperError} this.radius must be greater than or equal to zero.
     */
    CustomSensorVolume.prototype.update = function(context, sceneState) {
        if (this.radius < 0.0) {
            throw new DeveloperError("this.radius must be greater than or equal to zero.");
        }

        if (this.show) {
            // Initial render state creation
            if (!this._rs) {
                this._rs = context.createRenderState({
                    blending : {
                        enabled : true,
                        equationRgb : BlendEquation.ADD,
                        equationAlpha : BlendEquation.ADD,
                        functionSourceRgb : BlendFunction.SOURCE_ALPHA,
                        functionSourceAlpha : BlendFunction.SOURCE_ALPHA,
                        functionDestinationRgb : BlendFunction.ONE_MINUS_SOURCE_ALPHA,
                        functionDestinationAlpha : BlendFunction.ONE_MINUS_SOURCE_ALPHA
                    },
                    depthTest : {
                        enabled : true
                    },
                    depthMask : false
                });
            }

            // Recompile shader when material changes
            if (!this._material || (this._material !== this.material)) {
                this._material = this.material || new ColorMaterial();

                var fsSource =
                    "#line 0\n" +
                    ShadersNoise +
                    "#line 0\n" +
                    ShadersRay +
                    "#line 0\n" +
                    ShadersConstructiveSolidGeometry +
                    "#line 0\n" +
                    ShadersSensorVolume +
                    "#line 0\n" +
                    this.material._getShaderSource() +
                    "#line 0\n" +
                    CustomSensorVolumeFS;

                this._sp = this._sp && this._sp.release();
                this._sp = context.getShaderCache().getShaderProgram(CustomSensorVolumeVS, fsSource, attributeIndices);

                this._drawUniforms = combine(this._uniforms, this.material._uniforms);
            }

            // Recreate vertex buffer when directions change
            if ((this._directionsDirty) || (this._bufferUsage.value !== this.bufferUsage.value)) {
                this._directionsDirty = false;
                this._bufferUsage = this.bufferUsage;
                this._va = this._va && this._va.destroy();

                var directions = this._directions;
                if (directions && (directions.length >= 3)) {
                    this._va = CustomSensorVolume._createVertexArray(context, directions, this.radius, this.bufferUsage);
                }
            }
        }
    };

    /**
     * DOC_TBA
     * @memberof CustomSensorVolume
     */
    CustomSensorVolume.prototype.render = function(context) {
        if (this.show && this._va) {
            context.draw({
                primitiveType : PrimitiveType.TRIANGLES,
                shaderProgram : this._sp,
                uniformMap : this._drawUniforms,
                vertexArray : this._va,
                renderState : this._rs
            });
        }
    };

    /**
     * DOC_TBA
     * @memberof CustomSensorVolume
     */
    CustomSensorVolume.prototype.updateForPick = function(context) {
        if (this.show && this._va) {
            // Since this ignores all other materials, if a material does discard, the sensor will still be picked.
            var fsSource =
                "#define RENDER_FOR_PICK 1\n" +
                "#line 0\n" +
                ShadersRay +
                "#line 0\n" +
                ShadersConstructiveSolidGeometry +
                "#line 0\n" +
                ShadersSensorVolume +
                "#line 0\n" +
                CustomSensorVolumeFS;

            this._spPick = context.getShaderCache().getShaderProgram(CustomSensorVolumeVS, fsSource, attributeIndices);
            this._pickId = context.createPickId(this._pickIdThis);

            var that = this;
            this._pickUniforms = combine(this._uniforms, {
                u_pickColor : function() {
                    return that._pickId.normalizedRgba;
                }
            });

            this.updateForPick = function(context) {
            };
        }
    };

    /**
     * DOC_TBA
     * @memberof CustomSensorVolume
     */
    CustomSensorVolume.prototype.renderForPick = function(context, framebuffer) {
        if (this.show && this._va) {
            context.draw({
                primitiveType : PrimitiveType.TRIANGLES,
                shaderProgram : this._spPick,
                uniformMap : this._pickUniforms,
                vertexArray : this._va,
                renderState : this._rs,
                framebuffer : framebuffer
            });
        }
    };

    /**
     * DOC_TBA
     * @memberof CustomSensorVolume
     */
    CustomSensorVolume.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * DOC_TBA
     * @memberof CustomSensorVolume
     */
    CustomSensorVolume.prototype.destroy = function() {
        this._va = this._va && this._va.destroy();
        this._sp = this._sp && this._sp.release();
        this._spPick = this._spPick && this._spPick.release();
        this._pickId = this._pickId && this._pickId.destroy();
        return destroyObject(this);
    };

    return CustomSensorVolume;
});

/*global define*/
define('Scene/RectangularPyramidSensorVolume',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/Math',
        '../Core/Matrix4',
        '../Renderer/BufferUsage',
        './ColorMaterial',
        './CustomSensorVolume'
    ], function(
        DeveloperError,
        destroyObject,
        CesiumMath,
        Matrix4,
        BufferUsage,
        ColorMaterial,
        CustomSensorVolume) {
    

    /**
     * DOC_TBA
     *
     * @name RectangularPyramidSensorVolume
     * @constructor
     *
     * @see SensorVolumeCollection#addRectangularPyramid
     */
    function RectangularPyramidSensorVolume(template) {
        var t = template || {};

        /**
         * <code>true</code> if this sensor will be shown; otherwise, <code>false</code>
         *
         * @type Boolean
         *
         * @see RectangularPyramidSensorVolume#showIntersection
         */
        this.show = (typeof t.show === "undefined") ? true : t.show;

        /**
         * DOC_TBA
         *
         * @type Boolean
         *
         * @see RectangularPyramidSensorVolume#show
         */
        this.showIntersection = (typeof t.showIntersection === "undefined") ? true : t.showIntersection;

        /**
         * The 4x4 transformation matrix that transforms this sensor from model to world coordinates.  In it's model
         * coordinates, the sensor's principal direction is along the positive z-axis.  Half angles measured from the
         * principal direction and in the direction of the x-axis and y-axis define the extent of the rectangular
         * cross section.  This matrix is available to GLSL vertex and fragment shaders via
         * {@link agi_model} and derived uniforms.
         * <br /><br />
         * <div align="center">
         * <img src="images/RectangularPyramidSensorVolume.setModelMatrix.png" /><br />
         * Model coordinate system for a sensor
         * </div>
         *
         * @type Matrix4
         *
         * @see agi_model
         *
         * @example
         * // The sensor's vertex is located on the surface at -75.59777 degrees longitude and 40.03883 degrees latitude.
         * // The sensor's opens upward, along the surface normal.
         * var center = ellipsoid.cartographicDegreesToCartesian(new Cartographic2(-75.59777, 40.03883));
         * sensor.modelMatrix = Transforms.eastNorthUpToFixedFrame(center);
         */
        this.modelMatrix = t.modelMatrix || Matrix4.getIdentity();

        /**
         * DOC_TBA
         *
         * @type BufferUsage
         */
        this.bufferUsage = t.bufferUsage || BufferUsage.STATIC_DRAW;

        /**
         * DOC_TBA
         *
         * @type Number
         */
        this.radius = (typeof t.radius === "undefined") ? Number.POSITIVE_INFINITY : t.radius;

        /**
         * DOC_TBA
         *
         * @type Number
         *
         * @see RectangularPyramidSensorVolume#yHalfAngle
         */
        this.xHalfAngle = (typeof t.xHalfAngle === "undefined") ? CesiumMath.PI_OVER_TWO : t.xHalfAngle;
        this._xHalfAngle = undefined;

        /**
         * DOC_TBA
         *
         * @type Number
         *
         * @see RectangularPyramidSensorVolume#xHalfAngle
         */
        this.yHalfAngle = (typeof t.yHalfAngle === "undefined") ? CesiumMath.PI_OVER_TWO : t.yHalfAngle;
        this._yHalfAngle = undefined;

        /**
         * DOC_TBA
         */
        this.material = t.material || new ColorMaterial();

        /**
         * DOC_TBA
         */
        this.intersectionColor = t.intersectionColor || {
            red : 1.0,
            green : 1.0,
            blue : 0.0,
            alpha : 1.0
        };

        /**
         * DOC_TBA
         *
         * @type Number
         */
        this.erosion = (typeof t.erosion === "undefined") ? 1.0 : t.erosion;

        t._pickIdThis = t._pickIdThis || this;
        this._customSensor = new CustomSensorVolume(t);
    }

    /**
     * DOC_TBA
     *
     * @memberof RectangularPyramidSensorVolume
     *
     * @exception {DeveloperError} this.xHalfAngle and this.yHalfAngle must each be less than 90 degrees.
     * @exception {DeveloperError} this.radius must be greater than or equal to zero.
     */
    RectangularPyramidSensorVolume.prototype.update = function(context, sceneState) {
        if ((this.xHalfAngle > CesiumMath.PI_OVER_TWO) || (this.yHalfAngle > CesiumMath.PI_OVER_TWO)) {
            throw new DeveloperError("this.xHalfAngle and this.yHalfAngle must each be less than or equal to 90 degrees.");
        }

        var s = this._customSensor;

        s.show = this.show;
        s.showIntersection = this.showIntersection;
        s.modelMatrix = this.modelMatrix;
        s.bufferUsage = this.bufferUsage;
        s.radius = this.radius;
        s.material = this.material;
        s.intersectionColor = this.intersectionColor;
        s.erosion = this.erosion;

        if ((this._xHalfAngle !== this.xHalfAngle) || (this._yHalfAngle !== this.yHalfAngle)) {

            this._xHalfAngle = this.xHalfAngle;
            this._yHalfAngle = this.yHalfAngle;

            // At 90 degrees the sensor is completely open, and tan() goes to infinity.
            var tanX = Math.tan(Math.min(this.xHalfAngle, CesiumMath.toRadians(89.0)));
            var tanY = Math.tan(Math.min(this.yHalfAngle, CesiumMath.toRadians(89.0)));
            var theta = Math.atan(tanX / tanY);
            var cone = Math.atan(Math.sqrt(tanX * tanX + tanY * tanY));

            s.setDirections([{
                clock : theta,
                cone : cone
            }, {
                clock : CesiumMath.toRadians(180.0) - theta,
                cone : cone
            }, {
                clock : CesiumMath.toRadians(180.0) + theta,
                cone : cone
            }, {
                clock : -theta,
                cone : cone
            }]);
        }

        s.update(context, sceneState);
    };

    /**
     * DOC_TBA
     * @memberof RectangularPyramidSensorVolume
     */
    RectangularPyramidSensorVolume.prototype.render = function(context) {
        this._customSensor.render(context);
    };

    /**
     * DOC_TBA
     * @memberof RectangularPyramidSensorVolume
     */
    RectangularPyramidSensorVolume.prototype.updateForPick = function(context) {
        this._customSensor.updateForPick(context);
    };

    /**
     * DOC_TBA
     * @memberof RectangularPyramidSensorVolume
     */
    RectangularPyramidSensorVolume.prototype.renderForPick = function(context, framebuffer) {
        this._customSensor.renderForPick(context, framebuffer);
    };

    /**
     * DOC_TBA
     * @memberof RectangularPyramidSensorVolume
     */
    RectangularPyramidSensorVolume.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * DOC_TBA
     * @memberof RectangularPyramidSensorVolume
     */
    RectangularPyramidSensorVolume.prototype.destroy = function() {
        this._customSensor = this._customSensor && this._customSensor.destroy();
        return destroyObject(this);
    };

    return RectangularPyramidSensorVolume;
});
/*global define*/
define('Scene/SensorVolumeCollection',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        './ComplexConicSensorVolume',
        './CustomSensorVolume',
        './RectangularPyramidSensorVolume'
    ], function(
        DeveloperError,
        destroyObject,
        ComplexConicSensorVolume,
        CustomSensorVolume,
        RectangularPyramidSensorVolume) {
    

    /**
     * DOC_TBA
     *
     * @name SensorVolumeCollection
     * @constructor
     */
    function SensorVolumeCollection() {
        this._sensors = [];
    }

    /**
     * DOC_TBA
     *
     * @memberof SensorVolumeCollection
     *
     * @see SensorVolumeCollection#addCustom
     * @see SensorVolumeCollection#addComplexConic
     */
    SensorVolumeCollection.prototype.addRectangularPyramid = function(template) {
        var sensor = new RectangularPyramidSensorVolume(template);
        this._sensors.push(sensor);
        return sensor;
    };

    /**
     * DOC_TBA
     *
     * @memberof SensorVolumeCollection
     *
     * @see SensorVolumeCollection#addRectangularPyramid
     * @see SensorVolumeCollection#addCustom
     */
    SensorVolumeCollection.prototype.addComplexConic = function(template) {
        var sensor = new ComplexConicSensorVolume(template);
        this._sensors.push(sensor);
        return sensor;
    };

    /**
     * DOC_TBA
     *
     * @memberof SensorVolumeCollection
     *
     * @see SensorVolumeCollection#addRectangularPyramid
     * @see SensorVolumeCollection#addComplexConic
     */
    SensorVolumeCollection.prototype.addCustom = function(template) {
        var sensor = new CustomSensorVolume(template);
        this._sensors.push(sensor);
        return sensor;
    };

    /**
     * DOC_TBA
     *
     * @memberof SensorVolumeCollection
     *
     * @see SensorVolumeCollection#removeAll
     */
    SensorVolumeCollection.prototype.remove = function(sensor) {
        if (sensor) {
            var sensors = this._sensors;
            var i = sensors.indexOf(sensor);
            if (i !== -1) {
                sensors[i].destroy();
                sensors.splice(i, 1);
                return true;
            }
        }

        return false;
    };

    /**
     * DOC_TBA
     *
     * @memberof SensorVolumeCollection
     *
     * @see SensorVolumeCollection#remove
     */
    SensorVolumeCollection.prototype.removeAll = function() {
        var sensors = this._sensors;
        var length = sensors.length;
        for ( var i = 0; i < length; ++i) {
            sensors[i].destroy();
        }

        this._sensors = [];
    };

    /**
     * DOC_TBA
     * @memberof SensorVolumeCollection
     */
    SensorVolumeCollection.prototype.contains = function(sensor) {
        if (sensor) {
            return (this._sensors.indexOf(sensor) !== -1);
        }

        return false;
    };

    /**
     * DOC_TBA
     *
     * @memberof SensorVolumeCollection
     *
     * @see SensorVolumeCollection#getLength
     */
    SensorVolumeCollection.prototype.get = function(index) {
        if (typeof index === "undefined") {
            throw new DeveloperError("index is required.", "index");
        }

        return this._sensors[index];
    };

    /**
     * DOC_TBA
     *
     * @memberof SensorVolumeCollection
     *
     * @see SensorVolumeCollection#get
     */
    SensorVolumeCollection.prototype.getLength = function() {
        return this._sensors.length;
    };

    /**
     * @private
     */
    SensorVolumeCollection.prototype.update = function(context, sceneState) {
        var sensors = this._sensors;
        var length = sensors.length;
        for ( var i = 0; i < length; ++i) {
            sensors[i].update(context, sceneState);
        }
    };

    /**
     * @private
     */
    SensorVolumeCollection.prototype.render = function(context) {
        var sensors = this._sensors;
        var length = sensors.length;
        for ( var i = 0; i < length; ++i) {
            sensors[i].render(context);
        }
    };

    /**
     * @private
     */
    SensorVolumeCollection.prototype.updateForPick = function(context) {
        var sensors = this._sensors;
        var length = sensors.length;
        for ( var i = 0; i < length; ++i) {
            sensors[i].updateForPick(context);
        }
    };

    /**
     * @private
     */
    SensorVolumeCollection.prototype.renderForPick = function(context, framebuffer) {
        var sensors = this._sensors;
        var length = sensors.length;
        for ( var i = 0; i < length; ++i) {
            sensors[i].renderForPick(context, framebuffer);
        }
    };

    /**
     * DOC_TBA
     * @memberof SensorVolumeCollection
     */
    SensorVolumeCollection.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * DOC_TBA
     * @memberof SensorVolumeCollection
     */
    SensorVolumeCollection.prototype.destroy = function() {
        this.removeAll();
        return destroyObject(this);
    };

    return SensorVolumeCollection;
});
/*!
 * Copyright (c) 2000-2005, Sean O'Neil (s_p_oneil@hotmail.com)
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * * Neither the name of the project nor the names of its contributors may be
 *   used to endorse or promote products derived from this software without
 *   specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Modifications made by Analytical Graphics, Inc.
 */
/*global define*/
define('Shaders/SkyAtmosphereFS',[],function() {
  
  return "uniform float g;\n" +
"uniform float g2;\n" +
"varying vec3 v_rayleighColor;\n" +
"varying vec3 v_mieColor;\n" +
"varying vec3 v_toCamera;\n" +
"varying vec3 v_positionEC;\n" +
"void main (void)\n" +
"{\n" +
"agi_ellipsoid ellipsoid = agi_getWgs84EllipsoidEC();\n" +
"vec3 direction = normalize(v_positionEC);\n" +
"agi_ray ray = agi_ray(vec3(0.0, 0.0, 0.0), direction);\n" +
"agi_raySegment intersection = agi_rayEllipsoidIntersectionInterval(ray, ellipsoid);\n" +
"if (!agi_isEmpty(intersection)) {\n" +
"discard;\n" +
"}\n" +
"float fCos = dot(agi_sunDirectionWC, normalize(v_toCamera)) / length(v_toCamera);\n" +
"float fRayleighPhase = 0.75 * (1.0 + fCos*fCos);\n" +
"float fMiePhase = 1.5 * ((1.0 - g2) / (2.0 + g2)) * (1.0 + fCos*fCos) / pow(1.0 + g2 - 2.0*g*fCos, 1.5);\n" +
"const float fExposure = 2.0;\n" +
"vec3 rgb = fRayleighPhase * v_rayleighColor + fMiePhase * v_mieColor;\n" +
"gl_FragColor = vec4(vec3(1.0) - exp(-fExposure * rgb), 1.0);\n" +
"}\n" +
"";
});
/*!
 * Copyright (c) 2000-2005, Sean O'Neil (s_p_oneil@hotmail.com)
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * * Neither the name of the project nor the names of its contributors may be
 *   used to endorse or promote products derived from this software without
 *   specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Modifications made by Analytical Graphics, Inc.
 */
/*global define*/
define('Shaders/SkyAtmosphereVS',[],function() {
  
  return "attribute vec4 position;\n" +
"uniform float fCameraHeight;\n" +
"uniform float fCameraHeight2;\n" +
"uniform vec3 v3InvWavelength;\n" +
"uniform float fOuterRadius;\n" +
"uniform float fOuterRadius2;\n" +
"uniform float fInnerRadius;\n" +
"uniform float fInnerRadius2;\n" +
"uniform float fKrESun;\n" +
"uniform float fKmESun;\n" +
"uniform float fKr4PI;\n" +
"uniform float fKm4PI;\n" +
"uniform float fScale;\n" +
"uniform float fScaleDepth;\n" +
"uniform float fScaleOverScaleDepth;\n" +
"const int nSamples = 2;\n" +
"const float fSamples = 2.0;\n" +
"varying vec3 v_rayleighColor;\n" +
"varying vec3 v_mieColor;\n" +
"varying vec3 v_toCamera;\n" +
"varying vec3 v_positionEC;\n" +
"float scale(float fCos)\n" +
"{\n" +
"float x = 1.0 - fCos;\n" +
"return fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\n" +
"}\n" +
"void main(void)\n" +
"{\n" +
"vec3 v3Pos = position.xyz;\n" +
"vec3 v3Ray = v3Pos - agi_viewerPositionWC;\n" +
"float fFar = length(v3Ray);\n" +
"v3Ray /= fFar;\n" +
"#ifdef SKY_FROM_SPACE\n" +
"float B = 2.0 * dot(agi_viewerPositionWC, v3Ray);\n" +
"float C = fCameraHeight2 - fOuterRadius2;\n" +
"float fDet = max(0.0, B*B - 4.0 * C);\n" +
"float fNear = 0.5 * (-B - sqrt(fDet));\n" +
"vec3 v3Start = agi_viewerPositionWC + v3Ray * fNear;\n" +
"fFar -= fNear;\n" +
"float fStartAngle = dot(v3Ray, v3Start) / fOuterRadius;\n" +
"float fStartDepth = exp(-1.0 / fScaleDepth);\n" +
"float fStartOffset = fStartDepth*scale(fStartAngle);\n" +
"#else\n" +
"vec3 v3Start = agi_viewerPositionWC;\n" +
"float fHeight = length(v3Start);\n" +
"float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fCameraHeight));\n" +
"float fStartAngle = dot(v3Ray, v3Start) / fHeight;\n" +
"float fStartOffset = fDepth*scale(fStartAngle);\n" +
"#endif\n" +
"float fSampleLength = fFar / fSamples;\n" +
"float fScaledLength = fSampleLength * fScale;\n" +
"vec3 v3SampleRay = v3Ray * fSampleLength;\n" +
"vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\n" +
"vec3 v3FrontColor = vec3(0.0, 0.0, 0.0);\n" +
"for(int i=0; i<nSamples; i++)\n" +
"{\n" +
"float fHeight = length(v3SamplePoint);\n" +
"float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));\n" +
"float fLightAngle = dot(agi_sunDirectionWC, v3SamplePoint) / fHeight;\n" +
"float fCameraAngle = dot(v3Ray, v3SamplePoint) / fHeight;\n" +
"float fScatter = (fStartOffset + fDepth*(scale(fLightAngle) - scale(fCameraAngle)));\n" +
"vec3 v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));\n" +
"v3FrontColor += v3Attenuate * (fDepth * fScaledLength);\n" +
"v3SamplePoint += v3SampleRay;\n" +
"}\n" +
"v_mieColor = v3FrontColor * fKmESun;\n" +
"v_rayleighColor = v3FrontColor * (v3InvWavelength * fKrESun);\n" +
"v_toCamera = agi_viewerPositionWC - v3Pos;\n" +
"v_positionEC = (agi_modelView * position).xyz;\n" +
"gl_Position = agi_modelViewProjection * position;\n" +
"}\n" +
"";
});

/*global define*/
define('Shaders/TieDyeMaterial',[],function() {
  
  return "uniform vec4 u_lightColor;\n" +
"uniform vec4 u_darkColor;\n" +
"uniform float u_frequency;\n" +
"vec4 agi_getMaterialColor(float zDistance, vec2 st, vec3 str)\n" +
"{\n" +
"vec3 scaled = str / u_frequency;\n" +
"float t = abs(agi_snoise(scaled));\n" +
"return mix(u_lightColor, u_darkColor, t);\n" +
"}\n" +
"";
});
/*global define*/
define('Scene/TieDyeMaterial',[
        '../Shaders/Noise',
        '../Shaders/TieDyeMaterial'
    ], function(
        ShadersNoise,
        ShadersTieDyeMaterial){
    

    /**
     * DOC_TBA
     *
     * @name TieDyeMaterial
     * @constructor
     */
    function TieDyeMaterial(template) {
        var t = template || {};

        /**
         * DOC_TBA
         */
        this.lightColor = t.lightColor || {
            red : 1.0,
            green : 1.0,
            blue : 1.0,
            alpha : 0.5
        };

        /**
         * DOC_TBA
         */
        this.darkColor = t.darkColor || {
            red : 0.0,
            green : 0.0,
            blue : 1.0,
            alpha : 0.5
        };

        /**
         * DOC_TBA
         *
         * @type Number
         */
        this.frequency = t.frequency || (1.0 / 10.0);

        var that = this;
        this._uniforms = {
            u_lightColor : function() {
                return that.lightColor;
            },
            u_darkColor : function() {
                return that.darkColor;
            },
            u_frequency : function() {
                return that.frequency;
            }
        };
    }

    TieDyeMaterial.prototype._getShaderSource = function() {
        return "#line 0\n" +
               ShadersNoise +
               "#line 0\n" +
               ShadersTieDyeMaterial;
    };

    return TieDyeMaterial;
});

/*global define*/
define('Shaders/VerticalStripeMaterial',[],function() {
  
  return "uniform vec4 u_lightColor;\n" +
"uniform vec4 u_darkColor;\n" +
"uniform float u_offset;\n" +
"uniform float u_repeat;\n" +
"vec4 agi_getMaterialColor(float zDistance, vec2 st, vec3 str)\n" +
"{\n" +
"const float fuzz = 0.1;\n" +
"const float width = 0.5;\n" +
"float scaled = fract((st.s - u_offset) * (u_repeat * 0.5));\n" +
"float frac1 = clamp(scaled / fuzz, 0.0, 1.0);\n" +
"float frac2 = clamp((scaled - width) / fuzz, 0.0, 1.0);\n" +
"frac1 = frac1 * (1.0 - frac2);\n" +
"frac1 = frac1 * frac1 * (3.0 - (2.0 * frac1));\n" +
"return mix(u_lightColor, u_darkColor, frac1);\n" +
"}\n" +
"";
});
/*global define*/
define('Scene/VerticalStripeMaterial',['../Shaders/VerticalStripeMaterial'], function(ShadersVerticalStripeMaterial) {
    

    /**
     * DOC_TBA
     *
     * @name VerticalStripeMaterial
     * @constructor
     */
    function VerticalStripeMaterial(template) {
        var t = template || {};

        /**
         * DOC_TBA
         */
        this.lightColor = t.lightColor || {
            red : 1.0,
            green : 1.0,
            blue : 1.0,
            alpha : 0.5
        };

        /**
         * DOC_TBA
         */
        this.darkColor = t.darkColor || {
            red : 0.0,
            green : 0.0,
            blue : 1.0,
            alpha : 0.5
        };

        /**
         * DOC_TBA
         *
         * @type Number
         */
        this.offset = t.offset || 0.0;

        /**
         * DOC_TBA
         *
         * @type Number
         */
        this.repeat = t.repeat || 10.0;

        var that = this;
        this._uniforms = {
            u_lightColor : function() {
                return that.lightColor;
            },
            u_darkColor : function() {
                return that.darkColor;
            },
            u_offset : function() {
                return that.offset;
            },
            u_repeat : function() {
                return that.repeat;
            }
        };
    }

    VerticalStripeMaterial.prototype._getShaderSource = function() {
        return "#line 0\n" + ShadersVerticalStripeMaterial;
    };

    return VerticalStripeMaterial;
});

/*global define*/
define('Shaders/ViewportQuadFS',[],function() {
  
  return "uniform sampler2D u_texture;\n" +
"varying vec2 v_textureCoordinates;\n" +
"void main()\n" +
"{\n" +
"vec4 c = texture2D(u_texture, v_textureCoordinates);\n" +
"if (c.a == 0.0)\n" +
"{\n" +
"discard;\n" +
"}\n" +
"gl_FragColor = c;\n" +
"}\n" +
"";
});

/*global define*/
define('Shaders/ViewportQuadVS',[],function() {
  
  return "attribute vec4 position;\n" +
"attribute vec2 textureCoordinates;\n" +
"varying vec2 v_textureCoordinates;\n" +
"void main()\n" +
"{\n" +
"gl_Position = agi_viewportOrthographic * position;\n" +
"v_textureCoordinates = textureCoordinates;\n" +
"}\n" +
"";
});
/*global define*/
define('Scene/ViewportQuad',[
        '../Core/destroyObject',
        '../Core/Rectangle',
        '../Core/ComponentDatatype',
        '../Core/PrimitiveType',
        '../Renderer/BufferUsage',
        '../Shaders/ViewportQuadVS',
        '../Shaders/ViewportQuadFS'
    ], function(
        destroyObject,
        Rectangle,
        ComponentDatatype,
        PrimitiveType,
        BufferUsage,
        ViewportQuadVS,
        ViewportQuadFS) {
    

    /**
     * DOC_TBA
     *
     * @name ViewportQuad
     * @constructor
     */
    function ViewportQuad(rectangle) {
        this.renderState = null;
        this._sp = null;
        this._va = null;

        this.vertexShader = ViewportQuadVS;
        this.fragmentShader = ViewportQuadFS;

        this._texture = null;
        this._destroyTexture = true;

        this._framebuffer = null;
        this._destroyFramebuffer = false;

        this._rectangle = rectangle; // TODO: copy?
        this._dirtyRectangle = true;

        var that = this;
        this.uniforms = {
            u_texture : function() {
                return that._texture;
            }
        };
    }

    /**
     * DOC_TBA
     * @memberof ViewportQuad
     */
    ViewportQuad.prototype.getRectangle = function() {
        return this._rectangle;
    };

    /**
     * DOC_TBA
     *
     * @memberof ViewportQuad
     *
     * @param {Rectangle} value DOC_TBA
     */
    ViewportQuad.prototype.setRectangle = function(value) {
        if (value && !this._rectangle.equals(value)) {
            this._rectangle = new Rectangle(value.x, value.y, value.width, value.height);
            this._dirtyRectangle = true;
        }
    };

    /**
     * DOC_TBA
     * @memberof ViewportQuad
     */
    ViewportQuad.prototype.getTexture = function() {
        return this._texture;
    };

    /**
     * DOC_TBA
     * @memberof ViewportQuad
     */
    ViewportQuad.prototype.setTexture = function(value) {
        if (this._texture !== value) {
            this._texture = this._destroyTexture && this._texture && this._texture.destroy();
            this._texture = value;
        }
    };

    /**
     * DOC_TBA
     * @memberof ViewportQuad
     */
    ViewportQuad.prototype.getDestroyTexture = function() {
        return this._destroyTexture;
    };

    /**
     * DOC_TBA
     * @memberof ViewportQuad
     */
    ViewportQuad.prototype.setDestroyTexture = function(value) {
        this._destroyTexture = value;
    };

    /**
     * DOC_TBA
     * @memberof ViewportQuad
     */
    ViewportQuad.prototype.getFramebuffer = function() {
        return this._framebuffer;
    };

    /**
     * DOC_TBA
     * @memberof ViewportQuad
     */
    ViewportQuad.prototype.setFramebuffer = function(value) {
        if (this._framebuffer !== value) {
            this._framebuffer = this._destroyFramebuffer && this._framebuffer && this._framebuffer.destroy();
            this._framebuffer = value;
        }
    };

    /**
     * DOC_TBA
     * @memberof ViewportQuad
     */
    ViewportQuad.prototype.getDestroyFramebuffer = function() {
        return this._destroyFramebuffer;
    };

    /**
     * DOC_TBA
     * @memberof ViewportQuad
     */
    ViewportQuad.prototype.setDestroyFramebuffer = function(value) {
        this._destroyFramebuffer = value;
    };

    /**
     * DOC_TBA
     * @memberof ViewportQuad
     */
    ViewportQuad.prototype.render = function(context) {
        if (this._texture) {
            context.draw({
                primitiveType : PrimitiveType.TRIANGLE_FAN,
                shaderProgram : this._sp,
                uniformMap : this.uniforms,
                vertexArray : this._va,
                renderState : this.renderState,
                framebuffer : this._framebuffer
            });
        }
    };

    ViewportQuad._getAttributeIndices = function() {
        return {
            position : 0,
            textureCoordinates : 1
        };
    };

    ViewportQuad.prototype._update = function(context, sceneState) {
        if (this._dirtyRectangle) {
            this._dirtyRectangle = false;

            var rectangle = this._rectangle;
            var mesh = {
                attributes : {
                    position : {
                        componentDatatype : ComponentDatatype.FLOAT,
                        componentsPerAttribute : 2,
                        values : [rectangle.x, rectangle.y, rectangle.x + rectangle.width, rectangle.y, rectangle.x + rectangle.width, rectangle.y + rectangle.height, rectangle.x,
                                rectangle.y + rectangle.height]
                    },

                    textureCoordinates : {
                        componentDatatype : ComponentDatatype.FLOAT,
                        componentsPerAttribute : 2,
                        values : [0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0]
                    }
                }
            };

            this._va = context.createVertexArrayFromMesh({
                mesh : mesh,
                attributeIndices : ViewportQuad._getAttributeIndices(),
                bufferUsage : BufferUsage.STATIC_DRAW
            });
        }
    };

    /**
     * @private
     */
    ViewportQuad.prototype.update = function(context, sceneState) {
        this._sp = context.getShaderCache().getShaderProgram(this.vertexShader, this.fragmentShader, ViewportQuad._getAttributeIndices());
        this.renderState = context.createRenderState();

        this._update(context, sceneState);
        this.update = this._update;
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof ViewportQuad
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see ViewportQuad#destroy
     */
    ViewportQuad.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>null</code>) to the object as done in the example.
     *
     * @memberof ViewportQuad
     *
     * @return {null}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see ViewportQuad#isDestroyed
     *
     * @example
     * quad = quad && quad.destroy();
     */
    ViewportQuad.prototype.destroy = function() {
        this._va = this._va && this._va.destroy();
        this._sp = this._sp && this._sp.release();
        this._texture = this._destroyTexture && this._texture && this._texture.destroy();
        this._framebuffer = this._destroyFramebuffer && this._framebuffer && this._framebuffer.destroy();

        return destroyObject(this);
    };

    return ViewportQuad;
});
/*global define*/
define('Scene/CentralBody',[
        '../Core/DeveloperError',
        '../Core/RuntimeError',
        '../Core/combine',
        '../Core/destroyObject',
        '../Core/splice',
        '../Core/Math',
        '../Core/Intersect',
        '../Core/Occluder',
        '../Core/Ellipsoid',
        '../Core/BoundingSphere',
        '../Core/Rectangle',
        '../Core/Cache',
        '../Core/Cartesian2',
        '../Core/Cartesian3',
        '../Core/Cartesian4',
        '../Core/Cartographic2',
        '../Core/Matrix3',
        '../Core/ComponentDatatype',
        '../Core/IndexDatatype',
        '../Core/MeshFilters',
        '../Core/PrimitiveType',
        '../Core/CubeMapEllipsoidTessellator',
        '../Core/ExtentTessellator',
        '../Core/PlaneTessellator',
        '../Core/JulianDate',
        '../Renderer/BufferUsage',
        '../Renderer/CullFace',
        '../Renderer/DepthFunction',
        '../Renderer/PixelFormat',
        '../Renderer/MipmapHint',
        '../Renderer/TextureMagnificationFilter',
        '../Renderer/TextureMinificationFilter',
        '../Renderer/TextureWrap',
        './Projections',
        './Tile',
        './TileState',
        './SceneMode',
        './Texture2DPool',
        './ViewportQuad',
        '../Shaders/CentralBodyVS',
        '../Shaders/CentralBodyFS',
        '../Shaders/CentralBodyVSDepth',
        '../Shaders/CentralBodyFSDepth',
        '../Shaders/CentralBodyVSFilter',
        '../Shaders/CentralBodyFSFilter',
        '../Shaders/Ray',
        '../Shaders/ConstructiveSolidGeometry',
        '../Shaders/SkyAtmosphereFS',
        '../Shaders/SkyAtmosphereVS'
    ], function(
        DeveloperError,
        RuntimeError,
        combine,
        destroyObject,
        splice,
        CesiumMath,
        Intersect,
        Occluder,
        Ellipsoid,
        BoundingSphere,
        Rectangle,
        Cache,
        Cartesian2,
        Cartesian3,
        Cartesian4,
        Cartographic2,
        Matrix3,
        ComponentDatatype,
        IndexDatatype,
        MeshFilters,
        PrimitiveType,
        CubeMapEllipsoidTessellator,
        ExtentTessellator,
        PlaneTessellator,
        JulianDate,
        BufferUsage,
        CullFace,
        DepthFunction,
        PixelFormat,
        MipmapHint,
        TextureMagnificationFilter,
        TextureMinificationFilter,
        TextureWrap,
        Projections,
        Tile,
        TileState,
        SceneMode,
        Texture2DPool,
        ViewportQuad,
        CentralBodyVS,
        CentralBodyFS,
        CentralBodyVSDepth,
        CentralBodyFSDepth,
        CentralBodyVSFilter,
        CentralBodyFSFilter,
        ShadersRay,
        ShadersConstructiveSolidGeometry,
        SkyAtmosphereFS,
        SkyAtmosphereVS) {
    
    /*global document,Image,Uint16Array*/

    function TileTextureCachePolicy(description) {
        var desc = description || {};

        if (!desc.fetchFunc || typeof desc.fetchFunc !== "function") {
            throw new DeveloperError("description.fetchFunc is a required function.", "description.fetchFunc");
        }

        this._limit = desc.limit || 128;
        this._count = 0;
        this._fetchFunc = desc.fetchFunc;
        this._removeFunc = (typeof desc.removeFunc === "function") ? desc.removeFunc : undefined;
    }

    TileTextureCachePolicy.prototype.hit = function(object) {
        var time = new JulianDate();
        var current = object.key;
        while (current) {
            current._lastHit = time;
            current = current.parent;
        }
        return object.value;
    };

    TileTextureCachePolicy.prototype.miss = function(name, key, object) {
        var property = {
            key : key,
            value : undefined
        };

        property.value = this._fetchFunc(key);
        var lruTime = new JulianDate();
        this.hit(property);

        if (this._count < this._limit) {
            ++this._count;
            object[name] = property;
            return property.value;
        }

        var element;
        var index = '';
        var keys = Object.keys(object);
        for ( var i = 0; i < keys.length; ++i) {
            element = object[keys[i]];
            if (element.key._lastHit.isBefore(lruTime) && element.key.zoom > 2) {
                lruTime = element.key._lastHit;
                index = keys[i];
            }
        }

        element = object[index];
        if (this._removeFunc) {
            this._removeFunc(element.key);
        }
        delete object[index];

        object[name] = property;
        return property.value;
    };

    var attributeIndices = {
        position3D : 0,
        textureCoordinates : 1,
        position2D : 2
    };

    /**
     * DOC_TBA
     *
     * @param {Camera} camera DOC_TBA
     * @param {Ellipsoid} [ellipsoid=WGS84 Ellipsoid] Determines the size and shape of the central body.
     *
     * @name CentralBody
     * @constructor
     *
     * @exception {DeveloperError} camera is required.
     */
    function CentralBody(camera, ellipsoid) {
        if (!camera) {
            throw new DeveloperError("camera is required.", "camera");
        }

        ellipsoid = ellipsoid || Ellipsoid.getWgs84();

        this._ellipsoid = ellipsoid;
        this._maxExtent = {
            north : CesiumMath.PI_OVER_TWO,
            south : -CesiumMath.PI_OVER_TWO,
            west : -CesiumMath.PI,
            east : CesiumMath.PI
        };
        this._camera = camera;
        this._rootTile = new Tile({
            extent : this._maxExtent,
            zoom : 0,
            ellipsoid : ellipsoid
        });

        this._renderQueue = [];
        this._imageQueue = [];
        this._textureQueue = [];
        this._reprojectQueue = [];

        this._texturePool = undefined;
        this._textureCache = undefined;
        this._textureCacheLimit = 512; // TODO: pick appropriate cache limit

        // TODO: pick appropriate throttle limits
        this._textureThrottleLimit = 10;
        this._reprojectThrottleLimit = 10;
        this._imageThrottleLimit = 15;

        this._prefetchLimit = 1;

        this._spWithoutAtmosphere = undefined;
        this._spGroundFromSpace = undefined;
        this._spGroundFromAtmosphere = undefined;
        this._sp = undefined; // Reference to without-atmosphere, ground-from-space, or ground-from-atmosphere
        this._rsColor = undefined;

        this._spSkyFromSpace = undefined;
        this._spSkyFromAtmosphere = undefined;
        this._vaSky = undefined; // Reference to sky-from-space or sky-from-atmosphere
        this._spSky = undefined;
        this._rsSky = undefined;

        this._spDepth = undefined;
        this._vaDepth = undefined;
        this._rsDepth = undefined;

        this._quadH = undefined;
        this._quadV = undefined;

        this._fb = undefined;

        this._textureLogo = undefined;
        this.logoOffsetX = this.logoOffsetY = 0;
        this._quadLogo = undefined;

        this._dayTileProvider = undefined;
        this._nightImageSource = undefined;
        this._specularImageSource = undefined;
        this._cloudsImageSource = undefined;
        this._bumpImageSource = undefined;
        this._nightTexture = undefined;
        this._specularTexture = undefined;
        this._cloudsTexture = undefined;
        this._bumpTexture = undefined;
        this._showDay = false;
        this._showNight = false;
        this._showClouds = false;
        this._showCloudShadows = false;
        this._showSpecular = false;
        this._showBumps = false;
        this._showTerminator = false;

        this.refineFunc = this.refine;
        this.pixelError3D = 5.0;
        this.pixelError2D = 2.0;

        this.show = true;
        this.showGroundAtmosphere = false;
        this.showSkyAtmosphere = false;

        this.dayTileProvider = undefined;
        this.nightImageSource = undefined;
        this.specularImageSource = undefined;
        this.cloudsImageSource = undefined;
        this.bumpImageSource = undefined;
        this.showDay = true;
        this.showNight = true;
        this.showClouds = true;
        this.showCloudShadows = true;
        this.showSpecular = true;
        this.showBumps = true;

        this.bumpMapNormalZ = 0.5;
        this.dayNightBlendDelta = 0.05;
        this.showTerminator = false;
        this.nightIntensity = 2.0;
        this.morphTime = 1.0;

        this._mode = SceneMode.SCENE3D;
        this._projection = undefined;

        this._fCameraHeight = undefined;
        this._fCameraHeight2 = undefined;
        this._outerRadius = ellipsoid.getRadii().multiplyWithScalar(1.025).getMaximumComponent();

        // TODO: Do we want to expose any of these atmosphere constants?
        var Kr = 0.0025;
        var Kr4PI = Kr * 4.0 * Math.PI;
        var Km = 0.0015;
        var Km4PI = Km * 4.0 * Math.PI;
        var ESun = 15.0;
        var g = -0.95;
        var innerRadius = ellipsoid.getRadii().getMaximumComponent();
        var rayleighScaleDepth = 0.25;
        var inverseWaveLength = {
            x : 1.0 / Math.pow(0.650, 4.0), // Red
            y : 1.0 / Math.pow(0.570, 4.0), // Green
            z : 1.0 / Math.pow(0.475, 4.0) // Blue
        };

        this._minGroundFromAtmosphereHeight = 6378500.0; // from experimentation / where shader fails due to precision errors
        this._startFadeGroundFromAtmosphere = this._minGroundFromAtmosphereHeight + 1000;

        var that = this;

        var atmosphereUniforms = {
            v3InvWavelength : function() {
                return inverseWaveLength;
            },
            fCameraHeight : function() {
                return that._fCameraHeight;
            },
            fCameraHeight2 : function() {
                return that._fCameraHeight2;
            },
            fOuterRadius : function() {
                return that._outerRadius;
            },
            fOuterRadius2 : function() {
                return that._outerRadius * that._outerRadius;
            },
            fInnerRadius : function() {
                return innerRadius;
            },
            fInnerRadius2 : function() {
                return innerRadius * innerRadius;
            },
            fKrESun : function() {
                return Kr * ESun;
            },
            fKmESun : function() {
                return Km * ESun;
            },
            fKr4PI : function() {
                return Kr4PI;
            },
            fKm4PI : function() {
                return Km4PI;
            },
            fScale : function() {
                return 1.0 / (that._outerRadius - innerRadius);
            },
            fScaleDepth : function() {
                return rayleighScaleDepth;
            },
            fScaleOverScaleDepth : function() {
                return (1.0 / (that._outerRadius - innerRadius)) / rayleighScaleDepth;
            },
            g : function() {
                return g;
            },
            g2 : function() {
                return g * g;
            },
            fMinGroundFromAtmosphereHeight : function() {
                return that._minGroundFromAtmosphereHeight;
            },
            fstartFadeGroundFromAtmosphere : function() {
                return that._startFadeGroundFromAtmosphere;
            }
        };

        var uniforms = {
            u_nightTexture : function() {
                return that._nightTexture;
            },
            u_cloudMap : function() {
                return that._cloudsTexture;
            },
            u_specularMap : function() {
                return that._specularTexture;
            },
            u_bumpMap : function() {
                return that._bumpTexture;
            },
            u_bumpMapResoltuion : function() {
                return {
                    x : 1.0 / that._bumpTexture.getWidth(),
                    y : 1.0 / that._bumpTexture.getHeight()
                };
            },
            u_bumpMapNormalZ : function() {
                return that.bumpMapNormalZ;
            },
            u_dayNightBlendDelta : function() {
                return that.dayNightBlendDelta;
            },
            u_nightIntensity : function() {
                return that.nightIntensity;
            },
            u_morphTime : function() {
                return that.morphTime;
            }
        };

        // PERFORMANCE_IDEA:  Only combine these if showing the atmosphere.  Maybe this is too much of a micro-optimization.
        // http://jsperf.com/object-property-access-propcount
        this._drawUniforms = combine(uniforms, atmosphereUniforms);
    }

    /**
     * DOC_TBA
     *
     * @memberof CentralBody
     *
     * @return {Ellipsoid} DOC_TBA
     */
    CentralBody.prototype.getEllipsoid = function() {
        return this._ellipsoid;
    };

    CentralBody._isModeTransition = function(oldMode, newMode) {
        // SCENE2D, COLUMBUS_VIEW, and MORPHING use the same rendering path, so a
        // transition only occurs when switching from/to SCENE3D
        return ((oldMode !== newMode) &&
                ((oldMode === SceneMode.SCENE3D) ||
                 (newMode === SceneMode.SCENE3D)));
    };

    CentralBody.prototype._syncMorphTime = function(mode) {
        switch (mode) {
        case SceneMode.SCENE3D:
            this.morphTime = 1.0;
            break;

        case SceneMode.SCENE2D:
        case SceneMode.COLUMBUS_VIEW:
            this.morphTime = 0.0;
            break;

        // MORPHING - don't change it
        }
    };

    CentralBody.prototype._prefetchImages = function() {
        var limit = Math.max(this._prefetchLimit, this._dayTileProvider.zoomMin);
        var stack = [this._rootTile];
        while (stack.length !== 0) {
            var tile = stack.pop();

            if (tile.zoom < limit) {
                this._processTile(tile);
                stack = stack.concat(tile.getChildren());
            } else if (tile.zoom === limit) {
                this._processTile(tile);
            }
        }
    };

    CentralBody.prototype._createTextureCache = function(context) {
        if (this._dayTileProvider &&
            typeof this._dayTileProvider.tileWidth !== "undefined" &&
            typeof this._dayTileProvider.tileHeight !== "undefined") {
            this._texturePool = new Texture2DPool(this._dayTileProvider.tileWidth, this._dayTileProvider.tileHeight);
        } else {
            this._texturePool = undefined;
        }

        var pool = this._texturePool;

        var fetch = function(tile) {
            var texture;

            var width = parseInt(tile.image.width, 10);
            var height = parseInt(tile.image.height, 10);
            var usePool = pool && (width === pool.getWidth() && height === pool.getHeight());
            var inPool = false;

            if (usePool && pool.hasAvailable()) {
                texture = pool.getTexture();
                inPool = true;
            } else {
                texture = context.createTexture2D({
                    width : width,
                    height : height,
                    pixelFormat : PixelFormat.RGB
                });
            }

            if (usePool && !inPool) {
                pool.add(texture);
            }
            return texture;
        };

        var remove = function(tile) {
            var width = tile.texture.getWidth();
            var height = tile.texture.getHeight();
            var usePool = (width === pool.getWidth() && height === pool.getHeight());

            if (usePool) {
                pool.remove(tile.texture);
                tile.texture = undefined;
            } else {
                tile.texture = tile.texture && tile.texture.destroy();
            }

            tile._extentVA = tile._extentVA && tile._extentVA.destroy();
            tile.projection = undefined;
            tile.state = TileState.READY;
        };

        var policy = new TileTextureCachePolicy({
            fetchFunc : fetch,
            removeFunc : remove,
            limit : this._textureCacheLimit
        });
        this._textureCache = new Cache(policy);
    };

    CentralBody.prototype._fetchImage = function(tile) {
        var onload = function() {
            tile.state = TileState.IMAGE_LOADED;
        };
        var onerror = function() {
            tile.state = TileState.IMAGE_FAILED;
        };
        var oninvalid = function() {
            tile.state = TileState.IMAGE_INVALID;
        };
        return this._dayTileProvider.loadTileImage(tile, onload, onerror, oninvalid);
    };

    CentralBody.prototype._getTileBoundingSphere = function (tile, mode, projection) {
        var boundingVolume;
        if (mode === SceneMode.SCENE3D) {
            boundingVolume = tile.get3DBoundingSphere().clone();
        } else if (mode === SceneMode.COLUMBUS_VIEW){
            boundingVolume = tile.get2DBoundingSphere(projection).clone();
            boundingVolume.center = new Cartesian3(0.0, boundingVolume.center.x, boundingVolume.center.y);
        } else {
            var bv3D = tile.get3DBoundingSphere();
            var bv2D = tile.get2DBoundingSphere(projection);
            boundingVolume = new BoundingSphere(
                    bv2D.center.lerp(bv3D, this.morphTime),
                    Math.max(bv2D.radius, bv3D.radius));
        }
        return boundingVolume;
    };

    CentralBody.prototype._frustumCull = function(tile, mode, projection) {
        if (mode === SceneMode.SCENE2D) {
            var bRect = tile.get2DBoundingRectangle(projection);

            var frustum = this._camera.frustum;
            var position = this._camera.position;
            var x = position.x + frustum.left;
            var y = position.y + frustum.bottom;
            var w = position.x + frustum.right - x;
            var h = position.y + frustum.top - y;
            var fRect = new Rectangle(x, y, w, h);

            return !Rectangle.rectangleRectangleIntersect(bRect, fRect);
        }

        var boundingVolume = this._getTileBoundingSphere(tile, mode, projection);
        return this._camera.getVisibility(boundingVolume, BoundingSphere.planeSphereIntersect) === Intersect.OUTSIDE;
    };

    CentralBody.prototype._throttleImages = function() {
        var j = 0;
        for ( var i = 0; i < this._imageQueue.length && j < this._imageThrottleLimit; ++i) {
            var tile = this._imageQueue[i];

            if (this._frustumCull(tile, this._mode, this._projection)) {
                tile.state = TileState.READY;
                continue;
            }

            if (this._dayTileProvider.zoomMin !== 0 && tile.zoom === 0 && tile.x === 0 && tile.y === 0) {
                tile.image = this._createBaseTile();
                tile.projection = Projections.WGS84; // no need to re-project
                tile.state = TileState.IMAGE_LOADED;
            } else {
                tile.image = this._fetchImage(tile);
                if (!tile.projection) {
                    tile.projection = this._dayTileProvider.projection;
                }
            }

            ++j;
        }

        splice(this._imageQueue, 0, i);
    };

    CentralBody.prototype._createBaseTile = function() {
        // Some tile servers, like Bing, don't have a base image for the entire central body.
        // Create a 1x1 image that will never get rendered.
        var canvas = document.createElement("canvas");
        canvas.width = 1.0;
        canvas.height = 1.0;

        return canvas;
    };

    CentralBody.prototype._throttleReprojection = function() {
        var i = 0;
        var j = 0;
        for (; i < this._reprojectQueue.length && j < this._reprojectThrottleLimit; ++i) {
            var tile = this._reprojectQueue[i];

            if (this._frustumCull(tile, this._mode, this._projection)) {
                tile.image = undefined;
                tile.state = TileState.READY;
                continue;
            }

            tile.image = tile.projection.toWgs84(tile.extent, tile.image);
            tile.state = TileState.REPROJECTED;
            tile.projection = Projections.WGS84;

            ++j;
        }

        splice(this._reprojectQueue, 0, i);
    };

    CentralBody.prototype._throttleTextures = function(context) {
        var i = 0;
        var j = 0;
        for (; i < this._textureQueue.length && j < this._textureThrottleLimit; ++i) {
            var tile = this._textureQueue[i];

            if (this._frustumCull(tile, this._mode, this._projection)) {
                tile.image = undefined;
                tile.state = TileState.READY;
                continue;
            }

            tile.texture = this._textureCache.find(tile);
            tile.texture.copyFrom(tile.image);
            tile.texture.generateMipmap(MipmapHint.NICEST);
            tile.texture.setSampler({
                wrapS : TextureWrap.CLAMP,
                wrapT : TextureWrap.CLAMP,
                minificationFilter : TextureMinificationFilter.LINEAR_MIPMAP_LINEAR,
                magnificationFilter : TextureMagnificationFilter.LINEAR,
                maximumAnisotropy : context.getMaximumTextureFilterAnisotropy() || 8 // TODO: Remove Chrome work around
            });
            tile.state = TileState.TEXTURE_LOADED;
            tile.image = undefined;
            ++j;
        }

        splice(this._textureQueue, 0, i);
    };

    CentralBody.prototype._processTile = function(tile) {
        // check if tile needs to load image
        if ((!tile.state ||
             tile.state === TileState.READY ||
             tile.state === TileState.IMAGE_FAILED) &&
            this._imageQueue.indexOf(tile) === -1) {
            this._imageQueue.push(tile);
            tile.state = TileState.IMAGE_LOADING;
        }
        // or re-project the image
        else if (tile.state === TileState.IMAGE_LOADED && this._reprojectQueue.indexOf(tile) === -1) {
            this._reprojectQueue.push(tile);
            tile.state = TileState.REPROJECTING;
        }
        // or copy to a texture
        else if (tile.state === TileState.REPROJECTED && this._textureQueue.indexOf(tile) === -1) {
            this._textureQueue.push(tile);
            tile.state = TileState.TEXTURE_LOADING;
        }
        // or release invalid image if there is one
        else if (tile.state === TileState.IMAGE_INVALID && tile.image) {
            tile.image = undefined;
        }
    };

    CentralBody.prototype._enqueueTile = function(tile, context, sceneState) {
        var mode = sceneState.mode;
        var projection = sceneState.scene2D.projection;

        // tile is ready for rendering
        if (!this._dayTileProvider || (tile.state === TileState.TEXTURE_LOADED && tile.texture && !tile.texture.isDestroyed())) {
            // create vertex array the first time it is needed or when morphing
            if (!tile._extentVA ||
                tile._extentVA.isDestroyed() ||
                CentralBody._isModeTransition(this._mode, mode) ||
                tile._mode !== mode ||
                this._projection !== projection) {
                tile._extentVA = tile._extentVA && tile._extentVA.destroy();

                var ellipsoid = this._ellipsoid;
                var rtc = tile.get3DBoundingSphere().center;
                var projectedRTC = tile.get2DBoundingSphere(projection).center.clone();

                var gran = (tile.zoom > 0) ? 0.05 * (1 / tile.zoom * 2) : 0.05; // seems like a good value after testing it for what looks good

                var typedArray, buffer, stride, attributes, indexBuffer;
                var datatype = ComponentDatatype.FLOAT;
                var usage = BufferUsage.STATIC_DRAW;

                if (mode === SceneMode.SCENE3D) {
                    var buffers = ExtentTessellator.computeBuffers({
                        ellipsoid : ellipsoid,
                        extent : tile.extent,
                        granularity : gran,
                        generateTextureCoords : true,
                        interleave : true,
                        relativeToCenter : rtc
                    });

                    typedArray = datatype.toTypedArray(buffers.vertices);
                    buffer = context.createVertexBuffer(typedArray, usage);
                    stride = 5 * datatype.sizeInBytes;
                    attributes = [{
                        index : attributeIndices.position3D,
                        vertexBuffer : buffer,
                        componentDatatype : datatype,
                        componentsPerAttribute : 3,
                        normalize : false,
                        offsetInBytes : 0,
                        strideInBytes : stride
                    }, {
                        index : attributeIndices.textureCoordinates,
                        vertexBuffer : buffer,
                        componentDatatype : datatype,
                        componentsPerAttribute : 2,
                        normalize : false,
                        offsetInBytes : 3 * datatype.sizeInBytes,
                        strideInBytes : stride
                    }, {
                        index : attributeIndices.position2D,
                        value : [0.0, 0.0]
                    }];
                    indexBuffer = context.createIndexBuffer(new Uint16Array(buffers.indices), usage, IndexDatatype.UNSIGNED_SHORT);
                } else {
                    var vertices = [];
                    var width = tile.extent.east - tile.extent.west;
                    var height = tile.extent.north - tile.extent.south;
                    var lonScalar = 1.0 / width;
                    var latScalar = 1.0 / height;

                    var mesh = PlaneTessellator.compute({
                        resolution : {
                            x : Math.max(Math.ceil(width / gran), 2.0),
                            y : Math.max(Math.ceil(height / gran), 2.0)
                        },
                        onInterpolation : function(time) {
                            var lonLat = new Cartographic2(
                                    CesiumMath.lerp(tile.extent.west, tile.extent.east, time.x),
                                    CesiumMath.lerp(tile.extent.south, tile.extent.north, time.y));

                            var p = ellipsoid.toCartesian(lonLat).subtract(rtc);
                            vertices.push(p.x, p.y, p.z);

                            var u = (lonLat.longitude - tile.extent.west) * lonScalar;
                            var v = (lonLat.latitude - tile.extent.south) * latScalar;
                            vertices.push(u, v);

                            // TODO: This will not work if the projection's ellipsoid is different
                            // than the central body's ellipsoid.  Throw an exception?
                            var projectedLonLat = projection.project(lonLat).subtract(projectedRTC);
                            vertices.push(projectedLonLat.x, projectedLonLat.y);
                        }
                    });

                    typedArray = datatype.toTypedArray(vertices);
                    buffer = context.createVertexBuffer(typedArray, usage);
                    stride = 7 * datatype.sizeInBytes;
                    attributes = [{
                        index : attributeIndices.position3D,
                        vertexBuffer : buffer,
                        componentDatatype : datatype,
                        componentsPerAttribute : 3,
                        normalize : false,
                        offsetInBytes : 0,
                        strideInBytes : stride
                    }, {
                        index : attributeIndices.textureCoordinates,
                        vertexBuffer : buffer,
                        componentDatatype : datatype,
                        componentsPerAttribute : 2,
                        normalize : false,
                        offsetInBytes : 3 * datatype.sizeInBytes,
                        strideInBytes : stride
                    }, {
                        index : attributeIndices.position2D,
                        vertexBuffer : buffer,
                        componentDatatype : datatype,
                        componentsPerAttribute : 2,
                        normalize : false,
                        offsetInBytes : 5 * datatype.sizeInBytes,
                        strideInBytes : stride
                    }];

                    indexBuffer = context.createIndexBuffer(new Uint16Array(mesh.indexLists[0].values), usage, IndexDatatype.UNSIGNED_SHORT);
                }

                tile._extentVA = context.createVertexArray(attributes, indexBuffer);

                var intensity = (this._dayTileProvider && this._dayTileProvider.getIntensity && this._dayTileProvider.getIntensity(tile)) || 0.0;
                var drawUniforms = {
                    u_dayTexture : function() {
                        return tile.texture;
                    },
                    u_center3D : function() {
                        return rtc;
                    },
                    u_center2D : function() {
                        return (projectedRTC) ? projectedRTC.getXY() : Cartesian2.getZero();
                    },
                    u_modifiedModelView : function() {
                        return tile.modelView;
                    },
                    u_dayIntensity : function() {
                        return intensity;
                    }
                };
                tile._drawUniforms = combine(drawUniforms, this._drawUniforms);

                tile._mode = mode;
            }
            this._renderQueue.push(tile);

            if (mode === SceneMode.SCENE2D) {
                if (tile.zoom + 1 <= this._dayTileProvider.zoomMax) {
                    var children = tile.getChildren();
                    for ( var i = 0; i < children.length; ++i) {
                        this._processTile(children[i]);
                    }
                }
            }
        }
        // tile isn't ready, find a parent to render and start processing the tile.
        else {
            var parent = tile.parent;
            if (parent && this._renderQueue.indexOf(parent) === -1) {
                this._enqueueTile(parent, context, sceneState);
            }

            this._processTile(tile);
        }
    };

    CentralBody.prototype._refine3D = function(tile, viewportWidth, viewportHeight, mode, projection) {
        var width = viewportWidth;
        var height = viewportHeight;

        var pixelError = this.pixelError3D;
        var camera = this._camera;
        var frustum = camera.frustum;
        var provider = this._dayTileProvider;
        var extent = tile.extent;

        if (tile.zoom < provider.zoomMin) {
            return true;
        }

        var texturePixelError = (pixelError > 0.0) ? pixelError : 1.0;
        var pixelSizePerDistance = 2.0 * Math.tan(frustum.fovy * 0.5);

        if (height > width * frustum.aspectRatio) {
            pixelSizePerDistance /= height;
        } else {
            pixelSizePerDistance /= width;
        }

        var invPixelSizePerDistance = 1.0 / (texturePixelError * pixelSizePerDistance);

        var texelHeight = (extent.north - extent.south) / provider.tileHeight;
        var texelWidth = (extent.east - extent.west) / provider.tileWidth;
        var texelSize = (texelWidth > texelHeight) ? texelWidth : texelHeight;
        var dmin = texelSize * invPixelSizePerDistance;
        dmin *= this._ellipsoid.getMaximumRadius();

        var boundingVolume = this._getTileBoundingSphere(tile, mode, projection);

        var cameraPosition = camera.transform.multiplyWithVector(new Cartesian4(camera.position.x, camera.position.y, camera.position.z, 1.0)).getXYZ();
        var direction = camera.transform.multiplyWithVector(new Cartesian4(camera.direction.x, camera.direction.y, camera.direction.z, 0.0)).getXYZ();

        var toCenter = boundingVolume.center.subtract(cameraPosition);
        var toSphere = toCenter.normalize().multiplyWithScalar(toCenter.magnitude() - boundingVolume.radius);
        var distance = direction.multiplyWithScalar(direction.dot(toSphere)).magnitude();

        if (distance < dmin) {
            return true;
        }

        return false;
    };

    CentralBody.prototype._refine2D = function(tile, viewportWidth, viewportHeight, projection) {
        var camera = this._camera;
        var frustum = camera.frustum;
        var pixelError = this.pixelError2D;
        var provider = this._dayTileProvider;

        if (tile.zoom < provider.zoomMin) {
            return true;
        }

        var texturePixelError = (pixelError > 0.0) ? pixelError : 1.0;

        var tileWidth, tileHeight;
        if (tile.texture && !tile.texture.isDestroyed()) {
            tileWidth = tile.texture.getWidth();
            tileHeight = tile.texture.getHeight();
        } else if (tile.image && typeof tile.image.width !== "undefined") {
            tileWidth = tile.image.width;
            tileHeight = tile.image.height;
        } else {
            tileWidth = provider.tileWidth;
            tileHeight = provider.tileHeight;
        }

        var a = projection.project(new Cartographic2(tile.extent.west, tile.extent.north)).getXY();
        var b = projection.project(new Cartographic2(tile.extent.east, tile.extent.south)).getXY();
        var diagonal = a.subtract(b);
        var texelSize = Math.max(diagonal.x, diagonal.y) / Math.max(tileWidth, tileHeight);
        var pixelSize = Math.max(frustum.top - frustum.bottom, frustum.right - frustum.left) / Math.max(viewportWidth, viewportHeight);

        if (texelSize > pixelSize * texturePixelError) {
            return true;
        }

        return false;
    };

    /**
     * Determines whether a tile should be refined to a higher resolution.
     *
     * @memberof CentralBody
     *
     * @return {Boolean} <code>true</code> if a higher resolution tile should be displayed or <code>false</code> if a higher resolution tile is not needed.
     */
    CentralBody.prototype.refine = function(tile, viewportWidth, viewportHeight, mode, projection) {
        if (mode === SceneMode.SCENE2D) {
            return this._refine2D(tile, viewportWidth, viewportHeight, projection);
        }

        return this._refine3D(tile, viewportWidth, viewportHeight, mode, projection);
    };

    CentralBody.prototype._createScissorRectangle = function(description) {
        var quad = description.quad;
        var upperLeft = new Cartesian3(quad[0], quad[1], quad[2]);
        var lowerRight = new Cartesian3(quad[9], quad[10], quad[11]);
        var mvp = description.modelViewProjection;
        var clip = description.viewportTransformation;

        var center = upperLeft.add(lowerRight).multiplyWithScalar(0.5);
        var centerScreen = mvp.multiplyWithVector(new Cartesian4(center.x, center.y, center.z, 1.0));
        centerScreen = centerScreen.multiplyWithScalar(1.0 / centerScreen.w);
        var centerClip = clip.multiplyWithVector(centerScreen).getXYZ();

        var surfaceScreen = mvp.multiplyWithVector(new Cartesian4(upperLeft.x, upperLeft.y, upperLeft.z, 1.0));
        surfaceScreen = surfaceScreen.multiplyWithScalar(1.0 / surfaceScreen.w);
        var surfaceClip = clip.multiplyWithVector(surfaceScreen).getXYZ();

        var radius = Math.ceil(surfaceClip.subtract(centerClip).magnitude());
        var diameter = 2.0 * radius;

        return {
            x : Math.floor(centerClip.x) - radius,
            y : Math.floor(centerClip.y) - radius,
            width : diameter,
            height : diameter
        };
    };

    CentralBody.prototype._computeDepthQuad = function() {
        // PERFORMANCE_TODO: optimize diagonal matrix multiplies.
        var dInverse = Matrix3.createNonUniformScale(this._ellipsoid.getRadii());
        var d = Matrix3.createNonUniformScale(this._ellipsoid.getOneOverRadii());

        // TODO: Stop transforming camera position to world coordinates all the time.
        var p = this._camera.position;
        p = new Cartesian4(p.x, p.y, p.z, 1.0);
        p = this._camera.transform.multiplyWithVector(p).getXYZ();

        // Find the corresponding position in the scaled space of the ellipsoid.
        var q = d.multiplyWithVector(p);

        var qMagnitude = q.magnitude();
        var qUnit = q.normalize();

        // Determine the east and north directions at q.
        var eUnit = Cartesian3.getUnitZ().cross(q).normalize();
        var nUnit = qUnit.cross(eUnit).normalize();

        // Determine the radius of the "limb" of the ellipsoid.
        var wMagnitude = Math.sqrt(q.magnitudeSquared() - 1.0);

        // Compute the center and offsets.
        var center = qUnit.multiplyWithScalar(1.0 / qMagnitude);
        var scalar = wMagnitude / qMagnitude;
        var eastOffset = eUnit.multiplyWithScalar(scalar);
        var northOffset = nUnit.multiplyWithScalar(scalar);

        // A conservative measure for the longitudes would be to use the min/max longitudes of the bounding frustum.
        var upperLeft = dInverse.multiplyWithVector(center.add(northOffset).subtract(eastOffset));
        var upperRight = dInverse.multiplyWithVector(center.add(northOffset).add(eastOffset));
        var lowerLeft = dInverse.multiplyWithVector(center.subtract(northOffset).subtract(eastOffset));
        var lowerRight = dInverse.multiplyWithVector(center.subtract(northOffset).add(eastOffset));
        return [upperLeft.x, upperLeft.y, upperLeft.z, lowerLeft.x, lowerLeft.y, lowerLeft.z, upperRight.x, upperRight.y, upperRight.z, lowerRight.x, lowerRight.y, lowerRight.z];
    };

    /**
     * @private
     */
    CentralBody.prototype.update = function(context, sceneState) {
        var mode = sceneState.mode;
        var projection = sceneState.scene2D.projection;

        this._syncMorphTime(mode);

        var width, height;

        if (this._dayTileProvider !== this.dayTileProvider) {
            this._dayTileProvider = this.dayTileProvider;

            // destroy logo
            this._quadLogo = this._quadLogo && this._quadLogo.destroy();

            // stop loading everything
            this._imageQueue = [];
            this._textureQueue = [];
            this._reprojectQueue = [];

            // destroy tiles
            this._destroyTileTree();

            // destroy resources
            this._texturePool = this._texturePool && this._texturePool.destroy();
            this._textureCache = this._textureCache && this._textureCache.destroy();

            // create new tile tree
            this._rootTile = new Tile({
                extent : this._dayTileProvider.maxExtent || this._maxExtent,
                zoom : 0,
                ellipsoid : this._ellipsoid
            });

            this._prefetchImages();
        }

        var createLogo = (!this._textureLogo || !this._quadLogo || this._quadLogo.isDestroyed()) && this._dayTileProvider && this._dayTileProvider.getLogo && this._dayTileProvider.getLogo();
        if (createLogo) {
            this._textureLogo = context.createTexture2D({
                source : this._dayTileProvider.getLogo(),
                pixelFormat : PixelFormat.RGBA
            });
            this._quadLogo = new ViewportQuad(new Rectangle(this.logoOffsetX, this.logoOffsetY, this._textureLogo.getWidth(), this._textureLogo.getHeight()));
            this._quadLogo.setTexture(this._textureLogo);
        }

        if (!this._textureCache || this._textureCache.isDestroyed()) {
            this._createTextureCache(context);
        }

        width = context.getCanvas().clientWidth;
        height = context.getCanvas().clientHeight;

        var createFBO = !this._fb || this._fb.isDestroyed();
        var fboDimensionsChanged = this._fb && (this._fb.getColorTexture().getWidth() !== width || this._fb.getColorTexture().getHeight() !== height);

        if (createFBO || fboDimensionsChanged ||
            (!this._quadV || this._quadV.isDestroyed()) ||
            (!this._quadH || this._quadH.isDestroyed())) {

            this._fb = this._fb && this._fb.destroy();
            this._quadV = this._quadV && this._quadV.destroy();
            this._quadH = this._quadH && this._quadH.destroy();

            // create FBO and texture render targets
            this._fb = context.createFramebuffer({
                colorTexture : context.createTexture2D({
                    width : width,
                    height : height,
                    pixelFormat : PixelFormat.RGBA
                })
            });

            // create viewport quad for vertical gaussian blur pass
            this._quadV = new ViewportQuad(new Rectangle(0.0, 0.0, width, height));
            this._quadV.vertexShader = "#define VERTICAL 1\n" + CentralBodyVSFilter;
            this._quadV.fragmentShader = CentralBodyFSFilter;
            this._quadV.uniforms.u_height = function() {
                return height;
            };
            this._quadV.setTexture(this._fb.getColorTexture());
            this._quadV.setDestroyTexture(false);
            this._quadV.setFramebuffer(context.createFramebuffer({
                colorTexture : context.createTexture2D({
                    width : width,
                    height : height,
                    pixelFormat : PixelFormat.RGBA
                })
            }));
            this._quadV.setDestroyFramebuffer(true);

            // create viewport quad for horizontal gaussian blur pass
            this._quadH = new ViewportQuad(new Rectangle(0.0, 0.0, width, height));
            this._quadH.vertexShader = CentralBodyVSFilter;
            this._quadH.fragmentShader = CentralBodyFSFilter;
            this._quadH.uniforms.u_width = function() {
                return width;
            };
            this._quadH.setTexture(this._quadV.getFramebuffer().getColorTexture());
            this._quadH.setDestroyTexture(false);
        }

        this._quadV.update(context, sceneState);
        this._quadH.update(context, sceneState);

        if (this._quadLogo && !this._quadLogo.isDestroyed()) {
            this._quadLogo.update(context, sceneState);
        }

        var vs, fs;

        if (this.showSkyAtmosphere && !this._vaSky) {
            // PERFORMANCE_IDEA:  Is 60 the right amount to tessellate?  I think scaling the original
            // geometry in a vertex is a bad idea; at least, because it introduces a draw call per tile.
            var skyMesh = CubeMapEllipsoidTessellator.compute(new Ellipsoid(this._ellipsoid.getRadii().multiplyWithScalar(1.025)), 60);
            this._vaSky = context.createVertexArrayFromMesh({
                mesh : skyMesh,
                attributeIndices : MeshFilters.createAttributeIndices(skyMesh),
                bufferUsage : BufferUsage.STATIC_DRAW
            });

            vs = "#define SKY_FROM_SPACE \n" +
                 "#line 0 \n" +
                 SkyAtmosphereVS;

            fs = "#line 0\n" +
                 ShadersRay +
                 "#line 0\n" +
                 ShadersConstructiveSolidGeometry +
                 "#line 0\n" +
                 SkyAtmosphereFS;

            this._spSkyFromSpace = context.getShaderCache().getShaderProgram(vs, fs);

            vs = "#define SKY_FROM_ATMOSPHERE" +
                 "#line 0 \n" +
                 SkyAtmosphereVS;

            this._spSkyFromAtmosphere = context.getShaderCache().getShaderProgram(vs, fs);
            this._rsSky = context.createRenderState({
                cull : {
                    enabled : true,
                    face : CullFace.FRONT
                }
            // TODO: revisit when multi-frustum/depth test is ready
            /*depthTest : {
                enabled : true
            },
            depthMask : false*/
            });
        }

        if (CentralBody._isModeTransition(this._mode, mode) || this._projection !== projection) {
            if (mode === SceneMode.SCENE3D) {
                this._rsColor = context.createRenderState({ // Write color, not depth
                    cull : {
                        enabled : true
                    }
                });
                this._rsDepth = context.createRenderState({ // Write depth, not color
                    cull : {
                        enabled : true
                    },
                    depthTest : {
                        enabled : true,
                        func : DepthFunction.ALWAYS
                    },
                    colorMask : {
                        red : false,
                        green : false,
                        blue : false,
                        alpha : false
                    }
                });
            } else {
                this._rsColor = context.createRenderState();
                this._rsDepth = context.createRenderState();
            }
        }

        // TODO: Wait until multi-frustum
        //this._rsColor.depthTest.enabled = (mode === SceneMode.MORPHING);  // Depth test during morph
        var cull = (mode === SceneMode.SCENE3D) || (mode === SceneMode.MORPHING);
        this._rsColor.cull.enabled = cull;
        this._rsDepth.cull.enabled = cull;

        // update scisor/depth plane
        var depthQuad = this._computeDepthQuad();

        // TODO: re-enable scissorTest
        /*if (mode === SceneMode.SCENE3D) {
            var uniformState = context.getUniformState();
            var mvp = uniformState.getModelViewProjection();
            var scissorTest = {
                enabled : true,
                rectangle : this._createScissorRectangle({
                    quad : depthQuad,
                    modelViewProjection : mvp,
                    viewportTransformation : uniformState.getViewportTransformation()
                })
            };

            this._rsColor.scissorTest = scissorTest;
            this._rsDepth.scissorTest = scissorTest;
            this._quadV.renderState.scissorTest = scissorTest;
            this._quadH.renderState.scissorTest = scissorTest;
        }*/

        // depth plane
        if (!this._vaDepth) {
            var mesh = {
                attributes : {
                    position : {
                        componentDatatype : ComponentDatatype.FLOAT,
                        componentsPerAttribute : 3,
                        values : depthQuad
                    }
                },
                indexLists : [{
                    primitiveType : PrimitiveType.TRIANGLES,
                    values : [0, 1, 2, 2, 1, 3]
                }]
            };
            this._vaDepth = context.createVertexArrayFromMesh({
                mesh : mesh,
                attributeIndices : {
                    position : 0
                },
                bufferUsage : BufferUsage.DYNAMIC_DRAW
            });
        } else {
            var datatype = ComponentDatatype.FLOAT;
            this._vaDepth.getAttribute(0).vertexBuffer.copyFromArrayView(datatype.toTypedArray(depthQuad));
        }

        if (!this._spDepth) {
            this._spDepth = context.getShaderCache().getShaderProgram(
                    CentralBodyVSDepth,
                    "#line 0\n" +
                    ShadersRay +
                    "#line 0\n" +
                    ShadersConstructiveSolidGeometry +
                    "#line 0\n" +
                    CentralBodyFSDepth, {
                        position : 0
                    });
        }

        var that = this;

        // Throw exception if there was a problem asynchronously loading an image.
        if (this._exception) {
            var message = this._exception;
            this._exception = undefined;
            throw new RuntimeError(message);
        }

        // PERFORMANCE_IDEA:  Once a texture is created, it is not destroyed if
        // the corresponding show flag is turned off.  This will waste memory
        // if a user loads every texture, then sets all the flags to false.

        if (this._nightImageSource !== this.nightImageSource) {
            this._nightImageSource = this.nightImageSource;

            var nightImage = new Image();
            nightImage.onload = function() {
                that._nightTexture = that._nightTexture && that._nightTexture.destroy();
                that._nightTexture = context.createTexture2D({
                    source : nightImage,
                    pixelFormat : PixelFormat.RGB
                });
            };
            nightImage.onerror = function() {
                that._exception = "Could not load image: " + this.src + ".";
            };
            nightImage.src = this.nightImageSource;
        }

        if (this._specularMapSource !== this.specularMapSource) {
            this._specularMapSource = this.specularMapSource;

            var specularImage = new Image();
            specularImage.onload = function() {
                that._specularTexture = that._specularTexture && that._specularTexture.destroy();
                that._specularTexture = context.createTexture2D({
                    source : specularImage,
                    pixelFormat : PixelFormat.LUMINANCE
                });
            };
            specularImage.onerror = function() {
                that._exception = "Could not load image: " + this.src + ".";
            };
            specularImage.src = this.specularMapSource;
        }

        if (this._cloudsMapSource !== this.cloudsMapSource) {
            this._cloudsMapSource = this.cloudsMapSource;

            var cloudsImage = new Image();
            cloudsImage.onload = function() {
                that._cloudsTexture = that._cloudsTexture && that._cloudsTexture.destroy();
                that._cloudsTexture = context.createTexture2D({
                    source : cloudsImage,
                    pixelFormat : PixelFormat.LUMINANCE
                });
            };
            cloudsImage.onerror = function() {
                that._exception = "Could not load image: " + this.src + ".";
            };
            cloudsImage.src = this.cloudsMapSource;
        }

        if (this._bumpMapSource !== this.bumpMapSource) {
            this._bumpMapSource = this.bumpMapSource;

            var bumpImage = new Image();
            bumpImage.onload = function() {
                that._bumpTexture = that._bumpTexture && that._bumpTexture.destroy();
                that._bumpTexture = context.createTexture2D({
                    source : bumpImage,
                    pixelFormat : PixelFormat.LUMINANCE
                });
            };
            bumpImage.onerror = function() {
                that._exception = "Could not load image: " + this.src + ".";
            };
            bumpImage.src = this.bumpMapSource;
        }

        // Initial compile or re-compile if uber-shader parameters changed
        var dayChanged = ((this._showDay !== this.showDay) && (!this.showDay || this._dayTileProvider));
        var nightChanged = ((this._showNight !== this.showNight) && (!this.showNight || this._nightTexture));
        var cloudsChanged = ((this._showClouds !== this.showClouds) && (!this.showClouds || this._cloudsTexture));
        var cloudShadowsChanged = ((this._showCloudShadows !== this.showCloudShadows) && (!this.showCloudShadows || this._cloudsTexture));
        var specularChanged = ((this._showSpecular !== this.showSpecular) && (!this.showSpecular || this._specularTexture));
        var bumpsChanged = ((this._showBumps !== this.showBumps) && (!this.showBumps || this._bumpTexture));

        if (!this._sp ||
            (dayChanged || nightChanged || cloudsChanged || cloudShadowsChanged || specularChanged || bumpsChanged) ||
            (this._showTerminator !== this.showTerminator)) {

            vs = "#line 0\n" +
                 CentralBodyVS;

            fs = ((this.showDay && this._dayTileProvider) ? "#define SHOW_DAY 1\n" : "") +
                 ((this.showNight && this._nightTexture) ? "#define SHOW_NIGHT 1\n" : "") +
                 ((this.showClouds && this._cloudsTexture) ? "#define SHOW_CLOUDS 1\n" : "") +
                 ((this.showCloudShadows && this._cloudsTexture) ? "#define SHOW_CLOUD_SHADOWS 1\n" : "") +
                 ((this.showSpecular && this._specularTexture) ? "#define SHOW_SPECULAR 1\n" : "") +
                 ((this.showBumps && this._bumpTexture) ? "#define SHOW_BUMPS 1\n" : "") +
                 (this.showTerminator ? "#define SHOW_TERMINATOR 1\n" : "") +
                 "#line 0\n" +
                 CentralBodyFS;

            this._spWithoutAtmosphere = this._spWithoutAtmosphere && this._spWithoutAtmosphere.release();
            this._spGroundFromSpace = this._spGroundFromSpace && this._spGroundFromSpace.release();
            this._spGroundFromAtmosphere = this._spGroundFromAtmosphere && this._spGroundFromAtmosphere.release();

            this._spWithoutAtmosphere = context.getShaderCache().getShaderProgram(vs, fs, attributeIndices);
            this._spGroundFromSpace = context.getShaderCache().getShaderProgram(
                    "#define SHOW_GROUND_ATMOSPHERE 1\n" +
                    "#define SHOW_GROUND_ATMOSPHERE_FROM_SPACE 1\n" +
                    vs,
                    "#define SHOW_GROUND_ATMOSPHERE 1\n" +
                    "#define SHOW_GROUND_ATMOSPHERE_FROM_SPACE 1\n" +
                    fs, attributeIndices);
            this._spGroundFromAtmosphere = context.getShaderCache().getShaderProgram(
                    "#define SHOW_GROUND_ATMOSPHERE 1\n" +
                    "#define SHOW_GROUND_ATMOSPHERE_FROM_ATMOSPHERE 1\n" +
                    vs,
                    "#define SHOW_GROUND_ATMOSPHERE 1\n" +
                    "#define SHOW_GROUND_ATMOSPHERE_FROM_ATMOSPHERE 1\n" +
                    fs, attributeIndices);

            // Sync to public state
            this._showDay = dayChanged ? this.showDay : this._showDay;
            this._showNight = nightChanged ? this.showNight : this._showNight;
            this._showClouds = cloudsChanged ? this.showClouds : this._showClouds;
            this._showCloudShadows = cloudShadowsChanged ? this.showCloudShadows : this._showCloudShadows;
            this._showSpecular = specularChanged ? this.showSpecular : this._showSpecular;
            this._showBumps = bumpsChanged ? this.showBumps : this._showBumps;
            this._showTerminator = this.showTerminator;
        }

        var camera = this._camera;
        var cameraPosition = new Cartesian4(camera.position.x, camera.position.y, camera.position.z, 1.0);
        cameraPosition = camera.transform.multiplyWithVector(cameraPosition).getXYZ();
        this._fCameraHeight2 = cameraPosition.magnitudeSquared();
        this._fCameraHeight = Math.sqrt(this._fCameraHeight2);

        if (this._fCameraHeight > this._outerRadius) {
            // Viewer in space
            this._spSky = this._spSkyFromSpace;
            this._sp = this.showGroundAtmosphere ? this._spGroundFromSpace : this._spWithoutAtmosphere;
        } else {
            // after the camera passes the minimum height, there is no ground atmosphere effect
            var showAtmosphere = this._ellipsoid.toCartographic3(cameraPosition).height >= this._minGroundFromAtmosphereHeight;
            if (this.showGroundAtmosphere && showAtmosphere) {
                this._sp = this._spGroundFromAtmosphere;
            } else {
                this._sp = this._spWithoutAtmosphere;
            }
            this._spSky = this._spSkyFromAtmosphere;
        }

        var viewport = context.getViewport();
        width = viewport.width;
        height = viewport.height;

        var occluder = new Occluder(new BoundingSphere(Cartesian3.getZero(), this._ellipsoid.getMinimumRadius()), cameraPosition);

        var stack = [this._rootTile];
        while (stack.length !== 0) {
            var tile = stack.pop();

            if (this._frustumCull(tile, mode, projection)) {
                continue;
            }

            var boundingVolume;
            if (mode === SceneMode.SCENE3D) {
                boundingVolume = tile.get3DBoundingSphere();
                var occludeePoint = tile.getOccludeePoint();

                // occlusion culling
                if (occludeePoint && !occluder.isVisible(new BoundingSphere(occludeePoint, 0.0))) {
                    continue;
                } else if (!occluder.isVisible(boundingVolume)) {
                    continue;
                }
            }

            if (!this._dayTileProvider || tile.zoom + 1 > this._dayTileProvider.zoomMax || !this.refineFunc(tile, width, height, mode, projection)) {
                this._enqueueTile(tile, context, sceneState);
            } else {
                var children = tile.getChildren();
                stack = stack.concat(children);
            }
        }

        this._mode = mode;
        this._projection = projection;

        this._throttleImages();
        this._throttleReprojection();
        this._throttleTextures(context);
    };

    /**
     * DOC_TBA
     * @memberof CentralBody
     */
    CentralBody.prototype.render = function(context) {
        if (this.show) {
            // clear FBO
            context.clear(context.createClearState({
                framebuffer : this._fb,
                color : {
                    red : 0.0,
                    green : 0.0,
                    blue : 0.0,
                    alpha : 0.0
                }
            }));

            if (this.showSkyAtmosphere) {
                context.draw({
                    framebuffer : this._fb,
                    primitiveType : PrimitiveType.TRIANGLES,
                    shaderProgram : this._spSky,
                    uniformMap : this._drawUniforms,
                    vertexArray : this._vaSky,
                    renderState : this._rsSky
                });
            }

            var numberOfTiles = this._renderQueue.length;
            if (numberOfTiles === 0) {
                return;
            }
            var uniformState = context.getUniformState();
            var mv = uniformState.getModelView();

            context.beginDraw({
                framebuffer : this._fb,
                shaderProgram : this._sp,
                renderState : this._rsColor
            });

            // TODO: remove once multi-frustum/depth testing is implemented
            this._renderQueue.sort(function(a, b) {
                return a.zoom - b.zoom;
            });

            // render tiles to FBO
            for ( var i = 0; i < numberOfTiles; ++i) {
                var tile = this._renderQueue[i];

                var rtc;
                if (this.morphTime === 1.0) {
                    rtc = tile._drawUniforms.u_center3D();
                } else if (this.morphTime === 0.0) {
                    var center = tile._drawUniforms.u_center2D();
                    rtc = new Cartesian3(0.0, center.x, center.y);
                } else {
                    rtc = Cartesian3.getZero();
                }
                var centerEye = mv.multiplyWithVector(new Cartesian4(rtc.x, rtc.y, rtc.z, 1.0));
                var mvrtc = mv.clone();
                mvrtc.setColumn3(centerEye);
                tile.modelView = mvrtc;

                context.continueDraw({
                    primitiveType : PrimitiveType.TRIANGLES,
                    vertexArray : tile._extentVA,
                    uniformMap : tile._drawUniforms
                });
            }

            context.endDraw();

            // render quad with vertical gaussian blur with second-pass texture attached to FBO
            this._quadV.render(context);

            // render quad with horizontal gaussian blur
            this._quadH.render(context);

            // render depth plane
            if (this._mode === SceneMode.SCENE3D) {
                context.draw({
                    primitiveType : PrimitiveType.TRIANGLES,
                    shaderProgram : this._spDepth,
                    vertexArray : this._vaDepth,
                    renderState : this._rsDepth
                });
            }

            if (this._quadLogo && !this._quadLogo.isDestroyed()) {
                this._quadLogo.render(context);
            }

            this._renderQueue.length = 0;
        }
    };

    /**
     * DOC_TBA
     * @memberof CentralBody
     */
    CentralBody.prototype.renderForPick = function(context, framebuffer) {
        if (this.show) {
            if (this._mode === SceneMode.SCENE3D) {
                // Not actually pickable, but render depth-only so primitives on the backface
                // of the globe are not picked.
                context.draw({
                    primitiveType : PrimitiveType.TRIANGLES,
                    shaderProgram : this._spDepth,
                    vertexArray : this._vaDepth,
                    renderState : this._rsDepth,
                    framebuffer : framebuffer
                });
            }
        }
    };

    CentralBody.prototype._destroyTileTree = function() {
        var stack = [this._rootTile];
        while (stack.length !== 0) {
            var tile = stack.pop();

            // remove circular reference
            tile.parent = undefined;

            // destroy vertex array
            if (tile._extentVA) {
                tile._extentVA = tile._extentVA && tile._extentVA.destroy();
            }

            // destroy texture
            if (tile.texture) {
                // if the texture isn't in the texture pool, destroy it; otherwise,
                // it already has been or will be destroyed by it.
                var width = tile.texture.getWidth();
                var height = tile.texture.getHeight();
                var usePool = this._texturePool && (width === this._texturePool.getWidth() && height === this._texturePool.getHeight());
                tile.texture = (usePool) ? undefined : tile.texture && tile.texture.destroy();
            }

            // process children
            if (tile.children) {
                stack = stack.concat(tile.children);
            }
        }

        this._rootTile = undefined;
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof CentralBody
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see CentralBody#destroy
     */
    CentralBody.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>null</code>) to the object as done in the example.
     *
     * @memberof CentralBody
     *
     * @return {null}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CentralBody#isDestroyed
     *
     * @example
     * centralBody = centralBody && centralBody.destroy();
     */
    CentralBody.prototype.destroy = function() {
        this._texturePool = this._texturePool && this._texturePool.destroy();
        this._textureCache = this._textureCache && this._textureCache.destroy();

        this._destroyTileTree();
        this._fb = this._fb && this._fb.destroy();
        this._quadV = this._quadV && this._quadV.destroy();
        this._quadH = this._quadH && this._quadH.destroy();

        this._spWithoutAtmosphere = this._spWithoutAtmosphere && this._spWithoutAtmosphere.release();
        this._spGroundFromSpace = this._spGroundFromSpace && this._spGroundFromSpace.release();
        this._spGroundFromAtmosphere = this._spGroundFromAtmosphere && this._spGroundFromAtmosphere.release();

        this._vaSky = this._vaSky && this._vaSky.destroy();
        this._spSkyFromSpace = this._spSkyFromSpace && this._spSkyFromSpace.release();
        this._spSkyFromAtmosphere = this._spSkyFromAtmosphere && this._spSkyFromAtmosphere.release();

        this._spDepth = this._spDepth && this._spDepth.release();
        this._vaDepth = this._vaDepth && this._vaDepth.destroy();

        this._nightTexture = this._nightTexture && this._nightTexture.destroy();
        this._specularTexture = this._specularTexture && this._specularTexture.destroy();
        this._cloudsTexture = this._cloudsTexture && this._cloudsTexture.destroy();
        this._bumpTexture = this._bumpTexture && this._bumpTexture.destroy();

        return destroyObject(this);
    };

    return CentralBody;
});

/*! Copyright (c) 2010 Chris O'Hara <cohara87@gmail.com>. MIT Licensed */

/*global define*/
define('ThirdParty/Chain',[],function() {
    var Chain = {};

(function(exports) {

    exports = exports || {};

    var handlers = {}, createChain, add;

    createChain = function (context, stack, lastMethod) {

        var inHandler = context.halt = false;

        //The default error handler
        context.error = function (e) {
            throw e;
        };

        //Run the next method in the chain
        context.next = function (exit) {
            if (exit) {
                inHandler = false;
            }
            if (!context.halt && stack && stack.length) {
                var args = stack.shift(), method = args.shift();
                inHandler = true;
                try {
                    handlers[method].apply(context, [args, args.length, method]);
                } catch (e) {
                    context.error(e);
                }
            }
            return context;
        };

        //Bind each method to the context
        for (var alias in handlers) {
            if (typeof context[alias] === 'function') {
                continue;
            }
            (function (alias) {
                context[alias] = function () {
                    var args = Array.prototype.slice.call(arguments);
                    if (alias === 'onError') {
                        if (stack) {
                            handlers.onError.apply(context, [args, args.length]);
                            return context;
                        }

                        var new_context = {};
                        handlers.onError.apply(new_context, [args, args.length]);
                        return createChain(new_context, null, 'onError');
                    }
                    args.unshift(alias);
                    if (!stack) {
                        return createChain({}, [args], alias);
                    }
                    context.then = context[alias];
                    stack.push(args);
                    return inHandler ? context : context.next();
                };
            }(alias));
        }

        //'then' is an alias for the last method that was called
        if (lastMethod) {
            context.then = context[lastMethod];
        }

        //Used to call run(), chain() or another existing method when defining a new method
        //See load.js (https://github.com/chriso/load.js/blob/master/load.js) for an example
        context.call = function (method, args) {
            args.unshift(method);
            stack.unshift(args);
            context.next(true);
        };

        return context.next();
    };

    //Add a custom method/handler (see below)
    add = exports.addMethod = function (method /*, alias1, alias2, ..., callback */) {
        var args = Array.prototype.slice.call(arguments),
            handler = args.pop();
        for (var i = 0, len = args.length; i < len; i++) {
            if (typeof args[i] === 'string') {
                handlers[args[i]] = handler;
            }
        }
        //When no aliases have been defined, automatically add 'then<Method>'
        //e.g. adding 'run' also adds 'thenRun' as a method
        if (!--len) {
            handlers['then' + method.substr(0,1).toUpperCase() + method.substr(1)] = handler;
        }
        createChain(exports);
    };

    //chain() - Run each function sequentially
    add('chain', function (args) {
        var self = this, next = function () {
            if (self.halt) {
                return;
            } else if (!args.length) {
                return self.next(true);
            }
            try {
                if (null != args.shift().call(self, next, self.error)) {
                    next();
                }
            } catch (e) {
                self.error(e);
            }
        };
        next();
    });

    //run() - Run each function in parallel and progress once all functions are complete
    add('run', function (args, arg_len) {
        var self = this, chain = function () {
            if (self.halt) {
                return;
            } else if (!--arg_len) {
                self.next(true);
            }
        };
        var error = function (e) {
            self.error(e);
        };
        for (var i = 0, len = arg_len; !self.halt && i < len; i++) {
            if (null != args[i].call(self, chain, error)) {
                chain();
            }
        }
    });

    //defer() - Defer execution of the next method
    add('defer', function (args) {
        var self = this;
        setTimeout(function () {
            self.next(true);
        }, args.shift());
    });

    //onError() - Attach an error handler
    add('onError', function (args, arg_len) {
        var self = this;
        this.error = function (err) {
            self.halt = true;
            for (var i = 0; i < arg_len; i++) {
                args[i].call(self, err);
            }
        };
    });

}(Chain));

    return Chain;
});
/*!

Queue.js

A function to represent a queue

Created by Stephen Morley - http://code.stephenmorley.org/ - and released under
the terms of the CC0 1.0 Universal legal code:

http://creativecommons.org/publicdomain/zero/1.0/legalcode

*/
/*global define*/
define('ThirdParty/Queue',[],function() {

    /* Creates a new queue. A queue is a first-in-first-out (FIFO) data structure -
     * items are added to the end of the queue and removed from the front.
     */
    function Queue() {
        // initialise the queue and offset
        var queue = [];
        var offset = 0;

        /* Returns the length of the queue.
         */
        this.getLength = function() {
            // return the length of the queue
            return (queue.length - offset);
        };

        /* Returns true if the queue is empty, and false otherwise.
         */
        this.isEmpty = function() {
            // return whether the queue is empty
            return (queue.length === 0);
        };

        /* Enqueues the specified item. The parameter is:
         *
         * item - the item to enqueue
         */
        this.enqueue = function(item) {
            // enqueue the item
            queue.push(item);
        };

        /* Dequeues an item and returns it. If the queue is empty then undefined is
         * returned.
         */
        this.dequeue = function() {
            // if the queue is empty, return undefined
            if (queue.length === 0) {
                return undefined;
            }

            // store the item at the front of the queue
            var item = queue[offset];

            // increment the offset and remove the free space if necessary
            if (++offset * 2 >= queue.length) {
                queue = queue.slice(offset);
                offset = 0;
            }

            // return the dequeued item
            return item;
        };

        /* Returns the item at the front of the queue (without dequeuing it). If the
         * queue is empty then undefined is returned.
         */
        this.peek = function() {
            // return the item at the front of the queue
            return (queue.length > 0 ? queue[offset] : undefined);
        };
    }

    return Queue;
});
/*global define*/
define('Core/PolygonPipeline',[
        './DeveloperError',
        './Math',
        './Cartesian3',
        './pointInsideTriangle2D',
        './ComponentDatatype',
        './PrimitiveType',
        '../ThirdParty/Queue',
        './WindingOrder'
    ], function(
        DeveloperError,
        CesiumMath,
        Cartesian3,
        pointInsideTriangle2D,
        ComponentDatatype,
        PrimitiveType,
        Queue,
        WindingOrder) {
    

    function DoublyLinkedList() {
        this.head = null;
        this.tail = null;
        this.length = 0;
    }

    DoublyLinkedList.prototype.add = function(item) {
        if (item) {
            var node = {
                item : item,
                previous : this.tail,
                next : null
            };

            if (this.tail) {
                this.tail.next = node;
                this.tail = node;
            } else {
                // Insert into empty list.
                this.head = node;
                this.tail = node;
            }

            ++this.length;
        }
    };

    DoublyLinkedList.prototype.remove = function(item) {
        if (item) {
            if (item.previous && item.next) {
                item.previous.next = item.next;
                item.next.previous = item.previous;
            } else if (item.previous) {
                // Remove last node.
                item.previous.next = null;
                this.tail = item.previous;
            } else if (item.next) {
                // Remove first node.
                item.next.previous = null;
                this.head = item.next;
            } else {
                // Remove last node in linked list.
                this.head = null;
                this.tail = null;
            }

            --this.length;
        }
    };

    /**
     * DOC_TBA
     *
     * @exports PolygonPipeline
     */
    var PolygonPipeline = {
        /**
         * DOC_TBA
         *
         * Cleans up a simple polygon by removing duplicate adjacent positions and making
         * the first position not equal the last position.
         *
         * @exception {DeveloperError} positions is required.
         * @exception {DeveloperError} At least three positions are required.
         */
        cleanUp : function(positions) {
            if (!positions) {
                throw new DeveloperError("positions is required.", "positions");
            }

            var length = positions.length;
            if (length < 3) {
                throw new DeveloperError("At least three positions are required.", "positions");
            }

            var cleanedPositions = [];

            for ( var i0 = length - 1, i1 = 0; i1 < length; i0 = i1++) {
                var v0 = positions[i0];
                var v1 = positions[i1];

                if (!v0.equals(v1)) {
                    cleanedPositions.push(v1); // Shallow copy!
                }
            }

            return cleanedPositions;
        },

        /**
         * DOC_TBA
         *
         * @exception {DeveloperError} positions is required.
         * @exception {DeveloperError} At least three positions are required.
         */
        computeArea2D : function(positions) {
            if (!positions) {
                throw new DeveloperError("positions is required.", "positions");
            }

            var length = positions.length;
            if (length < 3) {
                throw new DeveloperError("At least three positions are required.", "positions");
            }

            var area = 0.0;

            for ( var i0 = length - 1, i1 = 0; i1 < length; i0 = i1++) {
                var v0 = positions[i0];
                var v1 = positions[i1];

                area += (v0.x * v1.y) - (v1.x * v0.y);
            }

            return area * 0.5;
        },

        /**
         * DOC_TBA
         *
         * @return {WindingOrder} DOC_TBA
         *
         * @exception {DeveloperError} positions is required.
         * @exception {DeveloperError} At least three positions are required.
         */
        computeWindingOrder2D : function(positions) {
            var area = PolygonPipeline.computeArea2D(positions);
            return (area >= 0.0) ? WindingOrder.COUNTER_CLOCKWISE : WindingOrder.CLOCKWISE;
        },

        /**
         * DOC_TBA
         *
         * @exception {DeveloperError} positions is required.
         * @exception {DeveloperError} At least three positions are required.
         */
        earClip2D : function(positions) {
            function isTipConvex(p0, p1, p2) {
                var u = p1.subtract(p0);
                var v = p2.subtract(p1);

                // Use the sign of the z component of the cross product
                return ((u.x * v.y) - (u.y * v.x)) >= 0.0;
            }

            // PERFORMANCE_IDEA:  This is slow at n^3.  Make it faster with:
            //   * http://www.geometrictools.com/Documentation/TriangulationByEarClipping.pdf
            //   * http://cgm.cs.mcgill.ca/~godfried/publications/triangulation.held.ps.gz
            //   * http://blogs.agi.com/insight3d/index.php/2008/03/20/triangulation-rhymes-with-strangulation/

            if (!positions) {
                throw new DeveloperError("positions is required.", "positions");
            }

            var length = positions.length;
            if (length < 3) {
                throw new DeveloperError("At least three positions are required.", "positions");
            }

            var remainingPositions = new DoublyLinkedList();

            for ( var i = 0; i < length; ++i) {
                remainingPositions.add({
                    position : positions[i],
                    index : i
                });
            }

            var indices = [];

            var previousNode = remainingPositions.head;
            var node = previousNode.next;
            var nextNode = node.next;

            var bailCount = length * length;

            while (remainingPositions.length > 3) {
                var p0 = previousNode.item.position;
                var p1 = node.item.position;
                var p2 = nextNode.item.position;

                if (isTipConvex(p0, p1, p2)) {
                    var isEar = true;

                    for (var n = (nextNode.next ? nextNode.next : remainingPositions.head);
                             n !== previousNode;
                             n = (n.next ? n.next : remainingPositions.head)) {
                        if (pointInsideTriangle2D(n.item.position, p0, p1, p2)) {
                            isEar = false;
                            break;
                        }
                    }

                    if (isEar) {
                        indices.push(previousNode.item.index);
                        indices.push(node.item.index);
                        indices.push(nextNode.item.index);

                        remainingPositions.remove(node);

                        node = nextNode;
                        nextNode = nextNode.next ? nextNode.next : remainingPositions.head;
                        continue;
                    }
                }

                previousNode = previousNode.next ? previousNode.next : remainingPositions.head;
                node = node.next ? node.next : remainingPositions.head;
                nextNode = nextNode.next ? nextNode.next : remainingPositions.head;

                if (--bailCount === 0) {
                    break;
                }
            }

            var n0 = remainingPositions.head;
            var n1 = n0.next;
            var n2 = n1.next;
            indices.push(n0.item.index);
            indices.push(n1.item.index);
            indices.push(n2.item.index);

            return indices;
        },

        /**
         * DOC_TBA
         *
         * @param {DOC_TBA} positions DOC_TBA
         * @param {DOC_TBA} indices DOC_TBA
         * @param {Number} [granularity] DOC_TBA
         *
         * @exception {DeveloperError} positions is required.
         * @exception {DeveloperError} indices is required.
         * @exception {DeveloperError} At least three indices are required.
         * @exception {DeveloperError} The number of indices must be divisable by three.
         * @exception {DeveloperError} Granularity must be greater than zero.
         */
        computeSubdivision : function(positions, indices, granularity) {
            if (!positions) {
                throw new DeveloperError("positions is required.", "positions");
            }

            if (!indices) {
                throw new DeveloperError("indices is required.", "indices");
            }

            if (indices.length < 3) {
                throw new DeveloperError("At least three indices are required.", "indices");
            }

            if (indices.length % 3 !== 0) {
                throw new DeveloperError("The number of indices must be divisable by three.", "indices");
            }

            granularity = granularity || CesiumMath.toRadians(1.0);
            if (granularity <= 0.0) {
                throw new DeveloperError("Granularity must be greater than zero.", "granularity");
            }

            // Use a queue for triangles that need (or might need) to be subdivided.
            var triangles = new Queue();

            var indicesLength = indices.length;
            for ( var j = 0; j < indicesLength; j += 3) {
                triangles.enqueue({
                    i0 : indices[j],
                    i1 : indices[j + 1],
                    i2 : indices[j + 2]
                });
            }

            // New positions due to edge splits are appended to the positions list.
            var subdividedPositions = positions.slice(0); // shadow copy!
            var subdividedIndices = [];

            // Used to make sure shared edges are not split more than once.
            var edges = {};

            while (!triangles.isEmpty()) {
                var triangle = triangles.dequeue();

                var v0 = subdividedPositions[triangle.i0];
                var v1 = subdividedPositions[triangle.i1];
                var v2 = subdividedPositions[triangle.i2];

                var g0 = v0.angleBetween(v1);
                var g1 = v1.angleBetween(v2);
                var g2 = v2.angleBetween(v0);

                var max = Math.max(g0, Math.max(g1, g2));
                var edge;
                var i;

                if (max > granularity) {
                    if (g0 === max) {
                        edge = Math.min(triangle.i0, triangle.i1).toString() + " " + Math.max(triangle.i0, triangle.i1).toString();

                        i = edges[edge];
                        if (!i) {
                            subdividedPositions.push(v0.add(v1).multiplyWithScalar(0.5));
                            i = subdividedPositions.length - 1;
                            edges[edge] = i;
                        }

                        triangles.enqueue({
                            i0 : triangle.i0,
                            i1 : i,
                            i2 : triangle.i2
                        });
                        triangles.enqueue({
                            i0 : i,
                            i1 : triangle.i1,
                            i2 : triangle.i2
                        });
                    } else if (g1 === max) {
                        edge = Math.min(triangle.i1, triangle.i2).toString() + " " + Math.max(triangle.i1, triangle.i2).toString();

                        i = edges[edge];
                        if (!i) {
                            subdividedPositions.push(v1.add(v2).multiplyWithScalar(0.5));
                            i = subdividedPositions.length - 1;
                            edges[edge] = i;
                        }

                        triangles.enqueue({
                            i0 : triangle.i1,
                            i1 : i,
                            i2 : triangle.i0
                        });
                        triangles.enqueue({
                            i0 : i,
                            i1 : triangle.i2,
                            i2 : triangle.i0
                        });
                    } else if (g2 === max) {
                        edge = Math.min(triangle.i2, triangle.i0).toString() + " " + Math.max(triangle.i2, triangle.i0).toString();

                        i = edges[edge];
                        if (!i) {
                            subdividedPositions.push(v2.add(v0).multiplyWithScalar(0.5));
                            i = subdividedPositions.length - 1;
                            edges[edge] = i;
                        }

                        triangles.enqueue({
                            i0 : triangle.i2,
                            i1 : i,
                            i2 : triangle.i1
                        });
                        triangles.enqueue({
                            i0 : i,
                            i1 : triangle.i0,
                            i2 : triangle.i1
                        });
                    }
                } else {
                    subdividedIndices.push(triangle.i0);
                    subdividedIndices.push(triangle.i1);
                    subdividedIndices.push(triangle.i2);
                }
            }

            return {
                attributes : {
                    position : {
                        componentDatatype : ComponentDatatype.FLOAT,
                        componentsPerAttribute : 3,
                        values : Cartesian3.flatten(subdividedPositions)
                    }
                },

                indexLists : [{
                    primitiveType : PrimitiveType.TRIANGLES,
                    values : subdividedIndices
                }]
            };
        },

        /**
         * DOC_TBA
         *
         * @exception {DeveloperError} ellipsoid is required.
         */
        scaleToGeodeticHeight : function(ellipsoid, mesh, height) {
            if (!ellipsoid) {
                throw new DeveloperError("ellipsoid is required.", "ellipsoid");
            }

            height = height || 0.0;

            if (mesh && mesh.attributes && mesh.attributes.position) {
                var positions = mesh.attributes.position.values;
                var length = positions.length;

                for ( var i = 0; i < length; i += 3) {
                    var p = new Cartesian3(positions[i], positions[i + 1], positions[i + 2]);
                    p = ellipsoid.scaleToGeodeticSurface(p);

                    var n = ellipsoid.geodeticSurfaceNormal(p);
                    n = n.multiplyWithScalar(height);

                    // Translate from surface to height.
                    p = p.add(n);

                    positions[i] = p.x;
                    positions[i + 1] = p.y;
                    positions[i + 2] = p.z;
                }
            }

            return mesh;
        }
    };

    return PolygonPipeline;
});
/*global define*/
define('Scene/Polygon',[
        '../Core/DeveloperError',
        '../Core/combine',
        '../Core/destroyObject',
        '../Core/Math',
        '../Core/Ellipsoid',
        '../Core/AxisAlignedBoundingRectangle',
        '../Core/Cartesian3',
        '../Core/ComponentDatatype',
        '../Core/MeshFilters',
        '../Core/PrimitiveType',
        '../Core/EllipsoidTangentPlane',
        '../Core/PolygonPipeline',
        '../Core/WindingOrder',
        '../Renderer/BlendingState',
        '../Renderer/BufferUsage',
        '../Renderer/CullFace',
        '../Renderer/VertexLayout',
        './ColorMaterial',
        './SceneMode',
        '../Shaders/Noise',
        '../Shaders/PolygonVS',
        '../Shaders/PolygonFS',
        '../Shaders/PolygonVSPick',
        '../Shaders/PolygonFSPick'
    ], function(
        DeveloperError,
        combine,
        destroyObject,
        CesiumMath,
        Ellipsoid,
        AxisAlignedBoundingRectangle,
        Cartesian3,
        ComponentDatatype,
        MeshFilters,
        PrimitiveType,
        EllipsoidTangentPlane,
        PolygonPipeline,
        WindingOrder,
        BlendingState,
        BufferUsage,
        CullFace,
        VertexLayout,
        ColorMaterial,
        SceneMode,
        Noise,
        PolygonVS,
        PolygonFS,
        PolygonVSPick,
        PolygonFSPick) {
    
    /*global Float32Array*/

    var attributeIndices = {
        position2D : 0,
        position3D : 1,
        textureCoordinates : 2
    };

    function PositionVertices() {
        this._va = null;
    }

    PositionVertices.prototype.getVertexArrays = function() {
        return this._va;
    };

    PositionVertices.prototype.update = function(context, positions, meshes, bufferUsage) {
        if (positions) {
            // Initially create or recreate vertex array and buffers
            this._destroyVA();

            var va = [];

            var length = meshes.length;
            for ( var i = 0; i < length; ++i) {
                va.push(context.createVertexArrayFromMesh({
                    mesh : meshes[i],
                    attributeIndices : attributeIndices,
                    bufferUsage : bufferUsage,
                    vertexLayout : VertexLayout.INTERLEAVED
                }));
            }

            this._va = va;
        } else {
            this._destroyVA();
        }
    };

    PositionVertices.prototype._destroyVA = function() {
        var va = this._va;
        if (va) {
            this._va = null;

            var length = va.length;
            for ( var i = 0; i < length; ++i) {
                va[i].destroy();
            }
        }
    };

    PositionVertices.prototype.isDestroyed = function() {
        return false;
    };

    PositionVertices.prototype.destroy = function() {
        this._destroyVA();
        return destroyObject(this);
    };

    /**
     * DOC_TBA
     *
     * @name Polygon
     * @constructor
     *
     * @example
     * var polygon = new Polygon();
     * polygon.material.color = {
     *   red   : 1.0,
     *   green : 0.0,
     *   blue  : 0.0,
     *   alpha : 1.0
     * };
     * polygon.setPositions([
     *   ellipsoid.toCartesian(new Cartographic3(...)),
     *   ellipsoid.toCartesian(new Cartographic3(...)),
     *   ellipsoid.toCartesian(new Cartographic3(...))
     * ]);
     */
    function Polygon() {
        this._sp = undefined;
        this._rs = undefined;

        this._spPick = undefined;
        this._rsPick = undefined;

        this._vertices = new PositionVertices();
        this._pickId = null;

        /**
         * DOC_TBA
         */
        this.ellipsoid = Ellipsoid.getWgs84();
        this._ellipsoid = undefined;

        /**
         * DOC_TBA
         */
        this.height = 0.0;
        this._height = undefined;

        /**
         * DOC_TBA
         */
        this.granularity = CesiumMath.toRadians(1.0);
        this._granularity = undefined;

        /**
         * DOC_TBA
         */
        this.scene2D = {
            /**
             * DOC_TBA
             */
            granularity : CesiumMath.toRadians(30.0)
        };

        /**
         * DOC_TBA
         */
        this.scene3D = {
        /**
         * DOC_TBA
         *
         * granularity can override object-level granularity
         */
        };

        this._positions = null;
        this._createVertexArray = false;

        /**
         * Determines if this polygon will be shown.
         *
         * @type Boolean
         */
        this.show = true;

        /**
         * The usage hint for the polygon's vertex buffer.
         *
         * @type BufferUsage
         *
         * @performance If <code>bufferUsage</code> changes, the next time
         * {@link Polygon#update} is called, the polygon's vertex buffer
         * is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.
         * For best performance, it is important to provide the proper usage hint.  If the polygon
         * will not change over several frames, use <code>BufferUsage.STATIC_DRAW</code>.
         * If the polygon will change every frame, use <code>BufferUsage.STREAM_DRAW</code>.
         */
        this.bufferUsage = BufferUsage.STATIC_DRAW;
        this._bufferUsage = BufferUsage.STATIC_DRAW;

        /**
         * DOC_TBA
         */
        this.material = new ColorMaterial({
            color : {
                red : 1.0,
                green : 1.0,
                blue : 0.0,
                alpha : 0.5
            }
        });
        this._material = undefined;

        /**
         * DOC_TBA
         *
         * @type Number
         */
        this.erosion = 1.0;

        /**
         * DOC_TBA
         *
         * @type Number
         */
        this.morphTime = 1.0;

        this._mode = SceneMode.SCENE3D;
        this._projection = undefined;

        var that = this;
        this._uniforms = {
            u_erosion : function() {
                return that.erosion;
            },
            u_morphTime : function() {
                return that.morphTime;
            },
            u_height : function() {
                return (that._mode !== SceneMode.SCENE2D) ? that.height : 0.0;
            }
        };
        this._pickUniforms = undefined;
        this._drawUniforms = undefined;
    }

    /**
     * DOC_TBA
     *
     * @memberof Polygon
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see Polygon#setPositions
     */
    Polygon.prototype.getPositions = function() {
        return this._positions;
    };

    /**
     * DOC_TBA
     *
     * @memberof Polygon
     *
     * @exception {DeveloperError} At least three positions are required.
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see Polygon#getPositions
     *
     * @example
     * polygon.setPositions([
     *   ellipsoid.toCartesian(new Cartographic3(...)),
     *   ellipsoid.toCartesian(new Cartographic3(...)),
     *   ellipsoid.toCartesian(new Cartographic3(...))
     * ]);
     */
    Polygon.prototype.setPositions = function(positions) {
        // positions can be null
        if (positions && (positions.length < 3)) {
            throw new DeveloperError("At least three positions are required.", "positions");
        }

        this._positions = positions;
        this._createVertexArray = true;
    };

    Polygon._appendTextureCoordinates = function(tangentPlane, positions2D, mesh) {
        var boundingRectangle = new AxisAlignedBoundingRectangle(positions2D);
        var origin = boundingRectangle.minimum;
        var extent = boundingRectangle.maximum.subtract(boundingRectangle.minimum);

        var positions = mesh.attributes.position.values;
        var length = positions.length;

        var textureCoordinates = new Float32Array(2 * (length / 3));
        var j = 0;

        // PERFORMANCE_IDEA:  Instead of storing texture coordinates per-vertex, we could
        // save memory by computing them in the fragment shader.  However, projecting
        // the point onto the plane may have precision issues.
        for ( var i = 0; i < length; i += 3) {
            var p = new Cartesian3(positions[i], positions[i + 1], positions[i + 2]);
            var st = tangentPlane.projectPointOntoPlane(p);
            st = st.subtract(origin);

            textureCoordinates[j++] = st.x / extent.x;
            textureCoordinates[j++] = st.y / extent.y;
        }

        mesh.attributes.textureCoordinates = {
            componentDatatype : ComponentDatatype.FLOAT,
            componentsPerAttribute : 2,
            values : textureCoordinates
        };

        return mesh;
    };

    Polygon.prototype._createMeshes = function() {
        // PERFORMANCE_IDEA:  Move this to a web-worker.
        var mesh;
        var meshes = null;

        if (this._positions) {
            var cleanedPositions = PolygonPipeline.cleanUp(this._positions);
            var tangentPlane = EllipsoidTangentPlane.create(this.ellipsoid, cleanedPositions);
            var positions2D = tangentPlane.projectPointsOntoPlane(cleanedPositions);

            var originalWindingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);
            if (originalWindingOrder.value === WindingOrder.CLOCKWISE.value) {
                positions2D.reverse();
                cleanedPositions.reverse();
            }

            var indices = PolygonPipeline.earClip2D(positions2D);

            // PERFORMANCE_IDEA:  Only compute texture coordinates if the material requires them.

            if (this._mode === SceneMode.SCENE3D) {
                mesh = PolygonPipeline.computeSubdivision(cleanedPositions, indices, this._granularity);
                mesh = Polygon._appendTextureCoordinates(tangentPlane, positions2D, mesh);
                mesh = PolygonPipeline.scaleToGeodeticHeight(this.ellipsoid, mesh, this.height);
                mesh = MeshFilters.reorderForPostVertexCache(mesh);
                mesh = MeshFilters.reorderForPreVertexCache(mesh);

                mesh.attributes.position2D = { // Not actually used in shader
                    value : [0.0, 0.0]
                };
                mesh.attributes.position3D = mesh.attributes.position;
                delete mesh.attributes.position;

                meshes = MeshFilters.fitToUnsignedShortIndices(mesh);
            } else {
                mesh = PolygonPipeline.computeSubdivision(cleanedPositions, indices, this._granularity);
                mesh = Polygon._appendTextureCoordinates(tangentPlane, positions2D, mesh);
                mesh = PolygonPipeline.scaleToGeodeticHeight(this.ellipsoid, mesh, this.height);
                mesh = MeshFilters.reorderForPostVertexCache(mesh);
                mesh = MeshFilters.reorderForPreVertexCache(mesh);
                mesh = MeshFilters.projectTo2D(mesh, this._projection);
                meshes = MeshFilters.fitToUnsignedShortIndices(mesh);
            }
        }

        return meshes;
    };

    Polygon._isModeTransition = function(oldMode, newMode) {
        // SCENE2D, COLUMBUS_VIEW, and MORPHING use the same rendering path, so a
        // transition only occurs when switching from/to SCENE3D
        return ((oldMode !== newMode) &&
                ((oldMode === SceneMode.SCENE3D) ||
                 (newMode === SceneMode.SCENE3D)));
    };

    Polygon.prototype._getGranularity = function(mode) {
        if (mode === SceneMode.SCENE3D) {
            return this.scene3D.granularity || this.granularity;
        }

        return this.scene2D.granularity || this.granularity;
    };

    Polygon.prototype._syncMorphTime = function(mode) {
        switch (mode) {
        case SceneMode.SCENE3D:
            this.morphTime = 1.0;
            break;

        case SceneMode.SCENE2D:
        case SceneMode.COLUMBUS_VIEW:
            this.morphTime = 0.0;
            break;

        // MORPHING - don't change it
        }
    };

    /**
     * Commits changes to properties before rendering by updating the object's WebGL resources.
     * This must be called before calling {@link Polygon#render} in order to realize
     * changes to polygon's positions and properties.
     *
     * @memberof Polygon
     *
     * @exception {DeveloperError} this.ellipsoid must be defined.
     * @exception {DeveloperError} this.granularity must be greater than zero.
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see Polygon#render
     */
    Polygon.prototype.update = function(context, sceneState) {

        if (!this.ellipsoid) {
            throw new DeveloperError("this.ellipsoid must be defined.");
        }

        var mode = sceneState.mode;
        var granularity = this._getGranularity(mode);

        if (granularity < 0.0) {
            throw new DeveloperError("this.granularity and scene2D/scene3D overrides must be greater than zero.");
        }

        if (this.show) {
            this._syncMorphTime(mode);
            this._mode = mode;

            var projection = sceneState.scene2D.projection;

            if (this._createVertexArray ||
                    (this._ellipsoid !== this.ellipsoid) ||
                    (this._height !== this.height) ||
                    (this._granularity !== granularity) ||
                    (this._bufferUsage.value !== this.bufferUsage.value) ||
                    (Polygon._isModeTransition(this._mode, mode)) ||
                    (this._projection !== projection)) {
                this._createVertexArray = false;
                this._ellipsoid = this.ellipsoid;
                this._height = this.height;
                this._granularity = granularity;
                this._bufferUsage = this.bufferUsage;

                this._projection = projection;

                this._vertices.update(context, this._positions, this._createMeshes(), this.bufferUsage);
            }

            if (!this._rs) {
                // TODO: Should not need this in 2D/columbus view, but is hiding a triangulation issue.
                this._rs = context.createRenderState({
                    cull : {
                        enabled : true,
                        face : CullFace.BACK
                    },
                    blending : BlendingState.ALPHA_BLEND
                });
            }

            // Recompile shader when material changes
            if (!this._material || (this._material !== this.material)) {
                this._material = this.material || new ColorMaterial();

                var fsSource =
                    "#line 0\n" +
                    Noise +
                    "#line 0\n" +
                    this.material._getShaderSource() +
                    "#line 0\n" +
                    PolygonFS;

                this._sp = this._sp && this._sp.release();
                this._sp = context.getShaderCache().getShaderProgram(PolygonVS, fsSource, attributeIndices);

                this._drawUniforms = combine(this._uniforms, this.material._uniforms);
            }
        }
    };

    /**
     * Renders the polygon.  In order for changes to positions and properties to be realized,
     * {@link Polygon#update} must be called before <code>render</code>.
     *
     * @memberof Polygon
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see Polygon#update
     * @see Polygon#setTextureAtlas
     */
    Polygon.prototype.render = function(context) {
        if (this.show) {
            var vas = this._vertices.getVertexArrays();
            var length = vas.length;
            for ( var j = 0; j < length; ++j) {
                context.draw({
                    primitiveType : PrimitiveType.TRIANGLES,
                    shaderProgram : this._sp,
                    uniformMap : this._drawUniforms,
                    vertexArray : vas[j],
                    renderState : this._rs
                });
            }
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof Polygon
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     */
    Polygon.prototype.updateForPick = function(context) {
        if (this.show) {
            this._spPick = context.getShaderCache().getShaderProgram(PolygonVSPick, PolygonFSPick, attributeIndices);

            this._rsPick = context.createRenderState({
                // TODO: Should not need this in 2D/columbus view, but is hiding a triangulation issue.
                cull : {
                    enabled : true,
                    face : CullFace.BACK
                }
            });

            this._pickId = context.createPickId(this);

            var that = this;
            this._pickUniforms = {
                u_pickColor : function() {
                    return that._pickId.normalizedRgba;
                },
                u_morphTime : function() {
                    return that.morphTime;
                },
                u_height : function() {
                    return that.height;
                }
            };

            this.updateForPick = function(context) {
            };
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof Polygon
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     */
    Polygon.prototype.renderForPick = function(context, framebuffer) {
        if (this.show) {
            var vas = this._vertices.getVertexArrays();
            var length = vas.length;
            for ( var j = 0; j < length; ++j) {
                context.draw({
                    primitiveType : PrimitiveType.TRIANGLES,
                    shaderProgram : this._spPick,
                    uniformMap : this._pickUniforms,
                    vertexArray : vas[j],
                    renderState : this._rsPick,
                    framebuffer : framebuffer
                });
            }
        }
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof Polygon
     *
     * @return {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     *
     * @see Polygon#destroy
     */
    Polygon.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>null</code>) to the object as done in the example.
     *
     * @memberof Polygon
     *
     * @return {null}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see Polygon#isDestroyed
     *
     * @example
     * polygon = polygon && polygon.destroy();
     */
    Polygon.prototype.destroy = function() {
        this._sp = this._sp && this._sp.release();
        this._spPick = this._spPick && this._spPick.release();
        this._vertices = this._vertices.destroy();
        this._pickId = this._pickId && this._pickId.destroy();
        return destroyObject(this);
    };

    return Polygon;
});
/**
 * @author sole / http://soledadpenades.com
 * @author mr.doob / http://mrdoob.com
 * @author Robert Eisele / http://www.xarg.org
 * @author Philippe / http://philippe.elsass.me
 * @author Robert Penner / http://www.robertpenner.com/easing_terms_of_use.html
 * @author Paul Lewis / http://www.aerotwist.com/
 * @author lechecacharro
 * @author Josh Faul / http://jocafa.com/
 * @author egraether / http://egraether.com/
 */

/*global define*/
define('ThirdParty/Tween',[],function() {

var TWEEN = TWEEN || ( function () {

	var _interval = null, _fps = 60, _autostart = false, _tweens = [];

	return {

		setFPS: function ( fps ) {

			_fps = fps || 60;

		},

		start: function ( fps ) {

			if ( fps ) {

				this.setFPS( fps );

			}

			if ( _interval === null ) {

				_interval = setInterval( this.update, 1000 / _fps );

			}

		},

		stop: function () {

			clearInterval( _interval );

			_interval = null;

		},

		setAutostart: function ( value ) {

			_autostart = value;

			if ( _autostart && _tweens.length ) {

				this.start();

			}

		},

		add: function ( tween ) {

			_tweens.push( tween );

			if ( _autostart ) {

				this.start();

			}

		},

		getAll: function () {

			return _tweens;

		},

		removeAll: function () {

			_tweens = [];

		},

		remove: function ( tween ) {

			var i = _tweens.indexOf( tween );

			if ( i !== -1 ) {

				_tweens.splice( i, 1 );

			}

		},

		update: function ( time ) {

			var i = 0, num_tweens = _tweens.length, time = time || Date.now();

			while ( i < num_tweens ) {

				if ( _tweens[ i ].update( time ) ) {

					i++;

				} else {

					_tweens.splice( i, 1 );
					num_tweens--;

				}

			}

			if ( num_tweens === 0 && _autostart ) {

				TWEEN.stop();

			}

		}

	};

} )();

TWEEN.Tween = function ( object ) {

	var _object = object,
	_valuesStart = {},
	_valuesDelta = {},
	_valuesEnd = {},
	_duration = 1000,
	_delayTime = 0,
	_startTime = null,
	_easingFunction = TWEEN.Easing.Linear.EaseNone,
	_chainedTween = null,
	_onUpdateCallback = null,
	_onCompleteCallback = null;

	this.to = function ( properties, duration ) {

		if( duration !== null ) {

			_duration = duration;

		}

		for ( var property in properties ) {

			// This prevents the engine from interpolating null values
			if ( _object[ property ] === null ) {

				continue;

			}

			// The current values are read when the tween starts;
			// here we only store the final desired values
			_valuesEnd[ property ] = properties[ property ];

		}

		return this;

	};

	this.start = function ( time ) {

		TWEEN.add( this );

		_startTime = time ? time + _delayTime : Date.now() + _delayTime;

		for ( var property in _valuesEnd ) {

			// Again, prevent dealing with null values
			if ( _object[ property ] === null ) {

				continue;

			}

			_valuesStart[ property ] = _object[ property ];
			_valuesDelta[ property ] = _valuesEnd[ property ] - _object[ property ];

		}

		return this;
	};

	this.stop = function () {

		TWEEN.remove( this );
		return this;

	};

	this.delay = function ( amount ) {

		_delayTime = amount;
		return this;

	};

	this.easing = function ( easing ) {

		_easingFunction = easing;
		return this;

	};

	this.chain = function ( chainedTween ) {

		_chainedTween = chainedTween;
		return this;

	};

	this.onUpdate = function ( onUpdateCallback ) {

		_onUpdateCallback = onUpdateCallback;
		return this;

	};

	this.onComplete = function ( onCompleteCallback ) {

		_onCompleteCallback = onCompleteCallback;
		return this;

	};

	this.update = function ( time ) {

		var property, elapsed, value;

		if ( time < _startTime ) {

			return true;

		}

		elapsed = ( time - _startTime ) / _duration;
		elapsed = elapsed > 1 ? 1 : elapsed;

		value = _easingFunction( elapsed );

		for ( property in _valuesDelta ) {

			_object[ property ] = _valuesStart[ property ] + _valuesDelta[ property ] * value;

		}

		if ( _onUpdateCallback !== null ) {

			_onUpdateCallback.call( _object, value );

		}

		if ( elapsed == 1 ) {

			if ( _onCompleteCallback !== null ) {

				_onCompleteCallback.call( _object );

			}

			if ( _chainedTween !== null ) {

				_chainedTween.start();

			}

			return false;

		}

		return true;

	};

	/*
	this.destroy = function () {

		TWEEN.remove( this );

	};
	*/
};

TWEEN.Easing = { Linear: {}, Quadratic: {}, Cubic: {}, Quartic: {}, Quintic: {}, Sinusoidal: {}, Exponential: {}, Circular: {}, Elastic: {}, Back: {}, Bounce: {} };


TWEEN.Easing.Linear.EaseNone = function ( k ) {

	return k;

};

//

TWEEN.Easing.Quadratic.EaseIn = function ( k ) {

	return k * k;

};

TWEEN.Easing.Quadratic.EaseOut = function ( k ) {

	return k * ( 2 - k );

};

TWEEN.Easing.Quadratic.EaseInOut = function ( k ) {

	if ( ( k *= 2 ) < 1 ) return 0.5 * k * k;
	return - 0.5 * ( --k * ( k - 2 ) - 1 );

};

//

TWEEN.Easing.Cubic.EaseIn = function ( k ) {

	return k * k * k;

};

TWEEN.Easing.Cubic.EaseOut = function ( k ) {

	return --k * k * k + 1;

};

TWEEN.Easing.Cubic.EaseInOut = function ( k ) {

	if ( ( k *= 2 ) < 1 ) return 0.5 * k * k * k;
	return 0.5 * ( ( k -= 2 ) * k * k + 2 );

};

//

TWEEN.Easing.Quartic.EaseIn = function ( k ) {

	return k * k * k * k;

};

TWEEN.Easing.Quartic.EaseOut = function ( k ) {

	return 1 - --k * k * k * k;

};

TWEEN.Easing.Quartic.EaseInOut = function ( k ) {

	if ( ( k *= 2 ) < 1) return 0.5 * k * k * k * k;
	return - 0.5 * ( ( k -= 2 ) * k * k * k - 2 );

};

//

TWEEN.Easing.Quintic.EaseIn = function ( k ) {

	return k * k * k * k * k;

};

TWEEN.Easing.Quintic.EaseOut = function ( k ) {

	return --k * k * k * k * k + 1;

};

TWEEN.Easing.Quintic.EaseInOut = function ( k ) {

	if ( ( k *= 2 ) < 1 ) return 0.5 * k * k * k * k * k;
	return 0.5 * ( ( k -= 2 ) * k * k * k * k + 2 );

};

//

TWEEN.Easing.Sinusoidal.EaseIn = function ( k ) {

	return 1 - Math.cos( k * Math.PI / 2 );

};

TWEEN.Easing.Sinusoidal.EaseOut = function ( k ) {

	return Math.sin( k * Math.PI / 2 );

};

TWEEN.Easing.Sinusoidal.EaseInOut = function ( k ) {

	return 0.5 * ( 1 - Math.cos( Math.PI * k ) );

};

//

TWEEN.Easing.Exponential.EaseIn = function ( k ) {

	return k === 0 ? 0 : Math.pow( 1024, k - 1 );

};

TWEEN.Easing.Exponential.EaseOut = function ( k ) {

	return k === 1 ? 1 : 1 - Math.pow( 2, - 10 * k );

};

TWEEN.Easing.Exponential.EaseInOut = function ( k ) {

	if ( k === 0 ) return 0;
	if ( k === 1 ) return 1;
	if ( ( k *= 2 ) < 1 ) return 0.5 * Math.pow( 1024, k - 1 );
	return 0.5 * ( - Math.pow( 2, - 10 * ( k - 1 ) ) + 2 );

};

//

TWEEN.Easing.Circular.EaseIn = function ( k ) {

	return 1 - Math.sqrt( 1 - k * k );

};

TWEEN.Easing.Circular.EaseOut = function ( k ) {

	return Math.sqrt( 1 - --k * k );

};

TWEEN.Easing.Circular.EaseInOut = function ( k ) {

	if ( ( k *= 2 ) < 1) return - 0.5 * ( Math.sqrt( 1 - k * k) - 1);
	return 0.5 * ( Math.sqrt( 1 - ( k -= 2) * k) + 1);

};

//

TWEEN.Easing.Elastic.EaseIn = function ( k ) {

	var s, a = 0.1, p = 0.4;
	if ( k === 0 ) return 0;
	if ( k === 1 ) return 1;
	if ( !a || a < 1 ) { a = 1; s = p / 4; }
	else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );
	return - ( a * Math.pow( 2, 10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) );

};

TWEEN.Easing.Elastic.EaseOut = function ( k ) {

	var s, a = 0.1, p = 0.4;
	if ( k === 0 ) return 0;
	if ( k === 1 ) return 1;
	if ( !a || a < 1 ) { a = 1; s = p / 4; }
	else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );
	return ( a * Math.pow( 2, - 10 * k) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) + 1 );

};

TWEEN.Easing.Elastic.EaseInOut = function ( k ) {

	var s, a = 0.1, p = 0.4;
	if ( k === 0 ) return 0;
	if ( k === 1 ) return 1;
	if ( !a || a < 1 ) { a = 1; s = p / 4; }
	else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );
	if ( ( k *= 2 ) < 1 ) return - 0.5 * ( a * Math.pow( 2, 10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) );
	return a * Math.pow( 2, -10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) * 0.5 + 1;

};

//

TWEEN.Easing.Back.EaseIn = function ( k ) {

	var s = 1.70158;
	return k * k * ( ( s + 1 ) * k - s );

};

TWEEN.Easing.Back.EaseOut = function ( k ) {

	var s = 1.70158;
	return --k * k * ( ( s + 1 ) * k + s ) + 1;

};

TWEEN.Easing.Back.EaseInOut = function ( k ) {

	var s = 1.70158 * 1.525;
	if ( ( k *= 2 ) < 1 ) return 0.5 * ( k * k * ( ( s + 1 ) * k - s ) );
	return 0.5 * ( ( k -= 2 ) * k * ( ( s + 1 ) * k + s ) + 2 );

};

//

TWEEN.Easing.Bounce.EaseIn = function ( k ) {

	return 1 - TWEEN.Easing.Bounce.EaseOut( 1 - k );

};

TWEEN.Easing.Bounce.EaseOut = function ( k ) {

	if ( k < ( 1 / 2.75 ) ) {

		return 7.5625 * k * k;

	} else if ( k < ( 2 / 2.75 ) ) {

		return 7.5625 * ( k -= ( 1.5 / 2.75 ) ) * k + 0.75;

	} else if ( k < ( 2.5 / 2.75 ) ) {

		return 7.5625 * ( k -= ( 2.25 / 2.75 ) ) * k + 0.9375;

	} else {

		return 7.5625 * ( k -= ( 2.625 / 2.75 ) ) * k + 0.984375;

	}

};

TWEEN.Easing.Bounce.EaseInOut = function ( k ) {

	if ( k < 0.5 ) return TWEEN.Easing.Bounce.EaseIn( k * 2 ) * 0.5;
	return TWEEN.Easing.Bounce.EaseOut( k * 2 - 1 ) * 0.5 + 0.5;

};

return TWEEN;
});

/*global define*/
define('Scene/AnimationCollection',[
        '../Core/DeveloperError',
        '../Core/clone',
        '../ThirdParty/Tween'
    ], function(
        DeveloperError,
        clone,
        Tween) {
    

    /**
     * DOC_TBA
     *
     * @name AnimationCollection
     * @constructor
     */
    function AnimationCollection() {
    }

    /**
     * DOC_TBA
     * @memberof AnimationCollection
     */
    AnimationCollection.prototype.add = function(template) {
        var t = template || {};
        t.duration = (typeof t.duration === "undefined") ? 3000 : t.duration;
        t.delayDuration = (typeof t.delayDuration === "undefined") ? 0 : t.delayDuration;
        t.easingFunction = (typeof t.easingFunction === "undefined") ? Tween.Easing.Linear.EaseNone : t.easingFunction;

        var value = clone(t.startValue);
        var tween = new Tween.Tween(value);
        tween.to(t.stopValue, t.duration);
        tween.delay(t.delayDuration);
        tween.easing(t.easingFunction);
        if (t.onUpdate) {
            tween.onUpdate(function() {
                t.onUpdate(value);
            });
        }
        tween.onComplete(t.onComplete || null);
        tween.start();

        return {
            _tween : tween
        };
    };

    /**
     * DOC_TBA
     * @memberof AnimationCollection
     *
     * @exception {DeveloperError} material is required.
     * @exception {DeveloperError} material has no properties with alpha components.
     */
    AnimationCollection.prototype.addAlpha = function(material, start, stop, template) {
        if (typeof material === "undefined") {
            throw new DeveloperError("material is required.", "material");
        }

        var properties = [];

        for ( var property in material) {
            if (material.hasOwnProperty(property) &&
                typeof material[property] !== "undefined" &&
                typeof material[property].alpha !== "undefined") {
                properties.push(property);
            }
        }

        if (properties.length === 0) {
            throw new DeveloperError("material has no properties with alpha components.", "material");
        }

        // Default to fade in
        start = (typeof start === "undefined") ? 0.0 : start;
        stop = (typeof stop === "undefined") ? 1.0 : stop;

        var t = template || {};
        t.duration = (typeof t.duration === "undefined") ? 3000 : t.duration;
        t.delayDuration = (typeof t.delayDuration === "undefined") ? 0 : t.delayDuration;
        t.easingFunction = (typeof t.easingFunction === "undefined") ? Tween.Easing.Linear.EaseNone : t.easingFunction;

        var value = {
            alpha : start
        };
        var tween = new Tween.Tween(value);
        tween.to({
            alpha : stop
        }, t.duration);
        tween.delay(t.delayDuration);
        tween.easing(t.easingFunction);
        tween.onUpdate(function() {
            var length = properties.length;
            for ( var i = 0; i < length; ++i) {
                material[properties[i]].alpha = value.alpha;
            }
        });
        tween.onComplete(t.onComplete || null);
        tween.start();

        return {
            _tween : tween
        };
    };

    /**
     * DOC_TBA
     * @memberof AnimationCollection
     */
    AnimationCollection.prototype.addProperty = function(object, property, start, stop, template) {
        if (typeof object === "undefined") {
            throw new DeveloperError("object is required.", "object");
        }

        if (typeof property === "undefined") {
            throw new DeveloperError("property is required.", "property");
        }

        if (typeof object[property] === "undefined") {
            throw new DeveloperError("object must have the specified property.");
        }

        var t = template || {};
        t.duration = (typeof t.duration === "undefined") ? 3000 : t.duration;
        t.delayDuration = (typeof t.delayDuration === "undefined") ? 0 : t.delayDuration;
        t.easingFunction = (typeof t.easingFunction === "undefined") ? Tween.Easing.Linear.EaseNone : t.easingFunction;

        var value = {
            value : start
        };
        var tween = new Tween.Tween(value);
        tween.to({
            value : stop
        }, t.duration);
        tween.delay(t.delayDuration);
        tween.easing(t.easingFunction);
        tween.onUpdate(function() {
            object[property] = value.value;
        });
        tween.onComplete(t.onComplete || null);
        tween.start();

        return {
            _tween : tween
        };
    };

    /**
     * DOC_TBA
     * @memberof AnimationCollection
     *
     * @exception {DeveloperError} material is required.
     * @exception {DeveloperError} material must have an offset property.
     */
    AnimationCollection.prototype.addOffsetIncrement = function(material, template) {
        if (typeof material === "undefined") {
            throw new DeveloperError("material is required.", "material");
        }

        if (typeof material.offset === "undefined") {
            throw new DeveloperError("material must have an offset property.", "material");
        }

        var t = template || {};
        t.duration = (typeof t.duration === "undefined") ? 3000 : t.duration;
        t.delayDuration = (typeof t.delayDuration === "undefined") ? 0 : t.delayDuration;
        t.easingFunction = (typeof t.easingFunction === "undefined") ? Tween.Easing.Linear.EaseNone : t.easingFunction;

        var value = {
            offset : material.offset
        };
        var tween = new Tween.Tween(value);
        tween.to({
            offset : material.offset + 1.0
        }, t.duration);
        tween.delay(t.delayDuration);
        tween.easing(t.easingFunction);
        tween.onUpdate(function() {
            material.offset = value.offset;
        });
        // t.onComplete is ignored.
        tween.onComplete(function() {
            tween.to({
                offset : material.offset + 1.0
            }, t.duration);
            tween.start();
        });
        tween.start();

        return {
            _tween : tween
        };
    };

    /**
     * DOC_TBA
     * @memberof AnimationCollection
     */
    AnimationCollection.prototype.remove = function(animation) {
        if (animation) {
            var count = Tween.getAll().length;
            Tween.remove(animation._tween);

            return Tween.getAll().length === (count - 1);
        }

        return false;
    };

    /**
     * DOC_TBA
     * @memberof AnimationCollection
     */
    AnimationCollection.prototype.removeAll = function() {
        Tween.removeAll();
    };

    /**
     * DOC_TBA
     * @memberof AnimationCollection
     */
    AnimationCollection.prototype.update = function() {
        Tween.update();
    };

    return AnimationCollection;
});
/*global define*/
define('Scene/Scene',[
        '../Core/destroyObject',
        '../Core/EquidistantCylindricalProjection',
        '../Core/Ellipsoid',
        '../Renderer/Context',
        './Camera',
        './CompositePrimitive',
        './AnimationCollection',
        './SceneMode'
    ], function(
        destroyObject,
        EquidistantCylindricalProjection,
        Ellipsoid,
        Context,
        Camera,
        CompositePrimitive,
        AnimationCollection,
        SceneMode) {
    

    /**
     * DOC_TBA
     *
     * @name Scene
     * @constructor
     */
    function Scene(canvas) {
        var context = new Context(canvas);

        this._canvas = canvas;
        this._context = context;
        this._primitives = new CompositePrimitive();
        this._pickFramebuffer = undefined;
        this._camera = new Camera(canvas);
        this._clearState = context.createClearState({
            color : {
                red : 0.0,
                green : 0.0,
                blue : 0.0,
                alpha : 1.0
            },
            depth : 1.0
        });

        this._animate = undefined; // Animation callback
        this._animations = new AnimationCollection();

        this._shaderFrameCount = 0;

        /**
         * DOC_TBA
         */
        this.mode = SceneMode.SCENE3D;

        /**
         * DOC_TBA
         */
        this.scene2D = {
            /**
             * DOC_TBA
             */
            projection : new EquidistantCylindricalProjection(Ellipsoid.getWgs84())
        };
    }

    /**
     * DOC_TBA
     * @memberof Scene
     */
    Scene.prototype.getCanvas = function() {
        return this._canvas;
    };

    /**
     * DOC_TBA
     * @memberof Scene
     */
    Scene.prototype.getContext = function() {
        return this._context;
    };

    /**
     * DOC_TBA
     * @memberof Scene
     */
    Scene.prototype.getPrimitives = function() {
        return this._primitives;
    };

    /**
     * DOC_TBA
     * @memberof Scene
     */
    Scene.prototype.getCamera = function() {
        return this._camera;
    };
    // TODO: setCamera

    /**
     * DOC_TBA
     * @memberof Scene
     */
    Scene.prototype.getUniformState = function() {
        return this._context.getUniformState();
    };

    /**
     * DOC_TBA
     * @memberof Scene
     */
    Scene.prototype.getAnimations = function() {
        return this._animations;
    };

    /**
     * DOC_TBA
     * @memberof Scene
     */
    Scene.prototype.setSunPosition = function(sunPosition) {
        this.getUniformState().setSunPosition(sunPosition);
    };

    /**
     * DOC_TBA
     * @memberof Scene
     */
    Scene.prototype.getSunPosition = function() {
        return this.getUniformState().getSunPosition();
    };

    /**
     * DOC_TBA
     * @memberof Scene
     */
    Scene.prototype.setAnimation = function(animationCallback) {
        this._animate = animationCallback;
    };

    /**
     * DOC_TBA
     * @memberof Scene
     */
    Scene.prototype.getAnimation = function() {
        return this._animate;
    };

    Scene.prototype._update = function() {
        var us = this.getUniformState();
        var camera = this._camera;

        // Destroy released shaders once every 120 frames to avoid thrashing the cache
        if (this._shaderFrameCount++ === 120) {
            this._shaderFrameCount = 0;
            this._context.getShaderCache().destroyReleasedShaderPrograms();
        }

        this._animations.update();
        camera.update();
        us.setProjection(camera.frustum.getProjectionMatrix());
        if (camera.frustum.getInfiniteProjectionMatrix) {
            us.setInfiniteProjection(camera.frustum.getInfiniteProjectionMatrix());
        }
        us.setView(camera.getViewMatrix());

        if (this._animate) {
            this._animate();
        }

        this._primitives.update(this._context, {
            mode : this.mode,
            scene2D : this.scene2D
        });
    };

    /**
     * DOC_TBA
     * @memberof Scene
     */
    Scene.prototype.render = function() {
        this._update();

        this._context.clear(this._clearState);
        this._primitives.render(this._context);
    };

    /**
     * DOC_TBA
     * @memberof Scene
     */
    Scene.prototype.pick = function(windowPosition) {
        var context = this._context;
        var primitives = this._primitives;

        this._pickFramebuffer = this._pickFramebuffer || context.createPickFramebuffer();
        var fb = this._pickFramebuffer.begin();

        // TODO: Should we also do a regular update?
        primitives.updateForPick(context);
        primitives.renderForPick(context, fb);

        return this._pickFramebuffer.end({
            x : windowPosition.x,
            y : (this._canvas.clientHeight - windowPosition.y)
        });
    };

    /**
     * DOC_TBA
     * @memberof Scene
     */
    Scene.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * DOC_TBA
     * @memberof Scene
     */
    Scene.prototype.destroy = function() {
        this._camera = this._camera && this._camera.destroy();
        this._pickFramebuffer = this._pickFramebuffer && this._pickFramebuffer.destroy();
        this._primitives = this._primitives && this._primitives.destroy();
        this._context = this._context && this._context.destroy();
        return destroyObject(this);
    };

    return Scene;
});
/*global define*/
define('Scene/SceneTransitioner',[
        '../Core/destroyObject',
        '../Core/Math',
        '../Core/EventHandler',
        '../Core/MouseEventType',
        '../Core/Ellipsoid',
        '../Core/Cartesian3',
        '../Core/Cartesian4',
        '../Core/Cartographic3',
        '../Core/Matrix4',
        '../ThirdParty/Tween',
        './OrthographicFrustum',
        './PerspectiveFrustum',
        './SceneMode'
    ], function(
        destroyObject,
        CesiumMath,
        EventHandler,
        MouseEventType,
        Ellipsoid,
        Cartesian3,
        Cartesian4,
        Cartographic3,
        Matrix4,
        Tween,
        OrthographicFrustum,
        PerspectiveFrustum,
        SceneMode) {
    

    /**
     * DOC_TBA
     *
     * @name SceneTransitioner
     * @constructor
     */
    function SceneTransitioner(scene, ellipsoid) {
        this._scene = scene;
        this._ellipsoid = ellipsoid || Ellipsoid.getWgs84();
        var canvas = scene.getCanvas();

        // Position camera and size frustum so the entire 2D map is visible
        var maxRadii = this._ellipsoid.getMaximumRadius();
        var position = new Cartesian3(0.0, 0.0, 2.0 * maxRadii);
        var direction = position.negate().normalize();
        var up = Cartesian3.getUnitY();

        var frustum = new OrthographicFrustum();
        frustum.right = maxRadii * Math.PI;
        frustum.left = -frustum.right;
        frustum.top = frustum.right * (canvas.clientHeight / canvas.clientWidth);
        frustum.bottom = -frustum.top;
        frustum.near = 0.01 * maxRadii;
        frustum.far = 60.0 * maxRadii;

        var transform = new Matrix4(
                0.0, 0.0, 1.0, 0.0,
                1.0, 0.0, 0.0, 0.0,
                0.0, 1.0, 0.0, 0.0,
                0.0, 0.0, 0.0, 1.0);

        this._camera2D = {
            position : position,
            direction : direction,
            up : up,
            frustum : frustum,
            transform : transform
        };

        position = new Cartesian3(0.0, -1.0, 1.0).normalize().multiplyWithScalar(5.0 * maxRadii);
        direction = Cartesian3.getZero().subtract(position).normalize();
        var right = direction.cross(Cartesian3.getUnitZ()).normalize();
        up = right.cross(direction);

        frustum = new PerspectiveFrustum();
        frustum.fovy = CesiumMath.toRadians(60.0);
        frustum.aspectRatio = canvas.clientWidth / canvas.clientHeight;
        frustum.near = 0.01 * maxRadii;
        frustum.far = 60.0 * maxRadii;

        this._cameraCV = {
            position : position,
            direction : direction,
            up : up,
            frustum : frustum,
            transform : transform
        };

        position = new Cartesian3(0.0, -2.0, 1.0).normalize().multiplyWithScalar(2.0 * maxRadii);
        direction = Cartesian3.getZero().subtract(position).normalize();
        right = direction.cross(Cartesian3.getUnitZ()).normalize();
        up = right.cross(direction);

        this._camera3D = {
            position : position,
            direction : direction,
            up : up,
            frustum : frustum
        };

        this._currentAnimations = [];
        this._morphHandler = undefined;
        this._morphCancelled = false;

        /**
         * DOC_TBA
         * @type {Number}
         */
        this.morphDuration2D = 3000;

        /**
         * DOC_TBA
         * @type {Number}
         */
        this.morphDuration3D = 3000;

        /**
         * DOC_TBA
         * @type {Number}
         */
        this.morphDurationColumbusView = 3000;

        /**
         * DOC_TBA
         * @type {Boolean}
         */
        this.endMorphOnMouseInput = true;
    }

    /**
     * DOC_TBA
     * @memberof SceneTransitioner
     */
    SceneTransitioner.prototype.to2D = function() {
        var scene = this._scene;

        if (scene.mode !== SceneMode.SCENE2D) {
            scene.mode = SceneMode.SCENE2D;

            this._destroyMorphHandler();

            var camera = scene.getCamera();
            var controllers = camera.getControllers();
            controllers.removeAll();
            controllers.add2D(this._ellipsoid);

            camera.frustum = this._camera2D.frustum.clone();
            camera.transform = this._camera2D.transform.clone();

            // TODO: Match incoming columbus-view or 3D position
            camera.position = this._camera2D.position.clone();
            camera.direction = this._camera2D.direction.clone();
            camera.up = this._camera2D.up.clone();
        }
    };

    /**
     * DOC_TBA
     * @memberof SceneTransitioner
     */
    SceneTransitioner.prototype.toColumbusView = function() {
        var scene = this._scene;
        var previousMode = scene.mode;

        if (scene.mode !== SceneMode.COLUMBUS_VIEW) {
            scene.mode = SceneMode.COLUMBUS_VIEW;

            this._destroyMorphHandler();

            var camera = scene.getCamera();
            var controllers = camera.getControllers();
            controllers.removeAll();

            controllers.addColumbusView();

            camera.frustum = this._cameraCV.frustum.clone();
            camera.transform = this._cameraCV.transform.clone();

            if (previousMode !== SceneMode.MORPHING || this._morphCancelled) {
                this._morphCancelled = false;

                // TODO: Match incoming 2D or 3D position
                camera.position = this._cameraCV.position.clone();
                camera.direction = this._cameraCV.direction.clone();
                camera.up = this._cameraCV.up.clone();
            }
        }
    };

    /**
     * DOC_TBA
     * @memberof SceneTransitioner
     */
    SceneTransitioner.prototype.to3D = function() {
        var scene = this._scene;
        var previousMode = scene.mode;

        if (scene.mode !== SceneMode.SCENE3D) {
            scene.mode = SceneMode.SCENE3D;

            this._destroyMorphHandler();

            var camera = scene.getCamera();
            var controllers = camera.getControllers();
            controllers.removeAll();
            controllers.addSpindle();
            controllers.addFreeLook();

            camera.frustum = this._camera3D.frustum.clone();
            camera.transform = Matrix4.getIdentity();

            if (previousMode !== SceneMode.MORPHING || this._morphCancelled) {
                this._morphCancelled = false;

                // TODO: Match incoming columbus-view or 2D position
                camera.position = this._camera3D.position.clone();
                camera.direction = this._camera3D.direction.clone();
                camera.up = this._camera3D.up.clone();
            }
        }
    };

    SceneTransitioner.prototype._createMorphHandler = function (endMorphFunction) {
        var that = this;

        var controllers = this._scene.getCamera().getControllers();
        controllers.removeAll();

        if (this.endMorphOnMouseInput) {
            this._morphHandler = new EventHandler(this._scene.getCanvas());
            this._morphHandler.setMouseAction(function () {
                that._morphCancelled = true;
                endMorphFunction.call(that);
            }, MouseEventType.LEFT_DOWN);
            this._morphHandler.setMouseAction(function () {
                that._morphCancelled = true;
                endMorphFunction.call(that);
            }, MouseEventType.MIDDLE_DOWN);
            this._morphHandler.setMouseAction(function () {
                that._morphCancelled = true;
                endMorphFunction.call(that);
            }, MouseEventType.RIGHT_DOWN);
            this._morphHandler.setMouseAction(function () {
                that._morphCancelled = true;
                endMorphFunction.call(that);
            }, MouseEventType.WHEEL);
        }
    };

    SceneTransitioner.prototype._destroyMorphHandler = function () {
        var animations = this._scene.getAnimations();
        for (var i = 0; i < this._currentAnimations.length; ++i) {
            animations.remove(this._currentAnimations[i]);
        }
        this._currentAnimations.length = 0;
        this._morphHandler = this._morphHandler && this._morphHandler.destroy();
    };

    SceneTransitioner.prototype._changeCameraTransform = function(camera, transform) {
        var pos = new Cartesian4(camera.position.x, camera.position.y, camera.position.z, 1.0);
        var dir = new Cartesian4(camera.direction.x, camera.direction.y, camera.direction.z, 0.0);
        var up = new Cartesian4(camera.up.x, camera.up.y, camera.up.z, 0.0);

        var frame = transform.inverseTransformation().multiplyWithMatrix(camera.transform);
        camera.transform = transform.clone();

        camera.position = frame.multiplyWithVector(pos).getXYZ();
        camera.direction = frame.multiplyWithVector(dir).getXYZ();
        camera.up = frame.multiplyWithVector(up).getXYZ();
        camera.right = camera.direction.cross(camera.up);
    };

    SceneTransitioner.prototype._columbusViewMorph = function(startPosition, endPosition, time) {
        // Just linear for now.
        return startPosition.lerp(endPosition, time);
    };

    SceneTransitioner.prototype._scenePerspectiveToOrthographic = function(duration, onComplete) {
        var that = this;

        var scene = this._scene;
        var camera = scene.getCamera();

        var startPos = camera.position;
        var startFOVy = camera.frustum.fovy;
        var endFOVy = CesiumMath.RADIANS_PER_DEGREE * 0.5;
        var d = startPos.magnitude() * Math.tan(startFOVy * 0.5);

        // TODO: remove this when multi-frustum is implemented.
        camera.frustum.far = d / Math.tan(endFOVy * 0.5) + 10000000.0;

        var update = function(value) {
            camera.frustum.fovy = CesiumMath.lerp(startFOVy, endFOVy, value.time);

            var distance = d / Math.tan(camera.frustum.fovy * 0.5);
            camera.position = camera.position.normalize().multiplyWithScalar(distance);
        };

        var animation = scene.getAnimations().add({
            duration : duration,
            easingFunction : Tween.Easing.Quartic.EaseOut,
            startValue : {
                time : 0.0
            },
            stopValue : {
                time : 1.0
            },
            onUpdate : update,
            onComplete : function() {
                camera.frustum = that._camera2D.frustum.clone();
                onComplete.call(that);
            }
        });
        this._currentAnimations.push(animation);
    };

    SceneTransitioner.prototype._sceneCVTo2D = function(duration, onComplete) {
        var that = this;

        var scene = this._scene;
        var camera = scene.getCamera();
        var maxRadii = this._ellipsoid.getMaximumRadius();

        this._changeCameraTransform(camera, this._cameraCV.transform);

        var startPos = camera.position.clone();
        var startDir = camera.direction.clone();
        var startUp = camera.up.clone();

        var tanPhi = Math.tan(this._cameraCV.frustum.fovy * 0.5);
        var tanTheta = this._cameraCV.frustum.aspectRatio * tanPhi;
        var d = (maxRadii * Math.PI) / tanTheta;

        var endPos = this._camera2D.position.normalize().multiplyWithScalar(d);
        var endDir = that._camera2D.direction.clone();
        var endUp = that._camera2D.up.clone();

        var updateCV = function(value) {
            camera.position = that._columbusViewMorph(startPos, endPos, value.time);
            camera.direction = that._columbusViewMorph(startDir, endDir, value.time);
            camera.up = that._columbusViewMorph(startUp, endUp, value.time);
            camera.right = camera.direction.cross(camera.up);
        };

        duration = duration * 0.5;
        var animation = scene.getAnimations().add({
            duration : duration,
            easingFunction : Tween.Easing.Quartic.EaseOut,
            startValue : {
                time : 0.0
            },
            stopValue : {
                time : 1.0
            },
            onUpdate : updateCV,
            onComplete : function() {
                that._scenePerspectiveToOrthographic(duration, onComplete);
            }
        });
        this._currentAnimations.push(animation);
    };

    SceneTransitioner.prototype._scene3DTo2D = function(duration, onComplete) {
        duration = duration * 0.5;

        var maxRadii = this._ellipsoid.getMaximumRadius();

        var tanPhi = Math.tan(this._camera3D.frustum.fovy * 0.5);
        var tanTheta = this._camera3D.frustum.aspectRatio * tanPhi;
        var d = (maxRadii * Math.PI) / tanTheta;

        var camera3DTo2D = {};
        camera3DTo2D.position = this._camera2D.position.normalize().multiplyWithScalar(d);
        camera3DTo2D.direction = this._camera2D.direction.clone();
        camera3DTo2D.up = this._camera2D.up.clone();

        var complete = function() {
            this._scenePerspectiveToOrthographic(duration, onComplete);
        };
        this._scene3DToCV(duration, camera3DTo2D, complete);
    };

    SceneTransitioner.prototype._sceneOrthographicToPerspective = function(duration, onComplete) {
        var that = this;

        var scene = this._scene;
        var camera = scene.getCamera();
        var maxRadii = this._ellipsoid.getMaximumRadius();

        var tanPhi = Math.tan(this._cameraCV.frustum.fovy * 0.5);
        var tanTheta = this._cameraCV.frustum.aspectRatio * tanPhi;
        var d = (maxRadii * Math.PI) / tanTheta;
        var endPos2D = this._camera2D.position.normalize().multiplyWithScalar(d);

        var top = camera.frustum.top;
        var bottom = camera.frustum.bottom;
        var right = camera.frustum.right;
        var left = camera.frustum.left;

        var frustum2D = this._camera2D.frustum;
        var frustumCV = this._cameraCV.frustum;

        var startPos = camera.position.clone();

        var update2D = function(value) {
            camera.position = that._columbusViewMorph(startPos, endPos2D, value.time);
            camera.frustum.top = CesiumMath.lerp(top, frustum2D.top, value.time);
            camera.frustum.bottom = CesiumMath.lerp(bottom, frustum2D.bottom, value.time);
            camera.frustum.right = CesiumMath.lerp(right, frustum2D.right, value.time);
            camera.frustum.left = CesiumMath.lerp(left, frustum2D.left, value.time);
        };

        var startTime = (right - left) / (2.0 * maxRadii * Math.PI);
        var endTime = 1.0;
        if (startTime > endTime) {
            startTime = 0.0;
        }

        var partialDuration = (endTime - startTime) * duration;
        if (partialDuration === 0 && startPos.getXY().subtract(endPos2D.getXY()).magnitude() !== 0) {
            partialDuration = duration;
            startTime = 0.0;
            endTime = 1.0;
        }

        var animation = scene.getAnimations().add({
            easingFunction : Tween.Easing.Quartic.EaseOut,
            duration : partialDuration,
            startValue : {
                time : startTime
            },
            stopValue : {
                time : endTime
            },
            onUpdate : update2D,
            onComplete : function() {
                camera.frustum = frustumCV.clone();
                onComplete.call(that);
            }
        });
        this._currentAnimations.push(animation);
    };

    SceneTransitioner.prototype._scene2DToCV = function(duration, onComplete) {
        var that = this;

        var scene = this._scene;
        var camera = scene.getCamera();

        duration = duration * 0.5;

        var completeFrustumChange = function() {
            var startPos = camera.position.clone();
            var startDir = camera.direction.clone();
            var startUp = camera.up.clone();

            var endPos = that._cameraCV.position.clone();
            var endDir = that._cameraCV.direction.clone();
            var endUp = that._cameraCV.up.clone();

            var updateCV = function(value) {
                camera.position = that._columbusViewMorph(startPos, endPos, value.time);
                camera.direction = that._columbusViewMorph(startDir, endDir, value.time);
                camera.up = that._columbusViewMorph(startUp, endUp, value.time);
                camera.right = camera.direction.cross(camera.up);
            };

            var animation = scene.getAnimations().add({
                duration : duration,
                easingFunction : Tween.Easing.Quartic.EaseOut,
                startValue : {
                    time : 0.0
                },
                stopValue : {
                    time : 1.0
                },
                onUpdate : updateCV,
                onComplete : function() {
                    onComplete.call(that);
                }
            });

            that._currentAnimations.push(animation);
        };

        this._sceneOrthographicToPerspective(duration, completeFrustumChange);
    };

    SceneTransitioner.prototype._scene3DToCV = function(duration, endCamera, onComplete) {
        var that = this;

        var scene = this._scene;
        var primitives = scene.getPrimitives();
        var cb = primitives.getCentralBody();

        var camera = scene.getCamera();
        this._changeCameraTransform(camera, this._cameraCV.transform);

        var startPos = camera.position.clone();
        var startDir = camera.direction.clone();
        var startUp = camera.up.clone();

        var endPos = endCamera.position.clone();
        var endDir = endCamera.direction.clone();
        var endUp = endCamera.up.clone();

        var update = function(value) {
            camera.position = that._columbusViewMorph(startPos, endPos, value.time);
            camera.direction = that._columbusViewMorph(startDir, endDir, value.time);
            camera.up = that._columbusViewMorph(startUp, endUp, value.time);
            camera.right = camera.direction.cross(camera.up);
        };
        var animation = scene.getAnimations().add({
            duration : duration,
            easingFunction : Tween.Easing.Quartic.EaseOut,
            startValue : {
                time : 0.0
            },
            stopValue : {
                time : 1.0
            },
            onUpdate : update,
            onComplete : function() {
                camera.position = endPos;
                camera.direction = endDir;
                camera.up = endUp;
            }
        });
        this._currentAnimations.push(animation);

        for ( var i = 0; i < primitives.getLength(); ++i) {
            var p = primitives.get(i);
            if(typeof p.morphTime !== 'undefined')
            {
                animation = scene.getAnimations().addProperty(p, "morphTime", 1.0, 0.0, {
                    duration : duration,
                    easingFunction : Tween.Easing.Quartic.EaseOut
                // TODO:
                //delayDuration : p.delayDuration
                });
                this._currentAnimations.push(animation);
            }
        }

        animation = scene.getAnimations().addProperty(cb, "morphTime", 1.0, 0.0, {
            duration : duration,
            easingFunction : Tween.Easing.Quartic.EaseOut,
            onComplete : function () {
                if (onComplete) {
                    onComplete.call(that);
                }
            }
        });
        this._currentAnimations.push(animation);
    };

    SceneTransitioner.prototype._scene2DTo3D = function (duration, onComplete) {
        duration = duration * 0.5;

        var camera = this._scene.getCamera();

        this._sceneOrthographicToPerspective(duration, function() {
            camera.frustum = this._cameraCV.frustum.clone();
            camera.transform = this._cameraCV.transform.clone();
            this._sceneCVTo3D(duration, onComplete);
        });
    };

    SceneTransitioner.prototype._sceneCVTo3D = function (duration, onComplete) {
        var scene = this._scene;
        var primitives = scene.getPrimitives();
        var cb = primitives.getCentralBody();

        var animation;
        for ( var i = 0; i < primitives.getLength(); ++i) {
            var p = primitives.get(i);
            if(typeof p.morphTime !== 'undefined')
            {
                animation = scene.getAnimations().addProperty(p, "morphTime", 0.0, 1.0, {
                    duration : duration,
                    easingFunction : Tween.Easing.Quartic.EaseOut
                //TODO:
                //delayDuration : p.delayDuration
                });
                this._currentAnimations.push(animation);
            }
        }

        var that = this;

        var camera = scene.getCamera();
        this._changeCameraTransform(camera, Matrix4.getIdentity());

        var startPos = camera.position;
        var startDir = camera.direction;
        var startUp = camera.up;

        var maxRadii = this._ellipsoid.getMaximumRadius();
        var endPos = this._ellipsoid.toCartesian(new Cartographic3(0.0, 0.0, 10.0));
        endPos = endPos.normalize().multiplyWithScalar(2.0 * maxRadii);
        var endDir = Cartesian3.getZero().subtract(endPos).normalize();
        var endRight = endDir.cross(Cartesian3.getUnitZ()).normalize();
        var endUp = endRight.cross(endDir);

        var update = function(value) {
            camera.position = that._columbusViewMorph(startPos, endPos, value.time);
            camera.direction = that._columbusViewMorph(startDir, endDir, value.time);
            camera.up = that._columbusViewMorph(startUp, endUp, value.time);
            camera.right = camera.direction.cross(camera.up);
        };
        animation = scene.getAnimations().add({
            duration : duration,
            easingFunction : Tween.Easing.Quartic.EaseOut,
            startValue : {
                time : 0.0
            },
            stopValue : {
                time : 1.0
            },
            onUpdate : update
        });
        this._currentAnimations.push(animation);

        animation = scene.getAnimations().addProperty(cb, "morphTime", 0.0, 1.0, {
            duration : duration,
            easingFunction : Tween.Easing.Quartic.EaseOut,
            onComplete : function() {
                onComplete.call(that);
            }
        });
        this._currentAnimations.push(animation);
    };

    /**
     * DOC_TBA
     * @memberof SceneTransitioner
     */
    SceneTransitioner.prototype.morphTo2D = function() {
        var previousMode = this._scene.mode;

        if (previousMode === SceneMode.SCENE2D || previousMode === SceneMode.MORPHING) {
            return;
        }

        this._scene.mode = SceneMode.MORPHING;
        this._createMorphHandler(this.to2D);

        if (previousMode === SceneMode.COLUMBUS_VIEW) {
            this._sceneCVTo2D(this.morphDuration2D, this.to2D);
        } else {
            this._scene3DTo2D(this.morphDuration2D, this.to2D);
        }
    };

    /**
     * DOC_TBA
     * @memberof SceneTransitioner
     */
    SceneTransitioner.prototype.morphToColumbusView = function() {
        var previousMode = this._scene.mode;

        if (previousMode === SceneMode.COLUMBUS_VIEW || previousMode === SceneMode.MORPHING) {
            return;
        }

        this._scene.mode = SceneMode.MORPHING;
        this._createMorphHandler(this.toColumbusView);

        if (previousMode === SceneMode.SCENE2D) {
            this._scene2DToCV(this.morphDurationColumbusView, this.toColumbusView);
        } else {
            this._scene3DToCV(this.morphDurationColumbusView, this._cameraCV, this.toColumbusView);
        }
    };

    /**
     * DOC_TBA
     * @memberof SceneTransitioner
     */
    SceneTransitioner.prototype.morphTo3D = function() {
        var scene = this._scene;
        var previousMode = scene.mode;

        if (previousMode === SceneMode.SCENE3D || previousMode === SceneMode.MORPHING) {
            return;
        }

        scene.mode = SceneMode.MORPHING;
        this._createMorphHandler(this.to3D);

        if (previousMode === SceneMode.SCENE2D) {
            this._scene2DTo3D(this.morphDuration3D, this.to3D);
        } else {
            this._sceneCVTo3D(this.morphDuration3D, this.to3D);
        }
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof SceneTransitioner
     *
     * @return {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     *
     * @see SceneTransitioner#destroy
     */
    SceneTransitioner.prototype.isDestroyed = function () {
        return false;
    };

    /**
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>null</code>) to the object as done in the example.
     *
     * @memberof SceneTransitioner
     *
     * @return {null}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see SceneTransitioner#isDestroyed
     *
     * @example
     * transitioner = transitioner && transitioner.destroy();
     */
    SceneTransitioner.prototype.destroy = function () {
        this._destroyMorphHandler();
        return destroyObject(this);
    };

    return SceneTransitioner;
});

/*!
* Lightweight JSONP fetcher
* Copyright 2010 Erik Karlsson. All rights reserved.
* BSD licensed
*/

/*global define*/
define('ThirdParty/jsonp',[],function() {
    /*global document,window*/

/*
* Usage:
* 
* JSONP.get( 'someUrl.php', {param1:'123', param2:'456'}, function(data){
*   //do something with data, which is the JSON object you should retrieve from someUrl.php
* });
*/
var JSONP = (function(){
	var counter = 0, head;
	function load(url) {
		var script = document.createElement('script'),
			done = false;
		script.src = url;
		script.async = true;
 
		script.onload = script.onreadystatechange = function() {
			if ( !done && (!this.readyState || this.readyState === "loaded" || this.readyState === "complete") ) {
				done = true;
				script.onload = script.onreadystatechange = null;
				if ( script && script.parentNode ) {
					script.parentNode.removeChild( script );
				}
			}
		};
		if ( !head ) {
			head = document.getElementsByTagName('head')[0];
		}
		head.appendChild( script );
	}
	function jsonp(url, params, callback, callbackParameterName) {
		var query = "?";
		params = params || {};
		callbackParameterName = callbackParameterName || "callback";
		for ( var key in params ) {
			if ( params.hasOwnProperty(key) ) {
				query += encodeURIComponent(key) + "=" + encodeURIComponent(params[key]) + "&";
			}
		}
		var uniqueName = "json" + (++counter);
		window[ uniqueName ] = function(data){
			callback(data);
			try {
				delete window[ uniqueName ];
			} catch (e) {}
			window[ uniqueName ] = null;
		};
 
		load(url + query + callbackParameterName + "=" + uniqueName);
		return uniqueName;
	}
	return {
		get:jsonp
	};
}());

    return JSONP.get;
});
/*global define*/
define('Scene/ArcGISTileProvider',[
        '../Core/DeveloperError',
        '../Core/Math',
        '../ThirdParty/jsonp',
        './Projections'
    ], function(
        DeveloperError,
        CesiumMath,
        jsonp,
        Projections) {
    
    /*global document,Image*/

    /**
     * Provides tile images hosted by an ArcGIS Server.
     *
     * @name ArcGISTileProvider
     * @constructor
     *
     * @param {String} description.host The ArcGIS Server host name.
     * @param {String} description.instance The instance name. The default value is "/arcgis/rest".
     * @param {String} description.folder The folder where the service is located.
     * @param {String} description.service The service name.
     * @param {String} description.proxy A proxy URL to send image requests through. This URL will have the desired image URL appended as a query parameter.
     *
     * @exception {DeveloperError} <code>description.host</code> is required.
     * @exception {DeveloperError} <code>description.service</code> is required.
     *
     * @see SingleTileProvider
     * @see BingMapsTileProvider
     * @see OpenStreetMapTileProvider
     * @see CompositeTileProvider
     *
     * @see <a href="http://resources.esri.com/help/9.3/arcgisserver/apis/rest/">ArcGIS Server REST API</a>
     * @see <a href="http://www.w3.org/TR/cors/">Cross-Origin Resource Sharing</a>
     *
     * @example
     * // ArcGIS World Street Maps tile provider
     * var esri = new ArcGISTileProvider({
     *     host : 'server.arcgisonline.com',
     *     service : 'World_Street_Map'
     * });
     */
    function ArcGISTileProvider(description) {
        var desc = description || {};
        var instance = desc.instance || 'arcgis/rest';

        if (!desc.host) {
            throw new DeveloperError("description.host is required.", "description.host");
        }

        if (!desc.service) {
            throw new DeveloperError("description.service is required.", "description.service");
        }

        this._url = '';
        if (desc.proxy) {
            this._url += desc.proxy + '?';
        }
        this._url += 'http://' + desc.host + '/' + instance + '/services/';
        if (desc.folder) {
            this._url += desc.folder + '/';
        }
        this._url += desc.service + '/MapServer';

        /**
         * The ArcGIS Server host name.
         * @type {String}
         */
        this.host = desc.host;

        /**
         * The instance name. The default value is "/arcgis/rest".
         * @type {String}
         */
        this.instance = instance;

        /**
         * The folder where the service is located.
         * @type {String}
         */
        this.folder = desc.folder;

        /**
         * The service name.
         * @type {String}
         */
        this.service = desc.service;

        /**
         * A proxy URL to send image requests through. This URL will have the desired image URL appended as a query parameter.
         * @type {String}
         */
        this.proxy = desc.proxy;

        // TODO: Get this information from the server

        /**
         * The cartographic extent of the base tile, with north, south, east and
         * west properties in radians.
         *
         * @type {Object}
         */
        this.maxExtent = {
            north : CesiumMath.toRadians(85.05112878),
            south : CesiumMath.toRadians(-85.05112878),
            west : -CesiumMath.PI,
            east : CesiumMath.PI
        };

        /**
         * The width of every image loaded.
         *
         * @type {Number}
         */
        this.tileWidth = 256;

        /**
         * The height of every image loaded.
         *
         * @type {Number}
         */
        this.tileHeight = 256;

        /**
         * The maximum zoom level that can be requested.
         *
         * @type {Number}
         */
        this.zoomMax = 19;

        /**
         * The minimum zoom level that can be requested.
         *
         * @type {Number}
         */
        this.zoomMin = 0;

        /**
         * The map projection of the image.
         *
         * @type {Enumeration}
         * @see Projections
         */
        this.projection = Projections.MERCATOR;

        this._logo = undefined;
        this._logoLoaded = false;

        var that = this;
        var callback = function(data) {
            var credit = data.copyrightText;

            var canvas = document.createElement("canvas");
            canvas.width = 800.0;
            canvas.height = 20.0;

            var context = canvas.getContext("2d");
            context.fillStyle = "#fff";
            context.font = '12px sans-serif';
            context.textBaseline = 'top';
            context.fillText(credit, 0, 0);

            that._logo = canvas;
            that._logoLoaded = true;
        };
        jsonp(this._url, {
            f : 'json'
        }, callback);
    }

    ArcGISTileProvider.prototype._getUrl = function(tile) {
        return this._url + '/tile/' + tile.zoom + '/' + tile.y + '/' + tile.x;
    };

    /**
     * Loads the image for <code>tile</code>.
     *
     * @memberof ArcGISTileProvider
     *
     * @param {Tile} tile The tile to load the image for.
     * @param {Function} onload A function that will be called when the image is finished loading.
     * @param {Function} onerror A function that will be called if there is an error loading the image.
     *
     * @exception {DeveloperError} <code>tile.zoom</code> is less than <code>zoomMin</code>
     * or greater than <code>zoomMax</code>.
     */
    ArcGISTileProvider.prototype.loadTileImage = function(tile, onload, onerror) {
        if (tile.zoom < this.zoomMin || tile.zoom > this.zoomMax) {
            throw new DeveloperError("The zoom must be between in [zoomMin, zoomMax].", "tile.zoom");
        }

        var image = new Image();
        if (onload && typeof onload === "function") {
            image.onload = function() {
                onload();
            };
        }
        if (onerror && typeof onerror === "function") {
            image.onerror = function() {
                onerror();
            };
        }
        image.crossOrigin = '';
        image.src = this._getUrl(tile);

        return image;
    };

    /**
     * DOC_TBA
     * @memberof ArcGISTileProvider
     */
    ArcGISTileProvider.prototype.getLogo = function() {
        return (this._logoLoaded) ? this._logo : undefined;
    };

    return ArcGISTileProvider;
});
/*!
   Portions Copyright (c) 2006-2009 Microsoft Corporation.  All rights reserved.

   http://msdn.microsoft.com/en-us/library/bb259689.aspx
   http://msdn.microsoft.com/en-us/cc300389.aspx#O

   MICROSOFT LIMITED PUBLIC LICENSE

   This license governs use of code marked as "sample" or "example" available on
   this web site without a license agreement, as provided under the section above
   titled "NOTICE SPECIFIC TO SOFTWARE AVAILABLE ON THIS WEB SITE." If you use
   such code (the "software"), you accept this license. If you do not accept the
   license, do not use the software.

   1. Definitions

   The terms "reproduce," "reproduction," "derivative works," and "distribution"
   have the same meaning here as under U.S. copyright law.

   A "contribution" is the original software, or any additions or changes to the software.

   A "contributor" is any person that distributes its contribution under this license.

   "Licensed patents" are a contributor's patent claims that read directly on its contribution.

   2. Grant of Rights

   (A) Copyright Grant - Subject to the terms of this license, including the license
   conditions and limitations in section 3, each contributor grants you a non-exclusive,
   worldwide, royalty-free copyright license to reproduce its contribution, prepare
   derivative works of its contribution, and distribute its contribution or any
   derivative works that you create.

   (B) Patent Grant - Subject to the terms of this license, including the license
   conditions and limitations in section 3, each contributor grants you a
   non-exclusive, worldwide, royalty-free license under its licensed patents to
   make, have made, use, sell, offer for sale, import, and/or otherwise dispose
   of its contribution in the software or derivative works of the contribution
   in the software.

   3. Conditions and Limitations

   (A) No Trademark License- This license does not grant you rights to use any
   contributors' name, logo, or trademarks.

   (B) If you bring a patent claim against any contributor over patents that
   you claim are infringed by the software, your patent license from such
   contributor to the software ends automatically.

   (C) If you distribute any portion of the software, you must retain all
   copyright, patent, trademark, and attribution notices that are present in
   the software.

   (D) If you distribute any portion of the software in source code form, you
   may do so only under this license by including a complete copy of this license
   with your distribution. If you distribute any portion of the software in
   compiled or object code form, you may only do so under a license that
   complies with this license.

   (E) The software is licensed "as-is." You bear the risk of using it. The
   contributors give no express warranties, guarantees or conditions. You may
   have additional consumer rights under your local laws which this license
   cannot change. To the extent permitted under your local laws, the contributors
   exclude the implied warranties of merchantability, fitness for a particular
   purpose and non-infringement.

   (F) Platform Limitation - The licenses granted in sections 2(A) and 2(B)
   extend only to the software or derivative works that you create that run
   on a Microsoft Windows operating system product.
 */
/*global define*/
define('Scene/BingMapsTileProvider',[
        '../Core/DeveloperError',
        '../Core/Math',
        '../ThirdParty/jsonp',
        './BingMapsStyle',
        './Projections',
        './ProxyUsagePolicy'
    ], function(
        DeveloperError,
        CesiumMath,
        jsonp,
        BingMapsStyle,
        Projections,
        ProxyUsagePolicy) {
    
    /*global Image*/

    /**
     * Uses the Bing Map imagery API to load images for tiles.
     *
     * @name BingMapsTileProvider
     * @constructor
     *
     * @param {String} description.server The name of the Bing Maps server hosting the imagery.
     * @param {String} description.key An optional Bing Maps key, which can be created at <a href="https://www.bingmapsportal.com/">https://www.bingmapsportal.com/</a>.
     * @param {Enumeration} description.mapStyle The type of Bing Maps imagery to load.
     * @param {String} description.proxy A proxy URL to send image requests through. This URL will have the desired image URL appended as a query parameter.
     * @param {Enumeration} description.proxyUsagePolicy Specify whether to use the supplied proxy for all images, or only those that don't support cross-origin requests.  By default, cross-origin will be used.
     *
     * @exception {DeveloperError} <code>description.server</code> is required.
     *
     * @see SingleTileProvider
     * @see ArcGISTileProvider
     * @see OpenStreetMapTileProvider
     * @see CompositeTileProvider
     *
     * @see <a href="http://msdn.microsoft.com/en-us/library/ff701713.aspx">Bing Maps REST Services</a>
     * @see <a href="http://www.w3.org/TR/cors/">Cross-Origin Resource Sharing</a>
     *
     * @example
     * // Bing Maps tile provider
     * var bing = new BingMapsTileProvider({
     *     server : "dev.virtualearth.net",
     *     mapStyle : BingMapsStyle.AERIAL
     * });
     */
    function BingMapsTileProvider(description) {
        var desc = description || {};
        var key = desc.key || "AquXz3981-1ND5jGs8qQn7R7YUP8qkWi77yZSVM7o3nIvzb-Mg0W2Ta57xuUyywX";
        var mapStyle = desc.mapStyle || BingMapsStyle.AERIAL;

        if (!desc.server) {
            throw new DeveloperError("description.server is required.", "description.server");
        }

        /**
         * The name of the Bing Maps server hosting the imagery.
         * @type {String}
         */
        this.server = desc.server;
        this._server = desc.server;

        /**
         * The Bing Maps key.
         * @type {String}
         */
        this.key = key;
        this._key = key;

        /**
         * The type of Bing Maps imagery to load.'
         * @type {Enumeration}
         */
        this.mapStyle = mapStyle;
        this._mapStyle = mapStyle;

        /**
         * A proxy URL to send image requests through. This URL will have the desired image URL appended as a query parameter.
         * @type {String}
         */
        this.proxy = desc.proxy;

        /**
         * Specify whether to use the supplied proxy for all images, or only those that don't support cross-origin requests.  By default, cross-origin will be used.
         * @type {Enumeration}
         */
        this.proxyUsagePolicy = desc.proxyUsagePolicy || ProxyUsagePolicy.USE_CORS;

        // TODO: The following 5 properties should be set in _requestTemplate.
        //       The may be needed before the response so for now set the default values.

        /**
         * The cartographic extent of the base tile, with north, south, east and
         * west properties in radians.
         *
         * @type {Object}
         */
        this.maxExtent = {
            north : CesiumMath.toRadians(85.05112878),
            south : CesiumMath.toRadians(-85.05112878),
            west : -CesiumMath.PI,
            east : CesiumMath.PI
        };

        /**
         * The width of every image loaded.
         *
         * @type {Number}
         */
        this.tileWidth = 256;

        /**
         * The height of every image loaded.
         *
         * @type {Number}
         */
        this.tileHeight = 256;

        /**
         * The maximum zoom level that can be requested.
         *
         * @type {Number}
         */
        this.zoomMax = 23;

        /**
         * The minimum zoom level that can be requested.
         *
         * @type {Number}
         */
        this.zoomMin = 1;

        /**
         * The map projection of the image.
         *
         * @type {Enumeration}
         * @see Projections
         */
        this.projection = Projections.MERCATOR;

        this._url = "";
        this._deferredQueue = [];
        this._requestTemplate();
    }

    /**
     * Converts a tiles (x, y, zoom) position into a quadkey used to request an image
     * from a Bing Maps server.
     *
     * @memberof BingMapsTileProvider
     *
     * @param {Number} x The tile's x coordinate.
     * @param {Number} y The tile's y coordinate.
     * @param {Number} zoom The tile's zoom level.
     *
     * @see <a href="http://msdn.microsoft.com/en-us/library/bb259689.aspx">Bing Maps Tile System</a>
     * @see BingMapsTileProvider#quadKeyToTileXY
     */
    BingMapsTileProvider.tileXYToQuadKey = function(x, y, zoom) {
        var quadkey = "";
        for ( var i = zoom; i > 0; --i) {
            var digit = "0".charCodeAt(0);
            var mask = 1 << (i - 1);
            if ((x & mask) !== 0) {
                digit++;
            }
            if ((y & mask) !== 0) {
                digit += 2;
            }
            quadkey += String.fromCharCode(digit);
        }
        return quadkey;
    };

    /**
     * Converts a tile's quadkey used to request an image from a Bing Maps server into the
     * (x, y, zoom) position.
     *
     * @memberof BingMapsTileProvider
     *
     * @param {String} quadkey The tile's quad key
     *
     * @see <a href="http://msdn.microsoft.com/en-us/library/bb259689.aspx">Bing Maps Tile System</a>
     * @see BingMapsTileProvider#tileXYToQuadKey
     */
    BingMapsTileProvider.quadKeyToTileXY = function(quadkey) {
        var result = {
            x : 0,
            y : 0,
            zoom : quadkey.length
        };

        for ( var i = result.zoom; i > 0; --i) {
            var mask = 1 << (i - 1);
            var c = quadkey[result.lod - i];
            if (c === '1') {
                result.x |= mask;
            } else if (c === '2') {
                result.y |= mask;
            } else if (c === '3') {
                result.x |= mask;
                result.y |= mask;
            }
        }

        return result;
    };

    BingMapsTileProvider.prototype._getMetadataUrl = function() {
        var url = '';
        if (this.proxyUsagePolicy === ProxyUsagePolicy.ALWAYS && this.proxy) {
            url += this.proxy + '?';
        }
        url += 'http://' + this.server + '/REST/v1/Imagery/Metadata/' + this.mapStyle.name;
        return url;
    };

    BingMapsTileProvider.prototype._getTileUrl = function(tile) {
        tile.quadkey = BingMapsTileProvider.tileXYToQuadKey(tile.x, tile.y, tile.zoom);

        var url = '';
        if (this.proxyUsagePolicy === ProxyUsagePolicy.ALWAYS && this.proxy) {
            url += this.proxy + '?';
        }
        url += this._url.replace('{quadkey}', tile.quadkey);

        return url;
    };

    BingMapsTileProvider.prototype._requestTemplate = function() {
        var url = this._getMetadataUrl();

        var that = this;

        var callback = function(data) {
            var resource = data.resourceSets[0].resources[0];
            that._url = resource.imageUrl;
            that._url = that._url.replace('{subdomain}', resource.imageUrlSubdomains[0]);
            that._url = that._url.replace('{culture}', "");

            that.tileWidth = resource.imageWidth;
            that.tileHeight = resource.imageHeight;
            that.zoomMin = resource.zoomMin;
            that.zoomMax = resource.zoomMax;

            that._deferredQueue.forEach(function(element) {
                this._loadImage(element);
            }, that);
            that._deferredQueue = [];
        };
        jsonp(url, {
            key : this.key
        }, callback, "jsonp");
    };

    /**
     * Loads the image for <code>tile</code>.
     *
     * @memberof BingMapsTileProvider
     *
     * @param {Tile} tile The tile to load the image for.
     * @param {Function} onload A function that will be called when the image is finished loading.
     * @param {Function} onerror A function that will be called if there is an error loading the image.
     * @param {Function} oninvalid A function that will be called if the image loaded is not valid.
     *
     * @exception {DeveloperError} <code>tile.zoom</code> is less than <code>zoomMin</code>
     * or greater than <code>zoomMax</code>.
     */
    BingMapsTileProvider.prototype.loadTileImage = function(tile, onload, onerror, oninvalid) {
        if (this.server !== this._server || this.key !== this._key || this.mapStyle.value !== this._mapStyle.value) {
            this._url = '';
            this._server = this.server;
            this._key = this.key;
            this._mapStyle = this.mapStyle;

            this._requestTemplate();
        }

        if (tile.zoom < this.zoomMin || tile.zoom > this.zoomMax) {
            throw new DeveloperError("The zoom must be between in [zoomMin, zoomMax].", "tile.zoom");
        }

        var image = new Image();

        if (!this._url) {
            if (!this._deferredQueue.contains) {
                this._deferredQueue.contains = function(tile) {
                    for ( var i = 0; i < this.length; ++i) {
                        var t = this[i].tile;
                        if (t.zoom === tile.zoom && t.x === tile.x && t.y === tile.y) {
                            return true;
                        }
                    }
                    return false;
                };
            }

            if (!this._deferredQueue.contains(tile)) {
                this._deferredQueue.push({
                    tile : tile,
                    onload : onload,
                    onerror : onerror,
                    image : image
                });
            }
            return image;
        }

        this._loadImage({
            tile : tile,
            onload : onload,
            onerror : onerror,
            oninvalid : oninvalid,
            image : image
        });
        return image;
    };

    BingMapsTileProvider.prototype._loadImage = function(element) {
        var tile = element.tile;
        var lat = CesiumMath.toDegrees((tile.extent.north + tile.extent.south) * 0.5);
        var lon = CesiumMath.toDegrees((tile.extent.east + tile.extent.west) * 0.5);
        var zoomResponse = false;
        var validZoom = false;
        var loaded = false;

        element.onload = (element.onload && typeof element.onload === "function") ? element.onload : function() {
        };
        element.onerror = (element.onerror && typeof element.onerror === "function") ? element.onerror : function() {
        };
        element.oninvalid = (element.oninvalid && typeof element.oninvalid === "function") ? element.oninvalid : function() {
        };

        var url = this._getMetadataUrl();

        jsonp(url, {
            centerPoint : lat + ',' + lon,
            zoomLevel : tile.zoom,
            key : this.key
        }, function(data) {
            if (typeof data.resourceSets[0] === "undefined") {
                element.onerror();
                return;
            }

            var resource = data.resourceSets[0].resources[0];
            if (!resource.vintageStart && !resource.vintageEnd) {
                element.oninvalid();
            } else {
                validZoom = true;
                if (loaded) {
                    element.onload();
                }
            }
            zoomResponse = true;
        }, "jsonp");

        var img = element.image;
        img.onload = function() {
            if (zoomResponse && validZoom) {
                element.onload();
            }
            loaded = true;
        };
        img.onerror = function() {
            element.onerror();
        };
        img.crossOrigin = '';
        img.src = this._getTileUrl(element.tile);
    };

    /**
     * DOC_TBA
     * @memberof BingMapsTileProvider
     */
    BingMapsTileProvider.prototype.getIntensity = function(tile) {
        if ((this.mapStyle === BingMapsStyle.AERIAL || this.mapStyle === BingMapsStyle.AERIAL_WITH_LABELS) && tile.zoom <= 8.0) {
            return 1.0;
        }
        return 0.1;
    };

    /**
     * DOC_TBA
     * @memberof BingMapsTileProvider
     */
    BingMapsTileProvider.prototype.getLogo = function() {
        if (typeof BingMapsTileProvider._logo === "undefined") {
            var image = new Image();
            image.loaded = false;
            image.onload = function() {
                BingMapsTileProvider._logo.loaded = true;
            };
            image.src = BingMapsTileProvider._logoData;
            BingMapsTileProvider._logo = image;
        }

        var logo = BingMapsTileProvider._logo;
        return (logo && logo.loaded) ? logo : undefined;
    };

    BingMapsTileProvider._logo = undefined;
    BingMapsTileProvider._logoLoaded = false;
    BingMapsTileProvider._logoData = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAF0AAAAdCAYAAADIKWCvAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAABBZSURBVHja1FoJdFTVGZ6ZzJZlskMgsrcEoqAQrBhBliKBiBDAgFUL5RQkgIDaKCoqGEBAFkGSgEYrCKgoYtWICLIZBBEOFkX0YEKoDSQo2SczmX36fS/3xscUBAKxp/ecl5eZd99/7/3+/37/cker0Wi0moami4qKCvJ6vVqj0RjEL4KCgvwul8vLe3l5uRdf+cXV2CZPnqwJbHl5eZSpjY2NDcL7Oj2a3+9XxtFqtX632+3FV76qqirK9Ak5fs3/oGGu11Qe1nnJPlpx6cLDw4mNPiQkxARggggSLi8AcuOzG8rwqIC/pFwoUA9lEWyj2Ww28X8+8Hg8EOV1QawTz9xq4C/VrkQxQvHN0fzXAnRauB7AGiIiIsJCQ0PDAFIIPusAjKO+vt5WU1Njs1qtDpvN5v4VgORoioXjboAcc3BwsAWKDA8LCwuFTK3D4aiHrBorBeJ/nU7nUilTeyULlkq4CMDaS6xbGofuUiBxp2P3+7Ecf3FxsXq3+5sCurQ+WroZ4FhGpI1Mur1vvyGYltZaa/156dLF7wDscxhUoR3SDYBsXBCU4gdwftIGJwfL9TudziD00ZtMpuCYmJjY8SmdUgYl1N3H/ierwg4/t+nHPEzOh34eXARcg8VrSW3cYT6fT6seA318Kvk+SXMqalCDGHQhOZynAEX5zLXwOebeCDrH4Fr4v8FgUPrxM+T5eIcRemBQPmDlA/i+pm4Vgq7FAJyoEXdLn9v6pg4dOngCH1ZX19SsXLn8MwzoxoI5OTeA9NJipQB89omJeXH3RUZGerkYNDPkhfXvGX/jA4mfL9D765XFJcRoulnTUirmr69Zh/5OLhSL8IvF6zAOwdCpx4AcjuEDYB6A6qHiAZpXKEDBy2KxBHEdMCCK0As5FKOMC4PSYIp+QZuKAZFG0bRgVfbhQ2UN7AdZjSDxO/QlL7oxVzd2qFso2t9k0LlINAJv9njcRtVW0eFZFC4bJmbARN0EGBcthO9xEfyDf31eLNhJ7heWacD35vjIoNaBg7o9XgPHQp9gAgXZ3ML410DuV/wJ72IX+gQQ0he48MjFBgV4OZYA0IDvjbBsI+4mvEPK1EnQOVeuVewCOncDqNQEZbA/n9F/2bGr6+h3VIATXBqaC3fg7eCO83Xq1IlU0yTg9WJCnAwtg8DrfyFQRV4wJhaHxUTDmrSwbJ2YiFSMH5NUQLDb7XW1tbV15GkuDhM0rt1WeKzOcfPKkTc5h7H/8Z9Cvl35XlEBFmfAQsIgz4/FG8n5bADDjIuAy22vKBTi3fQvGMNah4Y+9QDcRZ6FsvQY04h5QkyYBWIskGumIiX1kGsBqg9yaCF6KMr88COZw264PrGb0Iv/ZHHxwdlPPv7qoUOHsiXdQHarwsLCtR07dhzaq1evUfjswfserE17NfSiyBccGET6UrstbKew4cNH3DBq9OjU1q1axUdGRoQHCqmrs9kBdtWJEyeOZmU9uw7bHr63xsGtDpCCvNFJnvdLg3aUlZbWdu9+YyuH40U9xgphpAQ6CoHFRi5YsCijffu2v4+Ojm6BYMeolk9rr6ioqjx16tR3mzZtevfgwQNFGKOSSqBPYHQEgwiHnJhHH52V3qtX0gD6kkA5DofTda68vMLpcDrbtLkuPvB5YWHREe6YpKSkBwoKCp4aMGDAc9u2bZvSoUOHVKLBXSMM9KoiI73ao0sno+JS/VtvbZofHR1lCQC5HkCQ1zQwUBppCK/4+NbXJSdvH1yw7/PdT81+YmNlZWU9I6H0u9NHJCZ26cr+lVVV1ry8l/bh+1iAZH755Vce6t79hh6CVxtBxhh1Uj6fxcW1iMXV7+abk/oWFRWfyM5elbdnz+4f6BdgGKGPPPLonaNGpd2rNopAOQS5bZvrWl8MjBUrln0MC3Zx82JH/Iw7Zcfl5+cvSklJGQPQvcLR0qleE9D/q1ksYcFqKzly5KvD72x++71vvv66hE5FOCLj+PETBtwx+I67YDyK9aQMHjQ0MfH9m+4ZO2YOF+5Xh2/4wFCSBP7O5nfnqUEoOX2mbNfOXfnr16/bS/4W4ZoxNXVYj3vvu/fPlE8FdO2akPj8888vzMzMXHD48KHTU6ZO6z9u3H0TpOJoFPsPfLHv+cUL3wA49cKAgqdOm56WOnRIKhTQuK4jR/75bfGpUyfhpRwwkiqAbsOcbQMHDlxCeklOTn6YQM+dO/cgeR2WztTFR1prKugEQ09LgRDs7Oj28+cvfDA9fVS6utPp06Vl999/79zq6uoyTKoaW9pOXuN2w2KM4M8wyIjNzJx1z8iRw0fKxZeUnCmbMGH8wuzs3BnXX981QbH0yiprevrds5ctWz4xKalnD2mRa9et3/BK3ks7QNc/Q75Vgk6HxyiI8tPSRiXPmDk9wxLWYAxU0qSJf13ywQcfLKEe+R0Iv37WY7OeO3Bg/3HIqpSgQ3nB4PoorDFu87tbFsa1bBEjx54586GsgoLPjsHPnMbY5RjbjnG9MoIh+HQs+I6Ri4evlZaW+i6Us1x2nC77U3hgh59+Plcxdmz6M+fOnSthvI4J0bs7pNfGO0xk7Viga8GCrLf5HZQ2mve2ba9rnTF12h2BtAUlGTt37txFfj745eGDq3Ozd8LSSrGoSsi3cmFCPsMaDG1zvPXWG/sTEhLapaePVuS3bhUXN2lSxiAJOFv2qpy8vXv3FCL3qgSAVcDKLuSYIZvRjiHr2axVq1fnZAml6tLSRvYBVR2ilTMe4Dt03gwdIZu0qyiHpQsCLQBvsqXr1IBfCPQPP8j/EBljJRwlF1FNS8cEajGpGt7xuRYOrRqgwLdVVSxfvmQrt7d8P6lnz56BuSHjaDV1lZWVnYWMGsqHZXInUXYNxqgGCByzis8IZHb2i582WgwAg5zz/M2OHZ+cgCwH3qMjd9L3MLrizuFnfO88duzrsyLWVlqbtm3aITojXyulCVInI1vMk1SihKkA340QkRZ+wRrUFXO6zChxIUXTnrdl3nxzw2EsuB4AKBN3NjSX2FrM+FgQ08sYGs/cJSUl/05M7KpYcjS85Vm08zStCjkFx1GWA2PUQw4VVg8lS1AArIVxI+N+ZR7qd9u1axuv/pySMrTLhg2vVwBgM/qbmE0KYzJBSSb6kzvvvCtRvTvKSs+eJI+jP52oG8r14LqYNV91YU4nrZzZGBdktdZWqDsMHjwkgXQgkg2m9ibwK4tYRoR7TCyMMjFRshuTydAKoaV832az2y6rQqZVlO3morFrZBGMFyuSHkYUzAoZQajf++77738gj8vP4PzJAwYOTEC6Hot5RoHHoxGaxkRERMQijIzD3KKnTMmYqA4QsrLmbCB/cVcwEQuwZH/ApbkmoDOtFlZsf+3vr+7iRGSH8ePH3wNjjcLEI5FQ8GI5Mhygh2OCESwd4ArH4qCDyGg402EIuy2/8PWXhy89VcXwvSqKO2+R8nsqRoCidlwehLWbyblKxAUnu+KFFc/k5q75G+Lrjrg6tG/fviOuTstfWJmxdevHK+T8+M6GjRs3IECoRj5BSvKw7PxrBa1r0fSCY5nK0zMz2Svfv//Ap4MGDVQyyDZt4luvWfPywzNmPLgCCY+B3EsFMXqhgwQIBlYS0WInT56Syuil0Qn/dK5izeqcHTk5q7v8quZ1SqHJJ6w9cLGyoOaTV8Bm98JQCuDoy6dNnfoAAWXY2qdPcp9du3b1qa6uqWW3wKSOUdSWLe/9Izc3ey+ozEYeF/WdZq/rE3Q/BvUilKLDIZeWP/307NXBwSvCb7vt1tsVZ5jUo8dHH23N2bNn7yc5Oavy2Y90JONocGTP4SOGp4HGu0rBVVXV1jlz57xAC9IEOGgoLIBaFMCVYlOgJasrgKQXPPcGPsOc7Rs3rD/wUf6HRzIypvXr379fSgvkUkzYLpRBs4WHW0LbtWsXH9TQdDLCCoy0ms3SiYOnodVjYdWMvzMzH1n4+BOzxw3o3+8uTpwWNHr0yDEjRtx1t8zyZBytTja4ZQuLTv6A+HlRRUWFjY5Lq9UEgu49P/PVuyCHTsyroheNurSL3cSdRWt0BERCbkY5rNGzGLV06eKSl17KfZ++hzmEKOixiGaGf7px4qSJ4xijM/IZMmTwHUing6dPn7YI1GJiSRp37dVUEC/b0oW1eFjQohfHAgiM59m5z6yBA9qcmfnYGHU9I9B6Amsj+/fvKwRN1jEsY2JTW2M9g23OzFOLHVDBwhjutaJ660eEV8pKpgjTAi3dz/hYJGMMAatramqrpUXa7Ha+a8X3dSyKQbYGY1eyeikiJRbyGAQEr1v3WvnWrfnH33578zzSJp/37v2H5D59b+/86Y7tZ0ExDAR08KnNaunawGM7AM8JMjoJxmKDydes3PH0h4cSDLvG/2VCHzjNKK1G69+9e/fho0e/KmNZVFYB0eyMK0WtPBh9w3lAwrMD+AzWpVnt4skSlWtn7I9Wjjifcb9ThIuNloZAhKgbMbewli1bxsBpx0A5oQDZR2qBr7G7GqIB7gaWmLljqCifTOAAfigunmDFDRkytNvq1blZUv6BL74smDY14ynszB9FvsHd5G2KtV9JRip7+gAYC/Us6JByXOLIrhZgl7N8SjpZvGhhMbcna9T0+FwwLRGLpiU6leIEKISgQ56NoMLyzKzbs5bNgQCUErEAPNaxmcg4eBaL6MgnKsYyctEiOeNpDUuq9XSYAIWOz4guPKwwsTQMhZg4H44N4OqZHPkaGg8naPFOzIF+y33s2DdKciRjdeQSsSwnywOO34rT1cD7haV5eUqCuxJKMkrhVmW8ztMWeczla6gA0cEpFMBLfJagBeF9ngjZ1YvicZg8oBDveHkqJc5LA5sPFuqFopysibDwRLDFcWDIcwsXTxTJkKaosLDw9dfXHmDxCruOPsotDkXMrKFjh5lT7xx2XnJ05kxpMRO7i/mU5gQ9MFTzAnxanUecO9KCdeQ8eQYpowrubIJM7gVNBGZybtCD8o66Do3/Gw99eTEDxOVXW7k8JKG1y/SbZ5SsofPwg6VngKi/tXfvsRERlsiGZOePSPfdKzZvfucg5s+SglOciYaw4NW7d3LXmTNmZKjPAubNm7sWu6PW03DW52tuS9dewXPtr7xzzZKJi8XJ6jNT6grg87QpLA5t0KDBt8ye/eSLoaEhodKxFxWdPJGfn//h9u2fHBflgW7Dhw8f0bnz7xJkFZRJYE5O7pKNG9dvA22dYc2HVUmVT2kWTtdeQwVpLiexUIPXlEREvK8F9RkY7oHLI3G17D9gYM/pD06f1aFDu06XIweUUrps2bLFe/fuOQra+glUxGKbDbTkbKoTbQ7QmzzINd2aAnT+toYRDaMsUAcjrCgoosUtvXt3uWfsn+7u2LHj9SaT0cgTI0EjdU6ny3X27Nl/7dy1c9t7W94l/TB8rQS11LCkS/8FJ+25mjrLbwL6hX5W19xN/mxP/kiK1USEtiHgeQuPB3lAzViXzl8cciu/LGMkg6iFoW0dwGbtnGesdvgXhwBcFtr8zWmE/5egq4GnxQNERlT8iYjy8wv5cw6Gp+L3OhpR4vXJErQ4mXLhXZf4DY36533NCvp/BBgAjIr8TQiNmVwAAAAASUVORK5CYII=';

    return BingMapsTileProvider;
});
/*!
  This library rewrites the Canvas2D "measureText" function
  so that it returns a more complete metrics object.
  This library is licensed under the MIT (Expat) license,
  the text for which is included below.

   -----------------------------------------------------------------------------

  CHANGELOG:

    2012-01-21 - Whitespace handling added by Joe Turner
                 (https://github.com/oampo)

   -----------------------------------------------------------------------------

  Copyright (C) 2011 by Mike "Pomax" Kamermans

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.
*/
/*global define*/
define('ThirdParty/measureText',[],function() {
  /*global document*/
//  var NAME = "FontMetrics Library";
//  var VERSION = "1-2012.0121.1300";

  // if there is no getComputedStyle, this library won't work.
//  if(!document.defaultView.getComputedStyle) {
//    throw("ERROR: 'document.defaultView.getComputedStyle' not found. This library only works in browsers that can report computed CSS values.");
//  }

  // store the old text metrics function on the Canvas2D prototype
  //CanvasRenderingContext2D.prototype.measureTextWidth = CanvasRenderingContext2D.prototype.measureText;

  /**
   *  shortcut function for getting computed CSS values
   */
  var getCSSValue = function(element, property) {
    return document.defaultView.getComputedStyle(element,null).getPropertyValue(property);
  };

  // debug function
//  var show = function(canvas, ctx, xstart, w, h, metrics)
//  {
//    document.body.appendChild(canvas);
//    ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
//
//    ctx.beginPath();
//    ctx.moveTo(xstart,0);
//    ctx.lineTo(xstart,h);
//    ctx.closePath();
//    ctx.stroke();
//
//    ctx.beginPath();
//    ctx.moveTo(xstart+metrics.bounds.maxx,0);
//    ctx.lineTo(xstart+metrics.bounds.maxx,h);
//    ctx.closePath();
//    ctx.stroke();
//
//    ctx.beginPath();
//    ctx.moveTo(0,h/2-metrics.ascent);
//    ctx.lineTo(w,h/2-metrics.ascent);
//    ctx.closePath();
//    ctx.stroke();
//
//    ctx.beginPath();
//    ctx.moveTo(0,h/2+metrics.descent);
//    ctx.lineTo(w,h/2+metrics.descent);
//    ctx.closePath();
//    ctx.stroke();
//  }

  /**
   * The new text metrics function
   */
  return function(context2D, textstring) {
    var metrics = context2D.measureText(textstring),
        fontFamily = getCSSValue(context2D.canvas,"font-family"),
        fontSize = getCSSValue(context2D.canvas,"font-size").replace("px",""),
        isSpace = !(/\S/.test(textstring));
        metrics.fontsize = fontSize;

    // for text lead values, we meaure a multiline text container.
    var leadDiv = document.createElement("div");
    leadDiv.style.position = "absolute";
    leadDiv.style.opacity = 0;
    leadDiv.style.font = fontSize + "px " + fontFamily;
    leadDiv.innerHTML = textstring + "<br/>" + textstring;
    document.body.appendChild(leadDiv);

    // make some initial guess at the text leading (using the standard TeX ratio)
    metrics.leading = 1.2 * fontSize;

    // then we try to get the real value from the browser
    var leadDivHeight = getCSSValue(leadDiv,"height");
    leadDivHeight = leadDivHeight.replace("px","");
    if (leadDivHeight >= fontSize * 2) { metrics.leading = (leadDivHeight/2) | 0; }
    document.body.removeChild(leadDiv);

    // if we're not dealing with white space, we can compute metrics
    if (!isSpace) {
        // Have characters, so measure the text
        var canvas = document.createElement("canvas");
        var padding = 100;
        canvas.width = metrics.width + padding;
        canvas.height = 3*fontSize;
        canvas.style.opacity = 1;
        canvas.style.fontFamily = fontFamily;
        canvas.style.fontSize = fontSize;
        var ctx = canvas.getContext("2d");
        ctx.font = fontSize + "px " + fontFamily;

        var w = canvas.width,
            h = canvas.height,
            baseline = h/2;

        // Set all canvas pixeldata values to 255, with all the content
        // data being 0. This lets us scan for data[i] != 255.
        ctx.fillStyle = "white";
        ctx.fillRect(-1, -1, w+2, h+2);
        ctx.fillStyle = "black";
        ctx.fillText(textstring, padding/2, baseline);
        var pixelData = ctx.getImageData(0, 0, w, h).data;

        // canvas pixel data is w*4 by h*4, because R, G, B and A are separate,
        // consecutive values in the array, rather than stored as 32 bit ints.
        var i = 0,
            w4 = w * 4,
            len = pixelData.length;

        // Finding the ascent uses a normal, forward scanline
        while (++i < len && pixelData[i] === 255) {}
        var ascent = (i/w4)|0;

        // Finding the descent uses a reverse scanline
        i = len - 1;
        while (--i > 0 && pixelData[i] === 255) {}
        var descent = (i/w4)|0;

        // find the min-x coordinate
        for(i = 0; i<len && pixelData[i] === 255; ) {
          i += w4;
          if(i>=len) { i = (i-len) + 4; }}
        var minx = ((i%w4)/4) | 0;

        // find the max-x coordinate
        var step = 1;
        for(i = len-3; i>=0 && pixelData[i] === 255; ) {
          i -= w4;
          if(i<0) { i = (len - 3) - (step++)*4; }}
        var maxx = ((i%w4)/4) + 1 | 0;

        // set font metrics
        metrics.ascent = (baseline - ascent);
        metrics.descent = (descent - baseline);
        metrics.bounds = { minx: minx - (padding/2),
                           maxx: maxx - (padding/2),
                           miny: 0,
                           maxy: descent-ascent };
        metrics.height = 1+(descent - ascent);
    }

    // if we ARE dealing with whitespace, most values will just be zero.
    else {
        // Only whitespace, so we can't measure the text
        metrics.ascent = 0;
        metrics.descent = 0;
        metrics.bounds = { minx: 0,
                           maxx: metrics.width, // Best guess
                           miny: 0,
                           maxy: 0 };
        metrics.height = 0;
    }
    return metrics;
  };
});
/*global define*/
define('Scene/Label',[
        '../Core/shallowEquals',
        '../Core/Cartesian2',
        '../Core/Cartesian3',
        '../ThirdParty/measureText',
        './Billboard',
        './LabelStyle',
        './HorizontalOrigin',
        './VerticalOrigin'
    ], function(
        shallowEquals,
        Cartesian2,
        Cartesian3,
        measureText,
        Billboard,
        LabelStyle,
        HorizontalOrigin,
        VerticalOrigin) {
    
    /*global document*/

    /**
     * DOC_TBA
     *
     * @name Label
     * @internalConstructor
     *
     * @see LabelCollection
     * @see LabelCollection#add
     * @see Billboard
     *
     * @see <a href="http://www.whatwg.org/specs/web-apps/current-work/#2dcontext">HTML canvas 2D context</a>
     */
    function Label(labelTemplate, labelCollection) {
        var l = labelTemplate || {};
        var show = (typeof l.show === "undefined") ? true : l.show;
        var billboardCollection = labelCollection._getCollection();

        this._text = l.text || "";
        this._font = l.font || "30px sans-serif";
        this._fillColor = l.fillColor || {
            red : 1.0,
            green : 1.0,
            blue : 1.0,
            alpha : 1.0
        };
        this._outlineColor = l.outlineColor || {
            red : 0.0,
            green : 0.0,
            blue : 0.0,
            alpha : 1.0
        };
        this._style = l.style || LabelStyle.FILL;
        this._verticalOrigin = l.verticalOrigin || VerticalOrigin.BOTTOM;
        this._horizontalOrigin = l.horizontalOrigin || HorizontalOrigin.LEFT;
        this._pixelOffset = l.pixelOffset ? new Cartesian2(l.pixelOffset.x, l.pixelOffset.y) : Cartesian2.getZero();
        this._eyeOffset = l.eyeOffset ? new Cartesian3(l.eyeOffset.x, l.eyeOffset.y, l.eyeOffset.z) : Cartesian3.getZero();

        this._position = l.position ? new Cartesian3(l.position.x, l.position.y, l.position.z) : Cartesian3.getZero();
        this._scale = (typeof l.scale === "undefined") ? 1.0 : l.scale;
        this._show = show;

        this._billboardCollection = billboardCollection;
        this._labelCollection = labelCollection;
        this._billboards = undefined;

        this._createBillboards();
    }

    /**
     * Returns true if this label will be shown.  Call {@link Label#setShow}
     * to hide or show a label, instead of removing it and re-adding it to the collection.
     *
     * @memberof Label
     *
     * @return {Boolean} <code>true</code> if this label will be shown; otherwise, <code>false</code>.
     *
     * @see Label#setShow
     */
    Label.prototype.getShow = function() {
        return this._show;
    };

    /**
     * Determines if this label will be shown.  Call this to hide or show a label, instead
     * of removing it and re-adding it to the collection.
     *
     * @memberof Label
     *
     * @param {Boolean} value Indicates if this label will be shown.
     *
     * @see Label#getShow
     */
    Label.prototype.setShow = function(value) {
        if ((typeof value !== "undefined") && (value !== this._show)) {
            this._show = value;

            var billboards = this._billboards;
            var length = this._billboards ? this._billboards.length : 0;
            for ( var i = 0; i < length; i++) {
                billboards[i].setShow(value);
            }
        }
    };

    /**
     * Returns the Cartesian position of this label.
     *
     * @memberof Label
     *
     * @return {Cartesian3} The Cartesian position of this label.
     *
     * @see Label#setPosition
     */
    Label.prototype.getPosition = function() {
        return this._position;
    };

    /**
     * Sets the Cartesian position of this label.
     * <br /><br />
     * As shown in the examples, <code>value</code> can be either a {@link Cartesian3}
     * or an object literal with <code>x</code>, <code>y</code>, and <code>z</code> properties.
     * A copy of <code>value</code> is made, so changing it after calling <code>setPosition</code>
     * does not affect the label's position; an explicit call to <code>setPosition</code> is required.
     *
     * @memberof Label
     *
     * @param {Cartesian3} value The Cartesian position.
     *
     * @see Label#getPosition
     *
     * @example
     * // Example 1. Set a label's position using a Cartesian3.
     * l.setPosition(new Cartesian3(1.0, 2.0, 3.0));
     *
     * //////////////////////////////////////////////////////////////////
     *
     * // Example 2. Set a label's position using an object literal.
     * l.setPosition({
     *   x : 1.0,
     *   y : 2.0,
     *   z : 3.0});
     */
    Label.prototype.setPosition = function(value) {
        var p = this._position;

        if ((typeof value !== "undefined") &&
            ((p.x !== value.x) || (p.y !== value.y) || (p.z !== value.z))) {

            p.x = value.x;
            p.y = value.y;
            p.z = value.z;

            var billboards = this._billboards;
            var length = this._billboards ? this._billboards.length : 0;
            for ( var i = 0; i < length; i++) {
                billboards[i].setPosition(value);
            }
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof Label
     *
     * @see Label#setText
     */
    Label.prototype.getText = function() {
        return this._text;
    };

    /**
     * DOC_TBA
     *
     * @memberof Label
     *
     * @see Label#getText
     */
    Label.prototype.setText = function(value) {
        if ((typeof value !== "undefined") && (value !== this._text)) {
            this._text = value;
            this._createBillboards();
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof Label
     *
     * @see Label#setFont
     */
    Label.prototype.getFont = function() {
        return this._font;
    };

    /**
     * DOC_TBA
     *
     * @memberof Label
     *
     * CSS font-family
     *
     * @see Label#getFont
     * @see Label#setFillColor
     * @see Label#setOutlineColor
     * @see <a href="http://www.whatwg.org/specs/web-apps/current-work/#dom-context-2d-font">HTML canvas 2D context font</a>
     */
    Label.prototype.setFont = function(value) {
        if ((typeof value !== "undefined") && (this._font !== value)) {
            this._font = value;
            this._createBillboards();
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof Label
     *
     * @see Label#setFillColor
     */
    Label.prototype.getFillColor = function() {
        return this._fillColor;
    };

    /**
     * DOC_TBA
     *
     * CSS <color> values
     *
     * @memberof Label
     *
     * @see Label#getFillColor
     * @see Label#setOutlineColor
     * @see Label#setFont
     */
    Label.prototype.setFillColor = function(value) {
        if ((typeof value !== "undefined") && (this._fillColor !== value)) {
            this._fillColor = value;
            this._createBillboards();
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof Label
     *
     * @see Label#setOutlineColor
     */
    Label.prototype.getOutlineColor = function() {
        return this._outlineColor;
    };

    /**
     * DOC_TBA
     *
     * CSS <color> values
     *
     * @memberof Label
     *
     * @see Label#getOutlineColor
     * @see Label#setFillColor
     * @see Label#setFont
     */
    Label.prototype.setOutlineColor = function(value) {
        if ((typeof value !== "undefined") && (this._outlineColor !== value)) {
            this._outlineColor = value;
            this._createBillboards();
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof Label
     *
     * @see Label#setStyle
     */
    Label.prototype.getStyle = function() {
        return this._style;
    };

    /**
     * DOC_TBA
     *
     * @memberof Label
     *
     * @param {LabelStyle} value DOC_TBA
     *
     * @see Label#getStyle
     * @see Label#setOutlineColor
     * @see Label#setFillColor
     */
    Label.prototype.setStyle = function(value) {
        if ((typeof value !== "undefined") && (this._style !== value)) {
            this._style = value;
            this._createBillboards();
        }
    };

    /**
     * Returns the pixel offset from the origin of this label.
     *
     * @memberof Label
     *
     * @return {Cartesian2} The pixel offset of this label.
     *
     * @see Label#setPixelOffset
     */
    Label.prototype.getPixelOffset = function() {
        return this._pixelOffset;
    };

    /**
     * Sets the pixel offset in screen space from the origin of this label.  This is commonly used
     * to align multiple labels and billboards at the same position, e.g., an image and text.  The
     * screen space origin is the bottom, left corner of the canvas; <code>x</code> increases from
     * left to right, and <code>y</code> increases from bottom to top.
     * <br /><br />
     * <code>value</code> can be either a {@link Cartesian2}  or an object literal with
     * <code>x</code> and <code>y</code> properties.  A copy of <code>value</code> is made, so
     * changing it after calling <code>setPixelOffset</code> does not affect the label's pixel
     * offset; an explicit call to <code>setPixelOffset</code> is required.
     * <br /><br />
     * <div align="center">
     * <table border="0" cellpadding="5"><tr>
     * <td align="center"><code>default</code><br/><img src="images/Label.setPixelOffset.default.png" width="250" height="188" /></td>
     * <td align="center"><code>l.setPixelOffset({ x : 25, y : -75 });</code><br/><img src="images/Label.setPixelOffset.x50y-25.png" width="250" height="188" /></td>
     * </tr></table>
     * The label's origin is indicated by the yellow point.
     * </div>
     *
     * @memberof Label
     *
     * @param {Cartesian2} value The 2D Cartesian pixel offset.
     *
     * @see Label#getPixelOffset
     * @see Billboard#setPixelOffset
     */
    Label.prototype.setPixelOffset = function(value) {
        var p = this._pixelOffset;
        if ((typeof value !== "undefined") && ((p.x !== value.x) || (p.y !== value.y))) {
            p.x = value.x;
            p.y = value.y;
            this._setPixelOffsets();
        }
    };

    /**
     * Returns the 3D Cartesian offset applied to this label in eye coordinates.
     *
     * @memberof Label
     *
     * @return {Cartesian3} The 3D Cartesian offset applied to this label in eye coordinates.
     *
     * @see Label#setEyeOffset
     */
    Label.prototype.getEyeOffset = function() {
        return this._eyeOffset;
    };

    /**
     * Sets the 3D Cartesian offset applied to this label in eye coordinates.  Eye coordinates is a left-handed
     * coordinate system, where <code>x</code> points towards the viewer's right, <code>y</code> points up, and
     * <code>z</code> points into the screen.  Eye coordinates use the same scale as world and model coordinates,
     * which is typically meters.
     * <br /><br />
     * An eye offset is commonly used to arrange multiple label or objects at the same position, e.g., to
     * arrange a label above its corresponding 3D model.
     * <br /><br />
     * <code>value</code> can be either a {@link Cartesian3} or an object literal with <code>x</code>,
     * <code>y</code>, and <code>z</code> properties.  A copy of <code>value</code> is made, so changing it after
     * calling <code>setEyeOffset</code> does not affect the label's eye offset; an explicit call to
     * <code>setEyeOffset</code> is required.
     * <br /><br />
     * Below, the label is positioned at the center of the Earth but an eye offset makes it always
     * appear on top of the Earth regardless of the viewer's or Earth's orientation.
     * <br /><br />
     * <div align="center">
     * <table border="0" cellpadding="5"><tr>
     * <td align="center"><img src="images/Billboard.setEyeOffset.one.png" width="250" height="188" /></td>
     * <td align="center"><img src="images/Billboard.setEyeOffset.two.png" width="250" height="188" /></td>
     * </tr></table>
     * <code>l.setEyeOffset({ x : 0.0, y : 8000000.0, z : 0.0 });</code><br /><br />
     * </div>
     *
     * @memberof Label
     *
     * @param {Cartesian3} value The 3D Cartesian offset in eye coordinates.
     *
     * @see Label#getEyeOffset
     */
    Label.prototype.setEyeOffset = function(value) {
        var e = this._eyeOffset;

        if ((typeof value !== "undefined") &&
            ((e.x !== value.x) || (e.y !== value.y) || (e.z !== value.z))) {
            e.x = value.x;
            e.y = value.y;
            e.z = value.z;
            var billboards = this._billboards;
            var length = this._billboards ? this._billboards.length : 0;
            for ( var i = 0; i < length; i++) {
                var b = billboards[i];
                var eyeOffset = b.getEyeOffset();
                b.setEyeOffset({
                    x : this._eyeOffset.x + eyeOffset.x,
                    y : this._eyeOffset.y + eyeOffset.y,
                    z : this._eyeOffset.z + eyeOffset.z
                });
            }
        }
    };

    /**
     * Returns the horizontal origin of this label.
     *
     * @memberof Label
     *
     * @return {HorizontalOrigin} The horizontal origin of this label.
     *
     * @see Label#setHorizontalOrigin
     */
    Label.prototype.getHorizontalOrigin = function() {
        return this._horizontalOrigin;
    };

    /**
     * Sets the horizontal origin of this label, which determines if the label is
     * to the left, center, or right of its position.
     * <br /><br />
     * <div align="center">
     * <img src="images/Billboard.setHorizontalOrigin.png" width="400" height="300" /><br />
     * </div>
     *
     * @memberof Label
     *
     * @param {HorizontalOrigin} value The horizontal origin.
     *
     * @see Label#getHorizontalOrigin
     * @see Label#setVerticalOrigin
     *
     * @example
     * // Use a top, right origin
     * l.setHorizontalOrigin(HorizontalOrigin.RIGHT);
     * l.setVerticalOrigin(VerticalOrigin.TOP);
     */
    Label.prototype.setHorizontalOrigin = function(value) {
        if ((typeof value !== "undefined") && (this._horizontalOrigin !== value)) {
            this._horizontalOrigin = value;

            var billboards = this._billboards;
            var length = this._billboards ? this._billboards.length : 0;
            for ( var i = 0; i < length; i++) {
                billboards[i].setHorizontalOrigin(value);
            }
        }
    };

    /**
     * Returns the vertical origin of this label.
     *
     * @memberof Label
     *
     * @return {VerticalOrigin} The vertical origin of this label.
     *
     * @see Label#setVerticalOrigin
     */
    Label.prototype.getVerticalOrigin = function() {
        return this._verticalOrigin;
    };

    /**
     * Sets the vertical origin of this label, which determines if the label is
     * to the above, below, or at the center of its position.
     * <br /><br />
     * <div align="center">
     * <img src="images/Billboard.setVerticalOrigin.png" width="400" height="300" /><br />
     * </div>
     *
     * @memberof Label
     *
     * @param {VerticalOrigin} value The vertical origin.
     *
     * @see Label#getVerticalOrigin
     * @see Label#setHorizontalOrigin
     *
     * @example
     * // Use a top, right origin
     * l.setHorizontalOrigin(HorizontalOrigin.RIGHT);
     * l.setVerticalOrigin(VerticalOrigin.TOP);
     */
    Label.prototype.setVerticalOrigin = function(value) {
        if ((typeof value !== "undefined") && (this._verticalOrigin !== value)) {
            this._verticalOrigin = value;
            this._createBillboards();
        }
    };

    /**
     * Returns the uniform scale that is multiplied with the label's size in pixels.
     *
     * @memberof Label
     *
     * @return {Number} The scale used to size the label.
     *
     * @see Label#setScale
     */
    Label.prototype.getScale = function() {
        return this._scale;
    };

    /**
     * Sets the uniform scale that is multiplied with the label's size in pixels.
     * A scale of <code>1.0</code> does not change the size of the label; a scale greater than
     * <code>1.0</code> enlarges the label; a positive scale less than <code>1.0</code> shrinks
     * the label.
     * <br /><br />
     * Applying a large scale value may pixelate the label.  To make text larger without pixelation,
     * use a larger font size when calling {@link Label#setFont} instead.
     * <br /><br />
     * <div align="center">
     * <img src="images/Label.setScale.png" width="400" height="300" /><br/>
     * From left to right in the above image, the scales are <code>0.5</code>, <code>1.0</code>,
     * and <code>2.0</code>.
     * </div>
     *
     * @memberof Label
     *
     * @param {Number} value The scale used to size the label.
     *
     * @see Label#getScale
     * @see Label#setFont
     */
    Label.prototype.setScale = function(value) {
        if ((typeof value !== "undefined") && (this._scale !== value)) {
            this._scale = value;
            var billboards = this._billboards;
            var length = this._billboards ? this._billboards.length : 0;
            for ( var i = 0; i < length; i++) {
                billboards[i].setScale(value);
            }
            this._setPixelOffsets();
        }
    };

    /**
     * Computes the screen-space position of the label's origin, taking into account eye and pixel offsets.
     * The screen space origin is the bottom, left corner of the canvas; <code>x</code> increases from
     * left to right, and <code>y</code> increases from bottom to top.
     *
     * @memberof Label
     *
     * @param {UniformState} uniformState The same state object passed to {@link LabelCollection#render}.
     *
     * @return {Cartesian2} The screen-space position of the label.
     *
     * @exception {DeveloperError} Label must be in a collection.
     * @exception {DeveloperError} uniformState is required.
     *
     * @see Label#setEyeOffset
     * @see Label#setPixelOffset
     * @see LabelCollection#render
     *
     * @example
     * console.log(l.computeScreenSpacePosition(scene.getUniformState()).toString());
     */
    Label.prototype.computeScreenSpacePosition = function(uniformState) {
        // This function is basically a stripped-down JavaScript version of BillboardCollectionVS.glsl

        var billboards = this._billboards;
        var position = (this._billboards.length !== 0) ? billboards[0]._getActualPosition() : this._position;

        return Billboard._computeScreenSpacePosition(this._labelCollection.modelMatrix, position, this._eyeOffset, this._pixelOffset, uniformState);
    };

    /**
     * Determines if this label equals another label.  Labels are equal if all their properties
     * are equal.  Labels in different collections can be equal.
     *
     * @memberof Label
     *
     * @param {Label} other The label to compare for equality.
     *
     * @return {Boolean} <code>true</code> if the labels are equal; otherwise, <code>false</code>.
     */
    Label.prototype.equals = function(other) {
        return other &&
               (this.getShow() === other.getShow()) &&
               (this.getPosition().equals(other.getPosition())) &&
               (this.getPixelOffset().equals(other.getPixelOffset())) &&
               (this.getEyeOffset().equals(other.getEyeOffset())) &&
               (this.getHorizontalOrigin().value === other.getHorizontalOrigin().value) &&
               (this.getVerticalOrigin().value === other.getVerticalOrigin().value) &&
               (this.getScale() === other.getScale()) &&
               (this._text === other._text) &&
               (this._font === other._font) &&
               (shallowEquals(this._fillColor, other._fillColor)) &&
               (shallowEquals(this._outlineColor, other._outlineColor)) &&
               (this._style.value === other._style.value);
    };

    Label.prototype._destroy = function() {
        var billboardCollection = this._billboardCollection;
        var billboards = this._billboards;
        var length = this._billboards ? this._billboards.length : 0;
        for ( var i = 0; i < length; i++) {
            billboardCollection.remove(billboards[i]);
        }
        this._billboards = null;
        this._billboardCollection = null;
        this._labelCollection = null;
    };

    Label.prototype._getCollection = function() {
        return this._labelCollection;
    };

    Label.prototype._getBillboards = function() {
        return this._billboards;
    };

    Label.prototype._createBillboards = function() {
        var i;
        var length = this._billboards ? this._billboards.length : 0;
        for (i = 0; i < length; i++) {
            this._billboardCollection.remove(this._billboards[i]);
        }

        this._billboards = [];
        var text = this._text;
        length = text.length;
        var self = this;

        var onCanvasCreated = function() {
            self._setCreateTextureAtlas(true);
        };

        for (i = 0; i < length; i++) {
            var charValue = text.charAt(i);
            var billboard = this._billboardCollection.add({
                show : this._show,
                position : this._position,
                eyeOffset : this._eyeOffset,
                horizontalOrigin : this._horizontalOrigin,
                verticalOrigin : this._verticalOrigin,
                scale : this._scale,
                _pickIdThis : this
            });

            var canvasContainer = this._labelCollection._canvasContainer;
            var index = canvasContainer.add(charValue, this, onCanvasCreated);
            billboard.setImageIndex(index);
            billboard._labelDimension = canvasContainer.getItem(index)._dimension;
            this._billboards.push(billboard);
        }
        this._setPixelOffsets();
    };

    Label.prototype._createId = function(charValue) {
        return JSON.stringify({
            fillColor : this._fillColor.red.toString() + "," + this._fillColor.green.toString() + "," + this._fillColor.blue.toString() + "," + this._fillColor.alpha.toString(),
            font : this._font,
            outlineColor : this._outlineColor.red.toString() + "," + this._outlineColor.green.toString() + "," + this._outlineColor.blue.toString() + "," + this._outlineColor.alpha.toString(),
            style : this._style,
            verticalOrigin : this._verticalOrigin,
            value : charValue
        });
    };

    Label.prototype._createCanvas = function(charValue) {
        var font = this._font;

        var canvas = document.createElement("canvas");
        canvas.width = canvas.height = 1;
        canvas.style.font = font;
        canvas.style.display = 'hidden';

        var context2D = canvas.getContext("2d");
        context2D.font = font;


        //the vertical origin needs to be set before the measureText call. It won't work otherwise.
        //It's magic.
        var verticalOrigin = this._verticalOrigin;
        if (verticalOrigin === VerticalOrigin.BOTTOM) {
            context2D.textBaseline = "bottom";
        } else if (verticalOrigin === VerticalOrigin.TOP) {
            context2D.textBaseline = "top";
        } else {// VerticalOrigin.CENTER
            context2D.textBaseline = "middle";
        }

        //in order for measureText to calculate style, the canvas has to be
        //(temporarily) added to the DOM.
        document.body.appendChild(canvas);
        var dimensions = measureText(context2D, charValue);
        document.body.removeChild(canvas);
        var baseline = dimensions.height - dimensions.ascent;
        canvas.width = dimensions.width;
        canvas.height = dimensions.height;
        context2D.font = font;
        // font must be explicitly set again after changing width and height
        context2D.fillStyle = "rgba(" + this._fillColor.red * 255 + ", " + this._fillColor.green * 255 + ", " + this._fillColor.blue * 255 + ", " + this._fillColor.alpha + ")";
        context2D.strokeStyle = "rgba(" + this._outlineColor.red * 255 + ", " + this._outlineColor.green * 255 + ", " + this._outlineColor.blue * 255 + ", " + this._outlineColor.alpha + ")";

        var y = canvas.height - baseline;
        var style = this._style;

        canvas._dimension = {
            width : canvas.width,
            height : canvas.height,
            descent : dimensions.descent
        };

        if (style === LabelStyle.FILL) {
            context2D.fillText(charValue, 0, y);
        } else if (style === LabelStyle.OUTLINE) {
            context2D.strokeText(charValue, 0, y);
        } else {// LabelStyle.FILL_AND_OUTLINE
            context2D.fillText(charValue, 0, y);
            context2D.strokeText(charValue, 0, y);
        }
        return canvas;
    };

    Label.prototype._getMaxHeight = function() {
        var i;
        var billboards = this._billboards;
        var length = billboards.length;
        var maxHeight = 0;
        for (i = 0; i < length; i++) {
            var billboard = billboards[i];
            maxHeight = Math.max(maxHeight, billboard._labelDimension.height);
        }
        return maxHeight;
    };

    Label.prototype._setPixelOffsets = function() {
        var billboards = this._billboards;
        var maxHeight = 0;
        var i;
        var length = billboards.length;
        var thisPixelOffset = this._pixelOffset;
        var thisVerticalOrigin = this._verticalOrigin;
        var widthOffset = 0;
        var scale = this._scale;
        var dimension;
        var billboard;
        if (thisVerticalOrigin === VerticalOrigin.TOP) {
            maxHeight = this._getMaxHeight();
            for (i = 0; i < length; i++) {
                billboard = billboards[i];
                dimension = billboard._labelDimension;
                if (dimension.height < maxHeight) {
                    billboard.setPixelOffset({
                        x : thisPixelOffset.x + widthOffset,
                        y : thisPixelOffset.y - ((maxHeight - dimension.height) * scale) - (dimension.descent * scale)
                    });
                } else {
                    billboard.setPixelOffset({
                        x : thisPixelOffset.x + widthOffset,
                        y : thisPixelOffset.y - (dimension.descent * scale)
                    });
                }
                widthOffset += dimension.width * scale;
            }
        } else if (thisVerticalOrigin === VerticalOrigin.CENTER) {
            maxHeight = this._getMaxHeight();
            for (i = 0; i < length; i++) {
                billboard = billboards[i];
                dimension = billboard._labelDimension;
                if (dimension.height < maxHeight) {
                    billboard.setPixelOffset({
                        x : thisPixelOffset.x + widthOffset,
                        y : thisPixelOffset.y - (((maxHeight - billboard._labelDimension.height) / 2) * scale) - dimension.descent * scale
                    });
                } else {
                    billboard.setPixelOffset({
                        x : thisPixelOffset.x + widthOffset,
                        y : thisPixelOffset.y - billboard._labelDimension.descent * scale
                    });
                }
                widthOffset += dimension.width * scale;
            }
        } else if (thisVerticalOrigin === VerticalOrigin.BOTTOM) {
            for (i = 0; i < length; i++) {
                billboard = billboards[i];
                billboard.setPixelOffset({
                    x : thisPixelOffset.x + widthOffset,
                    y : thisPixelOffset.y - billboard._labelDimension.descent * scale
                });
                widthOffset += billboard._labelDimension.width * scale;
            }
        }
    };

    Label.prototype._setCreateTextureAtlas = function(value) {
        this._labelCollection._setCreateTextureAtlas(value);
    };

    return Label;
});
/*global define*/
define('Scene/LabelCollection',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/Matrix4',
        '../Renderer/BufferUsage',
        '../Renderer/PixelFormat',
        './BillboardCollection',
        './Label'
    ], function(
        DeveloperError,
        destroyObject,
        Matrix4,
        BufferUsage,
        PixelFormat,
        BillboardCollection,
        Label) {
    

    function CanvasContainer() {
        this._sources = {};
        this._sourcesArray = [];
    }

    CanvasContainer.prototype.add = function(charValue, label, canvasCreated) {
        var id = label._createId(charValue);
        if (this._contains(id)) {
            return this._getCanvas(id).index;
        }

        var canvas = label._createCanvas(charValue);
        this._sources[id] = canvas;
        canvas.index = this._sourcesArray.push(canvas) - 1;
        if (typeof canvasCreated !== "undefined") {
            canvasCreated();
        }
        return canvas.index;
    };

    CanvasContainer.prototype.getItems = function() {
        return this._sourcesArray;
    };

    CanvasContainer.prototype.getItem = function(index) {
        return this._sourcesArray[index];
    };

    CanvasContainer.prototype._contains = function(id) {
        return typeof this._sources[id] !== "undefined";
    };

    CanvasContainer.prototype._getCanvas = function(id) {
        return this._sources[id];
    };

    /**
     * A renderable collection of labels.  Labels are viewport-aligned text positioned in the 3D scene.
     * Each label can have a different font, color, scale, etc.
     * <br /><br />
     * <div align="center">
     * <img src="images/Label.png" width="400" height="300" /><br />
     * Example labels
     * </div>
     * <br /><br />
     * Labels are added and removed from the collection using {@link LabelCollection#add}
     * and {@link LabelCollection#remove}.
     *
     * @name LabelCollection
     * @constructor
     *
     * @performance For best performance, prefer a few collections, each with many labels, to
     * many collections with only a few labels each.  Also set the buffer usage via
     * {@link LabelCollection#bufferUsage} based on your expected update pattern.
     * Avoid having collections where some labels change every frame and others do not; instead,
     * create one or more collections for static labels, and one or more collections for dynamic labels.
     *
     * @see LabelCollection#add
     * @see LabelCollection#remove
     * @see LabelCollection#bufferUsage
     * @see Label
     * @see BillboardCollection
     *
     * @example
     * // Create a label collection with two labels
     * var labels = new LabelCollection();
     * labels.add({
     *   position : { x : 1.0, y : 2.0, z : 3.0 },
     *   text : "A label"
     * });
     * labels.add({
     *   position : { x : 4.0, y : 5.0, z : 6.0 },
     *   text : "Another label"
     * });
     */
    function LabelCollection() {
        this._billboardCollection = new BillboardCollection();
        this._labels = [];
        this._labelsRemoved = false;
        this._createTextureAtlas = false;
        this._canvasContainer = new CanvasContainer();

        /**
         * The 4x4 transformation matrix that transforms each label in this collection from model to world coordinates.
         * When this is the identity matrix, the labels are drawn in world coordinates, i.e., Earth's WGS84 coordinates.
         * Local reference frames can be used by providing a different transformation matrix, like that returned
         * by {@link Transforms.eastNorthUpToFixedFrame}.  This matrix is available to GLSL vertex and fragment
         * shaders via {@link agi_model} and derived uniforms.
         *
         * @type Matrix4
         *
         * @see Transforms.eastNorthUpToFixedFrame
         * @see agi_model
         *
         * @example
         * var center = ellipsoid.cartographicDegreesToCartesian(new Cartographic2(-75.59777, 40.03883));
         * labels.modelMatrix = Transforms.eastNorthUpToFixedFrame(center);
         * labels.add({
         *   position : new Cartesian3(0.0, 0.0, 0.0),
         *   text     : "Center"
         * });
         * labels.add({
         *   position : new Cartesian3(1000000.0, 0.0, 0.0),
         *   text     : "East"
         * });
         * labels.add({
         *   position : new Cartesian3(0.0, 1000000.0, 0.0),
         *   text     : "North"
         * });
         * labels.add({
         *   position : new Cartesian3(0.0, 0.0, 1000000.0),
         *   text     : "Up"
         * });
         */
        this.modelMatrix = Matrix4.getIdentity();

        /**
         * DOC_TBA
         *
         * @type Number
         */
        this.morphTime = 0.0;

        /**
         * The usage hint for the collection's vertex buffer.
         *
         * @performance If <code>bufferUsage</code> changes, the next time
         * {@link LabelCollection#update} is called, the collection's vertex buffer
         * is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.
         * For best performance, it is important to provide the proper usage hint.  If the collection
         * and labels will not change over several frames, use <code>BufferUsage.STATIC_DRAW</code>.
         * If all labels will change every frame or labels are added/removed every frame, use
         * <code>BufferUsage.STREAM_DRAW</code>.  If a subset of labels change every frame, use
         * <code>BufferUsage.DYNAMIC_DRAW</code>.
         */
        this.bufferUsage = BufferUsage.STATIC_DRAW;
    }

    LabelCollection.prototype._getCollection = function() {
        return this._billboardCollection;
    };

    LabelCollection.prototype._setCreateTextureAtlas = function(value) {
        this._createTextureAtlas = value;
    };

    /**
     * Creates and adds a label with the specified initial properties to the collection.
     * The added label is returned so it can be modified or removed from the collection later.
     *
     * @memberof LabelCollection
     *
     * @param {Object}[label=undefined] A template describing the label's properties as shown in Example 1.
     *
     * @return {Label} The label that was added to the collection.
     *
     * @performance Calling <code>add</code> is expected constant time.  However, when
     * {@link LabelCollection#update} is called, the collection's vertex buffer
     * and texture atlas are rewritten; these operations are <code>O(n)</code> and also incur
     * CPU to GPU overhead.  For best performance, add as many billboards as possible before
     * calling <code>update</code>.
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see LabelCollection#remove
     * @see LabelCollection#removeAll
     * @see LabelCollection#update
     *
     * @example
     * // Example 1:  Add a label, specifying all the default values.
     * var l = labels.add({
     *   show : true,
     *   position : Cartesian3.getZero(),
     *   text : "",
     *   font : "30px sans-serif",
     *   fillColor : "white",
     *   outlineColor : "white",
     *   style : LabelStyle.FILL,
     *   pixelOffset : Cartesian2.getZero(),
     *   eyeOffset : Cartesian3.getZero(),
     *   horizontalOrigin : HorizontalOrigin.LEFT,
     *   verticalOrigin : VerticalOrigin.BOTTOM,
     *   scale : 1.0,
     * });
     *
     * // Example 2:  Specify only the label's cartographic position,
     * // text, and font.
     * var l = labels.add({
     *   position : ellipsoid.toCartesian(
     *     CesiumMath.cartographic3ToRadians(
     *       new Cartographic3(longitude, latitude, height))),
     *   text : "Hello World",
     *   font : "24px Helvetica",
     * });
     */
    LabelCollection.prototype.add = function(label) {
        var l = new Label(label, this);
        l._index = this._labels.length;

        this._labels.push(l);

        return l;
    };

    /**
     * Removes a label from the collection.
     *
     * @memberof LabelCollection
     *
     * @param {Label} label The label to remove.
     *
     * @return {Boolean} <code>true</code> if the label was removed; <code>false</code> if the label was not found in the collection.
     *
     * @performance Calling <code>remove</code> is expected constant time.  However, when
     * {@link LabelCollection#update} is called, the collection's vertex buffer
     * is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.  For
     * best performance, remove as many labels as possible before calling <code>update</code>.
     * If you intend to temporarily hide a label, it is usually more efficient to call
     * {@link Label#setShow} instead of removing and re-adding the label.
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see LabelCollection#add
     * @see LabelCollection#removeAll
     * @see LabelCollection#update
     * @see Label#setShow
     *
     * @example
     * var l = labels.add(...);
     * labels.remove(l);  // Returns true
     */
    LabelCollection.prototype.remove = function(label) {
        if (label && (label._getCollection() === this)) {
            this._labels[label._index] = null;
            // Removed later
            this._labelsRemoved = true;
            label._destroy();

            return true;
        }

        return false;
    };

    /**
     * Removes all labels from the collection.
     *
     * @memberof LabelCollection
     *
     * @performance <code>O(n)</code>.  It is more efficient to remove all the labels
     * from a collection and then add new ones than to create a new collection entirely.
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see LabelCollection#add
     * @see LabelCollection#remove
     * @see LabelCollection#update
     *
     * @example
     * labels.add(...);
     * labels.add(...);
     * labels.removeAll();
     */
    LabelCollection.prototype.removeAll = function() {
        this._destroyLabels();
        this._labels = [];
        this._labelsRemoved = false;
        this._createTextureAtlas = true;
    };

    LabelCollection.prototype._removeLabels = function() {
        if (this._labelsRemoved) {
            this._labelsRemoved = false;

            var labels = [];
            var length = this._labels.length;
            for ( var i = 0, j = 0; i < length; ++i) {
                var label = this._labels[i];
                if (label) {
                    label._index = j++;
                    labels.push(label);
                }
            }
            this._labels = labels;
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof LabelCollection
     *
     * @param {Object} label DOC_TBA
     *
     * @see LabelCollection#get
     */
    LabelCollection.prototype.contains = function(label) {
        if (label) {
            var labels = this._labels;
            var length = labels.length;
            for ( var i = 0; i < length; i++) {
                if (labels[i] === label) {
                    return true;
                }
            }
        }

        return false;
    };

    /**
     * Returns the label in the collection at the specified index.  Indices are zero-based
     * and increase as labels are added.  Removing a label shifts all labels after
     * it to the left, changing their indices.  This function is commonly used with
     * {@link LabelCollection#getLength} to iterate over all the labels
     * in the collection.
     *
     * @memberof LabelCollection
     *
     * @param {Number} index The zero-based index of the billboard.
     *
     * @return {Label} The label at the specified index.
     *
     * @performance Expected constant time.  If labels were removed from the collection and
     * {@link LabelCollection#update} was not called, an implicit <code>O(n)</code>
     * operation is performed.
     *
     * @exception {DeveloperError} index is required.
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see LabelCollection#getLength
     *
     * @example
     * // Toggle the show property of every label in the collection
     * var len = labels.getLength();
     * for (var i = 0; i < len; ++i) {
     *   var l = billboards.get(i);
     *   l.setShow(!l.getShow());
     * }
     */
    LabelCollection.prototype.get = function(index) {
        if (typeof index === "undefined") {
            throw new DeveloperError("index is required.", "index");
        }

        this._removeLabels();
        return this._labels[index];
    };

    /**
     * Returns the number of labels in this collection.  This is commonly used with
     * {@link LabelCollection#get} to iterate over all the labels
     * in the collection.
     *
     * @memberof LabelCollection
     *
     * @return {Number} The number of labels in this collection.
     *
     * @performance Expected constant time.  If labels were removed from the collection and
     * {@link LabelCollection#update} was not called, an implicit <code>O(n)</code>
     * operation is performed.
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see LabelCollection#get
     *
     * @example
     * // Toggle the show property of every label in the collection
     * var len = labels.getLength();
     * for (var i = 0; i < len; ++i) {
     *   var l = billboards.get(i);
     *   l.setShow(!l.getShow());
     * }
     */
    LabelCollection.prototype.getLength = function() {
        this._removeLabels();
        return this._labels.length;
    };

    /**
     * @private
     */
    LabelCollection.prototype.update = function(context, sceneState) {
        this._billboardCollection.modelMatrix = this.modelMatrix;
        this._billboardCollection.morphTime = this.morphTime;
        this._billboardCollection.bufferUsage = this.bufferUsage;
        this._removeLabels();

        if (this._createTextureAtlas) {
            this._createTextureAtlas = false;

            // The previous texture atlas is implicitly destroyed by the billboard collection.
            var textureAtlas = (this._labels.length > 0) ? context.createTextureAtlas(this._canvasContainer.getItems(), PixelFormat.RGBA, 1) : null;
            this._billboardCollection.setTextureAtlas(textureAtlas);
        }

        this._billboardCollection.update(context, sceneState);
    };

    /**
     * Renders the labels.  In order for changes to properties to be realized,
     * {@link LabelCollection#update} must be called before <code>render</code>.
     * <br /><br />
     * Labels are rendered in a single pass using an uber-shader with a texture atlas, where
     * each image in the atlas corresponds to one label.
     *
     * @memberof LabelCollection
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see LabelCollection#update
     */
    LabelCollection.prototype.render = function(context) {
        this._billboardCollection.render(context);
    };

    /**
     * @private
     */
    LabelCollection.prototype.updateForPick = function(context) {
        this._billboardCollection.updateForPick(context);
    };

    /**
     * DOC_TBA
     * @memberof LabelCollection
     */
    LabelCollection.prototype.renderForPick = function(context, framebuffer) {
        this._billboardCollection.renderForPick(context, framebuffer);
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof LabelCollection
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see LabelCollection#destroy
     */
    LabelCollection.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>null</code>) to the object as done in the example.
     *
     * @memberof LabelCollection
     *
     * @return {null}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see LabelCollection#isDestroyed
     *
     * @example
     * labels = labels && labels.destroy();
     */
    LabelCollection.prototype.destroy = function() {
        this._destroyLabels();

        this._billboardCollection = this._billboardCollection && this._billboardCollection.destroy();

        return destroyObject(this);
    };

    LabelCollection.prototype._destroyLabels = function() {
        var labels = this._labels;
        var length = labels.length;
        for ( var i = 0; i < length; ++i) {
            if (labels[i]) {
                labels[i]._destroy();
            }
        }
    };

    return LabelCollection;
});
/*!
 * Copyright 2011-2012 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 */
var Cesium = window.Cesium = {_shaders:{}};
require(["Core/AxisAlignedBoundingBox", "Core/AxisAlignedBoundingRectangle", "Core/BoundingSphere", "Core/BoxTessellator", "Core/Cache", "Core/CachePolicy", "Core/Cartesian2", "Core/Cartesian3", "Core/Cartesian4", "Core/Cartographic2", "Core/Cartographic3", "Core/CatmullRomSpline", "Core/ComponentDatatype", "Core/CubeMapEllipsoidTessellator", "Core/DeveloperError", "Core/Ellipsoid", "Core/EllipsoidTangentPlane", "Core/Enumeration", "Core/EquidistantCylindricalProjection", "Core/EventHandler", "Core/EventModifier", "Core/ExtentTessellator", "Core/FAR", "Core/HermiteSpline", "Core/IndexDatatype", "Core/Intersect", "Core/IntersectionTests", "Core/Jobs", "Core/JulianDate", "Core/LeapSecond", "Core/Math", "Core/Matrix2", "Core/Matrix3", "Core/Matrix4", "Core/MercatorProjection", "Core/MeshFilters", "Core/MouseEventType", "Core/Occluder", "Core/PlaneTessellator", "Core/PolygonPipeline", "Core/PolylinePipeline", "Core/PrimitiveType", "Core/Quaternion", "Core/Rectangle", "Core/RuntimeError", "Core/Shapes", "Core/SunPosition", "Core/TimeConstants", "Core/TimeStandard", "Core/Tipsify", "Core/Transforms", "Core/TridiagonalSystemSolver", "Core/Visibility", "Core/WindingOrder", "Core/binarySearch", "Core/clone", "Core/combine", "Core/createGuid", "Core/destroyObject", "Core/pointInsideTriangle2D", "Core/requestAnimationFrame", "Core/shallowEquals", "Core/splice", "Renderer/BlendEquation", "Renderer/BlendFunction", "Renderer/BlendingState", "Renderer/Buffer", "Renderer/BufferUsage", "Renderer/Context", "Renderer/CubeMap", "Renderer/CullFace", "Renderer/DepthFunction", "Renderer/Framebuffer", "Renderer/FrontFace", "Renderer/MipmapHint", "Renderer/PickFramebuffer", "Renderer/PixelDatatype", "Renderer/PixelFormat", "Renderer/Renderbuffer", "Renderer/RenderbufferFormat", "Renderer/ShaderCache", "Renderer/ShaderProgram", "Renderer/StencilFunction", "Renderer/StencilOperation", "Renderer/Texture", "Renderer/TextureAtlas", "Renderer/TextureMagnificationFilter", "Renderer/TextureMinificationFilter", "Renderer/TextureWrap", "Renderer/UniformDatatype", "Renderer/UniformState", "Renderer/VertexArray", "Renderer/VertexArrayFacade", "Renderer/VertexLayout", "Scene/AnimationCollection", "Scene/ArcGISTileProvider", "Scene/Billboard", "Scene/BillboardCollection", "Scene/BingMapsStyle", "Scene/BingMapsTileProvider", "Scene/BlobMaterial", "Scene/Camera", "Scene/Camera2DController", "Scene/CameraColumbusViewController", "Scene/CameraControllerCollection", "Scene/CameraEventHandler", "Scene/CameraEventType", "Scene/CameraFlightController", "Scene/CameraFreeLookController", "Scene/CameraHelpers", "Scene/CameraSpindleController", "Scene/CameraSpindleControllerMode", "Scene/CentralBody", "Scene/CheckerboardMaterial", "Scene/ColorMaterial", "Scene/ComplexConicSensorVolume", "Scene/CompositePrimitive", "Scene/CompositeTileProvider", "Scene/CustomSensorVolume", "Scene/DistanceIntervalMaterial", "Scene/DotMaterial", "Scene/EulerSolver", "Scene/FacetMaterial", "Scene/GravityForce", "Scene/HorizontalOrigin", "Scene/HorizontalStripeMaterial", "Scene/Label", "Scene/LabelCollection", "Scene/LabelStyle", "Scene/OpenStreetMapTileProvider", "Scene/OrthographicFrustum", "Scene/Particle", "Scene/ParticleSystem", "Scene/PerspectiveFrustum", "Scene/Polygon", "Scene/Polyline", "Scene/Projections", "Scene/ProxyUsagePolicy", "Scene/RectangularPyramidSensorVolume", "Scene/Scene", "Scene/SceneMode", "Scene/SceneTransitioner", "Scene/SensorVolumeCollection", "Scene/SingleTileProvider", "Scene/SphericalRepulsionForce", "Scene/SpringForce", "Scene/Texture2DPool", "Scene/TieDyeMaterial", "Scene/Tile", "Scene/TileState", "Scene/VectorForce", "Scene/VerticalOrigin", "Scene/VerticalStripeMaterial", "Scene/ViewportQuad", "Scene/ViscousDrag", "Scene/combineMaterials", "Shaders/BillboardCollectionFS", "Shaders/BillboardCollectionVS", "Shaders/BlobMaterial", "Shaders/BuiltinFunctions", "Shaders/CentralBodyFS", "Shaders/CentralBodyFSDepth", "Shaders/CentralBodyFSFilter", "Shaders/CentralBodyVS", "Shaders/CentralBodyVSDepth", "Shaders/CentralBodyVSFilter", "Shaders/CheckerboardMaterial", "Shaders/ColorMaterial", "Shaders/ComplexConicSensorVolumeFS", "Shaders/ComplexConicSensorVolumeVS", "Shaders/ConstructiveSolidGeometry", "Shaders/CustomSensorVolumeFS", "Shaders/CustomSensorVolumeVS", "Shaders/DistanceIntervalMaterial", "Shaders/DotMaterial", "Shaders/FacetMaterial", "Shaders/HorizontalStripeMaterial", "Shaders/Noise", "Shaders/PolygonFS", "Shaders/PolygonFSPick", "Shaders/PolygonVS", "Shaders/PolygonVSPick", "Shaders/PolylineFS", "Shaders/PolylineVS", "Shaders/Ray", "Shaders/SensorVolume", "Shaders/SkyAtmosphereFS", "Shaders/SkyAtmosphereVS", "Shaders/TieDyeMaterial", "Shaders/VerticalStripeMaterial", "Shaders/ViewportQuadFS", "Shaders/ViewportQuadVS", "ThirdParty/Chain", "ThirdParty/Queue", "ThirdParty/Tween", "ThirdParty/jsonp", "ThirdParty/measureText"], function (Core_AxisAlignedBoundingBox, Core_AxisAlignedBoundingRectangle, Core_BoundingSphere, Core_BoxTessellator, Core_Cache, Core_CachePolicy, Core_Cartesian2, Core_Cartesian3, Core_Cartesian4, Core_Cartographic2, Core_Cartographic3, Core_CatmullRomSpline, Core_ComponentDatatype, Core_CubeMapEllipsoidTessellator, Core_DeveloperError, Core_Ellipsoid, Core_EllipsoidTangentPlane, Core_Enumeration, Core_EquidistantCylindricalProjection, Core_EventHandler, Core_EventModifier, Core_ExtentTessellator, Core_FAR, Core_HermiteSpline, Core_IndexDatatype, Core_Intersect, Core_IntersectionTests, Core_Jobs, Core_JulianDate, Core_LeapSecond, Core_Math, Core_Matrix2, Core_Matrix3, Core_Matrix4, Core_MercatorProjection, Core_MeshFilters, Core_MouseEventType, Core_Occluder, Core_PlaneTessellator, Core_PolygonPipeline, Core_PolylinePipeline, Core_PrimitiveType, Core_Quaternion, Core_Rectangle, Core_RuntimeError, Core_Shapes, Core_SunPosition, Core_TimeConstants, Core_TimeStandard, Core_Tipsify, Core_Transforms, Core_TridiagonalSystemSolver, Core_Visibility, Core_WindingOrder, Core_binarySearch, Core_clone, Core_combine, Core_createGuid, Core_destroyObject, Core_pointInsideTriangle2D, Core_requestAnimationFrame, Core_shallowEquals, Core_splice, Renderer_BlendEquation, Renderer_BlendFunction, Renderer_BlendingState, Renderer_Buffer, Renderer_BufferUsage, Renderer_Context, Renderer_CubeMap, Renderer_CullFace, Renderer_DepthFunction, Renderer_Framebuffer, Renderer_FrontFace, Renderer_MipmapHint, Renderer_PickFramebuffer, Renderer_PixelDatatype, Renderer_PixelFormat, Renderer_Renderbuffer, Renderer_RenderbufferFormat, Renderer_ShaderCache, Renderer_ShaderProgram, Renderer_StencilFunction, Renderer_StencilOperation, Renderer_Texture, Renderer_TextureAtlas, Renderer_TextureMagnificationFilter, Renderer_TextureMinificationFilter, Renderer_TextureWrap, Renderer_UniformDatatype, Renderer_UniformState, Renderer_VertexArray, Renderer_VertexArrayFacade, Renderer_VertexLayout, Scene_AnimationCollection, Scene_ArcGISTileProvider, Scene_Billboard, Scene_BillboardCollection, Scene_BingMapsStyle, Scene_BingMapsTileProvider, Scene_BlobMaterial, Scene_Camera, Scene_Camera2DController, Scene_CameraColumbusViewController, Scene_CameraControllerCollection, Scene_CameraEventHandler, Scene_CameraEventType, Scene_CameraFlightController, Scene_CameraFreeLookController, Scene_CameraHelpers, Scene_CameraSpindleController, Scene_CameraSpindleControllerMode, Scene_CentralBody, Scene_CheckerboardMaterial, Scene_ColorMaterial, Scene_ComplexConicSensorVolume, Scene_CompositePrimitive, Scene_CompositeTileProvider, Scene_CustomSensorVolume, Scene_DistanceIntervalMaterial, Scene_DotMaterial, Scene_EulerSolver, Scene_FacetMaterial, Scene_GravityForce, Scene_HorizontalOrigin, Scene_HorizontalStripeMaterial, Scene_Label, Scene_LabelCollection, Scene_LabelStyle, Scene_OpenStreetMapTileProvider, Scene_OrthographicFrustum, Scene_Particle, Scene_ParticleSystem, Scene_PerspectiveFrustum, Scene_Polygon, Scene_Polyline, Scene_Projections, Scene_ProxyUsagePolicy, Scene_RectangularPyramidSensorVolume, Scene_Scene, Scene_SceneMode, Scene_SceneTransitioner, Scene_SensorVolumeCollection, Scene_SingleTileProvider, Scene_SphericalRepulsionForce, Scene_SpringForce, Scene_Texture2DPool, Scene_TieDyeMaterial, Scene_Tile, Scene_TileState, Scene_VectorForce, Scene_VerticalOrigin, Scene_VerticalStripeMaterial, Scene_ViewportQuad, Scene_ViscousDrag, Scene_combineMaterials, Shaders_BillboardCollectionFS, Shaders_BillboardCollectionVS, Shaders_BlobMaterial, Shaders_BuiltinFunctions, Shaders_CentralBodyFS, Shaders_CentralBodyFSDepth, Shaders_CentralBodyFSFilter, Shaders_CentralBodyVS, Shaders_CentralBodyVSDepth, Shaders_CentralBodyVSFilter, Shaders_CheckerboardMaterial, Shaders_ColorMaterial, Shaders_ComplexConicSensorVolumeFS, Shaders_ComplexConicSensorVolumeVS, Shaders_ConstructiveSolidGeometry, Shaders_CustomSensorVolumeFS, Shaders_CustomSensorVolumeVS, Shaders_DistanceIntervalMaterial, Shaders_DotMaterial, Shaders_FacetMaterial, Shaders_HorizontalStripeMaterial, Shaders_Noise, Shaders_PolygonFS, Shaders_PolygonFSPick, Shaders_PolygonVS, Shaders_PolygonVSPick, Shaders_PolylineFS, Shaders_PolylineVS, Shaders_Ray, Shaders_SensorVolume, Shaders_SkyAtmosphereFS, Shaders_SkyAtmosphereVS, Shaders_TieDyeMaterial, Shaders_VerticalStripeMaterial, Shaders_ViewportQuadFS, Shaders_ViewportQuadVS, ThirdParty_Chain, ThirdParty_Queue, ThirdParty_Tween, ThirdParty_jsonp, ThirdParty_measureText) {
Cesium.AxisAlignedBoundingBox = Core_AxisAlignedBoundingBox;
Cesium.AxisAlignedBoundingRectangle = Core_AxisAlignedBoundingRectangle;
Cesium.BoundingSphere = Core_BoundingSphere;
Cesium.BoxTessellator = Core_BoxTessellator;
Cesium.Cache = Core_Cache;
Cesium.CachePolicy = Core_CachePolicy;
Cesium.Cartesian2 = Core_Cartesian2;
Cesium.Cartesian3 = Core_Cartesian3;
Cesium.Cartesian4 = Core_Cartesian4;
Cesium.Cartographic2 = Core_Cartographic2;
Cesium.Cartographic3 = Core_Cartographic3;
Cesium.CatmullRomSpline = Core_CatmullRomSpline;
Cesium.ComponentDatatype = Core_ComponentDatatype;
Cesium.CubeMapEllipsoidTessellator = Core_CubeMapEllipsoidTessellator;
Cesium.DeveloperError = Core_DeveloperError;
Cesium.Ellipsoid = Core_Ellipsoid;
Cesium.EllipsoidTangentPlane = Core_EllipsoidTangentPlane;
Cesium.Enumeration = Core_Enumeration;
Cesium.EquidistantCylindricalProjection = Core_EquidistantCylindricalProjection;
Cesium.EventHandler = Core_EventHandler;
Cesium.EventModifier = Core_EventModifier;
Cesium.ExtentTessellator = Core_ExtentTessellator;
Cesium.FAR = Core_FAR;
Cesium.HermiteSpline = Core_HermiteSpline;
Cesium.IndexDatatype = Core_IndexDatatype;
Cesium.Intersect = Core_Intersect;
Cesium.IntersectionTests = Core_IntersectionTests;
Cesium.Jobs = Core_Jobs;
Cesium.JulianDate = Core_JulianDate;
Cesium.LeapSecond = Core_LeapSecond;
Cesium.Math = Core_Math;
Cesium.Matrix2 = Core_Matrix2;
Cesium.Matrix3 = Core_Matrix3;
Cesium.Matrix4 = Core_Matrix4;
Cesium.MercatorProjection = Core_MercatorProjection;
Cesium.MeshFilters = Core_MeshFilters;
Cesium.MouseEventType = Core_MouseEventType;
Cesium.Occluder = Core_Occluder;
Cesium.PlaneTessellator = Core_PlaneTessellator;
Cesium.PolygonPipeline = Core_PolygonPipeline;
Cesium.PolylinePipeline = Core_PolylinePipeline;
Cesium.PrimitiveType = Core_PrimitiveType;
Cesium.Quaternion = Core_Quaternion;
Cesium.Rectangle = Core_Rectangle;
Cesium.RuntimeError = Core_RuntimeError;
Cesium.Shapes = Core_Shapes;
Cesium.SunPosition = Core_SunPosition;
Cesium.TimeConstants = Core_TimeConstants;
Cesium.TimeStandard = Core_TimeStandard;
Cesium.Tipsify = Core_Tipsify;
Cesium.Transforms = Core_Transforms;
Cesium.TridiagonalSystemSolver = Core_TridiagonalSystemSolver;
Cesium.Visibility = Core_Visibility;
Cesium.WindingOrder = Core_WindingOrder;
Cesium.binarySearch = Core_binarySearch;
Cesium.clone = Core_clone;
Cesium.combine = Core_combine;
Cesium.createGuid = Core_createGuid;
Cesium.destroyObject = Core_destroyObject;
Cesium.pointInsideTriangle2D = Core_pointInsideTriangle2D;
Cesium.requestAnimationFrame = Core_requestAnimationFrame;
Cesium.shallowEquals = Core_shallowEquals;
Cesium.splice = Core_splice;
Cesium.BlendEquation = Renderer_BlendEquation;
Cesium.BlendFunction = Renderer_BlendFunction;
Cesium.BlendingState = Renderer_BlendingState;
Cesium.Buffer = Renderer_Buffer;
Cesium.BufferUsage = Renderer_BufferUsage;
Cesium.Context = Renderer_Context;
Cesium.CubeMap = Renderer_CubeMap;
Cesium.CullFace = Renderer_CullFace;
Cesium.DepthFunction = Renderer_DepthFunction;
Cesium.Framebuffer = Renderer_Framebuffer;
Cesium.FrontFace = Renderer_FrontFace;
Cesium.MipmapHint = Renderer_MipmapHint;
Cesium.PickFramebuffer = Renderer_PickFramebuffer;
Cesium.PixelDatatype = Renderer_PixelDatatype;
Cesium.PixelFormat = Renderer_PixelFormat;
Cesium.Renderbuffer = Renderer_Renderbuffer;
Cesium.RenderbufferFormat = Renderer_RenderbufferFormat;
Cesium.ShaderCache = Renderer_ShaderCache;
Cesium.ShaderProgram = Renderer_ShaderProgram;
Cesium.StencilFunction = Renderer_StencilFunction;
Cesium.StencilOperation = Renderer_StencilOperation;
Cesium.Texture = Renderer_Texture;
Cesium.TextureAtlas = Renderer_TextureAtlas;
Cesium.TextureMagnificationFilter = Renderer_TextureMagnificationFilter;
Cesium.TextureMinificationFilter = Renderer_TextureMinificationFilter;
Cesium.TextureWrap = Renderer_TextureWrap;
Cesium.UniformDatatype = Renderer_UniformDatatype;
Cesium.UniformState = Renderer_UniformState;
Cesium.VertexArray = Renderer_VertexArray;
Cesium.VertexArrayFacade = Renderer_VertexArrayFacade;
Cesium.VertexLayout = Renderer_VertexLayout;
Cesium.AnimationCollection = Scene_AnimationCollection;
Cesium.ArcGISTileProvider = Scene_ArcGISTileProvider;
Cesium.Billboard = Scene_Billboard;
Cesium.BillboardCollection = Scene_BillboardCollection;
Cesium.BingMapsStyle = Scene_BingMapsStyle;
Cesium.BingMapsTileProvider = Scene_BingMapsTileProvider;
Cesium.BlobMaterial = Scene_BlobMaterial;
Cesium.Camera = Scene_Camera;
Cesium.Camera2DController = Scene_Camera2DController;
Cesium.CameraColumbusViewController = Scene_CameraColumbusViewController;
Cesium.CameraControllerCollection = Scene_CameraControllerCollection;
Cesium.CameraEventHandler = Scene_CameraEventHandler;
Cesium.CameraEventType = Scene_CameraEventType;
Cesium.CameraFlightController = Scene_CameraFlightController;
Cesium.CameraFreeLookController = Scene_CameraFreeLookController;
Cesium.CameraHelpers = Scene_CameraHelpers;
Cesium.CameraSpindleController = Scene_CameraSpindleController;
Cesium.CameraSpindleControllerMode = Scene_CameraSpindleControllerMode;
Cesium.CentralBody = Scene_CentralBody;
Cesium.CheckerboardMaterial = Scene_CheckerboardMaterial;
Cesium.ColorMaterial = Scene_ColorMaterial;
Cesium.ComplexConicSensorVolume = Scene_ComplexConicSensorVolume;
Cesium.CompositePrimitive = Scene_CompositePrimitive;
Cesium.CompositeTileProvider = Scene_CompositeTileProvider;
Cesium.CustomSensorVolume = Scene_CustomSensorVolume;
Cesium.DistanceIntervalMaterial = Scene_DistanceIntervalMaterial;
Cesium.DotMaterial = Scene_DotMaterial;
Cesium.EulerSolver = Scene_EulerSolver;
Cesium.FacetMaterial = Scene_FacetMaterial;
Cesium.GravityForce = Scene_GravityForce;
Cesium.HorizontalOrigin = Scene_HorizontalOrigin;
Cesium.HorizontalStripeMaterial = Scene_HorizontalStripeMaterial;
Cesium.Label = Scene_Label;
Cesium.LabelCollection = Scene_LabelCollection;
Cesium.LabelStyle = Scene_LabelStyle;
Cesium.OpenStreetMapTileProvider = Scene_OpenStreetMapTileProvider;
Cesium.OrthographicFrustum = Scene_OrthographicFrustum;
Cesium.Particle = Scene_Particle;
Cesium.ParticleSystem = Scene_ParticleSystem;
Cesium.PerspectiveFrustum = Scene_PerspectiveFrustum;
Cesium.Polygon = Scene_Polygon;
Cesium.Polyline = Scene_Polyline;
Cesium.Projections = Scene_Projections;
Cesium.ProxyUsagePolicy = Scene_ProxyUsagePolicy;
Cesium.RectangularPyramidSensorVolume = Scene_RectangularPyramidSensorVolume;
Cesium.Scene = Scene_Scene;
Cesium.SceneMode = Scene_SceneMode;
Cesium.SceneTransitioner = Scene_SceneTransitioner;
Cesium.SensorVolumeCollection = Scene_SensorVolumeCollection;
Cesium.SingleTileProvider = Scene_SingleTileProvider;
Cesium.SphericalRepulsionForce = Scene_SphericalRepulsionForce;
Cesium.SpringForce = Scene_SpringForce;
Cesium.Texture2DPool = Scene_Texture2DPool;
Cesium.TieDyeMaterial = Scene_TieDyeMaterial;
Cesium.Tile = Scene_Tile;
Cesium.TileState = Scene_TileState;
Cesium.VectorForce = Scene_VectorForce;
Cesium.VerticalOrigin = Scene_VerticalOrigin;
Cesium.VerticalStripeMaterial = Scene_VerticalStripeMaterial;
Cesium.ViewportQuad = Scene_ViewportQuad;
Cesium.ViscousDrag = Scene_ViscousDrag;
Cesium.combineMaterials = Scene_combineMaterials;
Cesium._shaders.BillboardCollectionFS = Shaders_BillboardCollectionFS;
Cesium._shaders.BillboardCollectionVS = Shaders_BillboardCollectionVS;
Cesium._shaders.BlobMaterial = Shaders_BlobMaterial;
Cesium._shaders.BuiltinFunctions = Shaders_BuiltinFunctions;
Cesium._shaders.CentralBodyFS = Shaders_CentralBodyFS;
Cesium._shaders.CentralBodyFSDepth = Shaders_CentralBodyFSDepth;
Cesium._shaders.CentralBodyFSFilter = Shaders_CentralBodyFSFilter;
Cesium._shaders.CentralBodyVS = Shaders_CentralBodyVS;
Cesium._shaders.CentralBodyVSDepth = Shaders_CentralBodyVSDepth;
Cesium._shaders.CentralBodyVSFilter = Shaders_CentralBodyVSFilter;
Cesium._shaders.CheckerboardMaterial = Shaders_CheckerboardMaterial;
Cesium._shaders.ColorMaterial = Shaders_ColorMaterial;
Cesium._shaders.ComplexConicSensorVolumeFS = Shaders_ComplexConicSensorVolumeFS;
Cesium._shaders.ComplexConicSensorVolumeVS = Shaders_ComplexConicSensorVolumeVS;
Cesium._shaders.ConstructiveSolidGeometry = Shaders_ConstructiveSolidGeometry;
Cesium._shaders.CustomSensorVolumeFS = Shaders_CustomSensorVolumeFS;
Cesium._shaders.CustomSensorVolumeVS = Shaders_CustomSensorVolumeVS;
Cesium._shaders.DistanceIntervalMaterial = Shaders_DistanceIntervalMaterial;
Cesium._shaders.DotMaterial = Shaders_DotMaterial;
Cesium._shaders.FacetMaterial = Shaders_FacetMaterial;
Cesium._shaders.HorizontalStripeMaterial = Shaders_HorizontalStripeMaterial;
Cesium._shaders.Noise = Shaders_Noise;
Cesium._shaders.PolygonFS = Shaders_PolygonFS;
Cesium._shaders.PolygonFSPick = Shaders_PolygonFSPick;
Cesium._shaders.PolygonVS = Shaders_PolygonVS;
Cesium._shaders.PolygonVSPick = Shaders_PolygonVSPick;
Cesium._shaders.PolylineFS = Shaders_PolylineFS;
Cesium._shaders.PolylineVS = Shaders_PolylineVS;
Cesium._shaders.Ray = Shaders_Ray;
Cesium._shaders.SensorVolume = Shaders_SensorVolume;
Cesium._shaders.SkyAtmosphereFS = Shaders_SkyAtmosphereFS;
Cesium._shaders.SkyAtmosphereVS = Shaders_SkyAtmosphereVS;
Cesium._shaders.TieDyeMaterial = Shaders_TieDyeMaterial;
Cesium._shaders.VerticalStripeMaterial = Shaders_VerticalStripeMaterial;
Cesium._shaders.ViewportQuadFS = Shaders_ViewportQuadFS;
Cesium._shaders.ViewportQuadVS = Shaders_ViewportQuadVS;
Cesium.Chain = ThirdParty_Chain;
Cesium.Queue = ThirdParty_Queue;
Cesium.Tween = ThirdParty_Tween;
Cesium.jsonp = ThirdParty_jsonp;
Cesium.measureText = ThirdParty_measureText;
}, undefined, true);
define("main", function(){});
}());