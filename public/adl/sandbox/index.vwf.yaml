# Copyright 2012 United States Government, as represented by the Secretary of Defense, Under
# Secretary of Defense (Personnel & Readiness).
# 
# Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
# in compliance with the License. You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software distributed under the License
# is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
# or implied. See the License for the specific language governing permissions and limitations under
# the License.

--- 
extends: http://vwf.example.com/navscene.vwf
properties:
  DisplayName:
  placemarks:
    Origin: [0, 0, 0]
  navmode: none     
  sunColor: 
    value: [1, 1, 1]
    set: |
            if(!this.sun) return;
            this.sun.color.r = value[0];
            this.sun.color.g = value[1];
            this.sun.color.b = value[2];
  sunDirection: 
    value: [0 , 0 , 1 ]
    set: |
            if(!this.sun) return;
            
            var x = value[2] * Math.sin(value[0])* Math.cos(value[1]);
            var y = value[2] * Math.sin(value[0])* Math.sin(value[1]);
            var z = value[2] * Math.cos(value[0]);
            
            this.sun.position.x = x;
            this.sun.position.y = y;
            this.sun.position.z = z;      
            this.sun.position.normalize();
            this.sun.position.multiplyScalar(100);
            this.sun.updateMatrixWorld(true);
  sunIntensity: 
    value: .5
    set: |
            if(!this.sun) return;
            this.sun.intensity = value;   
            this.sun.shadowDarkness = value;           
  ambientColor: 
    set: |
            //this.sun.shadowDarkness = MATH.lengthVec3(value);
  fogColor: [155, 155, 155]
  fogNear: 100
  fogFar: 1000
  fogType: 0
  fogDensity: .005
  materialDef:
    set: |  
           this.materialDef = value;
           
           return this.setTexture(value);
    get: |  
           return this.getTexture();
  skyTexture:
    set: |
            
            this.skyTexture = value;
            if(!this.sun) return;
            this.CreateSky(value);
            
    get: |
             return this.skyTexture    
  owner:
  type: scene
  EditorData:
    fogNear:
      displayname: Fog Near
      property: fogNear
      type: slider
      min: 0
      max: 2000
      step: 1
    fogFar:
      displayname: Fog Far
      property: fogFar
      type: slider
      min: 0
      max: 2000
      step: 1
    fogDensity:
      displayname: Fog Density
      property: fogDensity
      type: slider
      min: 0
      max: 1
      step: .001
    sunIntensity:
      displayname: Sun Intensity
      property: sunIntensity
      type: slider
      min: 0
      max: 5
      step: .1      
    fogType:
      displayname: Fog Type
      property: fogType
      type: choice
      labels:         
        - None
        - Linear
        - Quad
      values:
        - null
        - linear
        - exp  
    fogColorR:
      displayname: Fog Color
      property: fogColor
      type: color
    ambientColor:
      displayname: ambient
      property: ambientColor
      type: color     
    AsunColor:
      displayname: Sun Color
      property: sunColor
      type: color
    sunRot:
      displayname: Sun Direction
      property: sunDirection
      type: vector
      step: .05
    skyTexture:
      displayname: skyTexture
      property: skyTexture
      type: choice
      labels: 
        - CloudyNoon
        - Morning
        - Evening
        - Morning2
        - Storm
        - ThunderStorm
        - Night1
        - Night2
        - Bright
        - White
        - Black
      values:
        - cloudy_noon
        - early_morning
        - evening  
        - morning  
        - stormy
        - StormClouds   
        - night1
        - night2
        - bright
        - white
        - black
events:
  keyDown:
  keyUp:
  disconnected:
  newClient:
  clientDisconnect:
methods:  
  AmLocal:
  newplayer:
  deleteplayer:
  initialize:
  receiveChat:
  CreatePlane:
  PM:
  latencyTest:
  getSkyMat:
  cameraBroadcastStart:
  broadcastCameraPosition:
  tick:
  getBroadcasting:
  cameraBroadcastEnd:
  playSound:
  setMusic:
scripts:
- |
    this.initialize = function(){
 
       
       this.setCameraMode('Orbit');
       this.offset = [0,0,1];
       this.center = [0,0,0];
       this.flyspeed = 1;
       this.activeCameraComp = false;
       this.loaded = false;
       this.zoom = 4;
       this.x_rot = 0.15687500000000001;
       this.y_rot = 0.5839999999999994;
       //this.updateCamera();
       this.players = [];
       this.rel_x = 0;
       this.rel_y = 0;
       this.loaded= false;
       this.leftdown= false;
       this.middledown=false;
       this.rightdown= false;
       this.last_x = 0;
       this.last_y = 0;
       this.navmode = 'none';
     //  this.PickOptions = new MATH.CPUPickOptions();
     //  this.PickOptions.UserRenderBatches = true;
      
        $('#index-vwf').mousedown(function(e){this.localpointerDown(e);}.bind(this));
        
        $('#index-vwf').mousewheel(function(e){e.deltaY *= -1; this.localpointerWheel(e);}.bind(this));
        $('#index-vwf').mouseup(function(e){this.localpointerUp(e);}.bind(this));
        $('#index-vwf').mouseleave(function(e)
        {
            if($(e.toElement).hasClass('glyph'))
            {
            
            }
            else
            {
            
                this.localpointerUp(e);
            }
            
        }.bind(this));
        $('#index-vwf').mousemove(function(e){this.localpointerMove(e);}.bind(this));

       this.updateCallbacks = [];
       this.OwnedPrims = [];
      
       findcamera().fov = 70;
       findcamera().updateProjectionMatrix();
       var ground = new THREE.Mesh(new THREE.PlaneGeometry(256,256,10,10), new THREE.MeshPhongMaterial());
       ground.receiveShadow = true;
       ground.PickPriority = -1;
       
       
       var grassTex = THREE.ImageUtils.loadTexture('textures/gridnew.png');
       
      
       ground.material.map = grassTex;
        grassTex.wrapS = THREE.RepeatWrapping;
        grassTex.wrapT = THREE.RepeatWrapping;
        grassTex.repeat.x = 64;
        grassTex.repeat.y = 64;
       grassTex.anisotropy  = _dRenderer.getMaxAnisotropy();
       this.groundplane = ground;
       
       
       findscene().add(ground);
       
       if(this.materialDef)
       this.setTexture(this.materialDef);
       var l = new THREE.DirectionalLight();
       this.sun = l;
       this.sun.name = 'Sun';
       this.sun.castShadow = true;
       this.sun.shadowCameraNear = 1;
       this.sun.shadowCameraFar = 100;
       //this.sun.shadowCameraVisible = true;
       this.sun.shadowCameraBottom = -10;
       this.sun.shadowCameraLeft = -10;
       this.sun.shadowMapWidth = 1024;
       this.sun.shadowMapHeight = 1024;
       
       this.sun.shadowCameraTop = 10;
       this.sun.shadowCameraRight = 10;
       findscene().add(l);
       rebuildAllMaterials();
       
       this.sun.position.x = this.sunDirection[0];
       this.sun.position.y = this.sunDirection[1];
       this.sun.position.z = this.sunDirection[2];
       this.sun.position.normalize();
       this.sun.position.multiplyScalar(100);
       this.sun.intensity = this.sunIntensity;
       this.sun.shadowBias = -.005
       window._dGround = this.groundplane;
       this.groundplane.name = 'GroundPlane';
       //this.groundplane.visible = false;
       window._dSun = this.sun;
       
       this.sun.updateMatrixWorld(true);
       this.CreateSky(vwf.getProperty(this.id,'skyTexture') || 'white');
       /*findscene().setAmbientColor('rgb(200,200,200)');
       
       
      
       
       
       
       findscene().setFogType(MATH.FOG_QUADRATIC);
       findscene().setFogFar(360);
       findscene().setFogNear(100);
       findscene().setFogColor('#FFFFFF');
       
       */
         if(this.id == 'Scene-vwf') return;
          this.prerendercallback = this.prerender.bind(this);
          this.postrendercallback = this.postrender.bind(this);
          _dView.bind('prerender',this.prerendercallback);
          _dView.bind('postprerender',this.postrendercallback);
          this.createNameTag();
          this.updateCamera();
    }
    this.tick = function()
    {
       
        if(this.broadcastingCamera)
        {
            vwf_view.kernel.callMethod('index-vwf','broadcastCameraPosition',[this.camera.transform]);
        }
        if(this.receivingCameraBroadcast && this.cameramode != 'None')
            this.receivingCameraBroadcast = false;
        
    }
    this.broadcastCameraPosition = function(transform)
    {
        if(this.receivingCameraBroadcast)
        {
          
            this.camera.transform = transform;
        }
    }
    this.getBroadcasting = function()
    {
        return this.broadcastingCamera;
    }
    this.cameraBroadcastStart = function()
    {
        if(this.client == this.moniker)
        {
            
            this.broadcastingCamera = true;
            this.receivingCameraBroadcast = false;
        }else
        {
            alertify.confirm(_UserManager.GetPlayernameForClientID(this.client) + " would like to share the camera view with you. Accept?",function(ok)
            {
                if(ok)
                {
                
                    this.broadcastingCamera = false;
                    this.receivingCameraBroadcast = true;
                    this.cameramode = 'None';
                
                }
            
            }.bind(this));
            
        
        }
    
    }
    this.cameraBroadcastEnd = function()
    {
        if(this.client == this.moniker)
        {
            this.broadcastingCamera = false;
            this.receivingCameraBroadcast = false;
        }else
        {
            alertify.alert(_UserManager.GetPlayernameForClientID(this.client) + " has stopped sharing the camera view.");
            this.broadcastingCamera = false;
            this.receivingCameraBroadcast = false;
        }
    }
    this.cameraBroadcastPrompt = function()
    {
        
    
    }
    this.getSkyMat = function()
    {
    
        return this.skycube.material;
    
    }
    this.latencyTest = function(e)
    {
        if(this.moniker == this.client)
        {
            var time = new Date(e.time);
            var thistime = (new Date()) - time;
            _Notifier.alert("The round trip time to the server was: " + thistime +"ms");
        }
    }
    this.keyDown = function(e)
    {
      for(var i in this.children)
        this.children[i].keyDown(e);
    }
    this.keyUp = function(e)
    {
       for(var i in this.children)
        this.children[i].keyUp(e);
    }
    //the system is notifiying us that it has become disconnected from the server
    this.disconnected = function()
    {
        
        alert('This client has been disconnected from server. The page must be reloaded.');
        var user = _UserManager.GetCurrentUserID();
        
        try{vwf.deleteNode(user)} catch(e){};
        document[document.PlayerNumber +'link'] = null;
        document.PlayerNumber = null;
        _UserManager.currentUsername = null;
        window.onbeforeunload = null;
        $(window).unbind();
        window.location.reload();
    }
    //a new client has joined the simulation
    this.newClient = function(id)
    {
    
    
    }
    // a client other than this one has left
    this.clientDisconnect = function(id)
    {
    
    }
    this.CreatePlane = function(width,height)
    {
        
        var hw = width/2;
        var hh = height/2;
        
        var planemesh = new MATH.Mesh();
       
        var planeobj = new MATH.Object();
        planeobj.PickPriority = 0;
        planeobj.setMesh(planemesh);
        planemesh.setPositions([-hw,-hh,-.001, hw,-hh,-.001, hw,hh,-.001, -hw,hh,-.001]);
        planemesh.setTangents([-hw,-hh,0, hw,-hh,0, hw,hh,0, -hw,hh,0]);
        planemesh.setFaces([0,1,2,2,3,0]);
        planemesh.setUV([0,0,250/4 ,0,250/4,250/4,0,250/4]);
        findscene().addChild(planeobj);
        planeobj.InvisibleToCPUPick = false;
        return planeobj;
    }
    this.CreateSky = function(sky_name)
    {
     
        ////console.log('set sky ' + sky_name);
       
       //var sky_name = 'cloudy_noon';
       var urls = [];

        
        urls.push('skys/'+sky_name+'_FR.jpg');
        urls.push('skys/'+sky_name+'_BK.jpg');
        urls.push('skys/'+sky_name+'_RT.jpg');
        urls.push('skys/'+sky_name+'_LF.jpg');
        urls.push('skys/'+sky_name+'_UP.jpg');
        urls.push('skys/'+sky_name+'_DN.jpg');
       
       
        
       var loaded = function(){
            this.skymaterial.uniforms.texture.value.image = skyCubeTexture.image;
            this.skymaterial.uniforms.texture.value.needsUpdate = true;
       }.bind(this);
            var skyCubeTexture = THREE.ImageUtils.loadTextureCube(urls,undefined,loaded);
            skyCubeTexture.format = THREE.RGBFormat;
            skyCubeTexture.generateMipmaps = true;
            skyCubeTexture.minFilter = THREE.LinearFilter;
            skyCubeTexture.magFilter = THREE.LinearFilter;
            skyCubeTexture.wrapS = THREE.ClampToEdgeWrapping;
            skyCubeTexture.wrapT = THREE.ClampToEdgeWrapping;

            
       if(!this.skymaterial)
       {
       
                //default material expects all computation done cpu side, just renders
                // note that since the color, size, spin and orientation are just linear
                // interpolations, they can be done in the shader
                var vertShader_default = 
                "varying vec3 pos;"+
                "void main() {\n"+
                "   vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n"+
                " pos = position;"+
                "   gl_Position = projectionMatrix * mvPosition;\n"+
                "}    \n";
                var fragShader_default = 
               
                "uniform samplerCube texture;\n"+
                "varying vec3 pos;"+
                "void main() {\n"+
                "   gl_FragColor = textureCube(texture,pos);\n"+
                "}\n";
                
                //the default shader - the one used by the analytic solver, just has some simple stuff
                //note that this could be changed to do just life and lifespan, and calculate the 
                //size and color from to uniforms. Im not going to bother
                var attributes_default = {
                   
                    
                };
                var uniforms_default = {
                   
                    texture:   { type: "t", value: skyCubeTexture },
                  
                };
                uniforms_default.texture.value.wrapS = uniforms_default.texture.value.wrapT = THREE.RepeatWrapping;
                this.skymaterial = new THREE.ShaderMaterial( {
                    uniforms:       uniforms_default,
                    attributes:     attributes_default,
                    vertexShader:   vertShader_default,
                    fragmentShader: fragShader_default

                });
            this.skymaterial.uniforms.texture.value = skyCubeTexture;    
            this.skymaterial.depthWrite = false;
       }
       
       
       this.skymaterial.side = 1;
       
       this.skymaterial.fog = false;
       if(!this.skycube)
       {
           this.skycube = new THREE.Mesh(new THREE.CubeGeometry(1000,1000,1000), this.skymaterial);
           this.skycube.name = "SkyCube";
           this.skycube.renderDepth = -1;
           this.skycube.InvisibleToCPUPick = false;
           this.skycube.depthWrite = false;
           this.skycube.depthCheck = false;
           _dbackgroundScene.add(this.skycube);
           window._dSky = this.skycube;
       }
        
    }
    this.removeUpdateCallback = function(m)
    {
        this.updateCallbacks.splice(m,1);
    }
    this.addUpdateCallback = function(val)
    {
        this.updateCallbacks.push(val);
        return this.updateCallbacks.length-1;
    }
    this.callUpdateCallbacks = function()
    {
        
        for(var i =0; i<this.updateCallbacks.length; i++)
         this.updateCallbacks[i](this);
    }
    this.followObject = function(value)
    {
        if(this.objectFollowed)
        {
            if(this.objectFollowed.updateCallbacks)
            {
                this.objectFollowed.updateCallbacks.splice(this.followcallbacknum,1);
            }
        }
        if(value)
        {
            if(value.updateCallbacks)
            {
                value.updateCallbacks.push(this.updateCamera.bind(this));
                this.followcallbacknum = value.updateCallbacks.length;
            }
        }
        this.objectFollowed = value; 
        if(this.objectFollowed)
        this.oldRotZ = vwf.getProperty(this.objectFollowed.id,'rotZ');
    }
    this.targetUpdated = function(obj)
    {
        if(typeof(obj) == "string")
            obj = vwf_view.kernel.kernel.models[0].model.nodes[obj];
        if(obj)
        {
        this.center = obj.translation;
        if(obj.followOffset != null)
            this.center = MATH.addVec3(obj.translation,obj.followOffset);
        }
        
    }
    this.lookat = function(posfrom,posto,pointfront)
    {
                
                var to = MATH.subVec3(posfrom,posto);
                to = MATH.scaleVec3(to,1.0/MATH.lengthVec3(to));
                var a = MATH.crossVec3(pointfront,to);
                var tofront = goog.vec.Quaternion.createFromValues( a[0], a[1], a[2], 1 + MATH.dotVec3(pointfront,to) );    
                var angle = 0; var axis = [0,0,1];
                var  tofront_norm = [];
                goog.vec.Quaternion.normalize(tofront,tofront_norm);    
                var currentrot = [];
               
                angle = goog.vec.Quaternion.toAngleAxis(tofront_norm,axis);
                return [axis[0],axis[1],axis[2],angle/0.0174532925];   
    }
    this.multTranslate=  function(mat, translate, result) {
     
        if(mat == undefined) return;
        if (result === undefined) {
            result = [];
        }
        if (result !== mat) {
            for(var i = 0; i < mat.length; i++)
                result.push(mat[i]);
        }

        var val;
        if (translate[0] !== 0.0) {
            val = translate[0];
            result[12] += val * mat[0];
            result[13] += val * mat[1];
            result[14] += val * mat[2];
            result[15] += val * mat[3];
        }

        if (translate[1] !== 0.0) {
            val = translate[1];
            result[12] += val * mat[4];
            result[13] += val * mat[5];
            result[14] += val * mat[6];
            result[15] += val * mat[7];
        }

        if (translate[2] !== 0.0) {
            val = translate[2];
            result[12] += val * mat[8];
            result[13] += val * mat[9];
            result[14] += val * mat[10];
            result[15] += val * mat[11];
        }
        return result;
    },
    this.normalize = function(vec)
    {   
    
        if(vec == undefined) return;
        return MATH.scaleVec3(vec,1.0/MATH.lengthVec3(vec));
    }
    this.makeLookAt = function(eye, center, up, result) {
    
        if(eye == undefined) return;
       
        if (result === undefined) {
            result = [];
        }

        var f = MATH.subVec3(center, eye);
        f = this.normalize(f);

        var s = MATH.subVec3(f, up);
        s = this.normalize(s);

        var u = MATH.crossVec3(s, f);
        u =this.normalize(u);

        // s[0], u[0], -f[0], 0.0,
        // s[1], u[1], -f[1], 0.0,
        // s[2], u[2], -f[2], 0.0,
        // 0,    0,    0,     1.0

        result[0]=s[0]; result[1]=u[0]; result[2]=-f[0]; result[3]=0.0;
        result[4]=s[1]; result[5]=u[1]; result[6]=-f[1]; result[7]=0.0;
        result[8]=s[2]; result[9]=u[2]; result[10]=-f[2];result[11]=0.0;
        result[12]=  0; result[13]=  0; result[14]=  0;  result[15]=1.0;
        
        var tra = [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];        
        tra[12] = -eye[0];
        tra[13] = -eye[1];
        tra[14] = -eye[2];
        var newresult = MATH.mulMat4(result,tra);
        return newresult;
    }
    this.GetWorldPickRay = function(e)
    {

       var OldX = e.clientX - $('#index-vwf').offset().left;
        var OldY = e.clientY - $('#index-vwf').offset().top;

        var screenmousepos = [OldX/document.getElementById('index-vwf').clientWidth,OldY/document.getElementById('index-vwf').clientHeight,0,1];
        screenmousepos[0] *= 2;
        screenmousepos[1] *= 2;
        screenmousepos[0] -= 1;
        screenmousepos[1] -= 1;
        screenmousepos[1] *= -1;
        var worldmousepos = MATH.mulMat4Vec4(MATH.inverseMat4(getViewProjection()),screenmousepos);
        worldmousepos[0] /= worldmousepos[3];
        worldmousepos[1] /= worldmousepos[3];
        worldmousepos[2] /= worldmousepos[3];


        var campos = [_Editor.findcamera().position.x,_Editor.findcamera().position.y,_Editor.findcamera().position.z];
        var ray = MATH.subVec3(worldmousepos,campos);
        var dist = MATH.lengthVec3(ray);
        ray = MATH.scaleVec3(ray,1.0/MATH.lengthVec3(ray));
        return ray;
    }
    this.intersectLinePlane = function(ray,raypoint,planepoint,planenormal)
    {
        var n = MATH.dotVec3(MATH.subVec3(planepoint,raypoint),planenormal);
        var d = MATH.dotVec3(ray,planenormal);
        if(d == 0)
            return null;

        var dist = n/d;

        return dist;
    }
    this.localpointerDown = function( parms, pickInfo ){
     
      if(!_dView.inDefaultCamera()) return;
      parms.preventDefault();
      if(parms.which == 1) this.leftdown = true;
      if(parms.which == 2) this.middledown = true;
      if(parms.which == 3) this.rightdown = true;
     
      if(this.objectFollowed)
        this.oldRotZ = vwf.getProperty(this.objectFollowed.id,'rotZ');
     
      if(parms.which == 3 || parms.which == 2 && (this.cameramode == 'Orbit' || this.cameramode == 'Free'))
        {
        // Ask the browser to lock the pointer
       // $('#index-vwf')[0].requestPointerLock();
        }      
     
      this.last_x = parms.clientX/window.screen.width;
      this.last_y = parms.clientY/window.screen.height;
      
      if(this.cameramode == 'Navigate')
      {
            
           var campos = [_Editor.findcamera().position.x,_Editor.findcamera().position.y,_Editor.findcamera().position.z];
           var ray = this.GetWorldPickRay(parms);

          
         
           
            this.groundplane.PickPriority = 0;
           var oldintersectxy = _Editor.ThreeJSPick(campos,ray,this.PickOptions).point;
            this.groundplane.PickPriority = -1;
            var dxy2 = this.intersectLinePlane(ray,campos,[0,0,0],[0,0,1]);
           var oldintersectxy2 = MATH.addVec3(campos,MATH.scaleVec3(ray,dxy2));
            if(oldintersectxy2[2] > oldintersectxy[2]) oldintersectxy = oldintersectxy2;
          
           this.navpoint =  oldintersectxy;
      }
     
    }
    this.localpointerUp = function( parms, pickInfo ){
      
      if(!_dView.inDefaultCamera()) return;
      parms.preventDefault();
      if(parms.which == 1) this.leftdown = false;
      if(parms.which == 3) this.rightdown = false;
      if(parms.which == 2) this.middledown = false;
      if(parms.which == 2 || parms.which == 3)
        {
        // Ask the browser to lock the pointer
        //document.exitPointerLock();
        }    
    }
    this.localpointerMove = function( parms, pickInfo ){

      if(!_dView.inDefaultCamera()) return;
      if(document.AxisSelected != null)  
      if(document.AxisSelected != -1)
        return;
        
      if(this.rel_x == undefined) return;
      
      this.rel_x = this.last_x - parms.clientX/window.screen.width;
      this.rel_y = this.last_y - parms.clientY/window.screen.height;
      
      if((this.rightdown==true || this.middledown==true))
      {
        this.rel_x = -(parms.originalEvent.webkitMovementX || parms.originalEvent.mozMovementX || parms.originalEvent.MovementX)/1000 || this.rel_x;
        this.rel_y = -(parms.originalEvent.webkitMovementY || parms.originalEvent.mozMovementY || parms.originalEvent.MovementY)/1000 || this.rel_y;
      }
      
      if((this.rightdown==true && this.middledown==false))
      {
        
        if(this.objectFollowed)
        {  
            this.oldRotZ += this.rel_x*10 || 0;
            vwf_view.kernel.setProperty(this.objectFollowed.id,'rotZ', this.oldRotZ);
            //_Editor.findviewnode(this.objectFollowed.id).setRotZ(this.oldRotZ);
            
        }
        
        this.x_rot += this.rel_x;
        this.y_rot += this.rel_y;
        
        
      }
      
      if((this.cameramode == 'Orbit'|| this.cameramode == 'Free' ) && this.middledown == true )
      {
        
        
        var screenmousepos = [(parms.clientX-this.rel_x*1000)/window.screen.width,(parms.clientY-this.rel_y*1000)/window.screen.height,0,1];
        screenmousepos[0] *= 2;
        screenmousepos[1] *= 2;
        screenmousepos[0] -= 1;
        screenmousepos[1] -= 1;
        screenmousepos[1] *= -1;
        var worldmousepos = MATH.mulMat4Vec4(MATH.inverseMat4(getViewProjection()),screenmousepos);
        worldmousepos[0] /= worldmousepos[3];
        worldmousepos[1] /= worldmousepos[3];
        worldmousepos[2] /= worldmousepos[3];
       
        screenmousepos = [this.last_x,this.last_y,0,1];
        screenmousepos[0] *= 2;
        screenmousepos[1] *= 2;
        screenmousepos[0] -= 1;
        screenmousepos[1] -= 1;
        screenmousepos[1] *= -1;
        var worldmousepos2 = MATH.mulMat4Vec4(MATH.inverseMat4(getViewProjection()),screenmousepos);
        worldmousepos2[0] /= worldmousepos2[3];
        worldmousepos2[1] /= worldmousepos2[3];
        worldmousepos2[2] /= worldmousepos2[3];
       
       var panfactor = 10;
       if(this.cameramode == 'Free')
       panfactor = 50;
       
       ////console.log(this.zoom);
        this.center = MATH.addVec3(this.center,MATH.scaleVec3(MATH.subVec3(worldmousepos2,worldmousepos),panfactor * this.zoom));
        
        
      }
      
      if(this.cameramode == 'Navigate' && this.middledown == true)
      {   
           
           var campos = [_Editor.findcamera().position.x,_Editor.findcamera().position.y,_Editor.findcamera().position.z];
           var ray = this.GetWorldPickRay(parms);
        
           var dxy = this.intersectLinePlane(ray,campos,[0,0,this.navpoint[2]],[0,0,1]);
           var newintersectxy = MATH.addVec3(campos,MATH.scaleVec3(ray,dxy));
           var dxy2 = this.intersectLinePlane(ray,campos,[0,0,0],[0,0,1]);
           var newintersectxy2 = MATH.addVec3(campos,MATH.scaleVec3(ray,dxy2));
            if(newintersectxy2[2] > newintersectxy[2]) newintersectxy = newintersectxy2;
           var len  = MATH.subVec3(this.navpoint,newintersectxy)
           
           this.center = MATH.addVec3(this.center,MATH.subVec3(this.navpoint,newintersectxy));
          
         
      }
      
      this.last_x = parms.clientX/window.screen.width;
      this.last_y = parms.clientY/window.screen.height;
    }
    var tempvec = new THREE.Vector3(0,0,0);
    var tside = [0,0,0];
    var tfinaloffset = [0,0,0];
    var tfinalpos = [0,0,0];
    var XAXIS = [1,0,0];
    var YAXIS = [0,1,0];
    var ZAXIS = [0,0,1];
    var toffset = [0,0,0];
    var tstage2offset = [0,0,0];
    var txmatrix = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
    var tcrossmatrix = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
    function TempVec3(arr)
    {
        tempvec.x = arr[0];
        tempvec.y = arr[1];
        tempvec.z = arr[2];
        return  tempvec;
    }
    this.updateCamera = function()
      {
        
        if(!_dView.inDefaultCamera()) return;
        
        
        if(this.objectFollowed != null)    
            this.targetUpdated(this.objectFollowed);
        
        if(this.cameramode == 'None')
        {
            return;
        }
        
        if(this.cameramode != '3RDPerson' && this.cameramode != 'FirstPerson')
        {
            
            if(this.x_rot == undefined) return;
            var xmatrix = MATH.angleAxis(this.x_rot*10,ZAXIS,txmatrix);
            
            var offset = MATH.mulMat4Vec3(xmatrix,XAXIS,toffset);
            offset = Vec3.scale(offset,1/MATH.lengthVec3(offset),offset);
            tside = Vec3.cross([0,0,1],offset,tside);
            
            if(this.y_rot < .479 ) this.y_rot = .479;
            if(this.y_rot > .783 && (this.cameramode != 'Free' && this.cameramode != 'Fly')) this.y_rot = .783;
            if(this.y_rot > .783 && (this.cameramode == 'Free' || this.cameramode == 'Fly')) this.y_rot = .783;
            
            var crossmatrix = MATH.angleAxis(this.y_rot*10,tside,tcrossmatrix);
            var stage2offset = MATH.mulMat4Vec3(crossmatrix,offset,tstage2offset);
            
            stage2offset = Vec3.scale(stage2offset,1/MATH.lengthVec3(stage2offset),stage2offset);
            tfinaloffset = Vec3.scale(stage2offset,this.zoom,tfinaloffset);
            if(this.center[2] < .05)
             this.center[2] = .05;
            tfinalpos = Vec3.add(tfinaloffset,this.center,tfinalpos);
            
           
            findcamera().position.x = tfinalpos[0];
            findcamera().position.y = tfinalpos[1];
            findcamera().position.z = tfinalpos[2];
            findcamera().lookAt(TempVec3(this.center));
            
            findcamera().far = 5000;
            findcamera().near = .1;
        }else if(this.cameramode == 'FirstPerson')
        {
            //this.oldRotZ var xmatrix = MATH.angleAxis(this.x_rot*10,[0,0,1]);
            var rotation = this.objectFollowed.rotation;
            var xmatrix = MATH.angleAxis(this.oldRotZ,[0,0,1]);
            var offset = MATH.mulMat4Vec3(xmatrix,[0,1.5,.5]);
            
            offset = MATH.scaleVec3(offset,1/MATH.lengthVec3(offset));
            var side = MATH.crossVec3([0,0,1],offset);
           
            if(this.y_rot < .479 ) this.y_rot = .479;
            if(this.y_rot > .783 ) this.y_rot = .783;
            
            var crossmatrix = MATH.angleAxis(this.y_rot*10,side);
            var stage2offset = MATH.mulMat4Vec3(crossmatrix,offset);
            
            stage2offset = MATH.scaleVec3(stage2offset,1/MATH.lengthVec3(stage2offset));
            var finaloffset = MATH.scaleVec3(stage2offset,this.zoom);
            if(this.center[2] < .05)
             this.center[2] = .05;
            var finalpos = MATH.addVec3(finaloffset,this.center);
            
            //this.camera.translation = finalpos;
            findcamera().position.x = finalpos[0];
            findcamera().position.y = finalpos[1];
            findcamera().position.z = finalpos[2];
            findcamera().lookAt(TempVec3(this.center));
            findcamera().far = 5000;
            findcamera().near = .3;
            findcamera().updateProjectionMatrix(true);
            this.zoom = .0001;
            
        }else  if(this.cameramode == '3RDPerson')
        {
            
            var xmatrix = MATH.angleAxis(this.objectFollowed.rotZ,[0,0,1]);
            var offset = MATH.mulMat4Vec3(xmatrix,[0,1.5,.5]);
            
            var finaldist = MATH.lengthVec3(offset);  
            offset = MATH.scaleVec3(offset,1/finaldist);            
            var start = MATH.addVec3(this.center,MATH.scaleVec3(offset,.3));
            
            var oldpickstate = findviewnode(this.objectFollowed.id).PickPriority;
            
            var hit = _Editor.ThreeJSPick(start,MATH.scaleVec3(offset,1),{filter:function(o){return !(o.isAvatar === true || o.passable===true)}});
            if(hit)
            {
                finaldist = Math.min(finaldist,hit.distance-.2);
            }
            findviewnode(this.objectFollowed.id).PickPriority = oldpickstate;
            offset = MATH.scaleVec3(offset,finaldist);
            
            var finalpos = MATH.addVec3(offset,start);
            findcamera().position.x = finalpos[0];
            findcamera().position.y = finalpos[1];
            findcamera().position.z = finalpos[2];
            findcamera().lookAt(TempVec3(this.center));
            
        }
        this.callUpdateCallbacks();
        findcamera().updateMatrixWorld();
        findcamera().updateMatrix();
       
      }
      function findscene()
      {
             return vwf.views[0].state.scenes["index-vwf"].threeScene;
      }
      function findcamera()
      {
             return _Editor.findcamera();
      }
      function matcpy(mat)
      {
        var newmat = [];
        for(var i = 0; i < 16; i++)
            newmat[i] = mat[i];
        return newmat;    
      }
      function getViewProjection()
      {
        var cam = findcamera();
        cam.matrixWorldInverse.getInverse( cam.matrixWorld );

        var _viewProjectionMatrix = new THREE.Matrix4();
        _viewProjectionMatrix.multiplyMatrices( cam.projectionMatrix, cam.matrixWorldInverse );


        return MATH.transposeMat4(_viewProjectionMatrix.flattenToArray([]));
      }
      function to3Vec(vec,two,three)
      {
        if(vec.length)
            return new THREE.Vector3(vec[0],vec[1],vec[2]);
        else
            return new THREE.Vector3(vec,two,three);
      }
    this.setCameraMode = function(mode)
    {
        this.cameramode = mode;
        if(this.cameramode == 'Orbit')
            this.followObject(null);
        if(this.cameramode == 'Free' || this.cameramode == 'Fly')
        {
           this.ReprojectCameraCenter();
           this.followObject(null);
        }
    }
    this.orbitPoint = function(point)
    {
        this.setCameraMode('Orbit');
        var campos = [_Editor.findcamera().position.x,_Editor.findcamera().position.y,_Editor.findcamera().position.z];
        var diff = MATH.subVec3(campos,point);
        var length = MATH.lengthVec3(diff);
        diff = MATH.scaleVec3(diff,1.0/length);
        //this.offset = diff;
        this.zoom = length;
        this.center = point;
        this.objectFollowed = null;
        
    }
    this.ReprojectCameraCenter = function()
    {
            var campos = [findcamera().position.x,findcamera().position.y,findcamera().position.z];
            var worldmousepos  = this.GetCameraCenterRay();
            worldmousepos = MATH.scaleVec3(worldmousepos,.4);
            this.center = MATH.addVec3(worldmousepos,campos);  
            this.zoom = .4;
    }
    this.GetCameraCenterRay = function()
    {
        var screenmousepos = [0,0,0,1];
        var worldmousepos = MATH.mulMat4Vec4(MATH.inverseMat4(getViewProjection()),screenmousepos);
        worldmousepos[0] /= worldmousepos[3];
        worldmousepos[1] /= worldmousepos[3];
        worldmousepos[2] /= worldmousepos[3];


         var campos = [findcamera().position.x,findcamera().position.y,findcamera().position.z];
        var ray = MATH.subVec3(worldmousepos,campos);
        var dist = MATH.lengthVec3(ray);
        ray = MATH.scaleVec3(ray,1.0/MATH.lengthVec3(ray));
        return ray;
    }    
    this.pointerLeave = function( parms ){

    }
    this.localpointerWheel = function( pickInfo ) {
       
        
        if(this.cameramode != 'Navigate' && this.cameramode != 'Free'  && this.cameramode != 'Fly')
        { 
          
            
            if(this.zoom < .4 && pickInfo.deltaY < 0)
            {
                var campos = [findcamera().position.x,findcamera().position.y,findcamera().position.z];
                var worldmousepos  = this.GetCameraCenterRay();
                worldmousepos = MATH.scaleVec3(worldmousepos,1);
                this.center = MATH.addVec3(worldmousepos,campos);  
                this.zoom = 1;
            }else
            {
                if(pickInfo.deltaY < 0 )
                this.zoom *= .9;
                else
                this.zoom *= 1.1;
            }
        }
        if(this.cameramode == 'Navigate')
        {  
            this.center = MATH.addVec3(this.center,MATH.scaleVec3(MATH.subVec3(this.navpoint,this.center),.05));
            this.zoom = this.zoom + (3- this.zoom )*.01;
        }
        
        if(this.cameramode == 'Free' )
        { 
            if(pickInfo.deltaY > 0 )
            this.center = MATH.subVec3(this.center,this.GetCameraCenterRay());
            else
            this.center = MATH.addVec3(this.GetCameraCenterRay(),this.center);
            
        }
        if(this.cameramode == 'Fly')
        {
            if(pickInfo.deltaY > 0 )
            this.flyspeed *= 1.1;
            else 
            this.flyspeed *= .9;
            
            alertify.log('Flying at ' + Math.floor(75 / this.flyspeed) + ' mph');
        }
        if(this.cameramode == 'FirstPerson' && pickInfo.deltaY > 0)
        {
            this.cameramode = '3RDPerson';
        }
        else if(this.cameramode == '3RDPerson' && pickInfo.deltaY < 0)
        {
            this.y_rot =.6245;
            this.cameramode = 'FirstPerson';
        }
        
    }
    this.receiveChat = function(e)
    {
        ChatMessageReceived(e);
    }
    this.PM = function(e)
    {
        PMReceived(e);
    }
    function nodeExists(tempid)
    {
        for(var i in vwf.models.object.objects)
            if (vwf.models.object.objects[i].properties.tempid == tempid) return true;
        
        return false;
    }
    
    function findviewnode(id)
    {
        for(var i =0; i<vwf.views.length;i++)
        {
            if(vwf.views[i].state.nodes[id].threeObject) return vwf.views[i].state.nodes[id].threeObject;
        }
        return null;
    }
    
    this.newplayer = function(e)
    {
        
       
        
    }
    
    this.getTexture = function()
    {
            if(this.materialDef) return this.materialDef;    
           
            return {
                    shininess:15,
                    alpha:1,
                    ambient:{r:.8,g:.8,b:.8},
                    color:{r:1,g:1,b:1,a:1},
                    emit:{r:0,g:0,b:0},
                    reflect:0.8,
                    shadeless:false,
                    shadow:true,
                    specularColor:{r:0.5773502691896258,g:0.5773502691896258,b:0.5773502691896258},
                    specularLevel:1,
                    layers:[
                      {  alpha: 1,
                        blendMode: 0,
                        mapInput: 0,
                        mapTo: 1,
                        offsetx: 0,
                        offsety: 0,
                        rot: 0,
                        scalex: 250/9,
                        scaley: 250/9,
                        src: "textures/grid2.gif"}
                    ]
            }            
    
    }
    this.setTexture = function(value)
    {
            
             if(this.groundplane)
             this.setMaterialByDef(this.groundplane.material,value);
             
    }
    this.createNameTag = function()
    {
    
      var newdiv = document.createElement('img');
      
      $(newdiv).addClass('glyph');
      newdiv.style.position = 'absolute';
      newdiv.id = "Player " + this.name + 'icon';
      //newdiv.innerHTML = "" + this.name;
      $(newdiv).attr('src','../vwf/view/editorview/images/icons/scene.png');
      newdiv.style.left = '0px';
      newdiv.style.top = '0px';
      
      $('#glyphOverlay').append(newdiv);
      $(newdiv).disableSelection();
            $(newdiv).mousedown(function(e){$('#index-vwf').focus(); if(_Editor.GetSelectMode() == "None" || e.which != 1) $('#index-vwf').trigger(e)});
      $(newdiv).mouseup(function(e){$('#index-vwf').focus();$('#index-vwf').trigger(e)});
      $(newdiv).mousemove(function(e){$('#index-vwf').trigger(e)});
      $(newdiv).click(function(e){$('#index-vwf').focus(); if(_Editor.GetSelectMode() != "None") _Editor.SelectObjectPublic(this.id)}.bind(this));
      this.nametag = newdiv;
                 
    }
    this.deinitialize = function()
    {
       _dView.unbind('prerender',this.prerendercallback);
       _dView.unbind('postprerender',this.postrendercallback);
       $(this.nametag).remove();
    }
    this.prerender = function()
    {
        
       
        if(this.cameramode == 'Fly')
        { 
            var dist = window.deltaTime/(this.flyspeed * 30.0);
            var forward = new THREE.Vector3(0,0,-1);
            var center = new THREE.Vector3(0,0,0);
            var cam = findcamera();
            forward.applyMatrix4(cam.matrixWorld);
            center.applyMatrix4(cam.matrixWorld);
            var offset = forward.sub(center);
            
            offset.setLength(.400 + dist);
            
            center.add(offset);
            this.center = [center.x,center.y,center.z];
            findcamera().position = center;
            
            
            
        }
        
        
        this.updateCamera();
        this.updateCamera();
    }
    this.tempmatrix = (new THREE.Matrix4());
    this.lightvec = new THREE.Vector3(0,0,-3);
    this.postrender = function(e,viewprojection, wh, ww)
    {
        //set the skybox position
      
        this.skycube.position.x = findcamera().matrixWorld.elements[12];
        this.skycube.position.y = findcamera().matrixWorld.elements[13];
        this.skycube.position.z = findcamera().matrixWorld.elements[14];
        this.skycube.updateMatrixWorld();
      var div = this.nametag;
      var pos = [0,0,0,1];
      
      
      var screen = MATH.mulMat4Vec4(viewprojection,pos);
      screen[0] /= screen[3];
      screen[1] /= screen[3];
     
      screen[0] /= 2;
      screen[1] /= 2;
      screen[2] /= 2;
      screen[0] += .5;
      screen[1] += .5;
      
  
      screen[0] *= ww;
      screen[1] *= wh;
      
     
      screen[1] = wh - screen[1];

      div.style.top = (screen[1]+35)  +  'px';
      div.style.left = (screen[0]  - 20/2)  +'px';
     
     
      if((screen[0] < 0 || screen[0] > ww || screen[1] < 0 || screen[1] > wh))
      {
            if(div.style.display != 'none')
                div.style.display = 'none';
      }
      else
      {
          if((screen[2] > 10 || screen[2] < 0) && div.style.display != 'none')
             div.style.display = 'none';
          if(screen[2] < 10 && screen[2] > 0 && div.style.display == 'none')
             div.style.display = 'block';
      }
      
      
      
      //focus the shadow camera projection matrix around the camera tha views the scene.
      if(this.sun && this.sun.shadowCamera)
      {
       
      
       this.lightvec.x = 0;
       this.lightvec.y = 0;
       this.lightvec.z = -3;
       var campos = findcamera().localToWorld(this.lightvec);
       
       this.sun.shadowCamera.updateMatrixWorld(true)
        var lm = this.sun.shadowCamera.matrixWorld.clone();
        lm = this.tempmatrix.getInverse(lm);
        var camposLS = campos.applyMatrix4(lm);
        
       
        
        this.sun.shadowCamera.projectionMatrix.makeOrthographic(camposLS.x - 15,camposLS.x + 15,camposLS.y - 15,camposLS.y+15,-camposLS.z - 15 ,-camposLS.z + 15 );
        }
    }    
    this.setMaterialByDef = function(currentmat,value)
    {
        
        currentmat.color.r = value.color.r;
        currentmat.color.g = value.color.g;
        currentmat.color.b = value.color.b;
        
        currentmat.ambient.r = value.ambient.r;
        currentmat.ambient.g = value.ambient.g;
        currentmat.ambient.b = value.ambient.b;
        
        currentmat.emissive.r = value.emit.r;
        currentmat.emissive.g = value.emit.g;
        currentmat.emissive.b = value.emit.b;
        
        currentmat.specular.r = value.specularColor.r * value.specularLevel;
        currentmat.specular.g = value.specularColor.g * value.specularLevel;
        currentmat.specular.b = value.specularColor.b * value.specularLevel;
        
        currentmat.opacity = value.alpha;
        if(value.alpha < 1)
            currentmat.transparent = true;
        else
            currentmat.transparent = false;
            
        currentmat.shininess = value.shininess * 5 ;
        
        var mapnames = ['map','bumpMap','lightMap','normalMap','specularMap','envMap'];
        currentmat.reflectivity = value.reflect;
        for(var i =0; i < value.layers.length; i++)
        {
                var mapname;
                if(value.layers[i].mapTo == 1)
                {
                    mapname = 'map';
                    
                    
                    currentmat.alphaTest = 1 - value.layers[i].alpha;
                    
                }
                if(value.layers[i].mapTo == 2)
                {
                    mapname = 'bumpMap';
                    currentmat.bumpScale = value.layers[i].alpha;
                }
                if(value.layers[i].mapTo == 3)
                {
                    mapname = 'lightMap';
                }	
                if(value.layers[i].mapTo == 4)
                {
                    mapname = 'normalMap';
                    currentmat.normalScale.x = value.layers[i].alpha;
                    currentmat.normalScale.y = value.layers[i].alpha;
                }	
                if(value.layers[i].mapTo == 5)
                {
                    mapname = 'specularMap';
                }
                
                if(value.layers[i].mapTo == 6)
                {
                    mapname = 'envMap';
                }
                
                mapnames.splice(mapnames.indexOf(mapname),1);				
                
                String.prototype.endsWith = function(suffix) {
                    return this.indexOf(suffix, this.length - suffix.length) !== -1;
                };

                if((currentmat[mapname] && currentmat[mapname].image && !currentmat[mapname].image.src.toString().endsWith(value.layers[i].src)) || !currentmat[mapname])
                {
                    currentmat[mapname] = THREE.ImageUtils.loadTexture(value.layers[i].src);
                    
                }
                
                if(value.layers[i].mapInput == 0)
                {
                    currentmat[mapname].mapping = new THREE.UVMapping();
                }
                if(value.layers[i].mapInput == 1)
                {
                    currentmat[mapname].mapping = new THREE.CubeReflectionMapping();
                }
                if(value.layers[i].mapInput == 2)
                {
                    currentmat[mapname].mapping = new THREE.CubeRefractionMapping();
                }
                if(value.layers[i].mapInput == 3)
                {
                    currentmat[mapname].mapping = new THREE.SphericalReflectionMapping();
                }
                if(value.layers[i].mapInput == 4)
                {
                    currentmat[mapname].mapping = new THREE.SphericalRefractionMapping();
                }
                currentmat[mapname].wrapS = THREE.RepeatWrapping;
                currentmat[mapname].wrapT = THREE.RepeatWrapping;
                currentmat[mapname].repeat.x = value.layers[i].scalex;
                currentmat[mapname].repeat.y = value.layers[i].scaley;
                currentmat[mapname].offset.x = value.layers[i].offsetx;
                currentmat[mapname].offset.y = value.layers[i].offsety;
            
        }
        for(var i in mapnames)
        {
            currentmat[mapnames[i]] = null;
        }
        currentmat.needsUpdate = true;
    }      

        
    
    
 
 
   

   
