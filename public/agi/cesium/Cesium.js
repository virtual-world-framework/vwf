
/*!
* Copyright 2011-2012 Cesium Contributors
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Columbus View (Pat. Pend.)
*/
(function () {
/**
 * almond 0.0.3 Copyright (c) 2011, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
/*jslint strict: false, plusplus: false */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {

    var defined = {},
        waiting = {},
        aps = [].slice,
        main, req;

    if (typeof define === "function") {
        //If a define is already in play via another AMD loader,
        //do not overwrite.
        return;
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that "directory" and not name of the baseName's
                //module. For instance, baseName of "one/two/three", maps to
                //"one/two/three.js", but we want the directory, "one/two" for
                //this normalization.
                baseName = baseName.split("/");
                baseName = baseName.slice(0, baseName.length - 1);

                name = baseName.concat(name.split("/"));

                //start trimDots
                var i, part;
                for (i = 0; (part = name[i]); i++) {
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            }
        }
        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (waiting.hasOwnProperty(name)) {
            var args = waiting[name];
            delete waiting[name];
            main.apply(undef, args);
        }
        return defined[name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    function makeMap(name, relName) {
        var prefix, plugin,
            index = name.indexOf('!');

        if (index !== -1) {
            prefix = normalize(name.slice(0, index), relName);
            name = name.slice(index + 1);
            plugin = callDep(prefix);

            //Normalize according
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            p: plugin
        };
    }

    main = function (name, deps, callback, relName) {
        var args = [],
            usingExports,
            cjsModule, depName, i, ret, map;

        //Use name if no relName
        if (!relName) {
            relName = name;
        }

        //Call the callback to define the module, if necessary.
        if (typeof callback === 'function') {

            //Default to require, exports, module if no deps if
            //the factory arg has any arguments specified.
            if (!deps.length && callback.length) {
                deps = ['require', 'exports', 'module'];
            }

            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            for (i = 0; i < deps.length; i++) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = makeRequire(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = defined[name] = {};
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = {
                        id: name,
                        uri: '',
                        exports: defined[name]
                    };
                } else if (defined.hasOwnProperty(depName) || waiting.hasOwnProperty(depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw name + ' missing ' + depName;
                }
            }

            ret = callback.apply(defined[name], args);

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef) {
                    defined[name] = cjsModule.exports;
                } else if (!usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = req = function (deps, callback, relName, forceSync) {
        if (typeof deps === "string") {

            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            //Drop the config stuff on the ground.
            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = arguments[2];
            } else {
                deps = [];
            }
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 15);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function () {
        return req;
    };

    /**
     * Export require as a global, but only if it does not already exist.
     */
    if (!require) {
        require = req;
    }

    define = function (name, deps, callback) {

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (define.unordered) {
            waiting[name] = [name, deps, callback];
        } else {
            main(name, deps, callback);
        }
    };

    define.amd = {
        jQuery: true
    };
}());

define("..\ThirdParty\almond-0.0.3\almond.js", function(){});

/*global define*/
define('Core/DefaultProxy',[],function() {
    

    /**
     * A simple proxy that appends the desired resource as the sole query parameter
     * to the given proxy URL.
     *
     * @alias DefaultProxy
     * @constructor
     *
     * @param {String} proxy The proxy URL that will be used to requests all resources.
     */
    var DefaultProxy = function(proxy) {
        this.proxy = proxy;
    };

    /**
     * Get the final URL to use to request a given resource.
     *
     * @memberof DefaultProxy
     *
     * @param {String} resource The resource to request.
     */
    DefaultProxy.prototype.getURL = function(resource) {
        return this.proxy + '?' + encodeURIComponent(resource);
    };

    return DefaultProxy;
});
/*global define*/
define('Core/DeveloperError',[],function() {
    

    /**
     * Constructs an exception object that is thrown due to a developer error, e.g., invalid argument,
     * argument out of range, etc.  This exception should only be thrown during development;
     * it usually indicates a bug in the calling code.  This exception should never be
     * caught; instead the calling code should strive not to generate it.
     * <br /><br />
     * On the other hand, a {@link RuntimeError} indicates an exception that may
     * be thrown at runtime, e.g., out of memory, that the calling code should be prepared
     * to catch.
     *
     * @alias DeveloperError
     *
     * @param {String} [message=undefined] The error message for this exception.
     *
     * @see RuntimeError
     * @constructor
     */
    var DeveloperError = function(message) {
        /**
         * 'DeveloperError' indicating that this exception was thrown due to a developer error.
         * @type String
         * @constant
         */
        this.name = 'DeveloperError';

        /**
         * The explanation for why this exception was thrown.
         * @type String
         * @constant
         */
        this.message = message;

        /**
         * The Error object containing the stack trace.
         * @type Error
         * @constant
         *
         * @see <a href='https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error'>Error object on Mozilla Developer Network</a>.
         */
        this.error = new Error();
    };

    DeveloperError.prototype.toString = function () {
        var str = this.name + ': ' + this.message;
        if (typeof this.error !== 'undefined') {
            if (typeof this.error.stack !== 'undefined') {
                str += '\n' + this.error.stack.toString();
            } else {
                str += '\n' + this.error.toString();
            }
        }
        return str;
    };

    return DeveloperError;
});

/*global define*/
define('Core/Cartesian2',[
        './DeveloperError'
       ],function(
         DeveloperError) {
    

    /**
     * A 2D Cartesian point.
     * @alias Cartesian2
     * @constructor
     *
     * @param {Number} [x=0.0] The X component.
     * @param {Number} [y=0.0] The Y component.
     *
     * @see Cartesian3
     * @see Cartesian4
     */
    var Cartesian2 = function(x, y) {

        /**
         * The Y component.
         * @type Number
         */
        this.x = (typeof x !== 'undefined') ? x : 0.0;

        /**
         * The X component.
         * @type Number
         */
        this.y = (typeof y !== 'undefined') ? y : 0.0;
    };

    /**
     * Duplicates a Cartesian2 instance.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} cartesian The Cartesian to duplicate.
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian2.clone = function(cartesian, result) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }

        if (typeof result === 'undefined') {
            return new Cartesian2(cartesian.x, cartesian.y);
        }

        result.x = cartesian.x;
        result.y = cartesian.y;
        return result;
    };

    /**
     * Creates a Cartesian2 instance from an existing Cartesian3.  This simply takes the
     * x and y properties of the Cartesian3 and drops z.
     * @memberof Cartesian2
     * @function
     *
     * @param {Cartesian3} cartesian The Cartesian3 instance to create a Cartesian2 instance from.
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian2.fromCartesian3 = Cartesian2.clone;

    /**
     * Creates a Cartesian2 instance from an existing Cartesian4.  This simply takes the
     * x and y properties of the Cartesian4 and drops z and w.
     * @function
     *
     * @param {Cartesian4} cartesian The Cartesian4 instance to create a Cartesian2 instance from.
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian2.fromCartesian4 = Cartesian2.clone;

    /**
     * Computes the value of the maximum component for the supplied Cartesian.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} The cartesian to use.
     * @return {Number} The value of the maximum component.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian2.getMaximumComponent = function(cartesian) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        return Math.max(cartesian.x, cartesian.y);
    };

    /**
     * Computes the value of the minimum component for the supplied Cartesian.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} The cartesian to use.
     * @return {Number} The value of the minimum component.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian2.getMinimumComponent = function(cartesian) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        return Math.min(cartesian.x, cartesian.y);
    };

    /**
     * Computes the provided Cartesian's squared magnitude.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} cartesian The Cartesian instance whose squared magnitude is to be computed.
     * @return {Number} The squared magnitude.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian2.magnitudeSquared = function(cartesian) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        return cartesian.x * cartesian.x + cartesian.y * cartesian.y;
    };

    /**
     * Computes the Cartesian's magnitude (length).
     * @memberof Cartesian2
     *
     * @param {Cartesian2} cartesian The Cartesian instance whose magnitude is to be computed.
     * @return {Number} The magnitude.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian2.magnitude = function(cartesian) {
        return Math.sqrt(Cartesian2.magnitudeSquared(cartesian));
    };

    /**
     * Computes the normalized form of the supplied Cartesian.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} cartesian The Cartesian to be normalized.
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian2.normalize = function(cartesian, result) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        var magnitude = Cartesian2.magnitude(cartesian);
        if (typeof result === 'undefined') {
            return new Cartesian2(cartesian.x / magnitude, cartesian.y / magnitude);
        }
        result.x = cartesian.x / magnitude;
        result.y = cartesian.y / magnitude;
        return result;
    };

    /**
     * Computes the dot (scalar) product of two Cartesians.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} left The first Cartesian.
     * @param {Cartesian2} right The second Cartesian.
     * @return {Number} The dot product.
     *
     * @exception {DeveloperError} left is required.
     * @exception {DeveloperError} right is required.
     */
    Cartesian2.dot = function(left, right) {
        if (typeof left === 'undefined') {
            throw new DeveloperError('left is required');
        }
        if (typeof right === 'undefined') {
            throw new DeveloperError('right is required');
        }
        return left.x * right.x + left.y * right.y;
    };

    /**
     * Computes the componentwise product of two Cartesians.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} left The first Cartesian.
     * @param {Cartesian2} right The second Cartesian.
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.
     *
     * @exception {DeveloperError} left is required.
     * @exception {DeveloperError} right is required.
     */
    Cartesian2.multiplyComponents = function(left, right, result) {
        if (typeof left === 'undefined') {
            throw new DeveloperError('left is required');
        }
        if (typeof right === 'undefined') {
            throw new DeveloperError('right is required');
        }
        if (typeof result === 'undefined') {
            return new Cartesian2(left.x * right.x, left.y * right.y);
        }
        result.x = left.x * right.x;
        result.y = left.y * right.y;
        return result;
    };

    /**
     * Computes the componentwise sum of two Cartesians.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} left The first Cartesian.
     * @param {Cartesian2} right The second Cartesian.
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.
     *
     * @exception {DeveloperError} left is required.
     * @exception {DeveloperError} right is required.
     */
    Cartesian2.add = function(left, right, result) {
        if (typeof left === 'undefined') {
            throw new DeveloperError('left is required');
        }
        if (typeof right === 'undefined') {
            throw new DeveloperError('right is required');
        }
        if (typeof result === 'undefined') {
            return new Cartesian2(left.x + right.x, left.y + right.y);
        }
        result.x = left.x + right.x;
        result.y = left.y + right.y;
        return result;
    };

    /**
     * Computes the componentwise difference of two Cartesians.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} left The first Cartesian.
     * @param {Cartesian2} right The second Cartesian.
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.
     *
     * @exception {DeveloperError} left is required.
     * @exception {DeveloperError} right is required.
     */
    Cartesian2.subtract = function(left, right, result) {
        if (typeof left === 'undefined') {
            throw new DeveloperError('left is required');
        }
        if (typeof right === 'undefined') {
            throw new DeveloperError('right is required');
        }
        if (typeof result === 'undefined') {
            return new Cartesian2(left.x - right.x, left.y - right.y);
        }
        result.x = left.x - right.x;
        result.y = left.y - right.y;
        return result;
    };

    /**
     * Multiplies the provided Cartesian componentwise by the provided scalar.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} cartesian The Cartesian to be scaled.
     * @param {Number} scalar The scalar to multiply with.
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.
     *
     * @exception {DeveloperError} cartesian is required.
     * @exception {DeveloperError} scalar is required and must be a number.
     */
    Cartesian2.multiplyByScalar = function(cartesian, scalar, result) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        if (typeof scalar !== 'number') {
            throw new DeveloperError('scalar is required and must be a number.');
        }
        if (typeof result === 'undefined') {
            return new Cartesian2(cartesian.x * scalar,  cartesian.y * scalar);
        }
        result.x = cartesian.x * scalar;
        result.y = cartesian.y * scalar;
        return result;
    };

    /**
     * Divides the provided Cartesian componentwise by the provided scalar.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} cartesian The Cartesian to be divided.
     * @param {Number} scalar The scalar to divide by.
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.
     *
     * @exception {DeveloperError} cartesian is required.
     * @exception {DeveloperError} scalar is required and must be a number.
     */
    Cartesian2.divideByScalar = function(cartesian, scalar, result) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        if (typeof scalar !== 'number') {
            throw new DeveloperError('scalar is required and must be a number.');
        }
        if (typeof result === 'undefined') {
            return new Cartesian2(cartesian.x / scalar, cartesian.y / scalar);
        }
        result.x = cartesian.x / scalar;
        result.y = cartesian.y / scalar;
        return result;
    };

    /**
     * Negates the provided Cartesian.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} cartesian The Cartesian to be negated.
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian2.negate = function(cartesian, result) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        if (typeof result === 'undefined') {
            return new Cartesian2(-cartesian.x, -cartesian.y);
        }
        result.x = -cartesian.x;
        result.y = -cartesian.y;
        return result;
    };

    /**
     * Computes the absolute value of the provided Cartesian.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} cartesian The Cartesian whose absolute value is to be computed.
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian2.abs = function(cartesian, result) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        if (typeof result === 'undefined') {
            return new Cartesian2(Math.abs(cartesian.x), Math.abs(cartesian.y));
        }
        result.x = Math.abs(cartesian.x);
        result.y = Math.abs(cartesian.y);
        return result;
    };

    var lerpScratch = new Cartesian2();
    /**
     * Computes the linear interpolation or extrapolation at t using the provided cartesians.
     * @memberof Cartesian2
     *
     * @param start The value corresponding to t at 0.0.
     * @param end The value corresponding to t at 1.0.
     * @param t The point along t at which to interpolate.
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.
     *
     * @exception {DeveloperError} start is required.
     * @exception {DeveloperError} end is required.
     * @exception {DeveloperError} t is required and must be a number.
     */
    Cartesian2.lerp = function(start, end, t, result) {
        if (typeof start === 'undefined') {
            throw new DeveloperError('start is required.');
        }
        if (typeof end === 'undefined') {
            throw new DeveloperError('end is required.');
        }
        if (typeof t !== 'number') {
            throw new DeveloperError('t is required and must be a number.');
        }
        Cartesian2.multiplyByScalar(end, t, lerpScratch);
        result = Cartesian2.multiplyByScalar(start, 1.0 - t, result);
        return Cartesian2.add(lerpScratch, result, result);
    };

    var angleBetweenScratch = new Cartesian2();
    var angleBetweenScratch2 = new Cartesian2();
    /**
     * Returns the angle, in radians, between the provided Cartesians.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} left The first Cartesian.
     * @param {Cartesian2} right The second Cartesian.
     * @return {Number} The angle between the Cartesians.
     *
     * @exception {DeveloperError} left is required.
     * @exception {DeveloperError} right is required.
     */
    Cartesian2.angleBetween = function(left, right) {
        if (typeof left === 'undefined') {
            throw new DeveloperError('left is required');
        }
        if (typeof right === 'undefined') {
            throw new DeveloperError('right is required');
        }
        Cartesian2.normalize(left, angleBetweenScratch);
        Cartesian2.normalize(right, angleBetweenScratch2);
        return Math.acos(Cartesian2.dot(angleBetweenScratch, angleBetweenScratch2));
    };

    /**
     * Compares the provided Cartesians componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} [left] The first Cartesian.
     * @param {Cartesian2} [right] The second Cartesian.
     * @return {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    Cartesian2.equals = function(left, right) {
        return (left === right) ||
               ((typeof left !== 'undefined') &&
                (typeof right !== 'undefined') &&
                (left.x === right.x) &&
                (left.y === right.y));
    };

    /**
     * Compares the provided Cartesians componentwise and returns
     * <code>true</code> if they are within the provided epsilon,
     * <code>false</code> otherwise.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} [left] The first Cartesian.
     * @param {Cartesian2} [right] The second Cartesian.
     * @param {Number} epsilon The epsilon to use for equality testing.
     * @return {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
     *
     * @exception {DeveloperError} epsilon is required and must be a number.
     */
    Cartesian2.equalsEpsilon = function(left, right, epsilon) {
        if (typeof epsilon !== 'number') {
            throw new DeveloperError('epsilon is required and must be a number.');
        }
        return (left === right) ||
               ((typeof left !== 'undefined') &&
                (typeof right !== 'undefined') &&
                (Math.abs(left.x - right.x) <= epsilon) &&
                (Math.abs(left.y - right.y) <= epsilon));
    };

    /**
     * An immutable Cartesian2 instance initialized to (0.0, 0.0).
     * @memberof Cartesian2
     */
    Cartesian2.ZERO = Object.freeze(new Cartesian2(0.0, 0.0));

    /**
     * An immutable Cartesian2 instance initialized to (1.0, 0.0).
     * @memberof Cartesian2
     */
    Cartesian2.UNIT_X = Object.freeze(new Cartesian2(1.0, 0.0));

    /**
     * An immutable Cartesian2 instance initialized to (0.0, 1.0).
     * @memberof Cartesian2
     */
    Cartesian2.UNIT_Y = Object.freeze(new Cartesian2(0.0, 1.0));

    /**
     * Computes the value of the maximum component for this Cartesian.
     * @memberof Cartesian2
     *
     * @return {Number} The value of the maximum component.
     */
    Cartesian2.prototype.getMaximumComponent = function() {
        return Cartesian2.getMaximumComponent(this);
    };

    /**
     * Computes the value of the minimum component for this Cartesian.
     * @memberof Cartesian2
     *
     * @return {Number} The value of the minimum component.
     */
    Cartesian2.prototype.getMinimumComponent = function() {
        return Cartesian2.getMinimumComponent(this);
    };

    /**
     * Duplicates this Cartesian2 instance.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.
     */
    Cartesian2.prototype.clone = function(result) {
        return Cartesian2.clone(this, result);
    };

    /**
     * Computes this Cartesian's squared magnitude.
     * @memberof Cartesian2
     *
     * @return {Number} The squared magnitude.
     */
    Cartesian2.prototype.magnitudeSquared = function() {
        return Cartesian2.magnitudeSquared(this);
    };

    /**
     * Computes this Cartesian's magnitude (length).
     * @memberof Cartesian2
     *
     * @return {Number} The magnitude.
     */
    Cartesian2.prototype.magnitude = function() {
        return Cartesian2.magnitude(this);
    };

    /**
     * Computes the normalized form of this Cartesian.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.
     */
    Cartesian2.prototype.normalize = function(result) {
        return Cartesian2.normalize(this, result);
    };

    /**
     * Computes the dot (scalar) product of this Cartesian and a supplied cartesian.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} right The right hand side Cartesian.
     * @return {Number} The dot product.
     *
     * @exception {DeveloperError} right is required.
     */
    Cartesian2.prototype.dot = function(right) {
        return Cartesian2.dot(this, right);
    };

    /**
     * Computes the componentwise product of this Cartesian and the provided Cartesian.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} right The right hand side Cartesian.
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.
     *
     * @exception {DeveloperError} right is required.
     */
    Cartesian2.prototype.multiplyComponents = function(right, result) {
        return Cartesian2.multiplyComponents(this, right, result);
    };

    /**
     * Computes the componentwise sum of this Cartesian and the provided Cartesian.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} right The right hand side Cartesian.
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.
     *
     * @exception {DeveloperError} right is required.
     */
    Cartesian2.prototype.add = function(right, result) {
        return Cartesian2.add(this, right, result);
    };

    /**
     * Computes the componentwise difference of this Cartesian and the provided Cartesian.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} right The right hand side Cartesian.
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.
     *
     * @exception {DeveloperError} right is required.
     */
    Cartesian2.prototype.subtract = function(right, result) {
        return Cartesian2.subtract(this, right, result);
    };

    /**
     * Multiplies this Cartesian componentwise by the provided scalar.
     * @memberof Cartesian2
     *
     * @param {Number} scalar The scalar to multiply with.
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.
     *
     * @exception {DeveloperError} scalar is required and must be a number.
     */
    Cartesian2.prototype.multiplyByScalar = function(scalar, result) {
        return Cartesian2.multiplyByScalar(this, scalar, result);
    };

    /**
     * Divides this Cartesian componentwise by the provided scalar.
     * @memberof Cartesian2
     *
     * @param {Number} scalar The scalar to divide by.
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.
     *
     * @exception {DeveloperError} scalar is required and must be a number.
     */
    Cartesian2.prototype.divideByScalar = function(scalar, result) {
        return Cartesian2.divideByScalar(this, scalar, result);
    };

    /**
     * Negates this Cartesian.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.
     */
    Cartesian2.prototype.negate = function(result) {
        return Cartesian2.negate(this, result);
    };

    /**
     * Computes the absolute value of this Cartesian.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.
     */
    Cartesian2.prototype.abs = function(result) {
        return Cartesian2.abs(this, result);
    };

    /**
     * Computes the linear interpolation or extrapolation at t using this Cartesian
     * and the provided cartesian.  This cartesian is assumed to be t at 0.0.
     * @memberof Cartesian2
     *
     * @param end The value corresponding to t at 1.0.
     * @param t The point along t at which to interpolate.
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.
     *
     * @exception {DeveloperError} end is required.
     * @exception {DeveloperError} t is required and must be a number.
     */
    Cartesian2.prototype.lerp = function(end, t, result) {
        return Cartesian2.lerp(this, end, t, result);
    };

    /**
     * Returns the angle, in radians, between this Cartesian and the provided Cartesian.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} right The right hand side Cartesian.
     * @return {Number} The angle between the Cartesians.
     *
     * @exception {DeveloperError} left is required.
     * @exception {DeveloperError} right is required.
     */
    Cartesian2.prototype.angleBetween = function(right) {
        return Cartesian2.angleBetween(this, right);
    };

    /**
     * Compares this Cartesian against the provided Cartesian componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} [right] The right hand side Cartesian.
     * @return {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
     */
    Cartesian2.prototype.equals = function(right) {
        return Cartesian2.equals(this, right);
    };

    /**
     * Compares this Cartesian against the provided Cartesian componentwise and returns
     * <code>true</code> if they are within the provided epsilon,
     * <code>false</code> otherwise.
     * @memberof Cartesian2
     *
     * @param {Cartesian2} [right] The right hand side Cartesian.
     * @param {Number} epsilon The epsilon to use for equality testing.
     * @return {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
     *
     * @exception {DeveloperError} epsilon is required and must be a number.
     */
    Cartesian2.prototype.equalsEpsilon = function(right, epsilon) {
        return Cartesian2.equalsEpsilon(this, right, epsilon);
    };

    /**
     * Creates a string representing this Cartesian in the format '(x, y)'.
     * @memberof Cartesian2
     *
     * @return {String} A string representing the provided Cartesian in the format '(x, y)'.
     */
    Cartesian2.prototype.toString = function() {
        return '(' + this.x + ', ' + this.y + ')';
    };

    return Cartesian2;
});

/*global define*/
define('Core/Cartesian3',['./DeveloperError'
       ], function(
        DeveloperError) {
    

    /**
     * A 3D Cartesian point.
     * @alias Cartesian3
     * @constructor
     *
     * @param {Number} [x=0.0] The X component.
     * @param {Number} [y=0.0] The Y component.
     * @param {Number} [z=0.0] The Z component.
     *
     * @see Cartesian2
     * @see Cartesian4
     */
    var Cartesian3 = function(x, y, z) {

        /**
         * The X component.
         * @type Number
         */
        this.x = (typeof x !== 'undefined') ? x : 0.0;

        /**
         * The Y component.
         * @type Number
         */
        this.y = (typeof y !== 'undefined') ? y : 0.0;

        /**
         * The Z component.
         * @type Number
         */
        this.z = (typeof z !== 'undefined') ? z : 0.0;
    };

    /**
     * Converts the provided Spherical into Cartesian3 coordinates.
     * @memberof Cartesian3
     *
     * @param {Spherical} spherical The Spherical to be converted to Cartesian3.
     * @param {Cartesian3} [cartesian3] The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The modified result parameter, or a new instance if none was provided.
     *
     * @exception {DeveloperError} spherical is required.
     */
    Cartesian3.fromSpherical = function(spherical, result) {
        if (typeof spherical === 'undefined') {
            throw new DeveloperError('spherical is required');
        }
        if (typeof result === 'undefined') {
            result = new Cartesian3();
        }
        var clock = spherical.clock;
        var cone = spherical.cone;
        var magnitude = typeof spherical.magnitude === 'undefined' ? 1.0 : spherical.magnitude;
        var radial = magnitude * Math.sin(cone);
        result.x = radial * Math.cos(clock);
        result.y = radial * Math.sin(clock);
        result.z = magnitude * Math.cos(cone);
        return result;
    };

    /**
     * Duplicates a Cartesian3 instance.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} cartesian The Cartesian to duplicate.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian3.clone = function(cartesian, result) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }

        if (typeof result === 'undefined') {
            return new Cartesian3(cartesian.x, cartesian.y, cartesian.z);
        }

        result.x = cartesian.x;
        result.y = cartesian.y;
        result.z = cartesian.z;
        return result;
    };

    /**
     * Creates a Cartesian3 instance from an existing Cartesian4.  This simply takes the
     * x, y, and z properties of the Cartesian4 and drops w.
     * @function
     *
     * @param {Cartesian4} cartesian The Cartesian4 instance to create a Cartesian3 instance from.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian3.fromCartesian4 = Cartesian3.clone;

    /**
     * Computes the value of the maximum component for the supplied Cartesian.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} The cartesian to use.
     * @return {Number} The value of the maximum component.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian3.getMaximumComponent = function(cartesian) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        return Math.max(cartesian.x, cartesian.y, cartesian.z);
    };

    /**
     * Computes the value of the minimum component for the supplied Cartesian.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} The cartesian to use.
     * @return {Number} The value of the minimum component.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian3.getMinimumComponent = function(cartesian) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        return Math.min(cartesian.x, cartesian.y, cartesian.z);
    };

    /**
     * Computes the provided Cartesian's squared magnitude.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} cartesian The Cartesian instance whose squared magnitude is to be computed.
     * @return {Number} The squared magnitude.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian3.magnitudeSquared = function(cartesian) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        return cartesian.x * cartesian.x + cartesian.y * cartesian.y + cartesian.z * cartesian.z;
    };

    /**
     * Computes the Cartesian's magnitude (length).
     * @memberof Cartesian3
     *
     * @param {Cartesian3} cartesian The Cartesian instance whose magnitude is to be computed.
     * @return {Number} The magnitude.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian3.magnitude = function(cartesian) {
        return Math.sqrt(Cartesian3.magnitudeSquared(cartesian));
    };

    /**
     * Computes the normalized form of the supplied Cartesian.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} cartesian The Cartesian to be normalized.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian3.normalize = function(cartesian, result) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        var magnitude = Cartesian3.magnitude(cartesian);
        if (typeof result === 'undefined') {
            return new Cartesian3(cartesian.x / magnitude, cartesian.y / magnitude, cartesian.z / magnitude);
        }
        result.x = cartesian.x / magnitude;
        result.y = cartesian.y / magnitude;
        result.z = cartesian.z / magnitude;
        return result;
    };

    /**
     * Computes the dot (scalar) product of two Cartesians.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} left The first Cartesian.
     * @param {Cartesian3} right The second Cartesian.
     * @return {Number} The dot product.
     *
     * @exception {DeveloperError} left is required.
     * @exception {DeveloperError} right is required.
     */
    Cartesian3.dot = function(left, right) {
        if (typeof left === 'undefined') {
            throw new DeveloperError('left is required');
        }
        if (typeof right === 'undefined') {
            throw new DeveloperError('right is required');
        }
        return left.x * right.x + left.y * right.y + left.z * right.z;
    };

    /**
     * Computes the componentwise product of two Cartesians.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} left The first Cartesian.
     * @param {Cartesian3} right The second Cartesian.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
     *
     * @exception {DeveloperError} left is required.
     * @exception {DeveloperError} right is required.
     */
    Cartesian3.multiplyComponents = function(left, right, result) {
        if (typeof left === 'undefined') {
            throw new DeveloperError('left is required');
        }
        if (typeof right === 'undefined') {
            throw new DeveloperError('right is required');
        }
        if (typeof result === 'undefined') {
            return new Cartesian3(left.x * right.x, left.y * right.y, left.z * right.z);
        }
        result.x = left.x * right.x;
        result.y = left.y * right.y;
        result.z = left.z * right.z;
        return result;
    };

    /**
     * Computes the componentwise sum of two Cartesians.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} left The first Cartesian.
     * @param {Cartesian3} right The second Cartesian.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
     *
     * @exception {DeveloperError} left is required.
     * @exception {DeveloperError} right is required.
     */
    Cartesian3.add = function(left, right, result) {
        if (typeof left === 'undefined') {
            throw new DeveloperError('left is required');
        }
        if (typeof right === 'undefined') {
            throw new DeveloperError('right is required');
        }
        if (typeof result === 'undefined') {
            return new Cartesian3(left.x + right.x, left.y + right.y, left.z + right.z);
        }
        result.x = left.x + right.x;
        result.y = left.y + right.y;
        result.z = left.z + right.z;
        return result;
    };

    /**
     * Computes the componentwise difference of two Cartesians.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} left The first Cartesian.
     * @param {Cartesian3} right The second Cartesian.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
     *
     * @exception {DeveloperError} left is required.
     * @exception {DeveloperError} right is required.
     */
    Cartesian3.subtract = function(left, right, result) {
        if (typeof left === 'undefined') {
            throw new DeveloperError('left is required');
        }
        if (typeof right === 'undefined') {
            throw new DeveloperError('right is required');
        }
        if (typeof result === 'undefined') {
            return new Cartesian3(left.x - right.x, left.y - right.y, left.z - right.z);
        }
        result.x = left.x - right.x;
        result.y = left.y - right.y;
        result.z = left.z - right.z;
        return result;
    };

    /**
     * Multiplies the provided Cartesian componentwise by the provided scalar.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} cartesian The Cartesian to be scaled.
     * @param {Number} scalar The scalar to multiply with.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
     *
     * @exception {DeveloperError} cartesian is required.
     * @exception {DeveloperError} scalar is required and must be a number.
     */
    Cartesian3.multiplyByScalar = function(cartesian, scalar, result) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        if (typeof scalar !== 'number') {
            throw new DeveloperError('scalar is required and must be a number.');
        }
        if (typeof result === 'undefined') {
            return new Cartesian3(cartesian.x * scalar,  cartesian.y * scalar,  cartesian.z * scalar);
        }
        result.x = cartesian.x * scalar;
        result.y = cartesian.y * scalar;
        result.z = cartesian.z * scalar;
        return result;
    };

    /**
     * Divides the provided Cartesian componentwise by the provided scalar.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} cartesian The Cartesian to be divided.
     * @param {Number} scalar The scalar to divide by.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
     *
     * @exception {DeveloperError} cartesian is required.
     * @exception {DeveloperError} scalar is required and must be a number.
     */
    Cartesian3.divideByScalar = function(cartesian, scalar, result) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        if (typeof scalar !== 'number') {
            throw new DeveloperError('scalar is required and must be a number.');
        }
        if (typeof result === 'undefined') {
            return new Cartesian3(cartesian.x / scalar, cartesian.y / scalar, cartesian.z / scalar);
        }
        result.x = cartesian.x / scalar;
        result.y = cartesian.y / scalar;
        result.z = cartesian.z / scalar;
        return result;
    };

    /**
     * Negates the provided Cartesian.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} cartesian The Cartesian to be negated.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian3.negate = function(cartesian, result) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        if (typeof result === 'undefined') {
            return new Cartesian3(-cartesian.x, -cartesian.y, -cartesian.z);
        }
        result.x = -cartesian.x;
        result.y = -cartesian.y;
        result.z = -cartesian.z;
        return result;
    };

    /**
     * Computes the absolute value of the provided Cartesian.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} cartesian The Cartesian whose absolute value is to be computed.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian3.abs = function(cartesian, result) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        if (typeof result === 'undefined') {
            return new Cartesian3(Math.abs(cartesian.x), Math.abs(cartesian.y), Math.abs(cartesian.z));
        }
        result.x = Math.abs(cartesian.x);
        result.y = Math.abs(cartesian.y);
        result.z = Math.abs(cartesian.z);
        return result;
    };

    var lerpScratch = new Cartesian3();
    /**
     * Computes the linear interpolation or extrapolation at t using the provided cartesians.
     * @memberof Cartesian3
     *
     * @param start The value corresponding to t at 0.0.
     * @param end The value corresponding to t at 1.0.
     * @param t The point along t at which to interpolate.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
     *
     * @exception {DeveloperError} start is required.
     * @exception {DeveloperError} end is required.
     * @exception {DeveloperError} t is required and must be a number.
     */
    Cartesian3.lerp = function(start, end, t, result) {
        if (typeof start === 'undefined') {
            throw new DeveloperError('start is required.');
        }
        if (typeof end === 'undefined') {
            throw new DeveloperError('end is required.');
        }
        if (typeof t !== 'number') {
            throw new DeveloperError('t is required and must be a number.');
        }
        Cartesian3.multiplyByScalar(end, t, lerpScratch);
        result = Cartesian3.multiplyByScalar(start, 1.0 - t, result);
        return Cartesian3.add(lerpScratch, result, result);
    };

    var angleBetweenScratch = new Cartesian3();
    var angleBetweenScratch2 = new Cartesian3();
    /**
     * Returns the angle, in radians, between the provided Cartesians.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} left The first Cartesian.
     * @param {Cartesian3} right The second Cartesian.
     * @return {Number} The angle between the Cartesians.
     *
     * @exception {DeveloperError} left is required.
     * @exception {DeveloperError} right is required.
     */
    Cartesian3.angleBetween = function(left, right) {
        if (typeof left === 'undefined') {
            throw new DeveloperError('left is required');
        }
        if (typeof right === 'undefined') {
            throw new DeveloperError('right is required');
        }
        Cartesian3.normalize(left, angleBetweenScratch);
        Cartesian3.normalize(right, angleBetweenScratch2);
        return Math.acos(Cartesian3.dot(angleBetweenScratch, angleBetweenScratch2));
    };

    /**
     * Compares the provided Cartesians componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} [left] The first Cartesian.
     * @param {Cartesian3} [right] The second Cartesian.
     * @return {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    Cartesian3.equals = function(left, right) {
        return (left === right) ||
               ((typeof left !== 'undefined') &&
                (typeof right !== 'undefined') &&
                (left.x === right.x) &&
                (left.y === right.y) &&
                (left.z === right.z));
    };

    /**
     * Compares the provided Cartesians componentwise and returns
     * <code>true</code> if they are within the provided epsilon,
     * <code>false</code> otherwise.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} [left] The first Cartesian.
     * @param {Cartesian3} [right] The second Cartesian.
     * @param {Number} epsilon The epsilon to use for equality testing.
     * @return {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
     *
     * @exception {DeveloperError} epsilon is required and must be a number.
     */
    Cartesian3.equalsEpsilon = function(left, right, epsilon) {
        if (typeof epsilon !== 'number') {
            throw new DeveloperError('epsilon is required and must be a number.');
        }
        return (left === right) ||
               ((typeof left !== 'undefined') &&
                (typeof right !== 'undefined') &&
                (Math.abs(left.x - right.x) <= epsilon) &&
                (Math.abs(left.y - right.y) <= epsilon) &&
                (Math.abs(left.z - right.z) <= epsilon));
    };

    /**
     * Computes the cross (outer) product of two Cartesians.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} left The first Cartesian.
     * @param {Cartesian3} right The second Cartesian.
     * @return {Number} The cross product.
     *
     * @exception {DeveloperError} left is required.
     * @exception {DeveloperError} right is required.
     */
    Cartesian3.cross = function(left, right, result) {
        if (typeof left === 'undefined') {
            throw new DeveloperError('left is required');
        }
        if (typeof right === 'undefined') {
            throw new DeveloperError('right is required');
        }

        var leftX = left.x;
        var leftY = left.y;
        var leftZ = left.z;
        var rightX = right.x;
        var rightY = right.y;
        var rightZ = right.z;

        var x = leftY * rightZ - leftZ * rightY;
        var y = leftZ * rightX - leftX * rightZ;
        var z = leftX * rightY - leftY * rightX;

        if (typeof result === 'undefined') {
            return new Cartesian3(x, y, z);
        }
        result.x = x;
        result.y = y;
        result.z = z;
        return result;
    };

    /**
     * An immutable Cartesian3 instance initialized to (0.0, 0.0, 0.0).
     * @memberof Cartesian3
     */
    Cartesian3.ZERO = Object.freeze(new Cartesian3(0.0, 0.0, 0.0));

    /**
     * An immutable Cartesian3 instance initialized to (1.0, 0.0, 0.0).
     * @memberof Cartesian3
     */
    Cartesian3.UNIT_X = Object.freeze(new Cartesian3(1.0, 0.0, 0.0));

    /**
     * An immutable Cartesian3 instance initialized to (0.0, 1.0, 0.0).
     * @memberof Cartesian3
     */
    Cartesian3.UNIT_Y = Object.freeze(new Cartesian3(0.0, 1.0, 0.0));

    /**
     * An immutable Cartesian3 instance initialized to (0.0, 0.0, 1.0).
     * @memberof Cartesian3
     */
    Cartesian3.UNIT_Z = Object.freeze(new Cartesian3(0.0, 0.0, 1.0));

    /**
     * Computes the value of the maximum component for this Cartesian.
     * @memberof Cartesian3
     *
     * @return {Number} The value of the maximum component.
     */
    Cartesian3.prototype.getMaximumComponent = function() {
        return Cartesian3.getMaximumComponent(this);
    };

    /**
     * Computes the value of the minimum component for this Cartesian.
     * @memberof Cartesian3
     *
     * @return {Number} The value of the minimum component.
     */
    Cartesian3.prototype.getMinimumComponent = function() {
        return Cartesian3.getMinimumComponent(this);
    };

    /**
     * Duplicates this Cartesian3 instance.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
     */
    Cartesian3.prototype.clone = function(result) {
        return Cartesian3.clone(this, result);
    };

    /**
     * Computes this Cartesian's squared magnitude.
     * @memberof Cartesian3
     *
     * @return {Number} The squared magnitude.
     */
    Cartesian3.prototype.magnitudeSquared = function() {
        return Cartesian3.magnitudeSquared(this);
    };

    /**
     * Computes this Cartesian's magnitude (length).
     * @memberof Cartesian3
     *
     * @return {Number} The magnitude.
     */
    Cartesian3.prototype.magnitude = function() {
        return Cartesian3.magnitude(this);
    };

    /**
     * Computes the normalized form of this Cartesian.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
     */
    Cartesian3.prototype.normalize = function(result) {
        return Cartesian3.normalize(this, result);
    };

    /**
     * Computes the dot (scalar) product of this Cartesian and a supplied cartesian.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} right The right hand side Cartesian.
     * @return {Number} The dot product.
     *
     * @exception {DeveloperError} right is required.
     */
    Cartesian3.prototype.dot = function(right) {
        return Cartesian3.dot(this, right);
    };

    /**
     * Computes the componentwise product of this Cartesian and the provided Cartesian.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} right The right hand side Cartesian.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
     *
     * @exception {DeveloperError} right is required.
     */
    Cartesian3.prototype.multiplyComponents = function(right, result) {
        return Cartesian3.multiplyComponents(this, right, result);
    };

    /**
     * Computes the componentwise sum of this Cartesian and the provided Cartesian.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} right The right hand side Cartesian.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
     *
     * @exception {DeveloperError} right is required.
     */
    Cartesian3.prototype.add = function(right, result) {
        return Cartesian3.add(this, right, result);
    };

    /**
     * Computes the componentwise difference of this Cartesian and the provided Cartesian.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} right The right hand side Cartesian.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
     *
     * @exception {DeveloperError} right is required.
     */
    Cartesian3.prototype.subtract = function(right, result) {
        return Cartesian3.subtract(this, right, result);
    };

    /**
     * Multiplies this Cartesian componentwise by the provided scalar.
     * @memberof Cartesian3
     *
     * @param {Number} scalar The scalar to multiply with.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
     *
     * @exception {DeveloperError} scalar is required and must be a number.
     */
    Cartesian3.prototype.multiplyByScalar = function(scalar, result) {
        return Cartesian3.multiplyByScalar(this, scalar, result);
    };

    /**
     * Divides this Cartesian componentwise by the provided scalar.
     * @memberof Cartesian3
     *
     * @param {Number} scalar The scalar to divide by.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
     *
     * @exception {DeveloperError} scalar is required and must be a number.
     */
    Cartesian3.prototype.divideByScalar = function(scalar, result) {
        return Cartesian3.divideByScalar(this, scalar, result);
    };

    /**
     * Negates this Cartesian.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
     */
    Cartesian3.prototype.negate = function(result) {
        return Cartesian3.negate(this, result);
    };

    /**
     * Computes the absolute value of this Cartesian.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
     */
    Cartesian3.prototype.abs = function(result) {
        return Cartesian3.abs(this, result);
    };

    /**
     * Computes the linear interpolation or extrapolation at t using this Cartesian
     * and the provided cartesian.  This cartesian is assumed to be t at 0.0.
     * @memberof Cartesian3
     *
     * @param end The value corresponding to t at 1.0.
     * @param t The point along t at which to interpolate.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
     *
     * @exception {DeveloperError} end is required.
     * @exception {DeveloperError} t is required and must be a number.
     */
    Cartesian3.prototype.lerp = function(end, t, result) {
        return Cartesian3.lerp(this, end, t, result);
    };

    /**
     * Returns the angle, in radians, between this Cartesian and the provided Cartesian.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} right The right hand side Cartesian.
     * @return {Number} The angle between the Cartesians.
     *
     * @exception {DeveloperError} left is required.
     * @exception {DeveloperError} right is required.
     */
    Cartesian3.prototype.angleBetween = function(right) {
        return Cartesian3.angleBetween(this, right);
    };

    /**
     * Compares this Cartesian against the provided Cartesian componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} [right] The right hand side Cartesian.
     * @return {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
     */
    Cartesian3.prototype.equals = function(right) {
        return Cartesian3.equals(this, right);
    };

    /**
     * Compares this Cartesian against the provided Cartesian componentwise and returns
     * <code>true</code> if they are within the provided epsilon,
     * <code>false</code> otherwise.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} [right] The right hand side Cartesian.
     * @param {Number} epsilon The epsilon to use for equality testing.
     * @return {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
     *
     * @exception {DeveloperError} epsilon is required and must be a number.
     */
    Cartesian3.prototype.equalsEpsilon = function(right, epsilon) {
        return Cartesian3.equalsEpsilon(this, right, epsilon);
    };

    /**
     * Creates a string representing this Cartesian in the format '(x, y)'.
     * @memberof Cartesian3
     *
     * @return {String} A string representing the provided Cartesian in the format '(x, y)'.
     */
    Cartesian3.prototype.toString = function() {
        return '(' + this.x + ', ' + this.y + ', ' + this.z + ')';
    };

    /**
     * Computes the cross (outer) product of this and the provided Cartesian.
     * @memberof Cartesian3
     *
     * @param {Cartesian3} right The right hand side Cartesian.
     * @return {Number} The cross product.
     *
     * @exception {DeveloperError} right is required.
     */
    Cartesian3.prototype.cross = function(right, result) {
        return Cartesian3.cross(this, right, result);
    };

    return Cartesian3;
});

/*global define*/
define('Core/Cartesian4',['./DeveloperError'
       ], function(
        DeveloperError) {
    

    /**
     * A 4D Cartesian point.
     * @alias Cartesian4
     * @constructor
     *
     * @param {Number} [x=0.0] The X component.
     * @param {Number} [y=0.0] The Y component.
     * @param {Number} [z=0.0] The Z component.
     * @param {Number} [w=0.0] The W component.
     *
     * @see Cartesian2
     * @see Cartesian3
     */
    var Cartesian4 = function(x, y, z, w) {

        /**
         * The X component.
         * @type Number
         */
        this.x = (typeof x !== 'undefined') ? x : 0.0;

        /**
         * The Y component.
         * @type Number
         */
        this.y = (typeof y !== 'undefined') ? y : 0.0;

        /**
         * The Z component.
         * @type Number
         */
        this.z = (typeof z !== 'undefined') ? z : 0.0;

        /**
         * The W component.
         * @type Number
         */
        this.w = (typeof w !== 'undefined') ? w : 0.0;
    };

    /**
     * Duplicates a Cartesian4 instance.
     * @memberof Cartesian4
     *
     * @param {Cartesian4} cartesian The Cartesian to duplicate.
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The modified result parameter or a new Cartesian4 instance if none was provided.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian4.clone = function(cartesian, result) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }

        if (typeof result === 'undefined') {
            return new Cartesian4(cartesian.x, cartesian.y, cartesian.z, cartesian.w);
        }

        result.x = cartesian.x;
        result.y = cartesian.y;
        result.z = cartesian.z;
        result.w = cartesian.w;
        return result;
    };

    /**
     * Computes the value of the maximum component for the supplied Cartesian.
     * @memberof Cartesian4
     *
     * @param {Cartesian4} The cartesian to use.
     * @return {Number} The value of the maximum component.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian4.getMaximumComponent = function(cartesian) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        return Math.max(cartesian.x, cartesian.y, cartesian.z, cartesian.w);
    };

    /**
     * Computes the value of the minimum component for the supplied Cartesian.
     * @memberof Cartesian4
     *
     * @param {Cartesian4} The cartesian to use.
     * @return {Number} The value of the minimum component.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian4.getMinimumComponent = function(cartesian) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        return Math.min(cartesian.x, cartesian.y, cartesian.z, cartesian.w);
    };

    /**
     * Computes the provided Cartesian's squared magnitude.
     * @memberof Cartesian4
     *
     * @param {Cartesian4} cartesian The Cartesian instance whose squared magnitude is to be computed.
     * @return {Number} The squared magnitude.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian4.magnitudeSquared = function(cartesian) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        return cartesian.x * cartesian.x + cartesian.y * cartesian.y + cartesian.z * cartesian.z+ cartesian.w * cartesian.w;
    };

    /**
     * Computes the Cartesian's magnitude (length).
     * @memberof Cartesian4
     *
     * @param {Cartesian4} cartesian The Cartesian instance whose magnitude is to be computed.
     * @return {Number} The magnitude.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian4.magnitude = function(cartesian) {
        return Math.sqrt(Cartesian4.magnitudeSquared(cartesian));
    };

    /**
     * Computes the normalized form of the supplied Cartesian.
     * @memberof Cartesian4
     *
     * @param {Cartesian4} cartesian The Cartesian to be normalized.
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The modified result parameter or a new Cartesian4 instance if none was provided.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian4.normalize = function(cartesian, result) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        var magnitude = Cartesian4.magnitude(cartesian);
        if (typeof result === 'undefined') {
            return new Cartesian4(cartesian.x / magnitude, cartesian.y / magnitude, cartesian.z / magnitude, cartesian.w / magnitude);
        }
        result.x = cartesian.x / magnitude;
        result.y = cartesian.y / magnitude;
        result.z = cartesian.z / magnitude;
        result.w = cartesian.w / magnitude;
        return result;
    };

    /**
     * Computes the dot (scalar) product of two Cartesians.
     * @memberof Cartesian4
     *
     * @param {Cartesian4} left The first Cartesian.
     * @param {Cartesian4} right The second Cartesian.
     * @return {Number} The dot product.
     *
     * @exception {DeveloperError} left is required.
     * @exception {DeveloperError} right is required.
     */
    Cartesian4.dot = function(left, right) {
        if (typeof left === 'undefined') {
            throw new DeveloperError('left is required');
        }
        if (typeof right === 'undefined') {
            throw new DeveloperError('right is required');
        }
        return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;
    };

    /**
     * Computes the componentwise product of two Cartesians.
     * @memberof Cartesian4
     *
     * @param {Cartesian4} left The first Cartesian.
     * @param {Cartesian4} right The second Cartesian.
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The modified result parameter or a new Cartesian4 instance if none was provided.
     *
     * @exception {DeveloperError} left is required.
     * @exception {DeveloperError} right is required.
     */
    Cartesian4.multiplyComponents = function(left, right, result) {
        if (typeof left === 'undefined') {
            throw new DeveloperError('left is required');
        }
        if (typeof right === 'undefined') {
            throw new DeveloperError('right is required');
        }
        if (typeof result === 'undefined') {
            return new Cartesian4(left.x * right.x, left.y * right.y, left.z * right.z, left.w * right.w);
        }
        result.x = left.x * right.x;
        result.y = left.y * right.y;
        result.z = left.z * right.z;
        result.w = left.w * right.w;
        return result;
    };

    /**
     * Computes the componentwise sum of two Cartesians.
     * @memberof Cartesian4
     *
     * @param {Cartesian4} left The first Cartesian.
     * @param {Cartesian4} right The second Cartesian.
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The modified result parameter or a new Cartesian4 instance if none was provided.
     *
     * @exception {DeveloperError} left is required.
     * @exception {DeveloperError} right is required.
     */
    Cartesian4.add = function(left, right, result) {
        if (typeof left === 'undefined') {
            throw new DeveloperError('left is required');
        }
        if (typeof right === 'undefined') {
            throw new DeveloperError('right is required');
        }
        if (typeof result === 'undefined') {
            return new Cartesian4(left.x + right.x, left.y + right.y, left.z + right.z, left.w + right.w);
        }
        result.x = left.x + right.x;
        result.y = left.y + right.y;
        result.z = left.z + right.z;
        result.w = left.w + right.w;
        return result;
    };

    /**
     * Computes the componentwise difference of two Cartesians.
     * @memberof Cartesian4
     *
     * @param {Cartesian4} left The first Cartesian.
     * @param {Cartesian4} right The second Cartesian.
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The modified result parameter or a new Cartesian4 instance if none was provided.
     *
     * @exception {DeveloperError} left is required.
     * @exception {DeveloperError} right is required.
     */
    Cartesian4.subtract = function(left, right, result) {
        if (typeof left === 'undefined') {
            throw new DeveloperError('left is required');
        }
        if (typeof right === 'undefined') {
            throw new DeveloperError('right is required');
        }
        if (typeof result === 'undefined') {
            return new Cartesian4(left.x - right.x, left.y - right.y, left.z - right.z, left.w - right.w);
        }
        result.x = left.x - right.x;
        result.y = left.y - right.y;
        result.z = left.z - right.z;
        result.w = left.w - right.w;
        return result;
    };

    /**
     * Multiplies the provided Cartesian componentwise by the provided scalar.
     * @memberof Cartesian4
     *
     * @param {Cartesian4} cartesian The Cartesian to be scaled.
     * @param {Number} scalar The scalar to multiply with.
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The modified result parameter or a new Cartesian4 instance if none was provided.
     *
     * @exception {DeveloperError} cartesian is required.
     * @exception {DeveloperError} scalar is required and must be a number.
     */
    Cartesian4.multiplyByScalar = function(cartesian, scalar, result) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        if (typeof scalar !== 'number') {
            throw new DeveloperError('scalar is required and must be a number.');
        }
        if (typeof result === 'undefined') {
            return new Cartesian4(cartesian.x * scalar,  cartesian.y * scalar, cartesian.z * scalar, cartesian.w * scalar);
        }
        result.x = cartesian.x * scalar;
        result.y = cartesian.y * scalar;
        result.z = cartesian.z * scalar;
        result.w = cartesian.w * scalar;
        return result;
    };

    /**
     * Divides the provided Cartesian componentwise by the provided scalar.
     * @memberof Cartesian4
     *
     * @param {Cartesian4} cartesian The Cartesian to be divided.
     * @param {Number} scalar The scalar to divide by.
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The modified result parameter or a new Cartesian4 instance if none was provided.
     *
     * @exception {DeveloperError} cartesian is required.
     * @exception {DeveloperError} scalar is required and must be a number.
     */
    Cartesian4.divideByScalar = function(cartesian, scalar, result) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        if (typeof scalar !== 'number') {
            throw new DeveloperError('scalar is required and must be a number.');
        }
        if (typeof result === 'undefined') {
            return new Cartesian4(cartesian.x / scalar, cartesian.y / scalar, cartesian.z / scalar, cartesian.w / scalar);
        }
        result.x = cartesian.x / scalar;
        result.y = cartesian.y / scalar;
        result.z = cartesian.z / scalar;
        result.w = cartesian.w / scalar;
        return result;
    };

    /**
     * Negates the provided Cartesian.
     * @memberof Cartesian4
     *
     * @param {Cartesian4} cartesian The Cartesian to be negated.
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The modified result parameter or a new Cartesian4 instance if none was provided.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian4.negate = function(cartesian, result) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        if (typeof result === 'undefined') {
            return new Cartesian4(-cartesian.x, -cartesian.y, -cartesian.z, -cartesian.w);
        }
        result.x = -cartesian.x;
        result.y = -cartesian.y;
        result.z = -cartesian.z;
        result.w = -cartesian.w;
        return result;
    };

    /**
     * Computes the absolute value of the provided Cartesian.
     * @memberof Cartesian4
     *
     * @param {Cartesian4} cartesian The Cartesian whose absolute value is to be computed.
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The modified result parameter or a new Cartesian4 instance if none was provided.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Cartesian4.abs = function(cartesian, result) {
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        if (typeof result === 'undefined') {
            return new Cartesian4(Math.abs(cartesian.x), Math.abs(cartesian.y), Math.abs(cartesian.z), Math.abs(cartesian.w));
        }
        result.x = Math.abs(cartesian.x);
        result.y = Math.abs(cartesian.y);
        result.z = Math.abs(cartesian.z);
        result.w = Math.abs(cartesian.w);
        return result;
    };

    var lerpScratch = new Cartesian4();
    /**
     * Computes the linear interpolation or extrapolation at t using the provided cartesians.
     * @memberof Cartesian4
     *
     * @param start The value corresponding to t at 0.0.
     * @param end The value corresponding to t at 1.0.
     * @param t The point along t at which to interpolate.
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The modified result parameter or a new Cartesian4 instance if none was provided.
     *
     * @exception {DeveloperError} start is required.
     * @exception {DeveloperError} end is required.
     * @exception {DeveloperError} t is required and must be a number.
     */
    Cartesian4.lerp = function(start, end, t, result) {
        if (typeof start === 'undefined') {
            throw new DeveloperError('start is required.');
        }
        if (typeof end === 'undefined') {
            throw new DeveloperError('end is required.');
        }
        if (typeof t !== 'number') {
            throw new DeveloperError('t is required and must be a number.');
        }
        Cartesian4.multiplyByScalar(end, t, lerpScratch);
        result = Cartesian4.multiplyByScalar(start, 1.0 - t, result);
        return Cartesian4.add(lerpScratch, result, result);
    };

    /**
     * Compares the provided Cartesians componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @memberof Cartesian4
     *
     * @param {Cartesian4} [left] The first Cartesian.
     * @param {Cartesian4} [right] The second Cartesian.
     * @return {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    Cartesian4.equals = function(left, right) {
        return (left === right) ||
               ((typeof left !== 'undefined') &&
                (typeof right !== 'undefined') &&
                (left.x === right.x) &&
                (left.y === right.y) &&
                (left.z === right.z) &&
                (left.w === right.w));
    };

    /**
     * Compares the provided Cartesians componentwise and returns
     * <code>true</code> if they are within the provided epsilon,
     * <code>false</code> otherwise.
     * @memberof Cartesian4
     *
     * @param {Cartesian4} [left] The first Cartesian.
     * @param {Cartesian4} [right] The second Cartesian.
     * @param {Number} epsilon The epsilon to use for equality testing.
     * @return {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
     *
     * @exception {DeveloperError} epsilon is required and must be a number.
     */
    Cartesian4.equalsEpsilon = function(left, right, epsilon) {
        if (typeof epsilon !== 'number') {
            throw new DeveloperError('epsilon is required and must be a number.');
        }
        return (left === right) ||
               ((typeof left !== 'undefined') &&
                (typeof right !== 'undefined') &&
                (Math.abs(left.x - right.x) <= epsilon) &&
                (Math.abs(left.y - right.y) <= epsilon) &&
                (Math.abs(left.z - right.z) <= epsilon) &&
                (Math.abs(left.w - right.w) <= epsilon));
    };

    /**
     * An immutable Cartesian4 instance initialized to (0.0, 0.0, 0.0, 0.0).
     * @memberof Cartesian4
     */
    Cartesian4.ZERO = Object.freeze(new Cartesian4(0.0, 0.0, 0.0, 0.0));

    /**
     * An immutable Cartesian4 instance initialized to (1.0, 0.0, 0.0, 0.0).
     * @memberof Cartesian4
     */
    Cartesian4.UNIT_X = Object.freeze(new Cartesian4(1.0, 0.0, 0.0, 0.0));

    /**
     * An immutable Cartesian4 instance initialized to (0.0, 1.0, 0.0, 0.0).
     * @memberof Cartesian4
     */
    Cartesian4.UNIT_Y = Object.freeze(new Cartesian4(0.0, 1.0, 0.0, 0.0));

    /**
     * An immutable Cartesian4 instance initialized to (0.0, 0.0, 1.0, 0.0).
     * @memberof Cartesian4
     */
    Cartesian4.UNIT_Z = Object.freeze(new Cartesian4(0.0, 0.0, 1.0, 0.0));

    /**
     * An immutable Cartesian4 instance initialized to (0.0, 0.0, 0.0, 1.0).
     * @memberof Cartesian4
     */
    Cartesian4.UNIT_W = Object.freeze(new Cartesian4(0.0, 0.0, 0.0, 1.0));

    /**
     * Computes the value of the maximum component for this Cartesian.
     * @memberof Cartesian4
     *
     * @return {Number} The value of the maximum component.
     */
    Cartesian4.prototype.getMaximumComponent = function() {
        return Cartesian4.getMaximumComponent(this);
    };

    /**
     * Computes the value of the minimum component for this Cartesian.
     * @memberof Cartesian4
     *
     * @return {Number} The value of the minimum component.
     */
    Cartesian4.prototype.getMinimumComponent = function() {
        return Cartesian4.getMinimumComponent(this);
    };

    /**
     * Duplicates this Cartesian4 instance.
     * @memberof Cartesian4
     *
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The modified result parameter or a new Cartesian4 instance if none was provided.
     */
    Cartesian4.prototype.clone = function(result) {
        return Cartesian4.clone(this, result);
    };

    /**
     * Computes this Cartesian's squared magnitude.
     * @memberof Cartesian4
     *
     * @return {Number} The squared magnitude.
     */
    Cartesian4.prototype.magnitudeSquared = function() {
        return Cartesian4.magnitudeSquared(this);
    };

    /**
     * Computes this Cartesian's magnitude (length).
     * @memberof Cartesian4
     *
     * @return {Number} The magnitude.
     */
    Cartesian4.prototype.magnitude = function() {
        return Cartesian4.magnitude(this);
    };

    /**
     * Computes the normalized form of this Cartesian.
     * @memberof Cartesian4
     *
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The modified result parameter or a new Cartesian4 instance if none was provided.
     */
    Cartesian4.prototype.normalize = function(result) {
        return Cartesian4.normalize(this, result);
    };

    /**
     * Computes the dot (scalar) product of this Cartesian and a supplied cartesian.
     * @memberof Cartesian4
     *
     * @param {Cartesian4} right The right hand side Cartesian.
     * @return {Number} The dot product.
     *
     * @exception {DeveloperError} right is required.
     */
    Cartesian4.prototype.dot = function(right) {
        return Cartesian4.dot(this, right);
    };

    /**
     * Computes the componentwise product of this Cartesian and the provided Cartesian.
     * @memberof Cartesian4
     *
     * @param {Cartesian4} right The right hand side Cartesian.
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The modified result parameter or a new Cartesian4 instance if none was provided.
     *
     * @exception {DeveloperError} right is required.
     */
    Cartesian4.prototype.multiplyComponents = function(right, result) {
        return Cartesian4.multiplyComponents(this, right, result);
    };

    /**
     * Computes the componentwise sum of this Cartesian and the provided Cartesian.
     * @memberof Cartesian4
     *
     * @param {Cartesian4} right The right hand side Cartesian.
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The modified result parameter or a new Cartesian4 instance if none was provided.
     *
     * @exception {DeveloperError} right is required.
     */
    Cartesian4.prototype.add = function(right, result) {
        return Cartesian4.add(this, right, result);
    };

    /**
     * Computes the componentwise difference of this Cartesian and the provided Cartesian.
     * @memberof Cartesian4
     *
     * @param {Cartesian4} right The right hand side Cartesian.
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The modified result parameter or a new Cartesian4 instance if none was provided.
     *
     * @exception {DeveloperError} right is required.
     */
    Cartesian4.prototype.subtract = function(right, result) {
        return Cartesian4.subtract(this, right, result);
    };

    /**
     * Multiplies this Cartesian componentwise by the provided scalar.
     * @memberof Cartesian4
     *
     * @param {Number} scalar The scalar to multiply with.
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The modified result parameter or a new Cartesian4 instance if none was provided.
     *
     * @exception {DeveloperError} scalar is required and must be a number.
     */
    Cartesian4.prototype.multiplyByScalar = function(scalar, result) {
        return Cartesian4.multiplyByScalar(this, scalar, result);
    };

    /**
     * Divides this Cartesian componentwise by the provided scalar.
     * @memberof Cartesian4
     *
     * @param {Number} scalar The scalar to divide by.
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The modified result parameter or a new Cartesian4 instance if none was provided.
     *
     * @exception {DeveloperError} scalar is required and must be a number.
     */
    Cartesian4.prototype.divideByScalar = function(scalar, result) {
        return Cartesian4.divideByScalar(this, scalar, result);
    };

    /**
     * Negates this Cartesian.
     * @memberof Cartesian4
     *
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The modified result parameter or a new Cartesian4 instance if none was provided.
     */
    Cartesian4.prototype.negate = function(result) {
        return Cartesian4.negate(this, result);
    };

    /**
     * Computes the absolute value of this Cartesian.
     * @memberof Cartesian4
     *
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The modified result parameter or a new Cartesian4 instance if none was provided.
     */
    Cartesian4.prototype.abs = function(result) {
        return Cartesian4.abs(this, result);
    };

    /**
     * Computes the linear interpolation or extrapolation at t using this Cartesian
     * and the provided cartesian.  This cartesian is assumed to be t at 0.0.
     * @memberof Cartesian4
     *
     * @param end The value corresponding to t at 1.0.
     * @param t The point along t at which to interpolate.
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The modified result parameter or a new Cartesian4 instance if none was provided.
     *
     * @exception {DeveloperError} end is required.
     * @exception {DeveloperError} t is required and must be a number.
     */
    Cartesian4.prototype.lerp = function(end, t, result) {
        return Cartesian4.lerp(this, end, t, result);
    };

    /**
     * Compares this Cartesian against the provided Cartesian componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @memberof Cartesian4
     *
     * @param {Cartesian4} [right] The right hand side Cartesian.
     * @return {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
     */
    Cartesian4.prototype.equals = function(right) {
        return Cartesian4.equals(this, right);
    };

    /**
     * Compares this Cartesian against the provided Cartesian componentwise and returns
     * <code>true</code> if they are within the provided epsilon,
     * <code>false</code> otherwise.
     * @memberof Cartesian4
     *
     * @param {Cartesian4} [right] The right hand side Cartesian.
     * @param {Number} epsilon The epsilon to use for equality testing.
     * @return {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
     *
     * @exception {DeveloperError} epsilon is required and must be a number.
     */
    Cartesian4.prototype.equalsEpsilon = function(right, epsilon) {
        return Cartesian4.equalsEpsilon(this, right, epsilon);
    };

    /**
     * Creates a string representing this Cartesian in the format '(x, y)'.
     * @memberof Cartesian4
     *
     * @return {String} A string representing the provided Cartesian in the format '(x, y)'.
     */
    Cartesian4.prototype.toString = function() {
        return '(' + this.x + ', ' + this.y + ', ' + this.z + ', ' + this.w + ')';
    };

    return Cartesian4;
});

/*global define*/
define('Core/Enumeration',[],function() {
    

    /**
     * Constructs an enumeration that contains both a numeric value and a name.
     * This is used so the name of the enumeration is available in the debugger.
     *
     * @param {Number} [value=undefined] The numeric value of the enumeration.
     * @param {String} [name=undefined] The name of the enumeration for debugging purposes.
     * @param {Object} [properties=undefined] An object containing extra properties to be added to the enumeration.
     *
     * @alias Enumeration
     * @constructor
     * @example
     * // Create an object with two enumerations.
     * var filter = {
     *     NEAREST : new Enumeration(0x2600, 'NEAREST'),
     *     LINEAR : new Enumeration(0x2601, 'LINEAR')
     * };
     */
    var Enumeration = function(value, name, properties) {
        /**
         * The numeric value of the enumeration.
         * @type Number
         */
        this.value = value;

        /**
         * The name of the enumeration for debugging purposes.
         * @type String
         */
        this.name = name;

        if (typeof properties !== 'undefined') {
            for ( var propertyName in properties) {
                if (properties.hasOwnProperty(propertyName)) {
                    this[propertyName] = properties[propertyName];
                }
            }
        }
    };

    /**
     * Returns the numeric value of the enumeration.
     *
     * @memberof Enumeration
     *
     * @return {Number} The numeric value of the enumeration.
     */
    Enumeration.prototype.valueOf = function() {
        return this.value;
    };

    /**
     * Returns the name of the enumeration for debugging purposes.
     *
     * @memberof Enumeration
     *
     * @return {String} The name of the enumeration for debugging purposes.
     */
    Enumeration.prototype.toString = function() {
        return this.name;
    };

    return Enumeration;
});
/*global define*/
define('Core/ClockRange',[
        './Enumeration'
       ], function(
         Enumeration) {
    

    /**
     * Constants used by {@link Clock#tick} to determine behavior
     * when {@link Clock#startTime} or {@link Clock#stopTime} is reached.
     *
     * @exports ClockRange
     *
     * @see Clock
     * @see ClockStep
     */
    var ClockRange = {
        /**
         * {@link Clock#tick} will always advances the clock in its current direction.
         */
        UNBOUNDED : new Enumeration(0, 'UNBOUNDED'),

        /**
         * When {@link Clock#startTime} or {@link Clock#stopTime} is reached,
         * {@link Clock#tick} will not advance {@link Clock#currentTime} any further.
         */
        CLAMPED : new Enumeration(1, 'CLAMPED'),

        /**
         * When {@link Clock#startTime} or {@link Clock#stopTime} is reached,
         * {@link Clock#tick} will advance {@link Clock#currentTime} to the opposite end of the interval.
         */
        LOOP : new Enumeration(1, 'LOOP')
    };

    return ClockRange;
});

/*global define*/
define('Core/ClockStep',[
        './Enumeration'
       ], function(
         Enumeration) {
    

    /**
     * Constants to determine how much time advances with each call
     * to {@link Clock#tick}.
     *
     * @exports ClockStep
     *
     * @see Clock
     * @see ClockRange
     */
    var ClockStep = {
        /**
         * {@link Clock#tick} advances the current time by a fixed step,
         * which is the number of seconds specified by {@link Clock#multiplier}.
         */
        TICK_DEPENDENT : new Enumeration(0, 'TICK_DEPENDENT'),

        /**
         * {@link Clock#tick} advances the current time by the amount of system
         * time elapsed since the previous call multiplied by {@link Clock#multiplier}.
         */
        SYSTEM_CLOCK_DEPENDENT : new Enumeration(1, 'SYSTEM_CLOCK_DEPENDENT')
    };

    return ClockStep;
});

/*global define*/
define('Core/ComponentDatatype',['./Enumeration'], function(Enumeration) {
    

    // Earlier versions of IE do not support typed arrays, and as a result,
    // using them below will cause the setup function itself to fail, causing
    // the page to abort load, and preventing us from prompting to install
    // Chrome Frame.  To avoid this, bail out early and return a dummy object,
    // since we won't be able to create a WebGL context anyway.
    if (typeof Int8Array === 'undefined') {
        return {};
    }

    /**
     * DOC_TBA
     *
     * @alias ComponentDatatype
     * @enumeration
     */
    var ComponentDatatype = {};

    /**
     * DOC_TBA
     *
     * @constant
     * @type {Enumeration}
     * @memberOf ComponentDatatype
     */
    ComponentDatatype.BYTE = new Enumeration(0x1400, 'BYTE');
    ComponentDatatype.BYTE.sizeInBytes = Int8Array.BYTES_PER_ELEMENT;
    ComponentDatatype.BYTE.toTypedArray = function(values) {
        return new Int8Array(values);
    };

    ComponentDatatype.BYTE.createArrayBufferView = function(buffer, byteOffset) {
        return new Int8Array(buffer, byteOffset);
    };

    /**
     * DOC_TBA
     *
     * @constant
     * @type {Enumeration}
     * @memberOf ComponentDatatype
     */
    ComponentDatatype.UNSIGNED_BYTE = new Enumeration(0x1401, 'UNSIGNED_BYTE');
    ComponentDatatype.UNSIGNED_BYTE.sizeInBytes = Uint8Array.BYTES_PER_ELEMENT;
    ComponentDatatype.UNSIGNED_BYTE.toTypedArray = function(values) {
        return new Uint8Array(values);
    };

    ComponentDatatype.UNSIGNED_BYTE.createArrayBufferView = function(buffer, byteOffset) {
        return new Uint8Array(buffer, byteOffset);
    };

    /**
     * DOC_TBA
     *
     * @constant
     * @type {Enumeration}
     * @memberOf ComponentDatatype
     */
    ComponentDatatype.SHORT = new Enumeration(0x1402, 'SHORT');
    ComponentDatatype.SHORT.sizeInBytes = Int16Array.BYTES_PER_ELEMENT;
    ComponentDatatype.SHORT.toTypedArray = function(values) {
        return new Int16Array(values);
    };

    ComponentDatatype.SHORT.createArrayBufferView = function(buffer, byteOffset) {
        return new Int16Array(buffer, byteOffset);
    };

    /**
     * DOC_TBA
     *
     * @constant
     * @type {Enumeration}
     * @memberOf ComponentDatatype
     */
    ComponentDatatype.UNSIGNED_SHORT = new Enumeration(0x1403, 'UNSIGNED_SHORT');
    ComponentDatatype.UNSIGNED_SHORT.sizeInBytes = Uint16Array.BYTES_PER_ELEMENT;
    ComponentDatatype.UNSIGNED_SHORT.toTypedArray = function(values) {
        return new Uint16Array(values);
    };

    ComponentDatatype.UNSIGNED_SHORT.createArrayBufferView = function(buffer, byteOffset) {
        return new Uint16Array(buffer, byteOffset);
    };

    /**
     * DOC_TBA
     *
     * @constant
     * @type {Enumeration}
     * @memberOf ComponentDatatype
     */
    ComponentDatatype.FLOAT = new Enumeration(0x1406, 'FLOAT');
    ComponentDatatype.FLOAT.sizeInBytes = Float32Array.BYTES_PER_ELEMENT;
    ComponentDatatype.FLOAT.toTypedArray = function(values) {
        return new Float32Array(values);
    };

    ComponentDatatype.FLOAT.createArrayBufferView = function(buffer, byteOffset) {
        return new Float32Array(buffer, byteOffset);
    };

    /**
     * DOC_TBA
     */
    ComponentDatatype.validate = function(componentDatatype) {
        return ((componentDatatype === ComponentDatatype.BYTE) ||
                (componentDatatype === ComponentDatatype.UNSIGNED_BYTE) ||
                (componentDatatype === ComponentDatatype.SHORT) ||
                (componentDatatype === ComponentDatatype.UNSIGNED_SHORT) ||
                (componentDatatype === ComponentDatatype.FLOAT));
    };

    return ComponentDatatype;
});

/*global define*/
define('Core/Event',[
        './DeveloperError'
       ], function(
         DeveloperError) {
    

    /**
     * A generic utility class for managing subscribers for a particular event.
     * This class is usually instantiated inside of a container class and
     * exposed as a property for others to subscribe to.
     *
     * @alias Event
     * @constructor
     *
     * @example
     * MyObject.prototype.myListener = function(arg1, arg2) {
     *     this.myArg1Copy = arg1;
     *     this.myArg2Copy = arg2;
     * }
     *
     * var myObjectInstance = new MyObject();
     * var evt = new Event();
     * evt.addEventListener(MyObject.prototype.myListener, myObjectInstance);
     * evt.raiseEvent('1', '2');
     * evt.removeEventListener(MyObject.prototype.myListener);
     */
    var Event = function() {
        this._listeners = [];
        this._scopes = [];
    };

    /**
     * Registers a callback function to be executed whenever the event is raised.
     * An optional scope can be provided to serve as the <code>this</code> pointer
     * in which the function will execute.
     * @memberof Event
     *
     * @param {Function} listener The function to be executed when the event is raised.
     * @param {Object} [scope] An optional object scope to serve as the <code>this</code>
     * pointer in which the listener function will execute.
     *
     * @see Event#raiseEvent
     * @see Event#removeEventListener
     *
     * @exception {DeveloperError} listener is required and must be a function.
     * @exception {DeveloperError} listener is already subscribed.
     */
    Event.prototype.addEventListener = function(listener, scope) {
        if (typeof listener !== 'function') {
            throw new DeveloperError('listener is required and must be a function.');
        }

        var thisListeners = this._listeners;
        var index = thisListeners.indexOf(listener);

        if (index !== -1) {
            throw new DeveloperError('listener is already subscribed.');
        }

        thisListeners.push(listener);
        this._scopes.push(scope);
    };

    /**
     * Unregisters a previously registered callback.
     * @memberof Event
     *
     * @param {Function} listener The function to be unregistered.
     *
     * @see Event#addEventListener
     * @see Event#raiseEvent
     *
     * @exception {DeveloperError} listener is required and must be a function.
     * @exception {DeveloperError} listener is not subscribed.
     */
    Event.prototype.removeEventListener = function(listener) {
        if (typeof listener !== 'function') {
            throw new DeveloperError('listener is required and must be a function.');
        }

        var thisListeners = this._listeners;
        var index = thisListeners.indexOf(listener);

        if (index === -1) {
            throw new DeveloperError('listener is not subscribed.');
        }

        thisListeners.splice(index, 1);
        this._scopes.splice(index, 1);
    };

    /**
     * Raises the event by calling each registered listener with all supplied arguments.
     * @memberof Event
     *
     * @param {*} arguments This method takes any number of parameters and passes them through to the listener functions.
     *
     * @see Event#addEventListener
     * @see Event#removeEventListener
     */
    Event.prototype.raiseEvent = function() {
        var listeners = this._listeners;
        var scopes = this._scopes;
        for ( var i = listeners.length - 1; i > -1; i--) {
            listeners[i].apply(scopes[i], arguments);
        }
    };

    return Event;
});
/*global define*/
define('Core/EventModifier',['./Enumeration'], function(Enumeration) {
    

    /**
     * This enumerated type is for representing keyboard modifiers. These are keys
     * that are held down in addition to other event types.
     *
     * @exports EventModifier
     */
    var EventModifier = {
        /**
         * Represents the shift key being held down.
         *
         * @constant
         * @type {Enumeration}
         */
        SHIFT : new Enumeration(0, 'SHIFT'),

        /**
         * Represents the control key being held down.
         *
         * @constant
         * @type {Enumeration}
         */
        CTRL : new Enumeration(1, 'CTRL'),

        /**
         * Represents the alt key being held down.
         *
         * @constant
         * @type {Enumeration}
         */
        ALT : new Enumeration(2, 'ALT')
    };

    return EventModifier;
});
/*global define*/
define('Core/FAR',[],function() {
    

    /**
     * Distance from the Sun to Pluto in meters.
     *
     * @exports FAR
     */
    var FAR = 5906376272000.0;

    return FAR;
});
/*global define*/
define('Core/FullScreen',[
        './DeveloperError'
    ],function(
        DeveloperError) {
    
    var _prefix, _supportsFullScreen;

    /**
     * Encapsulates browser dependent methods for working with the
     * full screen standard.
     *
     * @exports FullScreen
     *
     * @see <a href='http://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html'>W3C Fullscreen Living Specification</a>
     */
    var FullScreen = {
        /**
         * Detects whether the browser supports the full screen standard.
         *
         * @returns <code>true</code> if the supports the full screen standard, <code>false</code> if otherwise.
         */
        supportsFullScreen : function() {
            if (typeof _supportsFullScreen === 'undefined') {
                _supportsFullScreen = false;
                // check for native support
                if (typeof document.exitFullscreen !== 'undefined') {
                    _supportsFullScreen = true;
                    _prefix = '';
                } else {
                    // check for full screen support by vendor prefix
                    var prefixes = ['webkit', 'moz', 'o', 'ms', 'khtml'];
                    for ( var i = 0; i < prefixes.length; i++) {
                        _prefix = prefixes[i];

                        if (typeof document[_prefix + 'CancelFullScreen'] !== 'undefined') {
                            _supportsFullScreen = true;
                            break;
                        }
                    }
                }
            }
            return _supportsFullScreen;
        },

        /**
         * Gets the name of the event that is fired when full screen is entered or exited or <code>undefined</code> if full screen is not supported.
         *
         * @returns the name of the event that is fired when full screen is entered or exited or <code>undefined</code> if full screen is not supported.
         */
        getFullScreenChangeEventName : function() {
            return FullScreen.supportsFullScreen() ? 'on' + _prefix + 'fullscreenchange' : undefined;
        },

        /**
         * Gets the name of the event that is fired when a full screen error occurs or <code>undefined</code> if full screen is not supported.
         *
         * @returns the name of the event that is fired when a full screen error occurs or <code>undefined</code> if full screen is not supported.
         */
        getFullScreenErrorEventName : function() {
            return FullScreen.supportsFullScreen() ? 'on' + _prefix + 'fullscreenerror' : undefined;
        },

        /**
         * Detects whether the browser is currently in full screen mode.
         *
         * @returns <code>true</code> if the browser is in full screen mode, <code>false</code> if not, and <code>undefined</code> if the browser does not support full screen mode.
         */
        isFullscreenEnabled : function() {
            if (FullScreen.supportsFullScreen()) {
                switch (_prefix) {
                case '':
                    return document.fullscreenEnabled;
                case 'webkit':
                    return document.webkitIsFullScreen;
                default:
                    return document[_prefix + 'FullScreen'];
                }
            }
            return undefined;
        },

        /**
         * Queues a request for full screen mode if the browser is currently not in full screen, does nothing otherwise.
         * @param {Object} element The HTML element which will be placed into full-screen.
         *
         * @example
         * // Put the entire page into full screen.
         * FullScreen.requestFullScreen(document.body)
         *
         * // Place only the Cesium canvas into full screen.
         * FullScreen.requestFullScreen(scene.getCanvas())
         */
        requestFullScreen : function(element) {
            if (FullScreen.supportsFullScreen()) {
                return (_prefix === '') ? element.requestFullScreen() : element[_prefix + 'RequestFullScreen']();
            }
        },

        /**
         * Exits full screen mode if the browser is currently in full screen, does nothing otherwise.
         */
        exitFullscreen : function() {
            if (FullScreen.supportsFullScreen()) {
                return (_prefix === '') ? document.exitFullscreen() : document[_prefix + 'CancelFullScreen']();
            }
        }
    };

    return FullScreen;
});
/*global define*/
define('Core/FeatureDetection',[
        './FullScreen'
    ], function(
        FullScreen) {
    

    /**
     * A set of functions to detect whether the current browser supports
     * various features.
     *
     * @exports FeatureDetection
     */
    var FeatureDetection = {};

    function extractVersion(versionString) {
        return versionString.split('.').map(function(v) {
            return parseInt(v, 10);
        });
    }

    var _isChrome;
    var _chromeVersion;
    function isChrome() {
        if (typeof _isChrome === 'undefined') {
            var fields = (/ Chrome\/([\.0-9]+)/).exec(navigator.userAgent);
            if (!fields) {
                return (_isChrome = false);
            }

            _isChrome = true;
            _chromeVersion = extractVersion(fields[1]);
        }

        return _isChrome;
    }

    function chromeVersion() {
        return isChrome() && _chromeVersion;
    }

    var _isSafari;
    var _safariVersion;
    function isSafari() {
        if (typeof _isSafari === 'undefined') {
            // Chrome contains Safari in the user agent too
            if (isChrome() || !(/ Safari\/[\.0-9]+/).test(navigator.userAgent)) {
                return (_isSafari = false);
            }

            var fields = (/ Version\/([\.0-9]+)/).exec(navigator.userAgent);
            if (!fields) {
                return (_isSafari = false);
            }

            _isSafari = true;
            _safariVersion = extractVersion(fields[1]);
        }

        return _isSafari;
    }

    function safariVersion() {
        return isSafari() && _safariVersion;
    }

    var _isWebkit;
    var _webkitVersion;
    function isWebkit() {
        if (typeof _isWebkit === 'undefined') {
            var fields = (/ AppleWebKit\/([\.0-9]+)(\+?)/).exec(navigator.userAgent);
            if (!fields) {
                return (_isWebkit = false);
            }

            _isWebkit = true;
            _webkitVersion = extractVersion(fields[1]);
            _webkitVersion.isNightly = !!fields[2];
        }

        return _isWebkit;
    }

    function webkitVersion() {
        return isWebkit() && _webkitVersion;
    }

    var _supportsCrossOriginImagery;

    /**
     * Detects whether the current browser supports the use of cross-origin
     * requests to load streaming imagery.
     *
     * @returns true if the browser can load cross-origin streaming imagery, false if not.
     *
     * @see <a href='http://www.w3.org/TR/cors/'>Cross-Origin Resource Sharing</a>
     */
    FeatureDetection.supportsCrossOriginImagery = function() {
        if (typeof _supportsCrossOriginImagery === 'undefined') {
            if (isSafari() && webkitVersion()[0] < 536) {
                // versions of Safari below this incorrectly throw a DOM error when calling
                // readPixels on a canvas containing a cross-origin image.
                _supportsCrossOriginImagery = false;
            } else {
                // any other versions of browsers that incorrectly block
                // readPixels on canvas containing crossOrigin images?
                _supportsCrossOriginImagery = 'withCredentials' in new XMLHttpRequest();
            }
        }
        return _supportsCrossOriginImagery;
    };

    /**
     * Detects whether the current browser supports the full screen standard.
     *
     * @returns true if the supports the full screen standard, false if not.
     *
     * @see FullScreen
     * @see <a href='http://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html'>W3C Fullscreen Living Specification</a>
     */
    FeatureDetection.supportsFullScreen = function() {
        return FullScreen.supportsFullScreen();
    };

    return FeatureDetection;
});
/*global define*/
define('Core/IndexDatatype',['./Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports IndexDatatype
     */
    var IndexDatatype = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        UNSIGNED_BYTE : new Enumeration(0x1401, 'UNSIGNED_BYTE'),
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        UNSIGNED_SHORT : new Enumeration(0x1403, 'UNSIGNED_SHORT')
    };

    return IndexDatatype;
});

/*global define*/
define('Core/Intersect',['./Enumeration'], function(Enumeration) {
    

    /**
     * This enumerated type is used in determining where, relative to the frustum, an
     * object is located. The object can either be fully contained within the frustum (INSIDE),
     * partially inside the frustum and partially outside (INTERSECTING), or somwhere entirely
     * outside of the frustum's 6 planes (OUTSIDE).
     *
     * @exports Intersect
     */
    var Intersect = {
        /**
         * Represents that an object is not contained within the frustum.
         *
         * @constant
         * @type {Enumeration}
         */
        OUTSIDE : new Enumeration(-1, 'OUTSIDE'),

        /**
         * Represents that an object intersects one of the frustum's planes.
         *
         * @constant
         * @type {Enumeration}
         */
        INTERSECTING : new Enumeration(0, 'INTERSECTING'),

        /**
         * Represents that an object is fully within the frustum.
         *
         * @constant
         * @type {Enumeration}
         */
        INSIDE : new Enumeration(1, 'INSIDE')
    };

    return Intersect;
});

/*global define*/
define('Core/AxisAlignedBoundingBox',[
        './DeveloperError',
        './Cartesian3',
        './Intersect'
    ], function(
        DeveloperError,
        Cartesian3,
        Intersect) {
    

    /**
     * Creates an instance of an AxisAlignedBoundingBox. The box is determined by finding the points spaced the
     * furthest apart on the x-, y-, and z-axes.
     *
     * @alias AxisAlignedBoundingBox
     *
     * @param {Array} positions List of points that the bounding box will enclose.  Each point must have a <code>x</code>, <code>y</code>, and <code>z</code> properties.
     *
     * @exception {DeveloperError} <code>positions</code> is required.
     *
     * @constructor
     * @immutable
     *
     * @example
     * // Compute an axis aligned bounding box enclosing two points.
     * var box = new AxisAlignedBoundingBox(
     *     [new Cartesian3(2, 0, 0), new Cartesian3(-2, 0, 0)]);
     */
    var AxisAlignedBoundingBox = function(positions) {
        if (!positions) {
            throw new DeveloperError('positions is required.');
        }

        var length = positions.length;
        if (length !== 0) {
            var minimumX = positions[0].x;
            var minimumY = positions[0].y;
            var minimumZ = positions[0].z;

            var maximumX = positions[0].x;
            var maximumY = positions[0].y;
            var maximumZ = positions[0].z;

            for ( var i = 1; i < length; i++) {
                var p = positions[i];
                var x = p.x;
                var y = p.y;
                var z = p.z;

                if (x < minimumX) {
                    minimumX = x;
                }

                if (x > maximumX) {
                    maximumX = x;
                }

                if (y < minimumY) {
                    minimumY = y;
                }

                if (y > maximumY) {
                    maximumY = y;
                }

                if (z < minimumZ) {
                    minimumZ = z;
                }

                if (z > maximumZ) {
                    maximumZ = z;
                }
            }

            var min = new Cartesian3(minimumX, minimumY, minimumZ);
            var max = new Cartesian3(maximumX, maximumY, maximumZ);

            /**
             * The minimum point defining the bounding box.
             *
             * @type {Cartesian3}
             */
            this.minimum = min;

            /**
             * The maximum point defining the bounding box.
             *
             * @type {Cartesian3}
             */
            this.maximum = max;

            /**
             * The center point of the bounding box.
             *
             * @type {Cartesian3}
             */
            this.center = (min.add(max)).multiplyByScalar(0.5);
        } else {
            this.minimum = undefined;
            this.maximum = undefined;
            this.center = undefined;
        }
    };

    /**
     * DOC_TBA
     * @memberof AxisAlignedBoundingBox
     */
    AxisAlignedBoundingBox.planeAABBIntersect = function(box, plane) {
        var max = box.maximum;
        var min = box.minimum;
        var center = max.add(min).divideByScalar(2);
        var h = max.subtract(min).divideByScalar(2); //The positive half diagonal
        var e = h.x * Math.abs(plane.x) + h.y * Math.abs(plane.y) + h.z * Math.abs(plane.z);
        var s = center.dot(plane) + plane.w; //signed distance from center
        if (s - e > 0) {
            return Intersect.INSIDE;
        }

        if (s + e < 0) {
            //Not in front because normals point inwards
            return Intersect.OUTSIDE;
        }

        return Intersect.INTERSECTING;
    };

    return AxisAlignedBoundingBox;
});

/*global define*/
define('Core/BoundingSphere',[
        './DeveloperError',
        './Cartesian3',
        './Intersect'
    ], function(
        DeveloperError,
        Cartesian3,
        Intersect) {
    

    /**
     * Computes a tight-fitting bounding sphere enclosing a list of 3D Cartesian points.
     * <br /><br />
     *
     * <p>
     * When called with a list of {Cartesian3} elements as the only argument, the bounding
     * sphere is computed by running two algorithms, a naive algorithm and Ritter's algorithm. The
     * smaller of the two spheres is used to ensure a tight fit.
     * <br />
     * When called with the first argument as a {Cartesian3} instance and the second argument as a {Number},
     * then a bounding sphere is constructed using the first point as its center and the second argument
     * as its radius.
     * </p>
     *
     * @alias BoundingSphere
     *
     * @param {Array} positions List of points that the bounding sphere will enclose.  Each point must have <code>x</code>, <code>y</code>, and <code>z</code> properties.
     * @param {Number} radius An optional parameter, only to be supplied if <code>positions</code> contains a single point.
     *
     * @exception {DeveloperError} <code>positions</code> is required.
     *
     * @see AxisAlignedBoundingBox
     * @see <a href='http://blogs.agi.com/insight3d/index.php/2008/02/04/a-bounding/'>Bounding Sphere computation article</a>
     *
     * @constructor
     * @immutable
     *
     * @example
     * // Compute a bounding sphere enclosing two points.
     * var sphere = new BoundingSphere([new Cartesian3(-2, 0, 0),
     *     new Cartesian3(2, 0, 0)]);
     * @example
     * // Compute the same bounding sphere using a center point and a radius.
     * var sphere = new BoundingSphere(new Cartesian3(0, 0, 0), 2);
     */
    var BoundingSphere = function(positions, radius) {
        if (!positions) {
            throw new DeveloperError('positions is required.');
        }

        if ((arguments.length === 2) && (typeof arguments[1] === 'number')) {
            /**
             * The center point of the sphere.
             *
             * @type {Cartesian3}
             */
            this.center = arguments[0].clone();
            /**
             * The radius of the sphere.
             *
             * @type {Number}
             */
            this.radius = arguments[1];
        } else {
            var x = positions[0].x;
            var y = positions[0].y;
            var z = positions[0].z;

            var xMin = new Cartesian3(x, y, z);
            var yMin = new Cartesian3(x, y, z);
            var zMin = new Cartesian3(x, y, z);

            var xMax = new Cartesian3(x, y, z);
            var yMax = new Cartesian3(x, y, z);
            var zMax = new Cartesian3(x, y, z);

            var currentPos;
            var numPositions = positions.length;
            for ( var i = 0; i < numPositions; i++) {
                currentPos = positions[i];
                x = currentPos.x;
                y = currentPos.y;
                z = currentPos.z;

                // Store points containing the the smallest and largest components
                if (x < xMin.x) {
                    xMin = currentPos;
                }

                if (x > xMax.x) {
                    xMax = currentPos;
                }

                if (y < yMin.y) {
                    yMin = currentPos;
                }

                if (y > yMax.y) {
                    yMax = currentPos;
                }

                if (z < zMin.z) {
                    zMin = currentPos;
                }

                if (z > zMax.z) {
                    zMax = currentPos;
                }
            }

            // Compute x-, y-, and z-spans (Squared distances b/n each component's min. and max.).
            var xSpan = (xMax.subtract(xMin)).magnitudeSquared();
            var ySpan = (yMax.subtract(yMin)).magnitudeSquared();
            var zSpan = (zMax.subtract(zMin)).magnitudeSquared();

            // Set the diameter endpoints to the largest span.
            var diameter1 = xMin;
            var diameter2 = xMax;
            var maxSpan = xSpan;
            if (ySpan > maxSpan) {
                maxSpan = ySpan;
                diameter1 = yMin;
                diameter2 = yMax;
            }
            if (zSpan > maxSpan) {
                maxSpan = zSpan;
                diameter1 = zMin;
                diameter2 = zMax;
            }

            // Calculate the center of the initial sphere found by Ritter's algorithm
            var ritterCenter = new Cartesian3(
                    (diameter1.x + diameter2.x) * 0.5,
                    (diameter1.y + diameter2.y) * 0.5,
                    (diameter1.z + diameter2.z) * 0.5);

            // Calculate the radius of the initial sphere found by Ritter's algorithm
            var radiusSquared = (diameter2.subtract(ritterCenter)).magnitudeSquared();
            var ritterRadius = Math.sqrt(radiusSquared);

            // Find the center of the sphere found using the Naive method.
            var minBoxPt = new Cartesian3(xMin.x, yMin.y, zMin.z);
            var maxBoxPt = new Cartesian3(xMax.x, yMax.y, zMax.z);
            var naiveCenter = (minBoxPt.add(maxBoxPt)).multiplyByScalar(0.5);

            // Begin 2nd pass to find naive radius and modify the ritter sphere.
            var naiveRadius = 0;
            for (i = 0; i < numPositions; i++) {
                currentPos = positions[i];

                // Find the furthest point from the naive center to calculate the naive radius.
                var r = (currentPos.subtract(naiveCenter)).magnitude();
                if (r > naiveRadius) {
                    naiveRadius = r;
                }

                // Make adjustments to the Ritter Sphere to include all points.
                var oldCenterToPointSquared = (currentPos.subtract(ritterCenter)).magnitudeSquared();
                if (oldCenterToPointSquared > radiusSquared) {
                    var oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);
                    // Calculate new radius to include the point that lies outside
                    ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;
                    radiusSquared = ritterRadius * ritterRadius;
                    // Calculate center of new Ritter sphere
                    var oldToNew = oldCenterToPoint - ritterRadius;
                    ritterCenter = new Cartesian3(
                            (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) / oldCenterToPoint,
                            (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) / oldCenterToPoint,
                            (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) / oldCenterToPoint);
                }
            }

            if (ritterRadius < naiveRadius) {
                this.center = ritterCenter;
                this.radius = ritterRadius;
            } else {
                this.center = naiveCenter;
                this.radius = naiveRadius;
            }
        }
    };

    /**
     * DOC_TBA
     * @memberof BoundingSphere
     */
    BoundingSphere.prototype.clone = function() {
        return new BoundingSphere(this.center, this.radius);
    };

    /**
     * DOC_TBA
     * @memberof BoundingSphere
     */
    BoundingSphere.planeSphereIntersect = function(sphere, plane) {
        var center = sphere.center;
        var radius = sphere.radius;
        var distanceToPlane = Cartesian3.dot(plane, center) + plane.w;

        if (distanceToPlane < -radius) {
            // The center point is OUTSIDE of the frustum
            return Intersect.OUTSIDE;
        } else if (distanceToPlane < radius) {
            // The center point is within the frustum, but radius extends beyond it; partial overlap
            return Intersect.INTERSECTING;
        }
        return Intersect.INSIDE;
    };

    return BoundingSphere;
});

/*global define*/
define('Core/LagrangePolynomialApproximation',[],function() {
    

    /**
     * Functions for performing Lagrange interpolation.
     * @exports LagrangePolynomialApproximation
     *
     * @see LinearApproximation
     * @see HermitePolynomialApproximation
     */
    var LagrangePolynomialApproximation = {
        type : 'Lagrange'
    };

    /**
     * Given the desired degree, returns the number of data points required for interpolation.
     *
     * @memberof LagrangePolynomialApproximation
     *
     * @param degree The desired degree of interpolation.
     *
     * @returns The number of required data points needed for the desired degree of interpolation.
     */
    LagrangePolynomialApproximation.getRequiredDataPoints = function(degree) {
        return Math.max(degree + 1.0, 2);
    };

    /**
     * <p>
     * Interpolates values using the supplied interpolation algorithm.  The appropriate subset of input
     * values to use for the interpolation is determined automatically from an interpolation given
     * degree.
     * </p>
     * <p>
     * The xTable array can contain any number of elements, and the appropriate subset will be
     * selected according to the degree of interpolation requested.  For example, if degree is 5,
     * the 6 elements surrounding x will be used for interpolation.  When using
     * {@link LinearApproximation} the degree should be 1 since it always deals with only 2 elements
     * surrounding x. The yTable array should contain a number of elements equal to:
     * <code>xTable.length * yStride</code>.  If insufficient elements are provided
     * to perform the requested degree of interpolation, the highest possible degree of interpolation
     * will be performed.
     * </p>
     *
     * @param {Number} x The independent variable for which the dependent variables will be interpolated.
     *
     * @param {Array} xTable The array of independent variables to use to interpolate.  The values
     * in this array must be in increasing order and the same value must not occur twice in the array.
     *
     * @param {Array} yTable The array of dependent variables to use to interpolate.  For a set of three
     * dependent values (p,q,w) and their derivatives (dp, dq, dw) at time 1 and time 2 this should be
     * as follows: {p1, q1, w1, dp1, dq1, dw1, p2, q2, w2, dp2, dq2, dw2}.
     *
     * @param {Number} yStride The number of dependent variable values in yTable corresponding to
     * each independent variable value in xTable.
     *
     * @returns An array of interpolated values.  The array contains at least yStride elements, each
     * of which is an interpolated dependent variable value.
     *
     * @see LinearApproximation
     * @see HermitePolynomialApproximation
     *
     * @memberof LagrangePolynomialApproximation
     *
     */
    LagrangePolynomialApproximation.interpolateOrderZero = function(x, xTable, yTable, yStride) {
        var i;
        var j;
        var length = xTable.length;
        var result = new Array(yStride);

        for (i = 0; i < yStride; i++) {
            result[i] = 0;
        }

        for (i = 0; i < length; i++) {
            var coefficient = 1;

            for (j = 0; j < length; j++) {
                if (j !== i) {
                    var diffX = xTable[i] - xTable[j];
                    coefficient *= (x - xTable[j]) / diffX;
                }
            }

            for (j = 0; j < yStride; j++) {
                result[j] += coefficient * yTable[i * yStride + j];
            }
        }

        return result;
    };

    return LagrangePolynomialApproximation;
});
/*global define*/
define('Core/LeapSecond',[
        './DeveloperError'
    ], function(
        DeveloperError) {
    

    /**
     * Describes a single leap second, which is constructed from a {@link JulianDate} and a
     * numerical offset representing the number of seconds TAI is ahead of the UTC time standard.
     *
     * @alias LeapSecond
     * @constructor
     *
     * @param {JulianDate} date A Julian date representing the time of the leap second.
     * @param {Number} offset The cumulative number of seconds, that TAI is ahead of UTC at provided date.
     *
     * @exception {DeveloperError} <code>date</code> is required.
     * @exception {DeveloperError} <code>offset</code> is required.
     *
     * @see JulianDate
     * @see TimeStandard
     *
     * @example
     * // Example 1. Construct a LeapSecond using a JulianDate
     * var date = new Date('January 1, 1990 00:00:00 UTC');
     * var leapSecond = new LeapSecond(JulianDate.fromDate(date), 25.0);
     * var offset = leapSecond.offset;    // 25.0
     *
     * //////////////////////////////////////////////////////////////////
     *
     * // Example 2. Construct a LeapSecond using a date string
     * var date = 'January 1, 1990 00:00:00 UTC';
     * var leapSecond = new LeapSecond(date, 25.0);
     */
    var LeapSecond = function(date, offset) {
        if (typeof date === 'undefined') {
            throw new DeveloperError('date is required.');
        }

        if (offset === null || isNaN(offset)) {
            throw new DeveloperError('offset is required and must be a number.');
        }

        /*
         * The Julian date at which this leap second occurs.
         *
         * @type {JulianDate}
         */
        this.julianDate = date;
        /*
         * The cumulative number of seconds between the UTC and TAI time standards at the time
         * of this leap second.
         *
         * @type {Number}
         */
        this.offset = offset;
    };

    /**
     * Sets the list of leap seconds used throughout Cesium.
     *
     * @memberof LeapSecond
     *
     * @param {Array} leapSeconds An array of {@link LeapSecond} objects.
     * @exception {DeveloperErrpr} leapSeconds is required and must be an array.
     *
     * @see LeapSecond.setLeapSeconds
     *
     * @example
     * LeapSecond.setleapSeconds([
     *                            new LeapSecond(new JulianDate(2453736, 43233.0, TimeStandard.TAI), 33), // January 1, 2006 00:00:00 UTC
     *                            new LeapSecond(new JulianDate(2454832, 43234.0, TimeStandard.TAI), 34), // January 1, 2009 00:00:00 UTC
     *                            new LeapSecond(new JulianDate(2456109, 43235.0, TimeStandard.TAI), 35)  // July 1, 2012 00:00:00 UTC
     *                           ]);
     */
    LeapSecond.setLeapSeconds = function(leapSeconds) {
        if (!Array.isArray(leapSeconds)) {
            throw new DeveloperError("leapSeconds is required and must be an array.");
        }
        LeapSecond._leapSeconds = leapSeconds;
        LeapSecond._leapSeconds.sort(LeapSecond.compareLeapSecondDate);
    };

    /**
     * Returns a copy of the array of leap seconds used throughout Cesium. By default, this is the
     * official list of leap seconds that was available when Cesium was released.
     *
     * @memberof LeapSecond
     *
     * @return {Array} A list of {@link LeapSecond} objects.
     *
     * @see LeapSecond.setLeapSeconds
     */
    LeapSecond.getLeapSeconds = function(leapSeconds) {
        return LeapSecond._leapSeconds;
    };

    /**
     * Checks whether two leap seconds are equivalent to each other.
     *
     * @memberof LeapSecond
     *
     * @param {LeapSecond} other The leap second to compare against.
     *
     * @return {Boolean} <code>true</code> if the leap seconds are equal; otherwise, <code>false</code>.
     *
     * @example
     * var date = new Date('January 1, 1990 00:00:00 UTC');
     * var leapSecond1 = new LeapSecond(JulianDate.fromDate(date), 25.0);
     * var leapSecond2 = new LeapSecond(JulianDate.fromDate(date), 25.0);
     * leapSecond1.equals(leapSecond2);     // true
     */
    LeapSecond.prototype.equals = function(other) {
        return this.julianDate.equals(other.julianDate) && (this.offset === other.offset);
    };

    /**
     * Given two leap seconds, determines which comes before the other by comparing
     * their respective Julian dates.
     *
     * @memberof LeapSecond
     *
     * @param {LeapSecond} leapSecond1 The first leap second to be compared.
     * @param {LeapSecond} leapSecond2 The second leap second to be compared.
     *
     * @return {Number} A negative value if the first leap second is earlier than the second,
     *                  a positive value if the first leap second is later than the second, or
     *                  zero if the two leap seconds are equal (ignoring their offsets).
     *
     * @see JulianDate#lessThan
     * @see JulianDate#isAfter
     *
     * @example
     * var date = new Date('January 1, 2006 00:00:00 UTC');
     * var leapSecond1 = new LeapSecond(JulianDate.fromDate(date), 33.0);
     * var leapSecond2 = new LeapSecond(JulianDate.fromDate(date), 34.0);
     * LeapSecond.compareLeapSecondDate(leapSecond1, leapSecond2);    // returns 0
     */
    LeapSecond.compareLeapSecondDate = function(leapSecond1, leapSecond2) {
        var julianDayNum1 = leapSecond1.julianDate.getJulianDayNumber();
        var julianDayNum2 = leapSecond2.julianDate.getJulianDayNumber();
        if (julianDayNum1 !== julianDayNum2) {
            return julianDayNum1 < julianDayNum2 ? -1 : 1;
        }
        var secondsOfDay1 = leapSecond1.julianDate.getSecondsOfDay();
        var secondsOfDay2 = leapSecond2.julianDate.getSecondsOfDay();
        if (secondsOfDay1 !== secondsOfDay2) {
            return secondsOfDay1 < secondsOfDay2 ? -1 : 1;
        }
        return 0;
    };

    LeapSecond._leapSeconds = [];

    return LeapSecond;
});
/*global define*/
define('Core/LinearApproximation',[
        './DeveloperError'
       ],function(
         DeveloperError) {
    


    /**
     * Functions for performing linear interpolation.
     * @exports LinearApproximation
     *
     * @see LagrangePolynomialApproximation
     * @see HermitePolynomialApproximation
     */
    var LinearApproximation = {
        type : 'Linear'
    };

    /**
     * Given the desired degree, returns the number of data points required for interpolation.
     *
     * @memberof LinearApproximation
     *
     * @param degree The desired degree of interpolation.
     *
     * @exception {DeveloperError} Linear interpolation can only generate a first degree polynomial.
     *
     * @returns The number of required data points needed for the desired degree of interpolation.
     */
    LinearApproximation.getRequiredDataPoints = function(degree) {
        if (degree !== 1) {
            throw new DeveloperError('Linear interpolation can only generate a first degree polynomial.');
        }
        return 2;
    };

    /**
     * <p>
     * Interpolates values using the supplied interpolation algorithm.  The appropriate subset of input
     * values to use for the interpolation is determined automatically from an interpolation given
     * degree.
     * </p>
     * <p>
     * The xTable array can contain any number of elements, and the appropriate subset will be
     * selected according to the degree of interpolation requested.  For example, if degree is 5,
     * the 6 elements surrounding x will be used for interpolation.  When using
     * {@link LinearApproximation} the degree should be 1 since it always deals with only 2 elements
     * surrounding x. The yTable array should contain a number of elements equal to:
     * <code>xTable.length * yStride</code>.  If insufficient elements are provided
     * to perform the requested degree of interpolation, the highest possible degree of interpolation
     * will be performed.
     * </p>
     *
     * @param {Number} x The independent variable for which the dependent variables will be interpolated.
     *
     * @param {Array} xTable The array of independent variables to use to interpolate.  The values
     * in this array must be in increasing order and the same value must not occur twice in the array.
     *
     * @param {Array} yTable The array of dependent variables to use to interpolate.  For a set of three
     * dependent values (p,q,w) and their derivatives (dp, dq, dw) at time 1 and time 2 this should be
     * as follows: {p1, q1, w1, dp1, dq1, dw1, p2, q2, w2, dp2, dq2, dw2}.
     *
     * @param {Number} yStride The number of dependent variable values in yTable corresponding to
     * each independent variable value in xTable.
     *
     * @returns An array of interpolated values.  The array contains at least yStride elements, each
     * of which is an interpolated dependent variable value.
     *
     * @see LagrangePolynomialApproximation
     * @see HermitePolynomialApproximation
     *
     *
     * @memberof LinearApproximation
     */
    LinearApproximation.interpolateOrderZero = function(x, xTable, yTable, yStride) {
        if (xTable.length !== 2) {
            throw new DeveloperError('The xTable provided to the linear interpolator must have exactly two elements.');
        } else if (yStride <= 0) {
            throw new DeveloperError('There must be at least 1 dependent variable for each independent variable.');
        }

        var result = new Array(yStride), x0 = xTable[0], x1 = xTable[1], i, y0, y1;

        for (i = 0; i < yStride; i++) {
            //calculates the interpolated values

            y0 = yTable[i];
            y1 = yTable[i + yStride];

            result[i] = (((y1 - y0) * x) + (x1 * y0) - (x0 * y1)) / (x1 - x0);
        }

        return result;
    };

    return LinearApproximation;
});
/*global define*/
define('Core/Math',[
        './DeveloperError'
       ], function(
         DeveloperError) {
    

    /**
     * Math functions.
     * @exports CesiumMath
     */
    var CesiumMath = {};

    /**
     * 0.1
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON1 = 0.1;

    /**
     * 0.01
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON2 = 0.01;

    /**
     * 0.001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON3 = 0.001;

    /**
     * 0.0001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON4 = 0.0001;

    /**
     * 0.00001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON5 = 0.00001;

    /**
     * 0.000001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON6 = 0.000001;

    /**
     * 0.0000001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON7 = 0.0000001;

    /**
     * 0.00000001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON8 = 0.00000001;

    /**
     * 0.000000001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON9 = 0.000000001;

    /**
     * 0.0000000001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON10 = 0.0000000001;

    /**
     * 0.00000000001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON11 = 0.00000000001;

    /**
     * 0.000000000001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON12 = 0.000000000001;

    /**
     * 0.0000000000001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON13 = 0.0000000000001;

    /**
     * 0.00000000000001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON14 = 0.00000000000001;

    /**
     * 0.000000000000001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON15 = 0.000000000000001;

    /**
     * 0.0000000000000001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON16 = 0.0000000000000001;

    /**
     * 0.00000000000000001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON17 = 0.00000000000000001;

    /**
     * 0.000000000000000001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON18 = 0.000000000000000001;

    /**
     * 0.0000000000000000001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON19 = 0.0000000000000000001;

    /**
     * 0.00000000000000000001
     * @constant
     * @type Number
     */
    CesiumMath.EPSILON20 = 0.00000000000000000001;

    /**
     * 3.986004418e14
     * @constant
     * @type Number
     */
    CesiumMath.GRAVITATIONALPARAMETER = 3.986004418e14;

    /**
     * Returns the sign of the value; 1 if the value is positive, -1 if the value is
     * negative, or 0 if the value is 0.
     *
     * @param {Number} value The value to return the sign of.
     *
     * @return {Number} The sign of value.
     */
    CesiumMath.sign = function(value) {
        if (value > 0) {
            return 1;
        } else if (value < 0) {
            return -1;
        }

        return 0;
    };

    /**
     * Returns the hyperbolic sine of a {@code Number}.
     * The hyperbolic sine of <em>value</em> is defined to be
     * (<em>e<sup>x</sup>&nbsp;-&nbsp;e<sup>-x</sup></em>)/2.0
     * where <i>e</i> is Euler's number, approximately 2.71828183.
     *
     * <p>Special cases:
     *   <ul>
     *     <li>If the argument is NaN, then the result is NaN.</li>
     *
     *     <li>If the argument is infinite, then the result is an infinity
     *     with the same sign as the argument.</li>
     *
     *     <li>If the argument is zero, then the result is a zero with the
     *     same sign as the argument.</li>
     *   </ul>
     *</p>
     *
     * @param value The number whose hyperbolic sine is to be returned.
     *
     * @return The hyperbolic sine of {@code value}.
     *
     */
    CesiumMath.sinh = function(value) {
        var part1 = Math.pow(Math.E, value);
        var part2 = Math.pow(Math.E, -1.0 * value);

        return (part1 - part2) * 0.5;
    };

    /**
     * Returns the hyperbolic cosine of a {@code Number}.
     * The hyperbolic cosine of <strong>value</strong> is defined to be
     * (<em>e<sup>x</sup>&nbsp;+&nbsp;e<sup>-x</sup></em>)/2.0
     * where <i>e</i> is Euler's number, approximately 2.71828183.
     *
     * <p>Special cases:
     *   <ul>
     *     <li>If the argument is NaN, then the result is NaN.</li>
     *
     *     <li>If the argument is infinite, then the result is positive infinity.</li>
     *
     *     <li>If the argument is zero, then the result is {@code 1.0}.</li>
     *   </ul>
     *</p>
     *
     * @param value The number whose hyperbolic cosine is to be returned.
     *
     * @return The hyperbolic cosine of {@code value}.
     */
    CesiumMath.cosh = function(value) {
        var part1 = Math.pow(Math.E, value);
        var part2 = Math.pow(Math.E, -1.0 * value);

        return (part1 + part2) * 0.5;
    };

    /**
     * DOC_TBA
     */
    CesiumMath.lerp = function(p, q, time) {
        return ((1.0 - time) * p) + (time * q);
    };

    /**
     * 1/pi
     *
     * @constant
     * @type {Number}
     * @see agi_pi
     */
    CesiumMath.PI = Math.PI;

    /**
     * 1/pi
     *
     * @constant
     * @type {Number}
     * @see agi_oneOverPi
     */
    CesiumMath.ONE_OVER_PI = 1.0 / Math.PI;

    /**
     * pi/2
     *
     * @constant
     * @type {Number}
     * @see agi_piOverTwo
     */
    CesiumMath.PI_OVER_TWO = Math.PI * 0.5;

    /**
     * pi/3
     * <br /><br />
     *
     * @constant
     * @type {Number}
     * @see agi_piOverThree
     */
    CesiumMath.PI_OVER_THREE = Math.PI / 3.0;

    /**
     * pi/4
     *
     * @constant
     * @type {Number}
     * @see agi_piOverFour
     */
    CesiumMath.PI_OVER_FOUR = Math.PI / 4.0;

    /**
     * pi/6
     *
     * @constant
     * @type {Number}
     * @see agi_piOverSix
     */
    CesiumMath.PI_OVER_SIX = Math.PI / 6.0;

    /**
     * 3pi/2
     *
     * @constant
     * @type {Number}
     * @see agi_threePiOver2
     */
    CesiumMath.THREE_PI_OVER_TWO = (3.0 * Math.PI) * 0.5;

    /**
     * 2pi
     *
     * @constant
     * @type {Number}
     * @see agi_twoPi
     */
    CesiumMath.TWO_PI = 2.0 * Math.PI;

    /**
     * 1/2pi
     *
     * @constant
     * @type {Number}
     * @see agi_oneOverTwoPi
     */
    CesiumMath.ONE_OVER_TWO_PI = 1.0 / (2.0 * Math.PI);

    /**
     * The number of radians in a degree.
     *
     * @constant
     * @type {Number}
     * @see agi_radiansPerDegree
     */
    CesiumMath.RADIANS_PER_DEGREE = Math.PI / 180.0;

    /**
     * The number of degrees in a radian.
     *
     * @constant
     * @type {Number}
     * @see agi_degreesPerRadian
     */
    CesiumMath.DEGREES_PER_RADIAN = 180.0 / Math.PI;

    /**
     * Converts degrees to radians.
     * @param {Number} degrees The angle to convert in degrees.
     * @return {Number} The corresponding angle in radians.
     */
    CesiumMath.toRadians = function(degrees) {
        return degrees * CesiumMath.RADIANS_PER_DEGREE;
    };

    /**
     * Converts radians to degrees.
     * @param {Number} radians The angle to convert in radians.
     * @return {Number} The corresponding angle in degrees.
     */
    CesiumMath.toDegrees = function(radians) {
        return radians * CesiumMath.DEGREES_PER_RADIAN;
    };

    /**
     * Converts a longitude value, in radians, to the range [<code>-Math.PI</code>, <code>Math.PI</code>).
     *
     * @param {Number} angle The longitude value, in radians, to convert to the range [<code>-Math.PI</code>, <code>Math.PI</code>).
     *
     * @return {Number} The equivalent longitude value in the range [<code>-Math.PI</code>, <code>Math.PI</code>).
     *
     * @example
     * // Convert 270 degrees to -90 degrees longitude
     * var longitude = CesiumMath.convertLongitudeRange(CesiumMath.toRadians(270.0));
     */
    CesiumMath.convertLongitudeRange = function(angle) {
        var twoPi = CesiumMath.TWO_PI;

        var simplified = angle - Math.floor(angle / twoPi) * twoPi;
        if (simplified < -Math.PI) {
            simplified += twoPi;
        } else if (simplified >= Math.PI) {
            simplified -= twoPi;
        }
        return simplified;
    };

    /**
     * Alters the value of input x such that <code>-CesiumMath.PI</code> <= x <= <code>CesiumMath.PI</code>
     * @param {Number} angle in radians
     * @return {Number} The angle in the range ()<code>-CesiumMath.PI</code>, <code>CesiumMath.PI</code>).
    */
    CesiumMath.negativePiToPi = function(x){
        var epsilon10 = CesiumMath.EPSILON10;
        var pi = CesiumMath.PI;
        var two_pi = CesiumMath.TWO_PI;
        while(x < -(pi+ epsilon10)){
            x += two_pi;
        }
        if(x < -pi){
            x = -pi;
        }
        while(x > pi + epsilon10){
            x-=two_pi;
        }
        if(x > pi){
            x = pi;
        }
        return x;
    };

    /**
     * DOC_TBA
     */
    CesiumMath.equalsEpsilon = function(left, right, epsilon) {
        epsilon = epsilon || 0.0;
        return Math.abs(left - right) <= epsilon;
    };

    var factorials = [1];

    /**
     * Computes the factorial of the provided number.
     *
     * @memberof CesiumMath
     *
     * @param {Number} n The number whose factorial is to be computed.
     *
     * @return {Number} The factorial of the provided number or undefined if the number is less than 0.
     *
     * @see <a href='http://en.wikipedia.org/wiki/Factorial'>Factorial on Wikipedia</a>.
     *
     * @example
     * //Compute 7!, which is equal to 5040
     * var computedFactorial = CesiumMath.factorial(7);
     *
     * @exception {DeveloperError} number greater than or equal to 0 is required.
     */
    CesiumMath.factorial = function(n) {
        if (typeof n !== 'number' || n < 0) {
            throw new DeveloperError('number greater than or equal to 0 is required.');
        }

        var length = factorials.length;
        if (n >= length) {
            var sum = factorials[length - 1];
            for ( var i = length; i <= n; i++) {
                factorials.push(sum * i);
            }
        }
        return factorials[n];
    };

    return CesiumMath;
});

/*global define*/
define('Core/HermitePolynomialApproximation',['./Math'
       ], function(
        CesiumMath) {
    

    var factorial = CesiumMath.factorial;

    function calculateCoefficientTerm(x, zIndices, xTable, derivOrder, termOrder, reservedIndices) {
        var result = 0;
        var reserved;
        var i;
        var j;

        if (derivOrder > 0) {
            for (i = 0; i < termOrder; i++) {
                reserved = false;
                for (j = 0; j < reservedIndices.length && !reserved; j++) {
                    if (i === reservedIndices[j]) {
                        reserved = true;
                    }
                }

                if (!reserved) {
                    reservedIndices.push(i);
                    result += calculateCoefficientTerm(x, zIndices, xTable, derivOrder - 1, termOrder, reservedIndices);
                    reservedIndices.splice(reservedIndices.length - 1, 1);
                }
            }

            return result;
        }

        result = 1;
        for (i = 0; i < termOrder; i++) {
            reserved = false;
            for (j = 0; j < reservedIndices.length && !reserved; j++) {
                if (i === reservedIndices[j]) {
                    reserved = true;
                }
            }

            if (!reserved) {
                result *= x - xTable[zIndices[i]];
            }
        }

        return result;
    }

    /**
     * Functions for performing Hermite interpolation.
     * @exports HermitePolynomialApproximation
     *
     * @see LinearApproximation
     * @see LagrangePolynomialApproximation
     */
    var HermitePolynomialApproximation = {
        type : 'Hermite'
    };

    /**
     * Given the desired degree, returns the number of data points required for interpolation.
     *
     * @memberof HermitePolynomialApproximation
     *
     * @param degree The desired degree of interpolation.
     *
     * @returns The number of required data points needed for the desired degree of interpolation.
     */
    HermitePolynomialApproximation.getRequiredDataPoints = function(degree) {
        return Math.max(degree + 1, 2);
    };

    /**
     * <p>
     * Interpolates values using the supplied interpolation algorithm.  The appropriate subset of input
     * values to use for the interpolation is determined automatically from an interpolation given
     * degree.
     * </p>
     * <p>
     * The xTable array can contain any number of elements, and the appropriate subset will be
     * selected according to the degree of interpolation requested.  For example, if degree is 5,
     * the 6 elements surrounding x will be used for interpolation.  When using
     * {@link LinearApproximation} the degree should be 1 since it always deals with only 2 elements
     * surrounding x. The yTable array should contain a number of elements equal to:
     * <code>xTable.length * yStride</code>.  If insufficient elements are provided
     * to perform the requested degree of interpolation, the highest possible degree of interpolation
     * will be performed.
     * </p>
     *
     * @param {Number} x The independent variable for which the dependent variables will be interpolated.
     *
     * @param {Array} xTable The array of independent variables to use to interpolate.  The values
     * in this array must be in increasing order and the same value must not occur twice in the array.
     *
     * @param {Array} yTable The array of dependent variables to use to interpolate.  For a set of three
     * dependent values (p,q,w) and their derivatives (dp, dq, dw) at time 1 and time 2 this should be
     * as follows: {p1, q1, w1, dp1, dq1, dw1, p2, q2, w2, dp2, dq2, dw2}.
     *
     * @param {Number} yStride The number of dependent variable values in yTable corresponding to
     * each independent variable value in xTable.
     *
     * @returns An array of interpolated values.  The array contains at least yStride elements, each
     * of which is an interpolated dependent variable value.
     *
     * @see LinearApproximation
     * @see LagrangePolynomialApproximation
     *
     * @memberof HermitePolynomialApproximation
     */
    HermitePolynomialApproximation.interpolateOrderZero = function(x, xTable, yTable, yStride) {
        var length = xTable.length, i, j, d, s, len, index, result = new Array(yStride), coefficients = new Array(yStride);

        for (i = 0; i < yStride; i++) {
            result[i] = 0;

            var l = new Array(length);
            coefficients[i] = l;
            for (j = 0; j < length; j++) {
                l[j] = [];
            }
        }

        var zIndicesLength = length, zIndices = new Array(zIndicesLength);

        for (i = 0; i < zIndicesLength; i++) {
            zIndices[i] = i;
        }

        var highestNonZeroCoef = length - 1;
        for (s = 0; s < yStride; s++) {
            for (j = 0; j < zIndicesLength; j++) {
                index = zIndices[j] * yStride + s;
                coefficients[s][0].push(yTable[index]);
            }

            for (i = 1; i < zIndicesLength; i++) {
                var nonZeroCoefficients = false;
                for (j = 0; j < zIndicesLength - i; j++) {
                    var zj = xTable[zIndices[j]];
                    var zn = xTable[zIndices[j + i]];

                    var numerator;
                    if (zn - zj <= 0) {
                        index = zIndices[j] * yStride + yStride * i + s;
                        numerator = yTable[index];
                        coefficients[s][i].push(numerator / factorial(i));
                    } else {
                        numerator = (coefficients[s][i - 1][j + 1] - coefficients[s][i - 1][j]);
                        coefficients[s][i].push(numerator / (zn - zj));
                    }
                    nonZeroCoefficients = nonZeroCoefficients || (numerator !== 0);
                }

                if (!nonZeroCoefficients) {
                    highestNonZeroCoef = i - 1;
                }
            }
        }

        for (d = 0, len = 0; d <= len; d++) {
            for (i = d; i <= highestNonZeroCoef; i++) {
                var tempTerm = calculateCoefficientTerm(x, zIndices, xTable, d, i, []);
                for (s = 0; s < yStride; s++) {
                    var coeff = coefficients[s][i][0];
                    result[s + d * yStride] += coeff * tempTerm;
                }
            }
        }

        return result;
    };

    return HermitePolynomialApproximation;
});
/*global define*/
define('Core/IntersectionTests',[
        './DeveloperError',
        './Math',
        './Cartesian3'
    ],
    function(
        DeveloperError,
        CesiumMath,
        Cartesian3) {
    

    /**
     * DOC_TBA
     *
     * @exports IntersectionTests
     */
    var IntersectionTests = {
        /**
         * DOC_TBA
         *
         * @param {Ray} ray DOC_TBA
         * @param {Cartesian3} planeNormal DOC_TBA
         * @param {Number} planeD DOC_TBA
         *
         * @exception {DeveloperError} ray is required.
         * @exception {DeveloperError} planeNormal is required.
         * @exception {DeveloperError} planeD is required.
         */
        rayPlane : function(ray, planeNormal, planeD) {
            if (typeof ray === 'undefined') {
                throw new DeveloperError('ray is required.');
            }

            if (typeof planeNormal === 'undefined') {
                throw new DeveloperError('planeNormal is required.');
            }

            if (typeof planeD === 'undefined') {
                throw new DeveloperError('planeD is required.');
            }

            var origin = Cartesian3.clone(ray.origin);
            var direction = Cartesian3.clone(ray.direction);
            var normal = Cartesian3.clone(planeNormal);

            var denominator = normal.dot(direction);

            if (Math.abs(denominator) < CesiumMath.EPSILON15) {
                // Ray is parallel to plane.  The ray may be in the polygon's plane.
                return undefined;
            }

            var t = (-planeD - normal.dot(origin)) / denominator;

            if (t < 0) {
                return undefined;
            }

            return origin.add(direction.multiplyByScalar(t));
        },

        /**
         * DOC_TBA
         *
         * @param {Ray} ray DOC_TBA
         * @param {Ellipsoid} ellipsoid DOC_TBA
         *
         * @exception {DeveloperError} ray is required.
         * @exception {DeveloperError} ellipsoid is required.
         */
        rayEllipsoid : function(ray, ellipsoid) {
            if (typeof ray === 'undefined') {
                throw new DeveloperError('ray is required.');
            }

            if (typeof ellipsoid === 'undefined') {
                throw new DeveloperError('ellipsoid is required.');
            }

            var inverseRadii = ellipsoid.getOneOverRadii();
            var q = inverseRadii.multiplyComponents(ray.origin);
            var w = inverseRadii.multiplyComponents(ray.direction);

            var q2 = q.magnitudeSquared();
            var qw = q.dot(w);

            var difference, w2, product, discriminant, temp;

            if (q2 > 1.0) {
                // Outside ellipsoid.
                if (qw >= 0.0) {
                    // Looking outward or tangent (0 intersections).
                    return undefined;
                }

                // qw < 0.0.
                var qw2 = qw * qw;
                difference = q2 - 1.0; // Positively valued.
                w2 = w.magnitudeSquared();
                product = w2 * difference;

                if (qw2 < product) {
                    // Imaginary roots (0 intersections).
                    return undefined;
                } else if (qw2 > product) {
                    // Distinct roots (2 intersections).
                    discriminant = qw * qw - product;
                    temp = -qw + Math.sqrt(discriminant); // Avoid cancellation.
                    var root0 = temp / w2;
                    var root1 = difference / temp;
                    if (root0 < root1) {
                        return {
                            start : root0,
                            stop : root1
                        };
                    }

                    return {
                        start : root1,
                        stop : root0
                    };
                } else {
                    // qw2 == product.  Repeated roots (2 intersections).
                    var root = Math.sqrt(difference / w2);
                    return {
                        start : root,
                        stop : root
                    };
                }

            } else if (q2 < 1.0) {
                // Inside ellipsoid (2 intersections).
                difference = q2 - 1.0; // Negatively valued.
                w2 = w.magnitudeSquared();
                product = w2 * difference; // Negatively valued.
                if (qw < 0.0) {
                    // Looking inward.
                    discriminant = qw * qw - product;
                    temp = qw - Math.sqrt(discriminant); // Avoid cancellation.  Negatively valued.
                    return {
                        start : 0.0,
                        stop : difference / temp
                    };
                } else if (qw > 0.0) {
                    // Looking outward.
                    discriminant = qw * qw - product;
                    temp = qw + Math.sqrt(discriminant); // Avoid cancellation. Positively valued.
                    return {
                        start : 0.0,
                        stop : temp / w2
                    };
                } else {
                    // qw == 0.0 // Looking tangent.
                    temp = Math.sqrt(-product);
                    return {
                        start : 0.0,
                        stop : temp / w2
                    };
                }
            } else {
                // q2 == 1.0. On ellipsoid.
                if (qw < 0.0) {
                    // Looking inward.
                    w2 = w.magnitudeSquared();
                    return {
                        start : 0.0,
                        stop : -qw / w2
                    };
                }

                // qw >= 0.0.  Looking outward or tangent.
                return undefined;
            }
        }
    };

    return IntersectionTests;
});

/*global define*/
define('Core/Matrix2',[
        './DeveloperError',
        './Cartesian2'
       ],
    function(
        DeveloperError,
        Cartesian2) {
    

    /**
     * A 2x2 matrix, indexable as a column-major order array.
     * Constructor parameters are in row-major order for code readability.
     * @alias Matrix2
     * @constructor
     *
     * @param {Number} [column0Row0=0.0] The value for column 0, row 0.
     * @param {Number} [column1Row0=0.0] The value for column 1, row 0.
     * @param {Number} [column0Row1=0.0] The value for column 0, row 1.
     * @param {Number} [column1Row1=0.0] The value for column 1, row 1.
     *
     * @see Matrix2.fromColumnMajor
     * @see Matrix2.fromRowMajorArray
     * @see Matrix3
     * @see Matrix4
     */
    var Matrix2 = function(column0Row0, column1Row0, column0Row1, column1Row1) {
        this[0] = typeof column0Row0 === 'undefined' ? 0.0 : column0Row0;
        this[1] = typeof column0Row1 === 'undefined' ? 0.0 : column0Row1;
        this[2] = typeof column1Row0 === 'undefined' ? 0.0 : column1Row0;
        this[3] = typeof column1Row1 === 'undefined' ? 0.0 : column1Row1;
    };

    /**
     * Duplicates a Matrix2 instance.
     * @memberof Matrix2
     *
     * @param {Matrix2} matrix The matrix to duplicate.
     * @param {Matrix2} [result] The object onto which to store the result.
     * @return {Matrix2} The modified result parameter or a new Matrix2 instance if none was provided.
     *
     * @exception {DeveloperError} matrix is required.
     */
    Matrix2.clone = function(values, result) {
        if (typeof values === 'undefined') {
            throw new DeveloperError('values is required');
        }
        if (typeof result === 'undefined') {
            return new Matrix2(values[0], values[2],
                               values[1], values[3]);
        }
        result[0] = values[0];
        result[1] = values[1];
        result[2] = values[2];
        result[3] = values[3];
        return result;
    };

    /**
     * Creates a Matrix2 instance from a column-major order array.
     * @memberof Matrix2
     * @function
     *
     * @param {Array} values The column-major order array.
     * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The modified result parameter, or a new Matrix2 instance if none was provided.
     *
     * @exception {DeveloperError} values is required.
     */
    Matrix2.fromColumnMajorArray = Matrix2.clone;

    /**
     * Creates a Matrix2 instance from a row-major order array.
     * The resulting matrix will be in column-major order.
     * @memberof Matrix2
     *
     * @param {Array} values The row-major order array.
     * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The modified result parameter, or a new Matrix2 instance if none was provided.
     *
     * @exception {DeveloperError} values is required.
     */
    Matrix2.fromRowMajorArray = function(values, result) {
        if (typeof values === 'undefined') {
            throw new DeveloperError('values is required.');
        }
        if (typeof result === 'undefined') {
            return new Matrix2(values[0], values[1],
                               values[2], values[3]);
        }
        result[0] = values[0];
        result[1] = values[2];
        result[2] = values[1];
        result[3] = values[3];
        return result;
    };

    /**
     * Creates an Array from the provided Matrix2 instance.
     * The array will be in column-major order.
     * @memberof Matrix2
     *
     * @param {Matrix2} matrix The matrix to use..
     * @param {Array} [result] The Array onto which to store the result.
     * @return {Array} The modified Array parameter or a new Array instance if none was provided.
     *
     * @exception {DeveloperError} matrix is required.
     */
    Matrix2.toArray = function(matrix, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required');
        }
        if (typeof result === 'undefined') {
            return [matrix[0], matrix[1], matrix[2], matrix[3]];
        }
        result[0] = matrix[0];
        result[1] = matrix[1];
        result[2] = matrix[2];
        result[3] = matrix[3];
        return result;
    };

    /**
     * Retrieves a copy of the matrix column at the provided index as a Cartesian2 instance.
     * @memberof Matrix2
     *
     * @param {Matrix2} matrix The matrix to use.
     * @param {Number} index The zero-based index of the column to retrieve.
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.
     *
     * @exception {DeveloperError} matrix is required.
     * @exception {DeveloperError} index is required and must be 0 or 1.
     *
     * @see Cartesian2
     */
    Matrix2.getColumn = function(matrix, index, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required.');
        }

        if (typeof index !== 'number' || index < 0 || index > 1) {
            throw new DeveloperError('index is required and must be 0 or 1.');
        }

        var startIndex = index * 2;
        var x = matrix[startIndex];
        var y = matrix[startIndex + 1];

        if (typeof result === 'undefined') {
            return new Cartesian2(x, y);
        }
        result.x = x;
        result.y = y;
        return result;
    };

    /**
     * Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian2 instance.
     * @memberof Matrix2
     *
     * @param {Matrix2} matrix The matrix to use.
     * @param {Number} index The zero-based index of the column to set.
     * @param {Cartesian2} cartesian The Cartesian whose values will be assigned to the specified column.
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Matrix2} The modified result parameter or a new Matrix2 instance if none was provided.
     *
     * @exception {DeveloperError} matrix is required.
     * @exception {DeveloperError} cartesian is required.
     * @exception {DeveloperError} index is required and must be 0 or 1.
     *
     * @see Cartesian2
     */
    Matrix2.setColumn = function(matrix, index, cartesian, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required');
        }
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        if (typeof index !== 'number' || index < 0 || index > 1) {
            throw new DeveloperError('index is required and must be 0 or 1.');
        }
        result = Matrix2.clone(matrix, result);
        var startIndex = index * 2;
        result[startIndex] = cartesian.x;
        result[startIndex + 1] = cartesian.y;
        return result;
    };

    /**
     * Retrieves a copy of the matrix row at the provided index as a Cartesian2 instance.
     * @memberof Matrix2
     *
     * @param {Matrix2} matrix The matrix to use.
     * @param {Number} index The zero-based index of the row to retrieve.
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.
     *
     * @exception {DeveloperError} matrix is required.
     * @exception {DeveloperError} index is required and must be 0 or 1.
     *
     * @see Cartesian2
     */
    Matrix2.getRow = function(matrix, index, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required.');
        }

        if (typeof index !== 'number' || index < 0 || index > 1) {
            throw new DeveloperError('index is required and must be 0 or 1.');
        }

        var x = matrix[index];
        var y = matrix[index + 2];

        if (typeof result === 'undefined') {
            return new Cartesian2(x, y);
        }
        result.x = x;
        result.y = y;
        return result;
    };

    /**
     * Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian2 instance.
     * @memberof Matrix2
     *
     * @param {Matrix2} matrix The matrix to use.
     * @param {Number} index The zero-based index of the row to set.
     * @param {Cartesian2} cartesian The Cartesian whose values will be assigned to the specified row.
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Matrix2} The modified result parameter or a new Matrix2 instance if none was provided.
     *
     * @exception {DeveloperError} matrix is required.
     * @exception {DeveloperError} cartesian is required.
     * @exception {DeveloperError} index is required and must be 0 or 1.
     *
     * @see Cartesian2
     */
    Matrix2.setRow = function(matrix, index, cartesian, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required');
        }
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        if (typeof index !== 'number' || index < 0 || index > 1) {
            throw new DeveloperError('index is required and must be 0 or 1.');
        }

        result = Matrix2.clone(matrix, result);
        result[index] = cartesian.x;
        result[index + 2] = cartesian.y;
        return result;
    };

    /**
     * Computes the product of two matrices.
     * @memberof Matrix2
     *
     * @param {Matrix2} left The first matrix.
     * @param {Matrix2} right The second matrix.
     * @param {Matrix2} [result] The object onto which to store the result.
     * @return {Matrix2} The modified result parameter or a new Matrix2 instance if none was provided.
     *
     * @exception {DeveloperError} left is required.
     * @exception {DeveloperError} right is required.
     */
    Matrix2.multiply = function(left, right, result) {
        if (typeof left === 'undefined') {
            throw new DeveloperError('left is required');
        }
        if (typeof right === 'undefined') {
            throw new DeveloperError('right is required');
        }

        var column0Row0 = left[0] * right[0] + left[2] * right[1];
        var column1Row0 = left[0] * right[2] + left[2] * right[3];
        var column0Row1 = left[1] * right[0] + left[3] * right[1];
        var column1Row1 = left[1] * right[2] + left[3] * right[3];

        if (typeof result === 'undefined') {
            return new Matrix2(column0Row0, column1Row0,
                               column0Row1, column1Row1);
        }
        result[0] = column0Row0;
        result[1] = column0Row1;
        result[2] = column1Row0;
        result[3] = column1Row1;
        return result;
    };

    /**
     * Computes the product of a matrix and a column vector.
     * @memberof Matrix2
     *
     * @param {Matrix2} matrix The matrix.
     * @param {Cartesian2} cartesian The column.
     * @param {Matrix2} [result] The object onto which to store the result.
     * @return {Matrix2} The modified result parameter or a new Cartesian2 instance if none was provided.
     *
     * @exception {DeveloperError} matrix is required.
     * @exception {DeveloperError} cartesian is required.
     */
    Matrix2.multiplyByVector = function(matrix, cartesian, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required');
        }
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }

        var x = matrix[0] * cartesian.x + matrix[2] * cartesian.y;
        var y = matrix[1] * cartesian.x + matrix[3] * cartesian.y;

        if (typeof result === 'undefined') {
            return new Cartesian2(x, y);
        }
        result.x = x;
        result.y = y;
        return result;
    };

    /**
     * Computes the product of a matrix and a scalar.
     * @memberof Matrix2
     *
     * @param {Matrix2} matrix The matrix.
     * @param {Number} scalar The number to multiply by.
     * @param {Matrix2} [result] The object onto which to store the result.
     * @return {Matrix2} The modified result parameter or a new Cartesian2 instance if none was provided.
     *
     * @exception {DeveloperError} matrix is required.
     * @exception {DeveloperError} scalar is required and must be a number.
     */
    Matrix2.multiplyByScalar = function(matrix, scalar, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required');
        }
        if (typeof scalar !== 'number') {
            throw new DeveloperError('scalar is required and must be a number');
        }

        if (typeof result === 'undefined') {
            return new Matrix2(matrix[0] * scalar, matrix[2] * scalar,
                               matrix[1] * scalar, matrix[3] * scalar);
        }
        result[0] = matrix[0] * scalar;
        result[1] = matrix[1] * scalar;
        result[2] = matrix[2] * scalar;
        result[3] = matrix[3] * scalar;
        return result;
    };

    /**
     * Creates a negated copy of the provided matrix.
     * @memberof Matrix2
     *
     * @param {Matrix2} matrix The matrix to negate.
     * @param {Matrix2} [result] The object onto which to store the result.
     * @return {Matrix2} The modified result parameter or a new Matrix2 instance if none was provided.
     *
     * @exception {DeveloperError} matrix is required.
     */
    Matrix2.negate = function(matrix, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required');
        }

        if (typeof result === 'undefined') {
            return new Matrix2(-matrix[0], -matrix[2],
                               -matrix[1], -matrix[3]);
        }
        result[0] = -matrix[0];
        result[1] = -matrix[1];
        result[2] = -matrix[2];
        result[3] = -matrix[3];
        return result;
    };

    /**
     * Computes the transpose of the provided matrix.
     * @memberof Matrix2
     *
     * @param {Matrix2} matrix The matrix to transpose.
     * @param {Matrix2} [result] The object onto which to store the result.
     * @return {Matrix2} The modified result parameter or a new Matrix2 instance if none was provided.
     *
     * @exception {DeveloperError} matrix is required.
     */
    Matrix2.transpose = function(matrix, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required');
        }

        var column0Row0 = matrix[0];
        var column0Row1 = matrix[2];
        var column1Row0 = matrix[1];
        var column1Row1 = matrix[3];

        if (typeof result === 'undefined') {
            return new Matrix2(column0Row0, column1Row0,
                               column0Row1, column1Row1);
        }
        result[0] = column0Row0;
        result[1] = column0Row1;
        result[2] = column1Row0;
        result[3] = column1Row1;
        return result;
    };

    /**
     * Compares the provided matrices componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @memberof Matrix2
     *
     * @param {Matrix2} [left] The first matrix.
     * @param {Matrix2} [right] The second matrix.
     * @return {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    Matrix2.equals = function(left, right) {
        return (left === right) ||
               (typeof left !== 'undefined' &&
                typeof right !== 'undefined' &&
                left[0] === right[0] &&
                left[1] === right[1] &&
                left[2] === right[2] &&
                left[3] === right[3]);
    };

    /**
     * Compares the provided matrices componentwise and returns
     * <code>true</code> if they are within the provided epsilon,
     * <code>false</code> otherwise.
     * @memberof Matrix2
     *
     * @param {Matrix2} [left] The first matrix.
     * @param {Matrix2} [right] The second matrix.
     * @param {Number} epsilon The epsilon to use for equality testing.
     * @return {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
     *
     * @exception {DeveloperError} epsilon is required and must be a number.
     */
    Matrix2.equalsEpsilon = function(left, right, epsilon) {
        if (typeof epsilon !== 'number') {
            throw new DeveloperError('epsilon is required and must be a number');
        }

        return (left === right) ||
                (typeof left !== 'undefined' &&
                typeof right !== 'undefined' &&
                Math.abs(left[0] - right[0]) <= epsilon &&
                Math.abs(left[1] - right[1]) <= epsilon &&
                Math.abs(left[2] - right[2]) <= epsilon &&
                Math.abs(left[3] - right[3]) <= epsilon);
    };

    /**
     * An immutable Matrix2 instance initialized to the identity matrix.
     * @memberof Matrix2
     */
    Matrix2.IDENTITY = Object.freeze(new Matrix2(1.0, 0.0, 0.0, 1.0));

    /**
     * The index into Matrix2 for column 0, row 0.
     * @memberof Matrix2
     *
     * @example
     * var matrix = new Matrix2();
     * matrix[Matrix2.COLUMN0ROW0] = 5.0; //set column 0, row 0 to 5.0
     */
    Matrix2.COLUMN0ROW0 = 0;

    /**
     * The index into Matrix2 for column 0, row 1.
     * @memberof Matrix2
     *
     * @example
     * var matrix = new Matrix2();
     * matrix[Matrix2.COLUMN0ROW1] = 5.0; //set column 0, row 1 to 5.0
     */
    Matrix2.COLUMN0ROW1 = 1;

    /**
     * The index into Matrix2 for column 1, row 0.
     * @memberof Matrix2
     *
     * @example
     * var matrix = new Matrix2();
     * matrix[Matrix2.COLUMN1ROW0] = 5.0; //set column 1, row 0 to 5.0
     */
    Matrix2.COLUMN1ROW0 = 2;

    /**
     * The index into Matrix2 for column 1, row 1.
     * @memberof Matrix2
     *
     * @example
     * var matrix = new Matrix2();
     * matrix[Matrix2.COLUMN1ROW1] = 5.0; //set column 1, row 1 to 5.0
     */
    Matrix2.COLUMN1ROW1 = 3;

    /**
     * Duplicates the provided Matrix2 instance.
     * @memberof Matrix2
     *
     * @param {Matrix2} [result] The object onto which to store the result.
     * @return {Matrix2} The modified result parameter or a new Matrix2 instance if none was provided.
     */
    Matrix2.prototype.clone = function(result) {
        return Matrix2.clone(this, result);
    };

    /**
     * Creates an Array from this Matrix2 instance.
     * @memberof Matrix2
     *
     * @param {Array} [result] The Array onto which to store the result.
     * @return {Array} The modified Array parameter or a new Array instance if none was provided.
     */
    Matrix2.prototype.toArray = function(result) {
        return Matrix2.toArray(this, result);
    };

    /**
     * Retrieves a copy of the matrix column at the provided index as a Cartesian2 instance.
     * @memberof Matrix2
     *
     * @param {Number} index The zero-based index of the column to retrieve.
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.
     *
     * @exception {DeveloperError} index is required and must be 0 or 1.
     *
     * @see Cartesian2
     */
    Matrix2.prototype.getColumn = function(index, result) {
        return Matrix2.getColumn(this, index, result);
    };

    /**
     * Computes a new matrix that replaces the specified column in this matrix with the provided Cartesian2 instance.
     * @memberof Matrix2
     *
     * @param {Number} index The zero-based index of the column to set.
     * @param {Cartesian2} cartesian The Cartesian whose values will be assigned to the specified column.
     *
     * @exception {DeveloperError} cartesian is required.
     * @exception {DeveloperError} index is required and must be 0 or 1.
     *
     * @see Cartesian2
     */
    Matrix2.prototype.setColumn = function(index, cartesian, result) {
        return Matrix2.setColumn(this, index, cartesian, result);
    };

    /**
     * Retrieves a copy of the matrix row at the provided index as a Cartesian2 instance.
     * @memberof Matrix2
     *
     * @param {Number} index The zero-based index of the row to retrieve.
     * @param {Cartesian2} [result] The object onto which to store the result.
     * @return {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.
     *
     * @exception {DeveloperError} index is required and must be 0 or 1.
     *
     * @see Cartesian2
     */
    Matrix2.prototype.getRow = function(index, result) {
        return Matrix2.getRow(this, index, result);
    };

    /**
     * Computes a new matrix that replaces the specified row in this matrix with the provided Cartesian2 instance.
     * @memberof Matrix2
     *
     * @param {Number} index The zero-based index of the row to set.
     * @param {Cartesian2} cartesian The Cartesian whose values will be assigned to the specified row.
     *
     * @exception {DeveloperError} cartesian is required.
     * @exception {DeveloperError} index is required and must be 0 or 1.
     *
     * @see Cartesian2
     */
    Matrix2.prototype.setRow = function(index, cartesian, result) {
        return Matrix2.setRow(this, index, cartesian, result);
    };

    /**
     * Computes the product of this matrix and the provided matrix.
     * @memberof Matrix2
     *
     * @param {Matrix2} right The right hand side matrix.
     * @param {Matrix2} [result] The object onto which to store the result.
     * @return {Matrix2} The modified result parameter or a new Matrix2 instance if none was provided.
     *
     * @exception {DeveloperError} right is required.
     */
    Matrix2.prototype.multiply = function(right, result) {
        return Matrix2.multiply(this, right, result);
    };

    /**
     * Computes the product of this matrix and a column vector.
     * @memberof Matrix2
     *
     * @param {Cartesian2} cartesian The column.
     * @param {Matrix2} [result] The object onto which to store the result.
     * @return {Matrix2} The modified result parameter or a new Cartesian2 instance if none was provided.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Matrix2.prototype.multiplyByVector = function(cartesian, result) {
        return Matrix2.multiplyByVector(this, cartesian, result);
    };

    /**
     * Computes the product of this matrix and a scalar.
     * @memberof Matrix2
     *
     * @param {Number} scalar The number to multiply by.
     * @param {Matrix2} [result] The object onto which to store the result.
     * @return {Matrix2} The modified result parameter or a new Cartesian2 instance if none was provided.
     *
     * @exception {DeveloperError} scalar is required and must be a number.
     */
    Matrix2.prototype.multiplyByScalar = function(scalar, result) {
        return Matrix2.multiplyByScalar(this, scalar, result);
    };
    /**
     * Creates a negated copy of this matrix.
     * @memberof Matrix2
     *
     * @param {Matrix2} matrix The matrix to negate.
     * @param {Matrix2} [result] The object onto which to store the result.
     * @return {Matrix2} The modified result parameter or a new Matrix2 instance if none was provided.
     *
     * @exception {DeveloperError} matrix is required.
     */
    Matrix2.prototype.negate = function(result) {
        return Matrix2.negate(this, result);
    };

    /**
     * Computes the transpose of this matrix.
     * @memberof Matrix2
     *
     * @param {Matrix2} [result] The object onto which to store the result.
     * @return {Matrix2} The modified result parameter or a new Matrix2 instance if none was provided.
     */
    Matrix2.prototype.transpose = function(result) {
        return Matrix2.transpose(this, result);
    };

    /**
     * Compares this matrix to the provided matrix componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @memberof Matrix2
     *
     * @param {Matrix2} [right] The right hand side matrix.
     * @return {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
     */
    Matrix2.prototype.equals = function(right) {
        return Matrix2.equals(this, right);
    };

    /**
     * Compares this matrix to the provided matrix componentwise and returns
     * <code>true</code> if they are within the provided epsilon,
     * <code>false</code> otherwise.
     * @memberof Matrix2
     *
     * @param {Matrix2} [right] The right hand side matrix.
     * @param {Number} epsilon The epsilon to use for equality testing.
     * @return {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
     *
     * @exception {DeveloperError} epsilon is required and must be a number.
     */
    Matrix2.prototype.equalsEpsilon = function(right, epsilon) {
        return Matrix2.equalsEpsilon(this, right, epsilon);
    };

    /**
     * Creates a string representing this Matrix with each row being
     * on a separate line and in the format '(column0, column1)'.
     * @memberof Matrix2
     *
     * @return {String} A string representing the provided Matrix with each row being on a separate line and in the format '(column0, column1)'.
     */
    Matrix2.prototype.toString = function() {
        return '(' + this[0] + ', ' + this[2] + ')\n' +
               '(' + this[1] + ', ' + this[3] + ')';
    };

    return Matrix2;
});

/*global define*/
define('Core/Matrix3',[
        './DeveloperError',
        './Cartesian3'
       ],
    function(
        DeveloperError,
        Cartesian3) {
    

    /**
     * A 3x3 matrix, indexable as a column-major order array.
     * Constructor parameters are in row-major order for code readability.
     * @alias Matrix3
     * @constructor
     *
     * @param {Number} [column0Row0=0.0] The value for column 0, row 0.
     * @param {Number} [column1Row0=0.0] The value for column 1, row 0.
     * @param {Number} [column2Row0=0.0] The value for column 2, row 0.
     * @param {Number} [column0Row1=0.0] The value for column 0, row 1.
     * @param {Number} [column1Row1=0.0] The value for column 1, row 1.
     * @param {Number} [column2Row1=0.0] The value for column 2, row 1.
     * @param {Number} [column0Row2=0.0] The value for column 0, row 2.
     * @param {Number} [column1Row2=0.0] The value for column 1, row 2.
     * @param {Number} [column2Row2=0.0] The value for column 2, row 2.
     *
     * @see Matrix3.fromColumnMajor
     * @see Matrix3.fromRowMajorArray
     * @see Matrix2
     * @see Matrix4
     */
    var Matrix3 = function(column0Row0, column1Row0, column2Row0,
                           column0Row1, column1Row1, column2Row1,
                           column0Row2, column1Row2, column2Row2) {
        this[0] = typeof column0Row0 === 'undefined' ? 0.0 : column0Row0;
        this[1] = typeof column0Row1 === 'undefined' ? 0.0 : column0Row1;
        this[2] = typeof column0Row2 === 'undefined' ? 0.0 : column0Row2;
        this[3] = typeof column1Row0 === 'undefined' ? 0.0 : column1Row0;
        this[4] = typeof column1Row1 === 'undefined' ? 0.0 : column1Row1;
        this[5] = typeof column1Row2 === 'undefined' ? 0.0 : column1Row2;
        this[6] = typeof column2Row0 === 'undefined' ? 0.0 : column2Row0;
        this[7] = typeof column2Row1 === 'undefined' ? 0.0 : column2Row1;
        this[8] = typeof column2Row2 === 'undefined' ? 0.0 : column2Row2;
    };

    /**
     * Duplicates a Matrix3 instance.
     * @memberof Matrix3
     *
     * @param {Matrix3} matrix The matrix to duplicate.
     * @param {Matrix3} [result] The object onto which to store the result.
     * @return {Matrix3} The modified result parameter or a new Matrix3 instance if none was provided.
     *
     * @exception {DeveloperError} matrix is required.
     */
    Matrix3.clone = function(values, result) {
        if (typeof values === 'undefined') {
            throw new DeveloperError('values is required');
        }
        if (typeof result === 'undefined') {
            return new Matrix3(values[0], values[3], values[6],
                               values[1], values[4], values[7],
                               values[2], values[5], values[8]);
        }
        result[0] = values[0];
        result[1] = values[1];
        result[2] = values[2];
        result[3] = values[3];
        result[4] = values[4];
        result[5] = values[5];
        result[6] = values[6];
        result[7] = values[7];
        result[8] = values[8];
        return result;
    };

    /**
     * Creates a Matrix3 instance from a column-major order array.
     * @memberof Matrix3
     * @function
     *
     * @param {Array} values The column-major order array.
     * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The modified result parameter, or a new Matrix3 instance if none was provided.
     *
     * @exception {DeveloperError} values is required.
     */
    Matrix3.fromColumnMajorArray = Matrix3.clone;

    /**
     * Creates a Matrix3 instance from a row-major order array.
     * The resulting matrix will be in column-major order.
     * @memberof Matrix3
     *
     * @param {Array} values The row-major order array.
     * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The modified result parameter, or a new Matrix3 instance if none was provided.
     *
     * @exception {DeveloperError} values is required.
     */
    Matrix3.fromRowMajorArray = function(values, result) {
        if (typeof values === 'undefined') {
            throw new DeveloperError('values is required.');
        }
        if (typeof result === 'undefined') {
            return new Matrix3(values[0], values[1], values[2],
                               values[3], values[4], values[5],
                               values[6], values[7], values[8]);
        }
        result[0] = values[0];
        result[1] = values[3];
        result[2] = values[6];
        result[3] = values[1];
        result[4] = values[4];
        result[5] = values[7];
        result[6] = values[2];
        result[7] = values[5];
        result[8] = values[8];
        return result;
    };

    /**
     * Computes a 3x3 rotation matrix from the provided quaternion.
     * @memberof Matrix3
     *
     * @param {Quaternion} quaternion the quaternion to use.
     *
     * @return {Matrix3} The 3x3 rotation matrix from this quaternion.
     */
    Matrix3.fromQuaternion = function(quaternion, result) {
        if (typeof quaternion === 'undefined') {
            throw new DeveloperError('quaternion is required');
        }
        var x2 = quaternion.x * quaternion.x;
        var xy = quaternion.x * quaternion.y;
        var xz = quaternion.x * quaternion.z;
        var xw = quaternion.x * quaternion.w;
        var y2 = quaternion.y * quaternion.y;
        var yz = quaternion.y * quaternion.z;
        var yw = quaternion.y * quaternion.w;
        var z2 = quaternion.z * quaternion.z;
        var zw = quaternion.z * quaternion.w;
        var w2 = quaternion.w * quaternion.w;

        var m00 = x2 - y2 - z2 + w2;
        var m01 = 2.0 * (xy + zw);
        var m02 = 2.0 * (xz - yw);

        var m10 = 2.0 * (xy - zw);
        var m11 = -x2 + y2 - z2 + w2;
        var m12 = 2.0 * (yz + xw);

        var m20 = 2.0 * (xz + yw);
        var m21 = 2.0 * (yz - xw);
        var m22 = -x2 - y2 + z2 + w2;

        if (typeof result === 'undefined') {
            return new Matrix3(m00, m10, m20,
                               m01, m11, m21,
                               m02, m12, m22);
        }
        result[0] = m00;
        result[1] = m01;
        result[2] = m02;
        result[3] = m10;
        result[4] = m11;
        result[5] = m12;
        result[6] = m20;
        result[7] = m21;
        result[8] = m22;
        return result;
    };

    /**
     * Creates an Array from the provided Matrix3 instance.
     * The array will be in column-major order.
     * @memberof Matrix3
     *
     * @param {Matrix3} matrix The matrix to use..
     * @param {Array} [result] The Array onto which to store the result.
     * @return {Array} The modified Array parameter or a new Array instance if none was provided.
     *
     * @exception {DeveloperError} matrix is required.
     */
    Matrix3.toArray = function(matrix, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required');
        }
        if (typeof result === 'undefined') {
            return [matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5], matrix[6], matrix[7], matrix[8]];
        }
        result[0] = matrix[0];
        result[1] = matrix[1];
        result[2] = matrix[2];
        result[3] = matrix[3];
        result[4] = matrix[4];
        result[5] = matrix[5];
        result[6] = matrix[6];
        result[7] = matrix[7];
        result[8] = matrix[8];
        return result;
    };

    /**
     * Retrieves a copy of the matrix column at the provided index as a Cartesian3 instance.
     * @memberof Matrix3
     *
     * @param {Matrix3} matrix The matrix to use.
     * @param {Number} index The zero-based index of the column to retrieve.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
     *
     * @exception {DeveloperError} matrix is required.
     * @exception {DeveloperError} index is required and must be 0, 1, or 2.
     *
     * @see Cartesian3
     */
    Matrix3.getColumn = function(matrix, index, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required.');
        }

        if (typeof index !== 'number' || index < 0 || index > 2) {
            throw new DeveloperError('index is required and must be 0, 1, or 2.');
        }

        var startIndex = index * 3;
        var x = matrix[startIndex];
        var y = matrix[startIndex + 1];
        var z = matrix[startIndex + 2];

        if (typeof result === 'undefined') {
            return new Cartesian3(x, y, z);
        }
        result.x = x;
        result.y = y;
        result.z = z;
        return result;
    };

    /**
     * Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian3 instance.
     * @memberof Matrix3
     *
     * @param {Matrix3} matrix The matrix to use.
     * @param {Number} index The zero-based index of the column to set.
     * @param {Cartesian3} cartesian The Cartesian whose values will be assigned to the specified column.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Matrix3} The modified result parameter or a new Matrix3 instance if none was provided.
     *
     * @exception {DeveloperError} matrix is required.
     * @exception {DeveloperError} cartesian is required.
     * @exception {DeveloperError} index is required and must be 0, 1, or 2.
     *
     * @see Cartesian3
     */
    Matrix3.setColumn = function(matrix, index, cartesian, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required');
        }
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        if (typeof index !== 'number' || index < 0 || index > 2) {
            throw new DeveloperError('index is required and must be 0, 1, or 2.');
        }
        result = Matrix3.clone(matrix, result);
        var startIndex = index * 3;
        result[startIndex] = cartesian.x;
        result[startIndex + 1] = cartesian.y;
        result[startIndex + 2] = cartesian.z;
        return result;
    };

    /**
     * Retrieves a copy of the matrix row at the provided index as a Cartesian3 instance.
     * @memberof Matrix3
     *
     * @param {Matrix3} matrix The matrix to use.
     * @param {Number} index The zero-based index of the row to retrieve.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
     *
     * @exception {DeveloperError} matrix is required.
     * @exception {DeveloperError} index is required and must be 0, 1, or 2.
     *
     * @see Cartesian3
     */
    Matrix3.getRow = function(matrix, index, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required.');
        }

        if (typeof index !== 'number' || index < 0 || index > 2) {
            throw new DeveloperError('index is required and must be 0, 1, or 2.');
        }

        var x = matrix[index];
        var y = matrix[index + 3];
        var z = matrix[index + 6];

        if (typeof result === 'undefined') {
            return new Cartesian3(x, y, z);
        }
        result.x = x;
        result.y = y;
        result.z = z;
        return result;
    };

    /**
     * Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian3 instance.
     * @memberof Matrix3
     *
     * @param {Matrix3} matrix The matrix to use.
     * @param {Number} index The zero-based index of the row to set.
     * @param {Cartesian3} cartesian The Cartesian whose values will be assigned to the specified row.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Matrix3} The modified result parameter or a new Matrix3 instance if none was provided.
     *
     * @exception {DeveloperError} matrix is required.
     * @exception {DeveloperError} cartesian is required.
     * @exception {DeveloperError} index is required and must be 0, 1, or 2.
     *
     * @see Cartesian3
     */
    Matrix3.setRow = function(matrix, index, cartesian, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required');
        }
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        if (typeof index !== 'number' || index < 0 || index > 2) {
            throw new DeveloperError('index is required and must be 0, 1, or 2.');
        }

        result = Matrix3.clone(matrix, result);
        result[index] = cartesian.x;
        result[index + 3] = cartesian.y;
        result[index + 6] = cartesian.z;
        return result;
    };

    /**
     * Computes the product of two matrices.
     * @memberof Matrix3
     *
     * @param {Matrix3} left The first matrix.
     * @param {Matrix3} right The second matrix.
     * @param {Matrix3} [result] The object onto which to store the result.
     * @return {Matrix3} The modified result parameter or a new Matrix3 instance if none was provided.
     *
     * @exception {DeveloperError} left is required.
     * @exception {DeveloperError} right is required.
     */
    Matrix3.multiply = function(left, right, result) {
        if (typeof left === 'undefined') {
            throw new DeveloperError('left is required');
        }
        if (typeof right === 'undefined') {
            throw new DeveloperError('right is required');
        }

        var column0Row0 = left[0] * right[0] + left[3] * right[1] + left[6] * right[2];
        var column0Row1 = left[1] * right[0] + left[4] * right[1] + left[7] * right[2];
        var column0Row2 = left[2] * right[0] + left[5] * right[1] + left[8] * right[2];

        var column1Row0 = left[0] * right[3] + left[3] * right[4] + left[6] * right[5];
        var column1Row1 = left[1] * right[3] + left[4] * right[4] + left[7] * right[5];
        var column1Row2 = left[2] * right[3] + left[5] * right[4] + left[8] * right[5];

        var column2Row0 = left[0] * right[6] + left[3] * right[7] + left[6] * right[8];
        var column2Row1 = left[1] * right[6] + left[4] * right[7] + left[7] * right[8];
        var column2Row2 = left[2] * right[6] + left[5] * right[7] + left[8] * right[8];

        if (typeof result === 'undefined') {
            return new Matrix3(column0Row0, column1Row0, column2Row0,
                               column0Row1, column1Row1, column2Row1,
                               column0Row2, column1Row2, column2Row2);
        }
        result[0] = column0Row0;
        result[1] = column0Row1;
        result[2] = column0Row2;
        result[3] = column1Row0;
        result[4] = column1Row1;
        result[5] = column1Row2;
        result[6] = column2Row0;
        result[7] = column2Row1;
        result[8] = column2Row2;
        return result;
    };

    /**
     * Computes the product of a matrix and a column vector.
     * @memberof Matrix3
     *
     * @param {Matrix3} matrix The matrix.
     * @param {Cartesian3} cartesian The column.
     * @param {Matrix3} [result] The object onto which to store the result.
     * @return {Matrix3} The modified result parameter or a new Cartesian3 instance if none was provided.
     *
     * @exception {DeveloperError} matrix is required.
     * @exception {DeveloperError} cartesian is required.
     */
    Matrix3.multiplyByVector = function(matrix, cartesian, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required');
        }
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }

        var vX = cartesian.x;
        var vY = cartesian.y;
        var vZ = cartesian.z;

        var x = matrix[0] * vX + matrix[3] * vY + matrix[6] * vZ;
        var y = matrix[1] * vX + matrix[4] * vY + matrix[7] * vZ;
        var z = matrix[2] * vX + matrix[5] * vY + matrix[8] * vZ;

        if (typeof result === 'undefined') {
            return new Cartesian3(x, y, z);
        }
        result.x = x;
        result.y = y;
        result.z = z;
        return result;
    };

    /**
     * Computes the product of a matrix and a scalar.
     * @memberof Matrix3
     *
     * @param {Matrix3} matrix The matrix.
     * @param {Number} scalar The number to multiply by.
     * @param {Matrix3} [result] The object onto which to store the result.
     * @return {Matrix3} The modified result parameter or a new Cartesian3 instance if none was provided.
     *
     * @exception {DeveloperError} matrix is required.
     * @exception {DeveloperError} scalar is required and must be a number.
     */
    Matrix3.multiplyByScalar = function(matrix, scalar, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required');
        }
        if (typeof scalar !== 'number') {
            throw new DeveloperError('scalar is required and must be a number');
        }

        if (typeof result === 'undefined') {
            return new Matrix3(matrix[0] * scalar, matrix[3] * scalar, matrix[6] * scalar,
                               matrix[1] * scalar, matrix[4] * scalar, matrix[7] * scalar,
                               matrix[2] * scalar, matrix[5] * scalar, matrix[8] * scalar);
        }
        result[0] = matrix[0] * scalar;
        result[1] = matrix[1] * scalar;
        result[2] = matrix[2] * scalar;
        result[3] = matrix[3] * scalar;
        result[4] = matrix[4] * scalar;
        result[5] = matrix[5] * scalar;
        result[6] = matrix[6] * scalar;
        result[7] = matrix[7] * scalar;
        result[8] = matrix[8] * scalar;
        return result;
    };

    /**
     * Creates a negated copy of the provided matrix.
     * @memberof Matrix3
     *
     * @param {Matrix3} matrix The matrix to negate.
     * @param {Matrix3} [result] The object onto which to store the result.
     * @return {Matrix3} The modified result parameter or a new Matrix3 instance if none was provided.
     *
     * @exception {DeveloperError} matrix is required.
     */
    Matrix3.negate = function(matrix, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required');
        }

        if (typeof result === 'undefined') {
            return new Matrix3(-matrix[0], -matrix[3], -matrix[6],
                               -matrix[1], -matrix[4], -matrix[7],
                               -matrix[2], -matrix[5], -matrix[8]);
        }
        result[0] = -matrix[0];
        result[1] = -matrix[1];
        result[2] = -matrix[2];
        result[3] = -matrix[3];
        result[4] = -matrix[4];
        result[5] = -matrix[5];
        result[6] = -matrix[6];
        result[7] = -matrix[7];
        result[8] = -matrix[8];
        return result;
    };

    /**
     * Computes the transpose of the provided matrix.
     * @memberof Matrix3
     *
     * @param {Matrix3} matrix The matrix to transpose.
     * @param {Matrix3} [result] The object onto which to store the result.
     * @return {Matrix3} The modified result parameter or a new Matrix3 instance if none was provided.
     *
     * @exception {DeveloperError} matrix is required.
     */
    Matrix3.transpose = function(matrix, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required');
        }

        var column0Row0 = matrix[0];
        var column0Row1 = matrix[3];
        var column0Row2 = matrix[6];
        var column1Row0 = matrix[1];
        var column1Row1 = matrix[4];
        var column1Row2 = matrix[7];
        var column2Row0 = matrix[2];
        var column2Row1 = matrix[5];
        var column2Row2 = matrix[8];

        if (typeof result === 'undefined') {
            return new Matrix3(column0Row0, column1Row0, column2Row0,
                               column0Row1, column1Row1, column2Row1,
                               column0Row2, column1Row2, column2Row2);
        }
        result[0] = column0Row0;
        result[1] = column0Row1;
        result[2] = column0Row2;
        result[3] = column1Row0;
        result[4] = column1Row1;
        result[5] = column1Row2;
        result[6] = column2Row0;
        result[7] = column2Row1;
        result[8] = column2Row2;
        return result;
    };

    /**
     * Compares the provided matrices componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @memberof Matrix3
     *
     * @param {Matrix3} [left] The first matrix.
     * @param {Matrix3} [right] The second matrix.
     * @return {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    Matrix3.equals = function(left, right) {
        return (left === right) ||
               (typeof left !== 'undefined' &&
                typeof right !== 'undefined' &&
                left[0] === right[0] &&
                left[1] === right[1] &&
                left[2] === right[2] &&
                left[3] === right[3] &&
                left[4] === right[4] &&
                left[5] === right[5] &&
                left[6] === right[6] &&
                left[7] === right[7] &&
                left[8] === right[8]);
    };

    /**
     * Compares the provided matrices componentwise and returns
     * <code>true</code> if they are within the provided epsilon,
     * <code>false</code> otherwise.
     * @memberof Matrix3
     *
     * @param {Matrix3} [left] The first matrix.
     * @param {Matrix3} [right] The second matrix.
     * @param {Number} epsilon The epsilon to use for equality testing.
     * @return {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
     *
     * @exception {DeveloperError} epsilon is required and must be a number.
     */
    Matrix3.equalsEpsilon = function(left, right, epsilon) {
        if (typeof epsilon !== 'number') {
            throw new DeveloperError('epsilon is required and must be a number');
        }

        return (left === right) ||
                (typeof left !== 'undefined' &&
                typeof right !== 'undefined' &&
                Math.abs(left[0] - right[0]) <= epsilon &&
                Math.abs(left[1] - right[1]) <= epsilon &&
                Math.abs(left[2] - right[2]) <= epsilon &&
                Math.abs(left[3] - right[3]) <= epsilon &&
                Math.abs(left[4] - right[4]) <= epsilon &&
                Math.abs(left[5] - right[5]) <= epsilon &&
                Math.abs(left[6] - right[6]) <= epsilon &&
                Math.abs(left[7] - right[7]) <= epsilon &&
                Math.abs(left[8] - right[8]) <= epsilon);
    };

    /**
     * An immutable Matrix3 instance initialized to the identity matrix.
     * @memberof Matrix3
     */
    Matrix3.IDENTITY = Object.freeze(new Matrix3(1.0, 0.0, 0.0,
                                                 0.0, 1.0, 0.0,
                                                 0.0, 0.0, 1.0));

    /**
     * The index into Matrix3 for column 0, row 0.
     * @memberof Matrix3
     */
    Matrix3.COLUMN0ROW0 = 0;

    /**
     * The index into Matrix3 for column 0, row 1.
     * @memberof Matrix3
     */
    Matrix3.COLUMN0ROW1 = 1;

    /**
     * The index into Matrix3 for column 0, row 2.
     * @memberof Matrix3
     */
    Matrix3.COLUMN0ROW2 = 2;

    /**
     * The index into Matrix3 for column 1, row 0.
     * @memberof Matrix3
     */
    Matrix3.COLUMN1ROW0 = 3;

    /**
     * The index into Matrix3 for column 1, row 1.
     * @memberof Matrix3
     */
    Matrix3.COLUMN1ROW1 = 4;

    /**
     * The index into Matrix3 for column 1, row 2.
     * @memberof Matrix3
     */
    Matrix3.COLUMN1ROW2 = 5;

    /**
     * The index into Matrix3 for column 2, row 0.
     * @memberof Matrix3
     */
    Matrix3.COLUMN2ROW0 = 6;

    /**
     * The index into Matrix3 for column 2, row 1.
     * @memberof Matrix3
     */
    Matrix3.COLUMN2ROW1 = 7;

    /**
     * The index into Matrix3 for column 2, row 2.
     * @memberof Matrix3
     */
    Matrix3.COLUMN2ROW2 = 8;

    /**
     * Duplicates the provided Matrix3 instance.
     * @memberof Matrix3
     *
     * @param {Matrix3} [result] The object onto which to store the result.
     * @return {Matrix3} The modified result parameter or a new Matrix3 instance if none was provided.
     */
    Matrix3.prototype.clone = function(result) {
        return Matrix3.clone(this, result);
    };

    /**
     * Creates an Array from this Matrix3 instance.
     * @memberof Matrix3
     *
     * @param {Array} [result] The Array onto which to store the result.
     * @return {Array} The modified Array parameter or a new Array instance if none was provided.
     */
    Matrix3.prototype.toArray = function(result) {
        return Matrix3.toArray(this, result);
    };

    /**
     * Retrieves a copy of the matrix column at the provided index as a Cartesian3 instance.
     * @memberof Matrix3
     *
     * @param {Number} index The zero-based index of the column to retrieve.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
     *
     * @exception {DeveloperError} index is required and must be 0, 1, or 2.
     *
     * @see Cartesian3
     */
    Matrix3.prototype.getColumn = function(index, result) {
        return Matrix3.getColumn(this, index, result);
    };

    /**
     * Computes a new matrix that replaces the specified column in this matrix with the provided Cartesian3 instance.
     * @memberof Matrix3
     *
     * @param {Number} index The zero-based index of the column to set.
     * @param {Cartesian3} cartesian The Cartesian whose values will be assigned to the specified column.
     *
     * @exception {DeveloperError} cartesian is required.
     * @exception {DeveloperError} index is required and must be 0, 1, or 2.
     *
     * @see Cartesian3
     */
    Matrix3.prototype.setColumn = function(index, cartesian, result) {
        return Matrix3.setColumn(this, index, cartesian, result);
    };

    /**
     * Retrieves a copy of the matrix row at the provided index as a Cartesian3 instance.
     * @memberof Matrix3
     *
     * @param {Number} index The zero-based index of the row to retrieve.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
     *
     * @exception {DeveloperError} index is required and must be 0, 1, or 2.
     *
     * @see Cartesian3
     */
    Matrix3.prototype.getRow = function(index, result) {
        return Matrix3.getRow(this, index, result);
    };

    /**
     * Computes a new matrix that replaces the specified row in this matrix with the provided Cartesian3 instance.
     * @memberof Matrix3
     *
     * @param {Number} index The zero-based index of the row to set.
     * @param {Cartesian3} cartesian The Cartesian whose values will be assigned to the specified row.
     *
     * @exception {DeveloperError} cartesian is required.
     * @exception {DeveloperError} index is required and must be 0, 1, or 2.
     *
     * @see Cartesian3
     */
    Matrix3.prototype.setRow = function(index, cartesian, result) {
        return Matrix3.setRow(this, index, cartesian, result);
    };

    /**
     * Computes the product of this matrix and the provided matrix.
     * @memberof Matrix3
     *
     * @param {Matrix3} right The right hand side matrix.
     * @param {Matrix3} [result] The object onto which to store the result.
     * @return {Matrix3} The modified result parameter or a new Matrix3 instance if none was provided.
     *
     * @exception {DeveloperError} right is required.
     */
    Matrix3.prototype.multiply = function(right, result) {
        return Matrix3.multiply(this, right, result);
    };

    /**
     * Computes the product of this matrix and a column vector.
     * @memberof Matrix3
     *
     * @param {Cartesian3} cartesian The column.
     * @param {Matrix3} [result] The object onto which to store the result.
     * @return {Matrix3} The modified result parameter or a new Cartesian3 instance if none was provided.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Matrix3.prototype.multiplyByVector = function(cartesian, result) {
        return Matrix3.multiplyByVector(this, cartesian, result);
    };

    /**
     * Computes the product of this matrix and a scalar.
     * @memberof Matrix3
     *
     * @param {Number} scalar The number to multiply by.
     * @param {Matrix3} [result] The object onto which to store the result.
     * @return {Matrix3} The modified result parameter or a new Cartesian3 instance if none was provided.
     *
     * @exception {DeveloperError} scalar is required and must be a number.
     */
    Matrix3.prototype.multiplyByScalar = function(scalar, result) {
        return Matrix3.multiplyByScalar(this, scalar, result);
    };
    /**
     * Creates a negated copy of this matrix.
     * @memberof Matrix3
     *
     * @param {Matrix3} matrix The matrix to negate.
     * @param {Matrix3} [result] The object onto which to store the result.
     * @return {Matrix3} The modified result parameter or a new Matrix3 instance if none was provided.
     *
     * @exception {DeveloperError} matrix is required.
     */
    Matrix3.prototype.negate = function(result) {
        return Matrix3.negate(this, result);
    };

    /**
     * Computes the transpose of this matrix.
     * @memberof Matrix3
     *
     * @param {Matrix3} [result] The object onto which to store the result.
     * @return {Matrix3} The modified result parameter or a new Matrix3 instance if none was provided.
     */
    Matrix3.prototype.transpose = function(result) {
        return Matrix3.transpose(this, result);
    };

    /**
     * Compares this matrix to the provided matrix componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @memberof Matrix3
     *
     * @param {Matrix3} [right] The right hand side matrix.
     * @return {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
     */
    Matrix3.prototype.equals = function(right) {
        return Matrix3.equals(this, right);
    };

    /**
     * Compares this matrix to the provided matrix componentwise and returns
     * <code>true</code> if they are within the provided epsilon,
     * <code>false</code> otherwise.
     * @memberof Matrix3
     *
     * @param {Matrix3} [right] The right hand side matrix.
     * @param {Number} epsilon The epsilon to use for equality testing.
     * @return {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
     *
     * @exception {DeveloperError} epsilon is required and must be a number.
     */
    Matrix3.prototype.equalsEpsilon = function(right, epsilon) {
        return Matrix3.equalsEpsilon(this, right, epsilon);
    };

    /**
     * Creates a string representing this Matrix with each row being
     * on a separate line and in the format '(column0, column1, column2)'.
     * @memberof Matrix3
     *
     * @return {String} A string representing the provided Matrix with each row being on a separate line and in the format '(column0, column1, column2)'.
     */
    Matrix3.prototype.toString = function() {
        return '(' + this[0] + ', ' + this[3] + ', ' + this[6] + ')\n' +
               '(' + this[1] + ', ' + this[4] + ', ' + this[7] + ')\n' +
               '(' + this[2] + ', ' + this[5] + ', ' + this[8] + ')';
    };

    return Matrix3;
});
/*global define*/
define('Core/MouseEventType',['./Enumeration'], function(Enumeration) {
    

    /**
     * This enumerated type is for classifying mouse events: down, up, click, double click, move and move while a button is held down.
     *
     * @exports MouseEventType
     */
    var MouseEventType = {
        /**
         * Represents a mouse left button down event.
         *
         * @constant
         * @type {Enumeration}
         */
        LEFT_DOWN : new Enumeration(0, 'LEFT_DOWN'),

        /**
         * Represents a mouse left button up event.
         *
         * @constant
         * @type {Enumeration}
         */
        LEFT_UP : new Enumeration(1, 'LEFT_UP'),

        /**
         * Represents a mouse left click event.
         *
         * @constant
         * @type {Enumeration}
         */
        LEFT_CLICK : new Enumeration(2, 'LEFT_CLICK'),

        /**
         * Represents a mouse left double click event.
         *
         * @constant
         * @type {Enumeration}
         */
        LEFT_DOUBLE_CLICK : new Enumeration(3, 'LEFT_DOUBLE_CLICK'),

        /**
         * Represents a mouse left button down event.
         *
         * @constant
         * @type {Enumeration}
         */
        RIGHT_DOWN : new Enumeration(5, 'RIGHT_DOWN'),

        /**
         * Represents a mouse right button up event.
         *
         * @constant
         * @type {Enumeration}
         */
        RIGHT_UP : new Enumeration(6, 'RIGHT_UP'),

        /**
         * Represents a mouse right click event.
         *
         * @constant
         * @type {Enumeration}
         */
        RIGHT_CLICK : new Enumeration(7, 'RIGHT_CLICK'),

        /**
         * Represents a mouse right double click event.
         *
         * @constant
         * @type {Enumeration}
         */
        RIGHT_DOUBLE_CLICK : new Enumeration(8, 'RIGHT_DOUBLE_CLICK'),

        /**
         * Represents a mouse middle button down event.
         *
         * @constant
         * @type {Enumeration}
         */
        MIDDLE_DOWN : new Enumeration(10, 'MIDDLE_DOWN'),

        /**
         * Represents a mouse middle button up event.
         *
         * @constant
         * @type {Enumeration}
         */
        MIDDLE_UP : new Enumeration(11, 'MIDDLE_UP'),

        /**
         * Represents a mouse middle click event.
         *
         * @constant
         * @type {Enumeration}
         */
        MIDDLE_CLICK : new Enumeration(12, 'MIDDLE_CLICK'),

        /**
         * Represents a mouse middle double click event.
         *
         * @constant
         * @type {Enumeration}
         */
        MIDDLE_DOUBLE_CLICK : new Enumeration(13, 'MIDDLE_DOUBLE_CLICK'),

        /**
         * Represents a mouse move event.
         *
         * @constant
         * @type {Enumeration}
         */
        MOVE : new Enumeration(15, 'MOVE'),

        /**
         * Represents a mouse wheel event.
         *
         * @constant
         * @type {Enumeration}
         */
        WHEEL : new Enumeration(16, 'WHEEL')
    };

    return MouseEventType;
});
/*global define*/
define('Core/PrimitiveType',['./Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports PrimitiveType
     */
    var PrimitiveType = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        POINTS : new Enumeration(0x0000, 'POINTS'),
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        LINES : new Enumeration(0x0001, 'LINES'),
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        LINE_LOOP : new Enumeration(0x0002, 'LINE_LOOP'),
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        LINE_STRIP : new Enumeration(0x0003, 'LINE_STRIP'),
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        TRIANGLES : new Enumeration(0x0004, 'TRIANGLES'),
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        TRIANGLE_STRIP : new Enumeration(0x0005, 'TRIANGLE_STRIP'),
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        TRIANGLE_FAN : new Enumeration(0x0006, 'TRIANGLE_FAN'),

        /**
         * DOC_TBA
         *
         * @param primitiveType
         *
         * @returns {Boolean}
         */
        validate : function(primitiveType) {
            return ((primitiveType === PrimitiveType.POINTS) ||
                    (primitiveType === PrimitiveType.LINES) ||
                    (primitiveType === PrimitiveType.LINE_LOOP) ||
                    (primitiveType === PrimitiveType.LINE_STRIP) ||
                    (primitiveType === PrimitiveType.TRIANGLES) ||
                    (primitiveType === PrimitiveType.TRIANGLE_STRIP) ||
                    (primitiveType === PrimitiveType.TRIANGLE_FAN));
        }
    };

    return PrimitiveType;
});

/*global define*/
define('Core/BoxTessellator',[
        './DeveloperError',
        './Cartesian3',
        './ComponentDatatype',
        './PrimitiveType'
    ], function(
        DeveloperError,
        Cartesian3,
        ComponentDatatype,
        PrimitiveType) {
    

    /**
     * DOC_TBA
     *
     * @alias BoxTessellator
     * @exports BoxTessellator
     *
     * @see CubeMapEllipsoidTessellator
     * @see PlaneTessellator
     */
    var BoxTessellator = {
        /**
         * DOC_TBA
         *
         * @exception {DeveloperError} All dimensions' components must be greater than or equal to zero.
         */
        compute : function(template) {
            template = template || {};
            var minimumCorner;
            var maximumCorner;

            if (template.minimumCorner && template.maximumCorner) {
                minimumCorner = template.minimumCorner;
                maximumCorner = template.maximumCorner;
            } else {
                var dimensions = template.dimensions || new Cartesian3(1.0, 1.0, 1.0);

                if (dimensions.x < 0 || dimensions.y < 0 || dimensions.z < 0) {
                    throw new DeveloperError('All dimensions components must be greater than or equal to zero.');
                }

                var corner = dimensions.multiplyByScalar(0.5);
                minimumCorner = corner.negate();
                maximumCorner = corner;
            }

            var mesh = {};
            mesh.attributes = {};
            mesh.indexLists = [];

            // 8 corner points.
            mesh.attributes.position = {
                componentDatatype : ComponentDatatype.FLOAT,
                componentsPerAttribute : 3,
                values : [
                          minimumCorner.x, minimumCorner.y, minimumCorner.z,
                          maximumCorner.x, minimumCorner.y, minimumCorner.z,
                          maximumCorner.x, maximumCorner.y, minimumCorner.z,
                          minimumCorner.x, maximumCorner.y, minimumCorner.z,
                          minimumCorner.x, minimumCorner.y, maximumCorner.z,
                          maximumCorner.x, minimumCorner.y, maximumCorner.z,
                          maximumCorner.x, maximumCorner.y, maximumCorner.z,
                          minimumCorner.x, maximumCorner.y, maximumCorner.z
                      ]
            };

            // 12 triangles:  6 faces, 2 triangles each.
            mesh.indexLists.push({
                primitiveType : PrimitiveType.TRIANGLES,
                values : [
                          4, 5, 6, // Top: plane z = corner.Z
                          4, 6, 7,
                          1, 0, 3, // Bottom: plane z = -corner.Z
                          1, 3, 2,
                          1, 6, 5, // Side: plane x = corner.X
                          1, 2, 6,
                          2, 3, 7, // Side: plane y = corner.Y
                          2, 7, 6,
                          3, 0, 4, // Side: plane x = -corner.X
                          3, 4, 7,
                          0, 1, 5, // Side: plane y = -corner.Y
                          0, 5, 4
                      ]
            });

            return mesh;
        }
    };

    return BoxTessellator;
});
/*global define*/
define('Core/CubeMapEllipsoidTessellator',[
        './DeveloperError',
        './Cartesian3',
        './ComponentDatatype',
        './PrimitiveType'
    ], function(
        DeveloperError,
        Cartesian3,
        ComponentDatatype,
        PrimitiveType) {
    

    /**
     * DOC_TBA
     *
     * @exports CubeMapEllipsoidTessellator
     *
     * @see BoxTessellator
     */
    var CubeMapEllipsoidTessellator = {};

    /**
     * DOC_TBA
     *
     * @param {Ellipsoid} ellipsoid DOC_TBA.
     * @param {Number} numberOfPartitions DOC_TBA.
     * @param {String} attributeName DOC_TBA.
     *
     * @exception {DeveloperError} numberOfPartitions must be greater than zero.
     */
    CubeMapEllipsoidTessellator.compute = function(ellipsoid, numberOfPartitions, attributeName) {
        if (numberOfPartitions <= 0) {
            throw new DeveloperError('numberOfPartitions must be greater than zero.');
        }

        attributeName = attributeName || 'position';

        var positions = [];
        var indices = [];

        function addEdgePositions(i0, i1) {
            var indices = [];
            indices[0] = i0;
            indices[2 + (numberOfPartitions - 1) - 1] = i1;

            var origin = positions[i0];
            var direction = positions[i1].subtract(positions[i0]);

            for ( var i = 1; i < numberOfPartitions; ++i) {
                var delta = i / numberOfPartitions;

                indices[i] = positions.length;
                positions.push(origin.add(direction.multiplyByScalar(delta)));
            }

            return indices;
        }

        function addFaceTriangles(leftBottomToTop, bottomLeftToRight, rightBottomToTop, topLeftToRight) {
            var origin = positions[bottomLeftToRight[0]];
            var x = positions[bottomLeftToRight[bottomLeftToRight.length - 1]].subtract(origin);
            var y = positions[topLeftToRight[0]].subtract(origin);

            var bottomIndicesBuffer = [];
            var topIndicesBuffer = [];

            var bottomIndices = bottomLeftToRight;
            var topIndices = topIndicesBuffer;

            for ( var j = 1; j <= numberOfPartitions; ++j) {
                if (j !== numberOfPartitions) {
                    if (j !== 1) {
                        //
                        // This copy could be avoided by ping ponging buffers.
                        //
                        bottomIndicesBuffer = topIndicesBuffer.slice(0);
                        bottomIndices = bottomIndicesBuffer;
                    }

                    topIndicesBuffer[0] = leftBottomToTop[j];
                    topIndicesBuffer[numberOfPartitions] = rightBottomToTop[j];

                    var deltaY = j / numberOfPartitions;
                    var offsetY = y.multiplyByScalar(deltaY);

                    for ( var i = 1; i < numberOfPartitions; ++i) {
                        var deltaX = i / numberOfPartitions;
                        var offsetX = x.multiplyByScalar(deltaX);

                        topIndicesBuffer[i] = positions.length;
                        positions.push(origin.add(offsetX).add(offsetY));
                    }
                } else {
                    if (j !== 1) {
                        bottomIndices = topIndicesBuffer;
                    }
                    topIndices = topLeftToRight;
                }

                for ( var k = 0; k < numberOfPartitions; ++k) {
                    indices.push(bottomIndices[k]);
                    indices.push(bottomIndices[k + 1]);
                    indices.push(topIndices[k + 1]);

                    indices.push(bottomIndices[k]);
                    indices.push(topIndices[k + 1]);
                    indices.push(topIndices[k]);
                }
            }
        }

        //
        // Initial cube.  In the plane, z = -1:
        //
        //                   +y
        //                    |
        //             Q2     * p3     Q1
        //                  / | \
        //              p0 *--+--* p2   +x
        //                  \ | /
        //             Q3     * p1     Q4
        //                    |
        //
        // Similarly, p4 to p7 are in the plane z = 1.
        //
        positions.push(new Cartesian3(-1, 0, -1));
        positions.push(new Cartesian3(0, -1, -1));
        positions.push(new Cartesian3(1, 0, -1));
        positions.push(new Cartesian3(0, 1, -1));
        positions.push(new Cartesian3(-1, 0, 1));
        positions.push(new Cartesian3(0, -1, 1));
        positions.push(new Cartesian3(1, 0, 1));
        positions.push(new Cartesian3(0, 1, 1));

        //
        // Edges
        //
        // 0 -> 1, 1 -> 2, 2 -> 3, 3 -> 0.  Plane z = -1
        // 4 -> 5, 5 -> 6, 6 -> 7, 7 -> 4.  Plane z = 1
        // 0 -> 4, 1 -> 5, 2 -> 6, 3 -> 7.  From plane z = -1 to plane z - 1
        //
        var edge0to1 = addEdgePositions(0, 1);
        var edge1to2 = addEdgePositions(1, 2);
        var edge2to3 = addEdgePositions(2, 3);
        var edge3to0 = addEdgePositions(3, 0);

        var edge4to5 = addEdgePositions(4, 5);
        var edge5to6 = addEdgePositions(5, 6);
        var edge6to7 = addEdgePositions(6, 7);
        var edge7to4 = addEdgePositions(7, 4);

        var edge0to4 = addEdgePositions(0, 4);
        var edge1to5 = addEdgePositions(1, 5);
        var edge2to6 = addEdgePositions(2, 6);
        var edge3to7 = addEdgePositions(3, 7);

        addFaceTriangles(edge0to4, edge0to1, edge1to5, edge4to5); // Q3 Face
        addFaceTriangles(edge1to5, edge1to2, edge2to6, edge5to6); // Q4 Face
        addFaceTriangles(edge2to6, edge2to3, edge3to7, edge6to7); // Q1 Face
        addFaceTriangles(edge3to7, edge3to0, edge0to4, edge7to4); // Q2 Face
        addFaceTriangles(edge7to4.slice(0).reverse(), edge4to5, edge5to6, edge6to7.slice(0).reverse()); // Plane z = 1
        addFaceTriangles(edge1to2, edge0to1.slice(0).reverse(), edge3to0.slice(0).reverse(), edge2to3); // Plane z = -1

        // Expand cube into ellipsoid and flatten values
        var radii = ellipsoid.getRadii();
        var length = positions.length;
        var q = 0;
        var flattenedPositions = new Array(length * 3);
        for ( var i = 0; i < length; ++i) {
            var item = positions[i];
            Cartesian3.normalize(item, item);
            Cartesian3.multiplyComponents(item, radii, item);
            flattenedPositions[q++] = item.x;
            flattenedPositions[q++] = item.y;
            flattenedPositions[q++] = item.z;
        }

        var mesh = {};
        mesh.attributes = {};
        mesh.indexLists = [];

        mesh.attributes[attributeName] = {
            componentDatatype : ComponentDatatype.FLOAT,
            componentsPerAttribute : 3,
            values : flattenedPositions
        };

        mesh.indexLists.push({
            primitiveType : PrimitiveType.TRIANGLES,
            values : indices
        });

        return mesh;
    };

    return CubeMapEllipsoidTessellator;
});
/*global define*/
define('Core/PlaneTessellator',[
        './DeveloperError',
        './Cartesian2',
        './PrimitiveType'
    ], function(
        DeveloperError,
        Cartesian2,
        PrimitiveType) {
    

    /**
     * DOC_TBA
     *
     * @exports PlaneTessellator
     *
     * @see CubeMapEllipsoidTessellator
     * @see BoxTessellator
     */
    var PlaneTessellator = {
        /**
         * DOC_TBA
         *
         * @exception {DeveloperError} Resolution must be greater than one in both the x and y directions.
         */
        compute : function(template) {
            template = template || {};
            var resolution = template.resolution || new Cartesian2(2, 2);
            var onInterpolation = template.onInterpolation; // Can be undefined

            if (resolution.x <= 1 || resolution.y <= 1) {
                throw new DeveloperError('Resolution must be greater than one in both the x and y directions.');
            }

            var i;
            var j;

            // To allow computing custom attributes, e.g., texture coordinates, etc.
            if (onInterpolation) {
                for (j = 0; j < resolution.y; ++j) {
                    var yTime = j / (resolution.y - 1);

                    for (i = 0; i < resolution.x; ++i) {
                        var xTime = i / (resolution.x - 1);
                        onInterpolation(new Cartesian2(xTime, yTime));
                    }
                }
            }

            var indices = [];

            // Counterclockwise winding order
            for (j = 0; j < resolution.y - 1; ++j) {
                var row = j * resolution.x;
                var aboveRow = (j + 1) * resolution.x;

                for (i = 0; i < resolution.x - 1; ++i) {
                    indices.push(row + i, row + i + 1, aboveRow + i + 1);
                    indices.push(row + i, aboveRow + i + 1, aboveRow + i);
                }
            }

            return {
                attributes : {},
                indexLists : [{
                    primitiveType : PrimitiveType.TRIANGLES,
                    values : indices
                }]
            };
        }
    };

    return PlaneTessellator;
});
/*global define*/
define('Core/Quaternion',[
        './Math',
        './Cartesian3',
        './Cartesian4',
        './Matrix3'
    ], function(
        CesiumMath,
        Cartesian3,
        Cartesian4,
        Matrix3) {
    

    /**
     * DOC_TBA
     *
     * @alias Quaternion
     *
     * @constructor
     *
     * @param {Number} x The x-component of the Quaternion.
     * @param {Number} y The y-component of the Quaternion.
     * @param {Number} z The z-component of the Quaternion.
     * @param {Number} w The w-component of the Quaternion.
     *
     * @see Matrix3
     */
    var Quaternion = function(x, y, z, w) {

        /**
         * The x coordinate.
         *
         * @type Number
         *
         * @see Quaternion.y
         * @see Quaternion.z
         * @see Quaternion.w
         */
        this.x = (typeof x !== 'undefined') ? x : 0.0;

        /**
         * The y coordinate.
         *
         * @type Number
         *
         * @see Quaternion.x
         * @see Quaternion.z
         * @see Quaternion.w
         */
        this.y = (typeof y !== 'undefined') ? y : 0.0;

        /**
         * The z coordinate.
         *
         * @type Number
         *
         * @see Quaternion.x
         * @see Quaternion.y
         * @see Quaternion.w
         */
        this.z = (typeof z !== 'undefined') ? z : 0.0;

        /**
         * The w coordinate.
         *
         * @type Number
         *
         * @see Quaternion.x
         * @see Quaternion.y
         * @see Quaternion.z
         */
        this.w = (typeof w !== 'undefined') ? w : 0.0;
    };

    /**
     * Returns a duplicate of a Quaternion.
     *
     * @param {Quaternion} quaternion The Quaternion to clone.
     * @return {Quaternion} A new Quaternion instance.
     */
    Quaternion.clone = function(quaternion) {
        return new Quaternion(quaternion.x, quaternion.y, quaternion.z, quaternion.w);
    };

    /**
     * An immutable Quaternion instance initialized to (0.0, 0.0, 0.0, 0.0).
     *
     * @memberof Quaternion
     */
    Quaternion.ZERO = Object.freeze(new Quaternion(0.0, 0.0, 0.0, 0.0));

    /**
     * An immutable Quaternion instance initialized to (0.0, 0.0, 0.0, 1.0).
     *
     * @memberof Quaternion
     */
    Quaternion.IDENTITY = Object.freeze(new Quaternion(0.0, 0.0, 0.0, 1.0));

    /**
     * Returns the conjugate of this quaternion.
     *
     * @memberof Quaternion
     *
     * @param {Quaternion} [result] The object to store the result into, if undefined a new instance will be created.
     *
     * @return {Quaternion} The modified result parameter or a new instance if result was undefined.
     */
    Quaternion.prototype.conjugate = function(result) {
        if (typeof result === 'undefined') {
            result = new Quaternion();
        }
        result.x = -this.x;
        result.y = -this.y;
        result.z = -this.z;
        result.w = this.w;
        return result;
    };

    /**
     * Returns the quaternion's norm squared.
     *
     * @memberof Quaternion
     *
     * @return {Number} The norm squared.
     *
     * @see Quaternion#norm
     */
    Quaternion.prototype.normSquared = function() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    };

    /**
     * Returns the quaternion's norm.
     *
     * @memberof Quaternion
     *
     * @return {Number} The norm.
     *
     * @see Quaternion#normSquared
     */
    Quaternion.prototype.norm = function() {
        return Math.sqrt(this.normSquared());
    };

    /**
     * Returns this quaternion normalized.
     *
     * @memberof Quaternion
     *
     * @param {Quaternion} [result] The object to store the result into, if undefined a new instance will be created.
     *
     * @return {Quaternion} The modified result parameter or a new instance if result was undefined.
     */
    Quaternion.prototype.normalize = function(result) {
        if (typeof result === 'undefined') {
            result = new Quaternion();
        }
        var inverseMagnitude = 1.0 / this.norm();
        result.x = this.x * inverseMagnitude;
        result.y = this.y * inverseMagnitude;
        result.z = this.z * inverseMagnitude;
        result.w = this.w * inverseMagnitude;
        return result;
    };

    /**
     * Returns the inverse of this quaternion.
     *
     * @memberof Quaternion
     *
     * @param {Quaternion} [result] The object to store the result into, if undefined a new instance will be created.
     *
     * @return {Quaternion} The modified result parameter or a new instance if result was undefined.
     */
    Quaternion.prototype.inverse = function(result) {
        var normSquared = this.normSquared();
        return this.conjugate(result).multiplyByScalar(1.0 / normSquared, result);
    };

    /**
     * Returns the componentwise sum of two quaternions, <code>this</code> + <code>other</code>.
     *
     * @memberof Quaternion
     *
     * @param {Quaternion} other The quaternion to sum with <code>this</code>.
     *
     * @return {Quaternion} The componentwise sum of two quaternions, <code>this</code> + <code>other</code>.
     *
     * @see Quaternion#subtract
     */
    Quaternion.prototype.add = function(other) {
        return new Quaternion(this.x + other.x, this.y + other.y, this.z + other.z, this.w + other.w);
    };

    /**
     * Returns the componentwise difference of two quaternions, <code>this</code> - <code>other</code>.
     *
     * @memberof Quaternion
     *
     * @param {Quaternion} other The quaternion to subtract from </code>this</code>.
     *
     * @return {Quaternion} The componentwise difference of two quaternions, <code>this</code> - <code>other</code>.
     *
     * @see Quaternion#add
     */
    Quaternion.prototype.subtract = function(other) {
        return new Quaternion(this.x - other.x, this.y - other.y, this.z - other.z, this.w - other.w);
    };

    /**
     * Returns this quaternion negated.
     *
     * @memberof Quaternion
     *
     * @return {Quaternion} This quaternion negated.
     */
    Quaternion.prototype.negate = function() {
        return new Quaternion(-this.x, -this.y, -this.z, -this.w);
    };

    /**
     * Returns the dot (scalar) product of two quaternions, <code>this</code> dot <code>other</code>.
     *
     * @memberof Quaternion
     *
     * @param {Quaternion} other The quaternion to dot with <code>this</code>.
     *
     * @return {Number} The dot (scalar) product of two quaternions, <code>this</code> dot <code>other</code>.
     *
     * @see Quaternion#multiply
     */
    Quaternion.prototype.dot = function(other) {
        return this.x * other.x + this.y * other.y + this.z * other.z + this.w * other.w;
    };

    /**
     * Returns the product two quaternions, <code>this</code> and <code>other</code>.
     *
     * @memberof Quaternion
     *
     * @param {Quaternion} other The quaternion to multiply with <code>this</code>.
     * @param {Quaternion} [result] The object to store the result into, if undefined a new instance will be created.
     *
     * @return {Quaternion} The modified result parameter or a new instance if result was undefined.
     *
     * @see Quaternion#dot
     */
    Quaternion.prototype.multiply = function(other, result) {
        var leftX = this.x;
        var leftY = this.y;
        var leftZ = this.z;
        var leftW = this.w;

        var rightX = other.x;
        var rightY = other.y;
        var rightZ = other.z;
        var rightW = other.w;

        if (typeof result === 'undefined') {
            result = new Quaternion();
        }
        result.x = leftY * rightZ - leftZ * rightY + leftX * rightW + leftW * rightX;
        result.y = leftZ * rightX - leftX * rightZ + leftY * rightW + leftW * rightY;
        result.z = leftX * rightY - leftY * rightX + leftZ * rightW + leftW * rightZ;
        result.w = leftW * rightW - leftX * rightX - leftY * rightY - leftZ * rightZ;
        return result;
    };

    /**
     * Returns this quaternion scaled by a scalar.
     *
     * @memberof Quaternion
     *
     * @param {Number} scalar The scalar that is multiplied with <code>this</code>.
     * @param {Quaternion} [result] The object to store the result into, if undefined a new instance will be created.
     *
     * @return {Quaternion} The modified result parameter or a new instance if result was undefined.
     *
     * @see Quaternion#divideByScalar
     */
    Quaternion.prototype.multiplyByScalar = function(scalar, result) {
        if (typeof result === 'undefined') {
            result = new Quaternion();
        }
        result.x = this.x * scalar;
        result.y = this.y * scalar;
        result.z = this.z * scalar;
        result.w = this.w * scalar;
        return result;
    };

    /**
     * Returns this quaternion divided by a scalar.
     *
     * @memberof Quaternion
     *
     * @param {Number} scalar The scalar to use for division.
     *
     * @return {Quaternion} This quaternion divided by a scalar.
     *
     * @see Quaternion#multiplyByScalar
     */
    Quaternion.prototype.divideByScalar = function(scalar) {
        return new Quaternion(this.x / scalar, this.y / scalar, this.z / scalar, this.w / scalar);
    };

    /**
     * Applies the rotation represented by this quaternion to a 4D Cartesian.
     *
     * @memberof Quaternion
     *
     * @param {Cartesian4} cartesian The cartesian to rotate.
     *
     * @return {Cartesian4} The rotated cartesian.
     */
    Quaternion.prototype.rotate = function(cartesian) {
        var c = new Cartesian4.clone(cartesian);
        var result = this.multiply(c).multiply(this.conjugate());
        return new Cartesian4(result.x, result.y, result.z, result.w);
    };

    /**
     * Returns the axis of rotation if this is a unit quaternion that represents a rotation.
     *
     * @memberof Quaternion
     *
     * @return {Cartesian3} The axis of rotation.
     *
     * @see Quaternion#getAngle
     * @see Quaternion.fromAxisAngle
     */
    Quaternion.prototype.getAxis = function(result) {
        if (typeof result === 'undefined') {
            result = new Cartesian3();
        }

        var w = this.w;
        if (Math.abs(w - 1.0) < CesiumMath.EPSILON6) {
            result.x = result.y = result.z = 0;
            return result;
        }

        var scalar = 1.0 / Math.sqrt(1.0 - (w * w));
        result.x = this.x * scalar;
        result.y = this.y * scalar;
        result.z = this.z * scalar;
        return result;
    };

    /**
     * Returns the angle of rotation if this is a unit quaternion that represents a rotation.
     *
     * @memberof Quaternion
     *
     * @return {Number} The angle of rotation.
     *
     * @see Quaternion#getAxis
     * @see Quaternion.fromAxisAngle
     */
    Quaternion.prototype.getAngle = function() {
        if (Math.abs(this.w - 1.0) < CesiumMath.EPSILON6) {
            return 0.0;
        }

        return 2.0 * Math.acos(this.w);
    };

    /**
     * Computes the linear interpolation between <code>this</code> and another quaternion.
     *
     * @memberof Quaternion
     *
     * @param {Number} t The normalized amount, in the range <code>[0,1]>/code>, between the two quaternions.
     * @param {Quaternion} q The ending Quaternion.
     *
     * @return {Quaternion} The interpolated quaternion between <code>this</code> and <code>q</code>, at <code>t</code>.
     */
    Quaternion.prototype.lerp = function(t, q) {
        var quaternion = Quaternion.clone(q);
        return this.multiplyByScalar(1.0 - t).add(quaternion.multiplyByScalar(t));
    };

    /**
     * Computes the spherical linear interpolation between <code>this</code> and another quaternion.
     *
     * @memberof Quaternion
     *
     * @param {Number} t The normalized amount, in the range <code>[0,1]</code>, between the two quaternions.
     * @param {Quaternion} q The ending quaternion.
     *
     * @return {Quaternion} The interpolated quaternion between <code>this</code> and <code>q</code>, at <code>t</code>.
     */
    Quaternion.prototype.slerp = function(t, q) {
        var quaternion = Quaternion.clone(q);
        var dot = this.dot(quaternion);

        // The angle between this must be acute. Since q and -q represent
        // the same rotation, negate q to get the acute angle.
        var r = quaternion;
        if (dot < 0.0) {
            dot = -dot;
            r = quaternion.negate();
        }

        // dot > 0, as the dot product approaches 1, the angle between the
        // quaternions vanishes. use linear interpolation.
        if (1.0 - dot < CesiumMath.EPSILON6) {
            return this.lerp(t, r);
        }

        var theta = Math.acos(dot);
        var scaledP = this.multiplyByScalar(Math.sin((1 - t) * theta));
        var scaledR = r.multiplyByScalar(Math.sin(t * theta));
        var sum = scaledP.add(scaledR);
        var result = sum.multiplyByScalar(1.0 / Math.sin(theta));

        return result;
    };

    /**
     * Computes the logarithm of this quaternion.
     *
     * @memberof Quaternion
     *
     * @return {Cartesian3} The result of the logarithm.
     */
    Quaternion.prototype.log = function() {
        var theta = Math.acos(this.w);
        var thetaOverSinTheta = 0.0;
        if (theta > CesiumMath.EPSILON6) {
            thetaOverSinTheta = theta / Math.sin(theta);
        }

        return new Cartesian3(this.x * thetaOverSinTheta, this.y * thetaOverSinTheta, this.z * thetaOverSinTheta);
    };

    /**
     * Raises this quaternion to the <code>t</code> power.
     *
     * @memberof Quaternion
     *
     * @param {Number} t The degree of this quaternion to compute.
     *
     * @return {Quaternion} This quaternion raised to the <code>t</code> power.
     */
    Quaternion.prototype.power = function(t) {
        return Quaternion.exp(this.log().multiplyByScalar(t));
    };

    /**
     * Returns a copy of this quaternion.
     *
     * @memberof Quaternion
     *
     * @return {Quaternion} A copy of this quaternion.
     */
    Quaternion.prototype.clone = function() {
        return new Quaternion(this.x, this.y, this.z, this.w);
    };

    /**
     * Returns <code>true</code> if this quaternion equals <code>other</code>, componentwise.
     *
     * @param {Quaternion} other The quaternion to test for equality.
     *
     * @return {Boolean} <code>true</code> if the quaternions are equal componentwise; otherwise, <code>false</code>.
     */
    Quaternion.prototype.equals = function(other) {
        return (this.x === other.x) &&
               (this.y === other.y) &&
               (this.z === other.z) &&
               (this.w === other.w);
    };

    /**
     * Returns <code>true</code> if this quaternion equals <code>other</code>, componentwise, within the specified epsilon.
     *
     * @memberof Quaternion
     *
     * @param {Quaternion} other The quaternion to test for equality.
     * @param {Number} [epsilon=0.0] The epsilon to use for equality testing.
     *
     * @return {Boolean} <code>true</code> if the quaternions are equal within the specified epsilon; otherwise, <code>false</code>.
     */
    Quaternion.prototype.equalsEpsilon = function(other, epsilon) {
        epsilon = epsilon || 0.0;
        return (Math.abs(this.x - other.x) <= epsilon) &&
               (Math.abs(this.y - other.y) <= epsilon) &&
               (Math.abs(this.z - other.z) <= epsilon) &&
               (Math.abs(this.w - other.w) <= epsilon);
    };

    /**
     * Returns a string representing this quaternion in the format (x, y, z, w).
     *
     * @memberof Quaternion
     *
     * @return {String} A string representing this Quaternion.
     */
    Quaternion.prototype.toString = function() {
        return '(' + this.x + ', ' + this.y + ', ' + this.z + ', ' + this.w + ')';
    };

    //Cached temp variable used by Quaternion.fromAxisAngle.
    var fromAxisAngleCartesian = new Cartesian3();

    /**
     * Creates a quaternion representing a rotation around an axis.
     *
     * @memberof Quaternion
     *
     * @param {Cartesian3} axis The axis of rotation.
     * @param {Number} angle The angle in radians to rotate around the axis.
     * @param {Quaternion} [result] The object to store the result into, if undefined a new instance will be created.
     *
     * @return {Quaternion} The modified result parameter or a new instance if result was undefined.
     *
     * @see Quaternion#getAxis
     * @see Quaternion#getAngle
     * @see Matrix3.fromAxisAngle
     */
    Quaternion.fromAxisAngle = function(axis, angle, result) {
        if (typeof result === 'undefined') {
            result = new Quaternion();
        }
        var halfAngle = angle / 2.0;
        var s = Math.sin(halfAngle);
        axis.normalize(fromAxisAngleCartesian);
        result.x = fromAxisAngleCartesian.x * s;
        result.y = fromAxisAngleCartesian.y * s;
        result.z = fromAxisAngleCartesian.z * s;
        result.w = Math.cos(halfAngle);
        return result;
    };

    /**
     * Creates a Quaternion from a 3x3 rotation matrix.
     *
     * @memberof Quaternion
     *
     * @param {Matrix3} matrix The rotation matrix.
     *
     * @return {Quaternion} The quaternion representing the rotation.
     *
     * @see Matrix3.fromQuaternion
     */
    Quaternion.fromRotationMatrix = function(matrix) {
        var x = 0;
        var y = 0;
        var z = 0;
        var w = 0;

        var m00 = matrix[Matrix3.COLUMN0ROW0];
        var m11 = matrix[Matrix3.COLUMN1ROW1];
        var m22 = matrix[Matrix3.COLUMN2ROW2];

        var factor = m00 * m11 * m22;

        var type = 0;
        if (m00 > factor) {
            type = 1;
            factor = m00;
        }

        if (m11 > factor) {
            type = 2;
            factor = m11;
        }

        if (m22 > factor) {
            type = 3;
            factor = m22;
        }

        if (type === 1) {
            x = 0.5 * Math.sqrt(1.0 + m00 - m11 - m22);
            factor = 1.0 / (4.0 * x);

            w = factor * (matrix[Matrix3.COLUMN2ROW1] - matrix[Matrix3.COLUMN1ROW2]);

            if (w < 0.0) {
                w = -w;
                factor = -factor;
            }

            y = factor * (matrix[Matrix3.COLUMN1ROW0] + matrix[Matrix3.COLUMN0ROW1]);
            z = factor * (matrix[Matrix3.COLUMN2ROW0] + matrix[Matrix3.COLUMN0ROW2]);
        } else if (type === 2) {
            y = 0.5 * Math.sqrt(1.0 - m00 + m11 - m22);
            factor = 1.0 / (4.0 * y);

            w = factor * (matrix[Matrix3.COLUMN0ROW2] - matrix[Matrix3.COLUMN2ROW0]);

            if (w < 0) {
                w = -w;
                factor = -factor;
            }

            x = factor * (matrix[Matrix3.COLUMN1ROW0] + matrix[Matrix3.COLUMN0ROW1]);
            z = factor * (matrix[Matrix3.COLUMN2ROW1] + matrix[Matrix3.COLUMN1ROW2]);
        } else if (type === 3) {
            z = 0.5 * Math.sqrt(1.0 - m00 - m11 + m22);
            factor = 1.0 / (4.0 * z);

            w = factor * (matrix[Matrix3.COLUMN1ROW0] - matrix[Matrix3.COLUMN0ROW1]);

            if (w < 0) {
                w = -w;
                factor = -factor;
            }

            x = factor * (matrix[Matrix3.COLUMN2ROW0] + matrix[Matrix3.COLUMN0ROW2]);
            y = factor * (matrix[Matrix3.COLUMN2ROW1] + matrix[Matrix3.COLUMN1ROW2]);
        } else {
            w = 0.5 * Math.sqrt(1.0 + factor);
            factor = 1.0 / (4.0 * w);

            x = factor * (matrix[Matrix3.COLUMN2ROW1] - matrix[Matrix3.COLUMN1ROW2]);
            y = factor * (matrix[Matrix3.COLUMN0ROW2] - matrix[Matrix3.COLUMN2ROW0]);
            z = factor * (matrix[Matrix3.COLUMN1ROW0] - matrix[Matrix3.COLUMN0ROW1]);
        }

        return new Quaternion(x, y, z, w);
    };

    /**
     * Computes the exponential of a Quaternion.
     *
     * @memberof Quaternion
     *
     * @param {Cartesian3} cartesian The cartesian power.
     *
     * @return {Quaternion} The Quaternion representing the exponential.
     */
    Quaternion.exp = function(cartesian) {
        var c = Cartesian3.clone(cartesian);
        var theta = c.magnitude();
        var sinThetaOverTheta = 0.0;
        if (theta > CesiumMath.EPSILON6) {
            sinThetaOverTheta = Math.sin(theta) / theta;
        }

        return new Quaternion(
                cartesian.x * sinThetaOverTheta,
                cartesian.y * sinThetaOverTheta,
                cartesian.z * sinThetaOverTheta,
                Math.cos(theta));
    };

    return Quaternion;
});

/*global define*/
define('Core/OrientationInterpolator',[
        './DeveloperError',
        './Quaternion'
    ],
    function (
        DeveloperError,
        Quaternion) {
    

    /**
     * Smoothly interpolates orientation, represented by <code>Quaternion</code>s, over time.
     * For example, this can be used to set a camera's axes along a path.
     *
     * @alias OrientationInterpolator
     * @constructor
     *
     * @param {Array} controlPoints An array, of at least length 2, of objects with <code>orientation</code> and
     * <code>time</code> properties.
     *
     * @exception {DeveloperError} controlPoints is required. It must be an array with at least a length of 3.
     *
     * @see Quaternion
     * @see CatmullRomSpline
     * @see HermiteSpline
     */
    var OrientationInterpolator = function(controlPoints) {
        if (!controlPoints || !(controlPoints instanceof Array) || controlPoints.length < 2) {
            throw new DeveloperError('controlPoints is required. It must be an array with at least a length of 3.');
        }

        this._points = controlPoints;
        this._lastTimeIndex = 0;
    };

    /**
     * Returns the array of control points.
     *
     * @memberof OrientationInterpolator
     * @return {Array} The array of control points.
     */
    OrientationInterpolator.prototype.getControlPoints = function() {
        return this._points;
    };

    OrientationInterpolator.prototype._findIndex = function(time) {
        // Take advantage of temporal coherence by checking current, next and previous intervals
        // for containment of time.
        var i = this._lastTimeIndex || 0;
        if (time >= this._points[i].time) {
            if (i + 1 < this._points.length && time < this._points[i + 1].time) {
                return i;
            } else if (i + 2 < this._points.length && time < this._points[i + 2].time) {
                this._lastTimeIndex = i + 1;
                return this._lastTimeIndex;
            }
        } else if (i - 1 >= 0 && time >= this._points[i - 1].time) {
            this._lastTimeIndex = i - 1;
            return this._lastTimeIndex;
        }

        // The above failed so do a linear search. For the use cases so far, the
        // length of the list is less than 10. In the future, if there is a bottle neck,
        // it might be here.
        for (i = 0; i < this._points.length - 1; ++i) {
            if (time >= this._points[i].time && time < this._points[i + 1].time) {
                break;
            }
        }

        if (i === this._points.length - 1) {
            i = this._points.length - 2;
        }

        this._lastTimeIndex = i;
        return this._lastTimeIndex;
    };

    /**
     * Evaluates the orientation at a given time.
     *
     * @memberof OrientationInterpolator
     *
     * @param {Number} time The time at which to evaluate the orientation.
     *
     * @exception {DeveloperError} time is required.
     * @exception {DeveloperError} time must be in the range <code>[a<sub>0</sub>, a<sub>n</sub>]</code>,
     * where <code>a<sub>0</sub></code> and <code>a<sub>n</sub></code> are the time properties of first and
     * last elements in the array given during construction, respectively.
     *
     * @return {Quaternion} The orientation at the given <code>time</code>.
     */
    OrientationInterpolator.prototype.evaluate = function(time) {
        if (typeof time === 'undefined') {
            throw new DeveloperError('time is required.');
        }

        if (time < this._points[0].time || time > this._points[this._points.length - 1].time) {
            throw new DeveloperError('time is out of range.');
        }

        var i = this._findIndex(time);
        var u = (time - this._points[i].time) / (this._points[i + 1].time - this._points[i].time);

        return this._points[i].orientation.slerp(u, this._points[i + 1].orientation);
    };

    return OrientationInterpolator;
});
/*global define*/
define('Core/Queue',[],function() {
    

    /**
     * A queue that can enqueue items at the end, and dequeue items from the front.
     *
     * @alias Queue
     * @constructor
     */
    var Queue = function() {
        this._array = [];
        this._offset = 0;

        /**
         * The length of the queue.
         */
        this.length = 0;
    };

    /**
     * Enqueues the specified item.
     *
     * @param {Object} item The item to enqueue.
     * @memberof Queue
     */
    Queue.prototype.enqueue = function(item) {
        this._array.push(item);
        this.length++;
    };

    /**
     * Dequeues an item.  Returns undefined if the queue is empty.
     *
     * @memberof Queue
     */
    Queue.prototype.dequeue = function() {
        if (this.length === 0) {
            return undefined;
        }

        var array = this._array;
        var offset = this._offset;
        var item = array[offset];
        array[offset] = undefined;

        offset++;
        if (offset > 10 && offset * 2 > array.length) {
            //compact array
            this._array = array.slice(offset);
            offset = 0;
        }

        this._offset = offset;
        this.length--;

        return item;
    };

    /**
     * Check whether this queue contains the specified item.
     *
     * @param {Object} the item to search for.
     * @memberof Queue
     */
    Queue.prototype.contains = function(item) {
        return this._array.indexOf(item) !== -1;
    };

    /**
     * Remove all items from the queue.
     * @memberof Queue
     */
    Queue.prototype.clear = function() {
        this._array.length = this._offset = this.length = 0;
    };

    /**
     * Sort the items in the queue in-place.
     *
     * @param {Function} compareFunction a function that defines the sort order.
     * @memberof Queue
     */
    Queue.prototype.sort = function(compareFunction) {
        if (this._offset > 0) {
            //compact array
            this._array = this._array.slice(this._offset);
            this._offset = 0;
        }

        this._array.sort(compareFunction);
    };

    return Queue;
});
/*global define*/
define('Core/Ray',['./Cartesian3', './DeveloperError'], function(Cartesian3, DeveloperError) {
    

    /**
     * Represents a ray that has an origin and extends infinitely in a given direction.
     *
     * @alias Ray
     * @constructor
     *
     * @param {Cartesian3} origin The origin of the ray.
     * @param {Cartesian3} direction The unit length direction of the ray.
     *
     * @exception {DeveloperError} origin is required.
     * @exception {DeveloperError} direction is required.
     */
    var Ray = function(origin, direction) {
        if (typeof origin === 'undefined') {
            throw new DeveloperError('origin is required');
        }

        if (typeof direction === 'undefined') {
            throw new DeveloperError('direction is required');
        }

        /**
         * The origin of the ray.
         *
         * @type {Cartesian3}
         */
        this.origin = origin;

        /**
         * The direction of the ray.
         *
         * @type {Cartesian3}
         */
        this.direction = direction.normalize();
    };

    /**
     * Returns a point along the ray given by r(t) = o + t*d, where o is the origin of the ray
     * and d is the direction.
     *
     * @memberof Ray
     *
     * @param {Number} [t=0.0] A scalar value.
     *
     * @returns {Cartesian3} The point along the ray.
     *
     * @example
     * //Get the first intersection point of a ray and an ellipsoid.
     * var intersection = IntersectionTests.rayEllipsoid(ray, ellipsoid);
     * var point = ray.getPoint(intersection.start);
     */
    Ray.prototype.getPoint = function(t) {
        t = (typeof t === 'undefined') ? 0.0 : t;
        return this.origin.add(this.direction.multiplyByScalar(t));
    };

    return Ray;
});
/*global define*/
define('Core/Rectangle',['./DeveloperError'], function(DeveloperError) {
    

    /**
     * DOC_TBA
     *
     * @alias Rectangle
     *
     * @param {Number} [x=0.0] The x coordinate of the rectangle.
     * @param {Number} [y=0.0] The y coordinate of the rectangle.
     * @param {Number} [width=0.0] The width of the rectangle.
     * @param {Number} [height=0.0] The height of the rectangle.
     *
     * @constructor
     */
    var Rectangle = function(x, y, width, height) {
        /**
         * The x coordinate of the rectangle
         *
         * @type Number
         *
         * @see Rectangle.y
         */
        this.x = x || 0.0;

        /**
         * The y coordinate of the rectangle
         *
         * @type Number
         *
         * @see Rectangle.x
         */
        this.y = y || 0.0;

        /**
         * The width of the rectangle
         *
         * @type Number
         *
         * @see Rectangle.height
         */
        this.width = width || 0.0;

        /**
         * The height of the rectangle
         *
         * @type Number
         *
         * @see Rectangle.width
         */
        this.height = height || 0.0;
    };

    /**
     * DOC_TBA
     *
     * @memberof Rectangle
     *
     * @param {Array} positions
     *
     * @return {Rectangle} An axis aligned rectangle bounding the positions.
     */
    Rectangle.createAxisAlignedBoundingRectangle = function(positions) {
        if (typeof positions === 'undefined') {
            throw new DeveloperError('positions is required.');
        }

        if (typeof positions.length === 'undefined' || positions.length <= 0) {
            throw new DeveloperError('The length of positions must be greater than zero.');
        }

        var length = positions.length;

        var minimumX = positions[0].x;
        var minimumY = positions[0].y;

        var maximumX = positions[0].x;
        var maximumY = positions[0].y;

        for ( var i = 1; i < length; i++) {
            var p = positions[i];
            var x = p.x;
            var y = p.y;

            if (x < minimumX) {
                minimumX = x;
            }

            if (x > maximumX) {
                maximumX = x;
            }

            if (y < minimumY) {
                minimumY = y;
            }

            if (y > maximumY) {
                maximumY = y;
            }
        }

        return new Rectangle(minimumX, minimumY, maximumX - minimumX, maximumY - minimumY);
    };

    /**
     * Returns a copy of this rectangle.
     *
     * @memberof Rectangle
     *
     * @return {Rectangle} A copy of this rectangle.
     */
    Rectangle.prototype.clone = function() {
        return new Rectangle(this.x, this.y, this.width, this.height);
    };

    /**
     * Returns <code>true</code> if this rectangle equals <code>other</code>, property for property.
     *
     * @memberof Rectangle
     *
     * @param {Rectangle} other The rectangle to compare for equality.
     *
     * @return {Boolean} <code>true</code> if the rectangles are equal; otherwise, <code>false</code>.
     */
    Rectangle.prototype.equals = function(other) {
        return (this.x === other.x) &&
               (this.y === other.y) &&
               (this.width === other.width) &&
               (this.height === other.height);
    };

    /**
     * Returns <code>true</code> if this rectangle equals <code>other</code>, property for property, within the specified epsilon.
     *
     * @memberof Rectangle
     *
     * @param {Rectangle} other The rectangle to compare for equality.
     * @param {Number} [epsilon=0.0] The epsilon to use for equality testing.
     *
     * @return {Boolean} <code>true</code> if the rectangles are equal within the specified epsilon; otherwise, <code>false</code>.
     */
    Rectangle.prototype.equalsEpsilon = function(other, epsilon) {
        epsilon = epsilon || 0.0;
        return (Math.abs(this.x - other.x) <= epsilon) &&
               (Math.abs(this.y - other.y) <= epsilon) &&
               (Math.abs(this.width - other.width) <= epsilon) &&
               (Math.abs(this.height - other.height) <= epsilon);
    };

    /**
     * Returns a string representing this rectangle in the format (x, y, width, height).
     *
     * @memberof Rectangle
     *
     * @return {String} A string representing this rectangle.
     */
    Rectangle.prototype.toString = function() {
        return '(' + this.x + ', ' + this.y + ', ' + this.width + ', ' + this.height + ')';
    };

    /**
     * DOC_TBA
     * @memberof Rectangle
     */
    Rectangle.rectangleRectangleIntersect = function(rect1, rect2) {
        return !(rect1.x > rect2.x + rect2.width ||
                 rect1.x + rect1.width < rect2.x ||
                 rect1.y + rect1.height < rect2.y ||
                 rect1.y > rect2.y + rect2.height);
    };

    return Rectangle;
});

/*global define*/
define('Core/RuntimeError',[],function() {
    

    /**
     * Constructs an exception object that is thrown due to an error that can occur at runtime, e.g.,
     * out of memory, could not compile shader, etc.  If a function may throw this
     * exception, the calling code should be prepared to catch it.
     * <br /><br />
     * On the other hand, a {@link DeveloperError} indicates an exception due
     * to a developer error, e.g., invalid argument, that usually indicates a bug in the
     * calling code.
     *
     * @alias RuntimeError
     *
     * @param {String} [message=undefined] The error message for this exception.
     *
     * @see DeveloperError
     * @constructor
     */
    var RuntimeError = function(message) {
        /**
         * 'RuntimeError' indicating that this exception was thrown due to a runtime error.
         * @type String
         * @constant
         */
        this.name = 'RuntimeError';

        /**
         * The explanation for why this exception was thrown.
         * @type String
         * @constant
         */
        this.message = message;

        /**
         * The Error object containing the stack trace.
         * @type Error
         * @constant
         *
         * @see <a href='https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error'>Error object on Mozilla Developer Network</a>.
         */
        this.error = new Error();
    };

    RuntimeError.prototype.toString = function () {
        var str = this.name + ': ' + this.message;
        if (typeof this.error !== 'undefined') {
            if (typeof this.error.stack !== 'undefined') {
                str += '\n' + this.error.stack.toString();
            } else {
                str += '\n' + this.error.toString();
            }
        }
        return str;
    };

    return RuntimeError;
});

/*global define*/
define('Core/Matrix4',[
        './DeveloperError',
        './RuntimeError',
        './Math',
        './Matrix3',
        './Cartesian3',
        './Cartesian4'
       ],
    function(
        DeveloperError,
        RuntimeError,
        CesiumMath,
        Matrix3,
        Cartesian3,
        Cartesian4) {
    

    /**
     * A 4x4 matrix, indexable as a column-major order array.
     * Constructor parameters are in row-major order for code readability.
     * @alias Matrix4
     * @constructor
     *
     * @param {Number} [column0Row0=0.0] The value for column 0, row 0.
     * @param {Number} [column1Row0=0.0] The value for column 1, row 0.
     * @param {Number} [column2Row0=0.0] The value for column 2, row 0.
     * @param {Number} [column3Row0=0.0] The value for column 3, row 0.
     * @param {Number} [column0Row1=0.0] The value for column 0, row 1.
     * @param {Number} [column1Row1=0.0] The value for column 1, row 1.
     * @param {Number} [column2Row1=0.0] The value for column 2, row 1.
     * @param {Number} [column3Row1=0.0] The value for column 3, row 1.
     * @param {Number} [column0Row2=0.0] The value for column 0, row 2.
     * @param {Number} [column1Row2=0.0] The value for column 1, row 2.
     * @param {Number} [column2Row2=0.0] The value for column 2, row 2.
     * @param {Number} [column3Row2=0.0] The value for column 3, row 2.
     * @param {Number} [column0Row3=0.0] The value for column 0, row 3.
     * @param {Number} [column1Row3=0.0] The value for column 1, row 3.
     * @param {Number} [column2Row3=0.0] The value for column 2, row 3.
     * @param {Number} [column3Row3=0.0] The value for column 3, row 3.
     *
     * @see Matrix4.fromColumnMajorArray
     * @see Matrix4.fromRowMajorArray
     * @see Matrix4.fromRotationTranslation
     * @see Matrix4.fromTranslation
     * @see Matrix4.fromCamera
     * @see Matrix4.computePerspectiveFieldOfView
     * @see Matrix4.computeOrthographicOffCenter
     * @see Matrix4.computePerspectiveOffCenter
     * @see Matrix4.computeInfinitePerspectiveOffCenter
     * @see Matrix4.computeViewportTransformation
     * @see Matrix2
     * @see Matrix3
     */
    var Matrix4 = function(column0Row0, column1Row0, column2Row0, column3Row0,
                           column0Row1, column1Row1, column2Row1, column3Row1,
                           column0Row2, column1Row2, column2Row2, column3Row2,
                           column0Row3, column1Row3, column2Row3, column3Row3) {
        this[0] = typeof column0Row0 === 'undefined' ? 0.0 : column0Row0;
        this[1] = typeof column0Row1 === 'undefined' ? 0.0 : column0Row1;
        this[2] = typeof column0Row2 === 'undefined' ? 0.0 : column0Row2;
        this[3] = typeof column0Row3 === 'undefined' ? 0.0 : column0Row3;
        this[4] = typeof column1Row0 === 'undefined' ? 0.0 : column1Row0;
        this[5] = typeof column1Row1 === 'undefined' ? 0.0 : column1Row1;
        this[6] = typeof column1Row2 === 'undefined' ? 0.0 : column1Row2;
        this[7] = typeof column1Row3 === 'undefined' ? 0.0 : column1Row3;
        this[8] = typeof column2Row0 === 'undefined' ? 0.0 : column2Row0;
        this[9] = typeof column2Row1 === 'undefined' ? 0.0 : column2Row1;
        this[10] = typeof column2Row2 === 'undefined' ? 0.0 : column2Row2;
        this[11] = typeof column2Row3 === 'undefined' ? 0.0 : column2Row3;
        this[12] = typeof column3Row0 === 'undefined' ? 0.0 : column3Row0;
        this[13] = typeof column3Row1 === 'undefined' ? 0.0 : column3Row1;
        this[14] = typeof column3Row2 === 'undefined' ? 0.0 : column3Row2;
        this[15] = typeof column3Row3 === 'undefined' ? 0.0 : column3Row3;
    };

    /**
     * Duplicates a Matrix4 instance.
     * @memberof Matrix4
     *
     * @param {Matrix4} matrix The matrix to duplicate.
     * @param {Matrix4} [result] The object onto which to store the result.
     * @return {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.
     *
     * @exception {DeveloperError} matrix is required.
     */
    Matrix4.clone = function(values, result) {
        if (typeof values === 'undefined') {
            throw new DeveloperError('values is required');
        }
        if (typeof result === 'undefined') {
            return new Matrix4(values[0], values[4], values[8], values[12],
                               values[1], values[5], values[9], values[13],
                               values[2], values[6], values[10], values[14],
                               values[3], values[7], values[11], values[15]);
        }
        result[0] = values[0];
        result[1] = values[1];
        result[2] = values[2];
        result[3] = values[3];
        result[4] = values[4];
        result[5] = values[5];
        result[6] = values[6];
        result[7] = values[7];
        result[8] = values[8];
        result[9] = values[9];
        result[10] = values[10];
        result[11] = values[11];
        result[12] = values[12];
        result[13] = values[13];
        result[14] = values[14];
        result[15] = values[15];
        return result;
    };

    /**
     * Computes a Matrix4 instance from a column-major order array.
     * @memberof Matrix4
     * @function
     *
     * @param {Array} values The column-major order array.
     * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The modified result parameter, or a new Matrix4 instance if none was provided.
     *
     * @exception {DeveloperError} values is required.
     */
    Matrix4.fromColumnMajorArray = Matrix4.clone;

    /**
     * Computes a Matrix4 instance from a row-major order array.
     * The resulting matrix will be in column-major order.
     * @memberof Matrix4
     *
     * @param {Array} values The row-major order array.
     * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The modified result parameter, or a new Matrix4 instance if none was provided.
     *
     * @exception {DeveloperError} values is required.
     */
    Matrix4.fromRowMajorArray = function(values, result) {
        if (typeof values === 'undefined') {
            throw new DeveloperError('values is required.');
        }
        if (typeof result === 'undefined') {
            return new Matrix4(values[0], values[1], values[2], values[3],
                               values[4], values[5], values[6], values[7],
                               values[8], values[9], values[10], values[11],
                               values[12], values[13], values[14], values[15]);
        }
        result[0] = values[0];
        result[1] = values[4];
        result[2] = values[8];
        result[3] = values[12];
        result[4] = values[1];
        result[5] = values[5];
        result[6] = values[9];
        result[7] = values[13];
        result[8] = values[2];
        result[9] = values[6];
        result[10] = values[10];
        result[11] = values[14];
        result[12] = values[3];
        result[13] = values[7];
        result[14] = values[11];
        result[15] = values[15];
        return result;
    };

    /**
     * Computes a Matrix4 instance from a Matrix3 representing the rotation
     * and a Cartesian3 representing the translation.
     * @memberof Matrix4
     *
     * @param {Matrix3} rotation The upper left portion of the matrix representing the rotation.
     * @param {Cartesian3} translation The upper right portion of the matrix representing the translation.
     * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The modified result parameter, or a new Matrix4 instance if none was provided.
     *
     * @exception {DeveloperError} rotation is required.
     * @exception {DeveloperError} translation is required.
     */
    Matrix4.fromRotationTranslation = function(rotation, translation, result) {
        if (typeof rotation === 'undefined') {
            throw new DeveloperError('rotation is required.');
        }
        if (typeof translation === 'undefined') {
            throw new DeveloperError('translation is required.');
        }
        if (typeof result === 'undefined') {
            return new Matrix4(rotation[0], rotation[3], rotation[6], translation.x,
                               rotation[1], rotation[4], rotation[7], translation.y,
                               rotation[2], rotation[5], rotation[8], translation.z,
                                       0.0,         0.0,         0.0,           1.0);
        }

        result[0] = rotation[0];
        result[1] = rotation[1];
        result[2] = rotation[2];
        result[3] = 0.0;
        result[4] = rotation[3];
        result[5] = rotation[4];
        result[6] = rotation[5];
        result[7] = 0.0;
        result[8] = rotation[6];
        result[9] = rotation[7];
        result[10] = rotation[8];
        result[11] = 0.0;
        result[12] = translation.x;
        result[13] = translation.y;
        result[14] = translation.z;
        result[15] = 1.0;
        return result;
    };

    /**
     * Computes a Matrix4 instance from a Cartesian3 representing the translation.
     * @memberof Matrix4
     *
     * @param {Cartesian3} translation The upper right portion of the matrix representing the translation.
     * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The modified result parameter, or a new Matrix4 instance if none was provided.
     *
     * @exception {DeveloperError} translation is required.
     */
    Matrix4.fromTranslation = function(translation, result) {
        return Matrix4.fromRotationTranslation(Matrix3.IDENTITY, translation, result);
    };

    var fromCameraF = new Cartesian3();
    var fromCameraS = new Cartesian3();
    var fromCameraU = new Cartesian3();

    /**
     * Computes a Matrix4 instance from a Camera.
     * @memberof Matrix4
     *
     * @param {Camera} camera The camera to use.
     * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The modified result parameter, or a new Matrix4 instance if none was provided.
     *
     * @exception {DeveloperError} camera is required.
     * @exception {DeveloperError} camera.eye is required.
     * @exception {DeveloperError} camera.target is required.
     * @exception {DeveloperError} camera.up is required.
     */
    Matrix4.fromCamera = function(camera, result) {
        if (typeof camera === 'undefined') {
            throw new DeveloperError('camera is required.');
        }

        var eye = camera.eye;
        var target = camera.target;
        var up = camera.up;

        if (typeof eye === 'undefined') {
            throw new DeveloperError('camera.eye is required.');
        }
        if (typeof target === 'undefined') {
            throw new DeveloperError('camera.target is required.');
        }
        if (typeof up === 'undefined') {
            throw new DeveloperError('camera.up is required.');
        }

        Cartesian3.subtract(target, eye, fromCameraF).normalize(fromCameraF);
        Cartesian3.cross(fromCameraF, up, fromCameraS).normalize(fromCameraS);
        Cartesian3.cross(fromCameraS, fromCameraF, fromCameraU).normalize(fromCameraU);

        var sX = fromCameraS.x;
        var sY = fromCameraS.y;
        var sZ = fromCameraS.z;
        var fX = fromCameraF.x;
        var fY = fromCameraF.y;
        var fZ = fromCameraF.z;
        var uX = fromCameraU.x;
        var uY = fromCameraU.y;
        var uZ = fromCameraU.z;
        var eyeX = eye.x;
        var eyeY = eye.y;
        var eyeZ = eye.z;
        var t0 = sX * -eyeX + sY * -eyeY+ sZ * -eyeZ;
        var t1 = uX * -eyeX + uY * -eyeY+ uZ * -eyeZ;
        var t2 = fX * eyeX + fY * eyeY + fZ * eyeZ;

        //The code below this comment is an optimized
        //version of the commented lines.
        //Rather that create two matrices and then multiply,
        //we just bake in the multiplcation as part of creation.
        //var rotation = new Matrix4(
        //                sX,  sY,  sZ, 0.0,
        //                uX,  uY,  uZ, 0.0,
        //               -fX, -fY, -fZ, 0.0,
        //                0.0,  0.0,  0.0, 1.0);
        //var translation = new Matrix4(
        //                1.0, 0.0, 0.0, -eye.x,
        //                0.0, 1.0, 0.0, -eye.y,
        //                0.0, 0.0, 1.0, -eye.z,
        //                0.0, 0.0, 0.0, 1.0);
        //return rotation.multiply(translation);
        if (typeof result === 'undefined') {
            return new Matrix4(
                    sX,   sY,  sZ, t0,
                    uX,   uY,  uZ, t1,
                   -fX,  -fY, -fZ, t2,
                    0.0, 0.0, 0.0, 1.0);
        }
        result[0] = sX;
        result[1] = uX;
        result[2] = -fX;
        result[3] = 0.0;
        result[4] = sY;
        result[5] = uY;
        result[6] = -fY;
        result[7] = 0.0;
        result[8] = sZ;
        result[9] = uZ;
        result[10] = -fZ;
        result[11] = 0.0;
        result[12] = t0;
        result[13] = t1;
        result[14] = t2;
        result[15] = 1.0;
        return result;

    };

     /**
      * Computes a Matrix4 instance representing a perspective transformation matrix.
      * @memberof Matrix4
      *
      * @param {Number} fovY The field of view along the Y axis in radians.
      * @param {Number} aspectRatio The aspect ratio.
      * @param {Number} near The distance to the near plane in meters.
      * @param {Number} far The distance to the far plane in meters.
      * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
      * @returns The modified result parameter, or a new Matrix4 instance if none was provided.
      *
      * @exception {DeveloperError} fovY must be in [0, PI).
      * @exception {DeveloperError} aspectRatio must be greater than zero.
      * @exception {DeveloperError} near must be greater than zero.
      * @exception {DeveloperError} far must be greater than zero.
      */
     Matrix4.computePerspectiveFieldOfView = function(fovY, aspectRatio, near, far, result) {
         if (fovY <= 0.0 || fovY > Math.PI) {
             throw new DeveloperError('fovY must be in [0, PI).');
         }

         if (aspectRatio <= 0.0) {
             throw new DeveloperError('aspectRatio must be greater than zero.');
         }

         if (near <= 0.0) {
             throw new DeveloperError('near must be greater than zero.');
         }

         if (far <= 0.0) {
             throw new DeveloperError('far must be greater than zero.');
         }

         var bottom = Math.tan(fovY * 0.5);

         var column1Row1 = 1.0 / bottom;
         var column0Row0 = column1Row1 / aspectRatio;
         var column2Row2 = (far + near) / (near - far);
         var column3Row2 = (2.0 * far * near) / (near - far);

         if (typeof result === 'undefined') {
             return new Matrix4(column0Row0, 0.0,         0.0,         0.0,
                                0.0,         column1Row1, 0.0,         0.0,
                                0.0,         0.0,         column2Row2, column3Row2,
                                0.0,         0.0,        -1.0,         0.0);
         }

         result[0] = column0Row0;
         result[1] = 0.0;
         result[2] = 0.0;
         result[3] = 0.0;
         result[4] = 0.0;
         result[5] = column1Row1;
         result[6] = 0.0;
         result[7] = 0.0;
         result[8] = 0.0;
         result[9] = 0.0;
         result[10] = column2Row2;
         result[11] = -1.0;
         result[12] = 0.0;
         result[13] = 0.0;
         result[14] = column3Row2;
         result[15] = 0.0;
         return result;
     };

    /**
    * Computes a Matrix4 instance representing an orthographic transformation matrix.
    * @memberof Matrix4
    *
    * @param {Number} left The number of meters to the left of the camera that will be in view.
    * @param {Number} right The number of meters to the right of the camera that will be in view.
    * @param {Number} bottom The number of meters below of the camera that will be in view.
    * @param {Number} top The number of meters above of the camera that will be in view.
    * @param {Number} near The distance to the near plane in meters.
    * @param {Number} far The distance to the far plane in meters.
    * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
    * @returns The modified result parameter, or a new Matrix4 instance if none was provided.
    *
    * @exception {DeveloperError} left is required.
    * @exception {DeveloperError} right is required.
    * @exception {DeveloperError} bottom is required.
    * @exception {DeveloperError} top is required.
    * @exception {DeveloperError} near is required.
    * @exception {DeveloperError} far is required.
    */
    Matrix4.computeOrthographicOffCenter = function(left, right, bottom, top, near, far, result) {
        if (typeof left === 'undefined') {
            throw new DeveloperError('left is required.');
        }
        if (typeof right === 'undefined') {
            throw new DeveloperError('right is required.');
        }
        if (typeof bottom === 'undefined') {
            throw new DeveloperError('bottom is required.');
        }
        if (typeof top === 'undefined') {
            throw new DeveloperError('top is required.');
        }
        if (typeof near === 'undefined') {
            throw new DeveloperError('near is required.');
        }
        if (typeof far === 'undefined') {
            throw new DeveloperError('far is required.');
        }

        var a = 1.0 / (right - left);
        var b = 1.0 / (top - bottom);
        var c = 1.0 / (far - near);

        var tx = -(right + left) * a;
        var ty = -(top + bottom) * b;
        var tz = -(far + near) * c;
        a *= 2.0;
        b *= 2.0;
        c *= -2.0;

        if (typeof result === 'undefined') {
            return new Matrix4(  a, 0.0, 0.0, tx,
                               0.0,   b, 0.0, ty,
                               0.0, 0.0,   c, tz,
                               0.0, 0.0, 0.0, 1.0);
        }

        result[0] = a;
        result[1] = 0.0;
        result[2] = 0.0;
        result[3] = 0.0;
        result[4] = 0.0;
        result[5] = b;
        result[6] = 0.0;
        result[7] = 0.0;
        result[8] = 0.0;
        result[9] = 0.0;
        result[10] = c;
        result[11] = 0.0;
        result[12] = tx;
        result[13] = ty;
        result[14] = tz;
        result[15] = 1.0;
        return result;
    };

    /**
     * Computes a Matrix4 instance representing an off center perspective transformation.
     * @memberof Matrix4
     *
     * @param {Number} left The number of meters to the left of the camera that will be in view.
     * @param {Number} right The number of meters to the right of the camera that will be in view.
     * @param {Number} bottom The number of meters below of the camera that will be in view.
     * @param {Number} top The number of meters above of the camera that will be in view.
     * @param {Number} near The distance to the near plane in meters.
     * @param {Number} far The distance to the far plane in meters.
     * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The modified result parameter, or a new Matrix4 instance if none was provided.
     *
     * @exception {DeveloperError} left is required.
     * @exception {DeveloperError} right is required.
     * @exception {DeveloperError} bottom is required.
     * @exception {DeveloperError} top is required.
     * @exception {DeveloperError} near is required.
     * @exception {DeveloperError} far is required.
     */
    Matrix4.computePerspectiveOffCenter = function(left, right, bottom, top, near, far, result) {
        if (typeof left === 'undefined') {
            throw new DeveloperError('left is required.');
        }
        if (typeof right === 'undefined') {
            throw new DeveloperError('right is required.');
        }
        if (typeof bottom === 'undefined') {
            throw new DeveloperError('bottom is required.');
        }
        if (typeof top === 'undefined') {
            throw new DeveloperError('top is required.');
        }
        if (typeof near === 'undefined') {
            throw new DeveloperError('near is required.');
        }
        if (typeof far === 'undefined') {
            throw new DeveloperError('far is required.');
        }

        var column0Row0 = 2.0 * near / (right - left);
        var column1Row1 = 2.0 * near / (top - bottom);
        var column2Row0 = (right + left) / (right - left);
        var column2Row1 = (top + bottom) / (top - bottom);
        var column2Row2 = -(far + near) / (far - near);
        var column2Row3 = -1.0;
        var column3Row2 = -2.0 * far * near / (far - near);

        if (typeof result === 'undefined') {
            return new Matrix4(column0Row0, 0.0,         column2Row0, 0.0,
                                       0.0, column1Row1, column2Row1, 0.0,
                                       0.0, 0.0,         column2Row2, column3Row2,
                                       0.0, 0.0,         column2Row3, 0.0);
        }

        result[0] = column0Row0;
        result[1] = 0.0;
        result[2] = 0.0;
        result[3] = 0.0;
        result[4] = 0.0;
        result[5] = column1Row1;
        result[6] = 0.0;
        result[7] = 0.0;
        result[8] = column2Row0;
        result[9] = column2Row1;
        result[10] = column2Row2;
        result[11] = column2Row3;
        result[12] = 0.0;
        result[13] = 0.0;
        result[14] = column3Row2;
        result[15] = 0.0;
        return result;
    };

    /**
     * Computes a Matrix4 instance representing an infinite off center perspective transformation.
     * @memberof Matrix4
     *
     * @param {Number} left The number of meters to the left of the camera that will be in view.
     * @param {Number} right The number of meters to the right of the camera that will be in view.
     * @param {Number} bottom The number of meters below of the camera that will be in view.
     * @param {Number} top The number of meters above of the camera that will be in view.
     * @param {Number} near The distance to the near plane in meters.
     * @param {Number} far The distance to the far plane in meters.
     * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The modified result parameter, or a new Matrix4 instance if none was provided.
     *
     * @exception {DeveloperError} left is required.
     * @exception {DeveloperError} right is required.
     * @exception {DeveloperError} bottom is required.
     * @exception {DeveloperError} top is required.
     * @exception {DeveloperError} near is required.
     */
    Matrix4.computeInfinitePerspectiveOffCenter = function(left, right, bottom, top, near, result) {
        if (typeof left === 'undefined') {
            throw new DeveloperError('left is required.');
        }
        if (typeof right === 'undefined') {
            throw new DeveloperError('right is required.');
        }
        if (typeof bottom === 'undefined') {
            throw new DeveloperError('bottom is required.');
        }
        if (typeof top === 'undefined') {
            throw new DeveloperError('top is required.');
        }
        if (typeof near === 'undefined') {
            throw new DeveloperError('near is required.');
        }

        var column0Row0 = 2.0 * near / (right - left);
        var column1Row1 = 2.0 * near / (top - bottom);
        var column2Row0 = (right + left) / (right - left);
        var column2Row1 = (top + bottom) / (top - bottom);
        var column2Row2 = -1.0;
        var column2Row3 = -1.0;
        var column3Row2 = -2.0 * near;

        if (typeof result === 'undefined') {
            return new Matrix4(column0Row0, 0.0,         column2Row0, 0.0,
                                       0.0, column1Row1, column2Row1, 0.0,
                                       0.0, 0.0,         column2Row2, column3Row2,
                                       0.0, 0.0,         column2Row3, 0.0);
        }

        result[0] = column0Row0;
        result[1] = 0.0;
        result[2] = 0.0;
        result[3] = 0.0;
        result[4] = 0.0;
        result[5] = column1Row1;
        result[6] = 0.0;
        result[7] = 0.0;
        result[8] = column2Row0;
        result[9] = column2Row1;
        result[10] = column2Row2;
        result[11] = column2Row3;
        result[12] = 0.0;
        result[13] = 0.0;
        result[14] = column3Row2;
        result[15] = 0.0;
        return result;
    };

    /**
     * Computes a Matrix4 instance that transforms from normalized device coordinates to window coordinates.
     * @memberof Matrix4
     *
     * @param {Object}[viewport = { x : 0.0, y : 0.0, width : 0.0, height : 0.0 }] The viewport's corners as shown in Example 1.
     * @param {Number}[nearDepthRange = 0.0] The near plane distance in window coordinates.
     * @param {Number}[farDepthRange = 1.0] The far plane distance in window coordinates.
     * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The modified result parameter, or a new Matrix4 instance if none was provided.
     *
     * @see agi_viewportTransformation
     * @see Context#getViewport
     *
     * @example
     * // Example 1.  Create viewport transformation using an explicit viewport and depth range.
     * var m = Matrix4.computeViewportTransformation({
     *     x : 0.0,
     *     y : 0.0,
     *     width : 1024.0,
     *     height : 768.0
     * }, 0.0, 1.0);
     *
     * // Example 2.  Create viewport transformation using the context's viewport.
     * var m = Matrix4.computeViewportTransformation(context.getViewport());
     */
    Matrix4.computeViewportTransformation = function(viewport, nearDepthRange, farDepthRange, result) {
        var v = viewport || {};
        v.x = v.x || 0.0;
        v.y = v.y || 0.0;
        v.width = v.width || 0.0;
        v.height = v.height || 0.0;
        nearDepthRange = nearDepthRange || 0.0;
        farDepthRange = (typeof farDepthRange === 'undefined') ? 1.0 : farDepthRange;

        var halfWidth = v.width * 0.5;
        var halfHeight = v.height * 0.5;
        var halfDepth = (farDepthRange - nearDepthRange) * 0.5;

        var column0Row0 = halfWidth;
        var column1Row1 = halfHeight;
        var column2Row2 = halfDepth;
        var column3Row0 = v.x + halfWidth;
        var column3Row1 = v.y + halfHeight;
        var column3Row2 = nearDepthRange + halfDepth;
        var column3Row3 = 1.0;

        if (typeof result === 'undefined') {
            return new Matrix4(column0Row0, 0.0,         0.0,         column3Row0,
                               0.0,         column1Row1, 0.0,         column3Row1,
                               0.0,         0.0,         column2Row2, column3Row2,
                               0.0,         0.0,         0.0,         column3Row3);
        }
        result[0] = column0Row0;
        result[1] = 0.0;
        result[2] = 0.0;
        result[3] = 0.0;
        result[4] = 0.0;
        result[5] = column1Row1;
        result[6] = 0.0;
        result[7] = 0.0;
        result[8] = 0.0;
        result[9] = 0.0;
        result[10] = column2Row2;
        result[11] = 0.0;
        result[12] = column3Row0;
        result[13] = column3Row1;
        result[14] = column3Row2;
        result[15] = column3Row3;
        return result;
    };

    /**
     * Computes an Array from the provided Matrix4 instance.
     * The array will be in column-major order.
     * @memberof Matrix4
     *
     * @param {Matrix4} matrix The matrix to use..
     * @param {Array} [result] The Array onto which to store the result.
     * @return {Array} The modified Array parameter or a new Array instance if none was provided.
     *
     * @exception {DeveloperError} matrix is required.
     */
    Matrix4.toArray = function(matrix, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required');
        }
        if (typeof result === 'undefined') {
            return [matrix[0], matrix[1], matrix[2], matrix[3],
                    matrix[4], matrix[5], matrix[6], matrix[7],
                    matrix[8], matrix[9], matrix[10], matrix[11],
                    matrix[12], matrix[13], matrix[14], matrix[15]];
        }
        result[0] = matrix[0];
        result[1] = matrix[1];
        result[2] = matrix[2];
        result[3] = matrix[3];
        result[4] = matrix[4];
        result[5] = matrix[5];
        result[6] = matrix[6];
        result[7] = matrix[7];
        result[8] = matrix[8];
        result[9] = matrix[9];
        result[10] = matrix[10];
        result[11] = matrix[11];
        result[12] = matrix[12];
        result[13] = matrix[13];
        result[14] = matrix[14];
        result[15] = matrix[15];
        return result;
    };

    /**
     * Retrieves a copy of the matrix column at the provided index as a Cartesian4 instance.
     * @memberof Matrix4
     *
     * @param {Matrix4} matrix The matrix to use.
     * @param {Number} index The zero-based index of the column to retrieve.
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The modified result parameter or a new Cartesian4 instance if none was provided.
     *
     * @exception {DeveloperError} matrix is required.
     * @exception {DeveloperError} index is required and must be 0, 1, 2, or 3.
     *
     * @see Cartesian4
     */
    Matrix4.getColumn = function(matrix, index, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required.');
        }

        if (typeof index !== 'number' || index < 0 || index > 3) {
            throw new DeveloperError('index is required and must be 0, 1, 2, or 3.');
        }

        var startIndex = index * 4;
        var x = matrix[startIndex];
        var y = matrix[startIndex + 1];
        var z = matrix[startIndex + 2];
        var w = matrix[startIndex + 3];

        if (typeof result === 'undefined') {
            return new Cartesian4(x, y, z, w);
        }
        result.x = x;
        result.y = y;
        result.z = z;
        result.w = w;
        return result;
    };

    /**
     * Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian4 instance.
     * @memberof Matrix4
     *
     * @param {Matrix4} matrix The matrix to use.
     * @param {Number} index The zero-based index of the column to set.
     * @param {Cartesian4} cartesian The Cartesian whose values will be assigned to the specified column.
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.
     *
     * @exception {DeveloperError} matrix is required.
     * @exception {DeveloperError} cartesian is required.
     * @exception {DeveloperError} index is required and must be 0, 1, 2, or 3.
     *
     * @see Cartesian4
     */
    Matrix4.setColumn = function(matrix, index, cartesian, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required');
        }
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        if (typeof index !== 'number' || index < 0 || index > 3) {
            throw new DeveloperError('index is required and must be 0, 1, 2, or 3.');
        }
        result = Matrix4.clone(matrix, result);
        var startIndex = index * 4;
        result[startIndex] = cartesian.x;
        result[startIndex + 1] = cartesian.y;
        result[startIndex + 2] = cartesian.z;
        result[startIndex + 3] = cartesian.w;
        return result;
    };

    /**
     * Retrieves a copy of the matrix row at the provided index as a Cartesian4 instance.
     * @memberof Matrix4
     *
     * @param {Matrix4} matrix The matrix to use.
     * @param {Number} index The zero-based index of the row to retrieve.
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The modified result parameter or a new Cartesian4 instance if none was provided.
     *
     * @exception {DeveloperError} matrix is required.
     * @exception {DeveloperError} index is required and must be 0, 1, 2, or 3.
     *
     * @see Cartesian4
     */
    Matrix4.getRow = function(matrix, index, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required.');
        }

        if (typeof index !== 'number' || index < 0 || index > 3) {
            throw new DeveloperError('index is required and must be 0, 1, 2, or 3.');
        }

        var x = matrix[index];
        var y = matrix[index + 4];
        var z = matrix[index + 8];
        var w = matrix[index + 12];

        if (typeof result === 'undefined') {
            return new Cartesian4(x, y, z, w);
        }
        result.x = x;
        result.y = y;
        result.z = z;
        result.w = w;
        return result;
    };

    /**
     * Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian4 instance.
     * @memberof Matrix4
     *
     * @param {Matrix4} matrix The matrix to use.
     * @param {Number} index The zero-based index of the row to set.
     * @param {Cartesian4} cartesian The Cartesian whose values will be assigned to the specified row.
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.
     *
     * @exception {DeveloperError} matrix is required.
     * @exception {DeveloperError} cartesian is required.
     * @exception {DeveloperError} index is required and must be 0, 1, 2, or 3.
     *
     * @see Cartesian4
     */
    Matrix4.setRow = function(matrix, index, cartesian, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required');
        }
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }
        if (typeof index !== 'number' || index < 0 || index > 3) {
            throw new DeveloperError('index is required and must be 0, 1, 2, or 3.');
        }

        result = Matrix4.clone(matrix, result);
        result[index] = cartesian.x;
        result[index + 4] = cartesian.y;
        result[index + 8] = cartesian.z;
        result[index + 12] = cartesian.w;
        return result;
    };

    /**
     * Computes the product of two matrices.
     * @memberof Matrix4
     *
     * @param {Matrix4} left The first matrix.
     * @param {Matrix4} right The second matrix.
     * @param {Matrix4} [result] The object onto which to store the result.
     * @return {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.
     *
     * @exception {DeveloperError} left is required.
     * @exception {DeveloperError} right is required.
     */
    Matrix4.multiply = function(left, right, result) {
        if (typeof left === 'undefined') {
            throw new DeveloperError('left is required');
        }
        if (typeof right === 'undefined') {
            throw new DeveloperError('right is required');
        }

        var left0 = left[0];
        var left1 = left[1];
        var left2 = left[2];
        var left3 = left[3];
        var left4 = left[4];
        var left5 = left[5];
        var left6 = left[6];
        var left7 = left[7];
        var left8 = left[8];
        var left9 = left[9];
        var left10 = left[10];
        var left11 = left[11];
        var left12 = left[12];
        var left13 = left[13];
        var left14 = left[14];
        var left15 = left[15];

        var right0 = right[0];
        var right1 = right[1];
        var right2 = right[2];
        var right3 = right[3];
        var right4 = right[4];
        var right5 = right[5];
        var right6 = right[6];
        var right7 = right[7];
        var right8 = right[8];
        var right9 = right[9];
        var right10 = right[10];
        var right11 = right[11];
        var right12 = right[12];
        var right13 = right[13];
        var right14 = right[14];
        var right15 = right[15];

        var column0Row0 = left0 * right0 + left4 * right1 + left8 * right2 + left12 * right3;
        var column0Row1 = left1 * right0 + left5 * right1 + left9 * right2 + left13 * right3;
        var column0Row2 = left2 * right0 + left6 * right1 + left10 * right2 + left14 * right3;
        var column0Row3 = left3 * right0 + left7 * right1 + left11 * right2 + left15 * right3;

        var column1Row0 = left0 * right4 + left4 * right5 + left8 * right6 + left12 * right7;
        var column1Row1 = left1 * right4 + left5 * right5 + left9 * right6 + left13 * right7;
        var column1Row2 = left2 * right4 + left6 * right5 + left10 * right6 + left14 * right7;
        var column1Row3 = left3 * right4 + left7 * right5 + left11 * right6 + left15 * right7;

        var column2Row0 = left0 * right8 + left4 * right9 + left8 * right10 + left12 * right11;
        var column2Row1 = left1 * right8 + left5 * right9 + left9 * right10 + left13 * right11;
        var column2Row2 = left2 * right8 + left6 * right9 + left10 * right10 + left14 * right11;
        var column2Row3 = left3 * right8 + left7 * right9 + left11 * right10 + left15 * right11;

        var column3Row0 = left0 * right12 + left4 * right13 + left8 * right14 + left12 * right15;
        var column3Row1 = left1 * right12 + left5 * right13 + left9 * right14 + left13 * right15;
        var column3Row2 = left2 * right12 + left6 * right13 + left10 * right14 + left14 * right15;
        var column3Row3 = left3 * right12 + left7 * right13 + left11 * right14 + left15 * right15;

        if (typeof result === 'undefined') {
            return new Matrix4(column0Row0, column1Row0, column2Row0, column3Row0,
                               column0Row1, column1Row1, column2Row1, column3Row1,
                               column0Row2, column1Row2, column2Row2, column3Row2,
                               column0Row3, column1Row3, column2Row3, column3Row3);
        }
        result[0] = column0Row0;
        result[1] = column0Row1;
        result[2] = column0Row2;
        result[3] = column0Row3;
        result[4] = column1Row0;
        result[5] = column1Row1;
        result[6] = column1Row2;
        result[7] = column1Row3;
        result[8] = column2Row0;
        result[9] = column2Row1;
        result[10] = column2Row2;
        result[11] = column2Row3;
        result[12] = column3Row0;
        result[13] = column3Row1;
        result[14] = column3Row2;
        result[15] = column3Row3;
        return result;
    };

    /**
     * Computes the product of a matrix and a column vector.
     * @memberof Matrix4
     *
     * @param {Matrix4} matrix The matrix.
     * @param {Cartesian4} cartesian The column.
     * @param {Matrix4} [result] The object onto which to store the result.
     * @return {Matrix4} The modified result parameter or a new Cartesian4 instance if none was provided.
     *
     * @exception {DeveloperError} matrix is required.
     * @exception {DeveloperError} cartesian is required.
     */
    Matrix4.multiplyByVector = function(matrix, cartesian, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required');
        }
        if (typeof cartesian === 'undefined') {
            throw new DeveloperError('cartesian is required');
        }

        var vX = cartesian.x;
        var vY = cartesian.y;
        var vZ = cartesian.z;
        var vW = cartesian.w;

        var x = matrix[0] * vX + matrix[4] * vY + matrix[8] * vZ + matrix[12] * vW;
        var y = matrix[1] * vX + matrix[5] * vY + matrix[9] * vZ + matrix[13] * vW;
        var z = matrix[2] * vX + matrix[6] * vY + matrix[10] * vZ + matrix[14] * vW;
        var w = matrix[3] * vX + matrix[7] * vY + matrix[11] * vZ + matrix[15] * vW;

        if (typeof result === 'undefined') {
            return new Cartesian4(x, y, z, w);
        }
        result.x = x;
        result.y = y;
        result.z = z;
        result.w = w;
        return result;
    };

    /**
     * Computes the product of a matrix and a scalar.
     * @memberof Matrix4
     *
     * @param {Matrix4} matrix The matrix.
     * @param {Number} scalar The number to multiply by.
     * @param {Matrix4} [result] The object onto which to store the result.
     * @return {Matrix4} The modified result parameter or a new Cartesian4 instance if none was provided.
     *
     * @exception {DeveloperError} matrix is required.
     * @exception {DeveloperError} scalar is required and must be a number.
     */
    Matrix4.multiplyByScalar = function(matrix, scalar, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required');
        }
        if (typeof scalar !== 'number') {
            throw new DeveloperError('scalar is required and must be a number');
        }

        if (typeof result === 'undefined') {
            return new Matrix4(matrix[0] * scalar, matrix[4] * scalar, matrix[8] * scalar, matrix[12] * scalar,
                               matrix[1] * scalar, matrix[5] * scalar, matrix[9] * scalar, matrix[13] * scalar,
                               matrix[2] * scalar, matrix[6] * scalar, matrix[10] * scalar, matrix[14] * scalar,
                               matrix[3] * scalar, matrix[7] * scalar, matrix[11] * scalar, matrix[15] * scalar);
        }
        result[0] = matrix[0] * scalar;
        result[1] = matrix[1] * scalar;
        result[2] = matrix[2] * scalar;
        result[3] = matrix[3] * scalar;
        result[4] = matrix[4] * scalar;
        result[5] = matrix[5] * scalar;
        result[6] = matrix[6] * scalar;
        result[7] = matrix[7] * scalar;
        result[8] = matrix[8] * scalar;
        result[9] = matrix[9] * scalar;
        result[10] = matrix[10] * scalar;
        result[11] = matrix[11] * scalar;
        result[12] = matrix[12] * scalar;
        result[13] = matrix[13] * scalar;
        result[14] = matrix[14] * scalar;
        result[15] = matrix[15] * scalar;
        return result;
    };

    /**
     * Computes a negated copy of the provided matrix.
     * @memberof Matrix4
     *
     * @param {Matrix4} matrix The matrix to negate.
     * @param {Matrix4} [result] The object onto which to store the result.
     * @return {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.
     *
     * @exception {DeveloperError} matrix is required.
     */
    Matrix4.negate = function(matrix, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required');
        }

        if (typeof result === 'undefined') {
            return new Matrix4(-matrix[0], -matrix[4], -matrix[8], -matrix[12],
                               -matrix[1], -matrix[5], -matrix[9], -matrix[13],
                               -matrix[2], -matrix[6], -matrix[10], -matrix[14],
                               -matrix[3], -matrix[7], -matrix[11], -matrix[15]);
        }
        result[0] = -matrix[0];
        result[1] = -matrix[1];
        result[2] = -matrix[2];
        result[3] = -matrix[3];
        result[4] = -matrix[4];
        result[5] = -matrix[5];
        result[6] = -matrix[6];
        result[7] = -matrix[7];
        result[8] = -matrix[8];
        result[9] = -matrix[9];
        result[10] = -matrix[10];
        result[11] = -matrix[11];
        result[12] = -matrix[12];
        result[13] = -matrix[13];
        result[14] = -matrix[14];
        result[15] = -matrix[15];
        return result;
    };

    /**
     * Computes the transpose of the provided matrix.
     * @memberof Matrix4
     *
     * @param {Matrix4} matrix The matrix to transpose.
     * @param {Matrix4} [result] The object onto which to store the result.
     * @return {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.
     *
     * @exception {DeveloperError} matrix is required.
     */
    Matrix4.transpose = function(matrix, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required');
        }
        if (typeof result === 'undefined') {
            return new Matrix4(matrix[0], matrix[1], matrix[2], matrix[3],
                               matrix[4], matrix[5], matrix[6], matrix[7],
                               matrix[8], matrix[9], matrix[10], matrix[11],
                               matrix[12], matrix[13], matrix[14], matrix[15]);
        }

        var matrix1 = matrix[1];
        var matrix2 = matrix[2];
        var matrix3 = matrix[3];
        var matrix6 = matrix[6];
        var matrix7 = matrix[7];
        var matrix11 = matrix[11];

        result[0] = matrix[0];
        result[1] = matrix[4];
        result[2] = matrix[8];
        result[3] = matrix[12];
        result[4] = matrix1;
        result[5] = matrix[5];
        result[6] = matrix[9];
        result[7] = matrix[13];
        result[8] = matrix2;
        result[9] = matrix6;
        result[10] = matrix[10];
        result[11] = matrix[14];
        result[12] = matrix3;
        result[13] = matrix7;
        result[14] = matrix11;
        result[15] = matrix[15];
        return result;
    };

    /**
     * Compares the provided matrices componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @memberof Matrix4
     *
     * @param {Matrix4} [left] The first matrix.
     * @param {Matrix4} [right] The second matrix.
     * @return {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    Matrix4.equals = function(left, right) {
        return (left === right) ||
               (typeof left !== 'undefined' &&
                typeof right !== 'undefined' &&
                left[0] === right[0] &&
                left[1] === right[1] &&
                left[2] === right[2] &&
                left[3] === right[3] &&
                left[4] === right[4] &&
                left[5] === right[5] &&
                left[6] === right[6] &&
                left[7] === right[7] &&
                left[8] === right[8] &&
                left[9] === right[9] &&
                left[10] === right[10] &&
                left[11] === right[11] &&
                left[12] === right[12] &&
                left[13] === right[13] &&
                left[14] === right[14] &&
                left[15] === right[15]);
    };

    /**
     * Compares the provided matrices componentwise and returns
     * <code>true</code> if they are within the provided epsilon,
     * <code>false</code> otherwise.
     * @memberof Matrix4
     *
     * @param {Matrix4} [left] The first matrix.
     * @param {Matrix4} [right] The second matrix.
     * @param {Number} epsilon The epsilon to use for equality testing.
     * @return {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
     *
     * @exception {DeveloperError} epsilon is required and must be a number.
     */
    Matrix4.equalsEpsilon = function(left, right, epsilon) {
        if (typeof epsilon !== 'number') {
            throw new DeveloperError('epsilon is required and must be a number');
        }

        return (left === right) ||
                (typeof left !== 'undefined' &&
                typeof right !== 'undefined' &&
                Math.abs(left[0] - right[0]) <= epsilon &&
                Math.abs(left[1] - right[1]) <= epsilon &&
                Math.abs(left[2] - right[2]) <= epsilon &&
                Math.abs(left[3] - right[3]) <= epsilon &&
                Math.abs(left[4] - right[4]) <= epsilon &&
                Math.abs(left[5] - right[5]) <= epsilon &&
                Math.abs(left[6] - right[6]) <= epsilon &&
                Math.abs(left[7] - right[7]) <= epsilon &&
                Math.abs(left[8] - right[8]) <= epsilon &&
                Math.abs(left[9] - right[9]) <= epsilon &&
                Math.abs(left[10] - right[10]) <= epsilon &&
                Math.abs(left[11] - right[11]) <= epsilon &&
                Math.abs(left[12] - right[12]) <= epsilon &&
                Math.abs(left[13] - right[13]) <= epsilon &&
                Math.abs(left[14] - right[14]) <= epsilon &&
                Math.abs(left[15] - right[15]) <= epsilon);
    };

    /**
     * Gets the translation portion of the provided matrix, assuming the matrix is a affine transformation matrix.
     * @memberof Matrix4
     *
     * @param {Matrix4} matrix The matrix to use.
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
     *
     * @exception {DeveloperError} matrix is required.
     *
     * @see Cartesian3
     */
    Matrix4.getTranslation = function(matrix, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required');
        }
        if (typeof result === 'undefined') {
            return new Cartesian3(matrix[12], matrix[13], matrix[14]);
        }
        result.x = matrix[12];
        result.y = matrix[13];
        result.z = matrix[14];
        return result;
    };

    /**
     * Gets the upper left 3x3 rotation matrix of the provided matrix, assuming the matrix is a affine transformation matrix.
     * @memberof Matrix4
     *
     * @param {Matrix4} matrix The matrix to use.
     * @param {Matrix3} [result] The object onto which to store the result.
     * @return {Matrix3} The modified result parameter or a new Cartesian3 instance if none was provided.
     *
     * @exception {DeveloperError} matrix is required.
     *
     * @see Matrix3
     */
     Matrix4.getRotation = function(matrix, result) {
         if (typeof matrix === 'undefined') {
             throw new DeveloperError('matrix is required');
         }
         if (typeof result === 'undefined') {
             return new Matrix3(matrix[0], matrix[4], matrix[8],
                                matrix[1], matrix[5], matrix[9],
                                matrix[2], matrix[6], matrix[10]);
         }
         result[0] = matrix[0];
         result[1] = matrix[1];
         result[2] = matrix[2];
         result[3] = matrix[4];
         result[4] = matrix[5];
         result[5] = matrix[6];
         result[6] = matrix[8];
         result[7] = matrix[9];
         result[8] = matrix[10];
         return result;
     };

     /**
      * Computes the inverse of the provided matrix using Cramers Rule.
      * If the determinant is zero, the matrix can not be inverted, and an exception is thrown.
      * If the matrix is an affine transformation matrix, it is more efficient
      * to invert it with {@link #inverseTransformation}.
      * @memberof Matrix4
      *
      * @param {Matrix4} matrix The matrix to invert.
      * @param {Matrix4} [result] The object onto which to store the result.
      * @return {Matrix4} The modified result parameter or a new Cartesian3 instance if none was provided.
      *
      * @exception {DeveloperError} matrix is required.
      * @exception {RuntimeError} matrix is not invertible because its determinate is zero.
      */
    Matrix4.inverse = function(matrix, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required');
        }

        //
        // Ported from:
        //   ftp://download.intel.com/design/PentiumIII/sml/24504301.pdf
        //
        var src0 = matrix[0];
        var src1 = matrix[4];
        var src2 = matrix[8];
        var src3 = matrix[12];
        var src4 = matrix[1];
        var src5 = matrix[5];
        var src6 = matrix[9];
        var src7 = matrix[13];
        var src8 = matrix[2];
        var src9 = matrix[6];
        var src10 = matrix[10];
        var src11 = matrix[14];
        var src12 = matrix[3];
        var src13 = matrix[7];
        var src14 = matrix[11];
        var src15 = matrix[15];

        // calculate pairs for first 8 elements (cofactors)
        var tmp0 = src10 * src15;
        var tmp1 = src11 * src14;
        var tmp2 = src9 * src15;
        var tmp3 = src11 * src13;
        var tmp4 = src9 * src14;
        var tmp5 = src10 * src13;
        var tmp6 = src8 * src15;
        var tmp7 = src11 * src12;
        var tmp8 = src8 * src14;
        var tmp9 = src10 * src12;
        var tmp10 = src8 * src13;
        var tmp11 = src9 * src12;

        // calculate first 8 elements (cofactors)
        var dst0 = (tmp0 * src5 + tmp3 * src6 + tmp4 * src7) - (tmp1 * src5 + tmp2 * src6 + tmp5 * src7);
        var dst1 = (tmp1 * src4 + tmp6 * src6 + tmp9 * src7) - (tmp0 * src4 + tmp7 * src6 + tmp8 * src7);
        var dst2 = (tmp2 * src4 + tmp7 * src5 + tmp10 * src7) - (tmp3 * src4 + tmp6 * src5 + tmp11 * src7);
        var dst3 = (tmp5 * src4 + tmp8 * src5 + tmp11 * src6) - (tmp4 * src4 + tmp9 * src5 + tmp10 * src6);
        var dst4 = (tmp1 * src1 + tmp2 * src2 + tmp5 * src3) - (tmp0 * src1 + tmp3 * src2 + tmp4 * src3);
        var dst5 = (tmp0 * src0 + tmp7 * src2 + tmp8 * src3) - (tmp1 * src0 + tmp6 * src2 + tmp9 * src3);
        var dst6 = (tmp3 * src0 + tmp6 * src1 + tmp11 * src3) - (tmp2 * src0 + tmp7 * src1 + tmp10 * src3);
        var dst7 = (tmp4 * src0 + tmp9 * src1 + tmp10 * src2) - (tmp5 * src0 + tmp8 * src1 + tmp11 * src2);

        // calculate pairs for second 8 elements (cofactors)
        tmp0 = src2 * src7;
        tmp1 = src3 * src6;
        tmp2 = src1 * src7;
        tmp3 = src3 * src5;
        tmp4 = src1 * src6;
        tmp5 = src2 * src5;
        tmp6 = src0 * src7;
        tmp7 = src3 * src4;
        tmp8 = src0 * src6;
        tmp9 = src2 * src4;
        tmp10 = src0 * src5;
        tmp11 = src1 * src4;

        // calculate second 8 elements (cofactors)
        var dst8 = (tmp0 * src13 + tmp3 * src14 + tmp4 * src15) - (tmp1 * src13 + tmp2 * src14 + tmp5 * src15);
        var dst9 = (tmp1 * src12 + tmp6 * src14 + tmp9 * src15) - (tmp0 * src12 + tmp7 * src14 + tmp8 * src15);
        var dst10 = (tmp2 * src12 + tmp7 * src13 + tmp10 * src15) - (tmp3 * src12 + tmp6 * src13 + tmp11 * src15);
        var dst11 = (tmp5 * src12 + tmp8 * src13 + tmp11 * src14) - (tmp4 * src12 + tmp9 * src13 + tmp10 * src14);
        var dst12 = (tmp2 * src10 + tmp5 * src11 + tmp1 * src9) - (tmp4 * src11 + tmp0 * src9 + tmp3 * src10);
        var dst13 = (tmp8 * src11 + tmp0 * src8 + tmp7 * src10) - (tmp6 * src10 + tmp9 * src11 + tmp1 * src8);
        var dst14 = (tmp6 * src9 + tmp11 * src11 + tmp3 * src8) - (tmp10 * src11 + tmp2 * src8 + tmp7 * src9);
        var dst15 = (tmp10 * src10 + tmp4 * src8 + tmp9 * src9) - (tmp8 * src9 + tmp11 * src10 + tmp5 * src8);

        // calculate determinant
        var det = src0 * dst0 + src1 * dst1 + src2 * dst2 + src3 * dst3;

        if (Math.abs(det) < CesiumMath.EPSILON20) {
            throw new RuntimeError('matrix is not invertible because its determinate is zero.');
        }

        // calculate matrix inverse
        det = 1.0 / det;
        if (typeof result === 'undefined') {
            return new Matrix4(dst0 * det, dst4 * det, dst8 * det, dst12 * det,
                               dst1 * det, dst5 * det, dst9 * det, dst13 * det,
                               dst2 * det, dst6 * det, dst10 * det, dst14 * det,
                               dst3 * det, dst7 * det, dst11 * det, dst15 * det);
        }

        result[0] = dst0 * det;
        result[1] = dst1 * det;
        result[2] = dst2 * det;
        result[3] = dst3 * det;
        result[4] = dst4 * det;
        result[5] = dst5 * det;
        result[6] = dst6 * det;
        result[7] = dst7 * det;
        result[8] = dst8 * det;
        result[9] = dst9 * det;
        result[10] = dst10 * det;
        result[11] = dst11 * det;
        result[12] = dst12 * det;
        result[13] = dst13 * det;
        result[14] = dst14 * det;
        result[15] = dst15 * det;
        return result;
    };

    /**
     * Computes the inverse of the provided matrix assuming it is
     * an affine transformation matrix, where the upper left 3x3 elements
     * are a rotation matrix, and the upper three elements in the fourth
     * column are the translation.  The bottom row is assumed to be [0, 0, 0, 1].
     * The matrix is not verified to be in the proper form.
     * This method is faster than computing the inverse for a general 4x4
     * matrix using {@link #inverse}.
     * @memberof Matrix4
     *
     * @param {Matrix4} matrix The matrix to invert.
     * @param {Matrix4} [result] The object onto which to store the result.
     * @return {Matrix4} The modified result parameter or a new Cartesian3 instance if none was provided.
     *
     * @exception {DeveloperError} matrix is required.
     */
    Matrix4.inverseTransformation = function(matrix, result) {
        if (typeof matrix === 'undefined') {
            throw new DeveloperError('matrix is required');
        }

        //This function is an optimized version of the below 4 lines.
        //var rT = Matrix3.transpose(Matrix4.getRotation(matrix));
        //var rTN = Matrix3.negate(rT);
        //var rTT = Matrix3.multiplyByVector(rTN, Matrix4.getTranslation(matrix));
        //return Matrix4.fromRotationTranslation(rT, rTT, result);

        var matrix0 = matrix[0];
        var matrix1 = matrix[1];
        var matrix2 = matrix[2];
        var matrix4 = matrix[4];
        var matrix5 = matrix[5];
        var matrix6 = matrix[6];
        var matrix8 = matrix[8];
        var matrix9 = matrix[9];
        var matrix10 = matrix[10];

        var vX = matrix[12];
        var vY = matrix[13];
        var vZ = matrix[14];

        var x = -matrix0 * vX - matrix1 * vY - matrix2 * vZ;
        var y = -matrix4 * vX - matrix5 * vY - matrix6 * vZ;
        var z = -matrix8 * vX - matrix9 * vY - matrix10 * vZ;

        if (typeof result === 'undefined') {
            return new Matrix4(matrix0, matrix1, matrix2,  x,
                               matrix4, matrix5, matrix6,  y,
                               matrix8, matrix9, matrix10, z,
                               0.0,         0.0,      0.0, 1.0);
        }
        result[0] = matrix0;
        result[1] = matrix4;
        result[2] = matrix8;
        result[3] = 0.0;
        result[4] = matrix1;
        result[5] = matrix5;
        result[6] = matrix9;
        result[7] = 0.0;
        result[8] = matrix2;
        result[9] = matrix6;
        result[10] = matrix10;
        result[11] = 0.0;
        result[12] = x;
        result[13] = y;
        result[14] = z;
        result[15] = 1.0;
        return result;
    };

    /**
     * An immutable Matrix4 instance initialized to the identity matrix.
     * @memberof Matrix4
     */
    Matrix4.IDENTITY = Object.freeze(new Matrix4(1.0, 0.0, 0.0, 0.0,
                                                 0.0, 1.0, 0.0, 0.0,
                                                 0.0, 0.0, 1.0, 0.0,
                                                 0.0, 0.0, 0.0, 1.0));

    /**
     * The index into Matrix4 for column 0, row 0.
     * @memberof Matrix4
     */
    Matrix4.COLUMN0ROW0 = 0;

    /**
     * The index into Matrix4 for column 0, row 1.
     * @memberof Matrix4
     */
    Matrix4.COLUMN0ROW1 = 1;

    /**
     * The index into Matrix4 for column 0, row 2.
     * @memberof Matrix4
     */
    Matrix4.COLUMN0ROW2 = 2;

    /**
     * The index into Matrix4 for column 0, row 3.
     * @memberof Matrix4
     */
    Matrix4.COLUMN0ROW3 = 3;

    /**
     * The index into Matrix4 for column 1, row 0.
     * @memberof Matrix4
     */
    Matrix4.COLUMN1ROW0 = 4;

    /**
     * The index into Matrix4 for column 1, row 1.
     * @memberof Matrix4
     */
    Matrix4.COLUMN1ROW1 = 5;

    /**
     * The index into Matrix4 for column 1, row 2.
     * @memberof Matrix4
     */
    Matrix4.COLUMN1ROW2 = 6;

    /**
     * The index into Matrix4 for column 1, row 3.
     * @memberof Matrix4
     */
    Matrix4.COLUMN1ROW3 = 7;

    /**
     * The index into Matrix4 for column 2, row 0.
     * @memberof Matrix4
     */
    Matrix4.COLUMN2ROW0 = 8;

    /**
     * The index into Matrix4 for column 2, row 1.
     * @memberof Matrix4
     */
    Matrix4.COLUMN2ROW1 = 9;

    /**
     * The index into Matrix4 for column 2, row 2.
     * @memberof Matrix4
     */
    Matrix4.COLUMN2ROW2 = 10;

    /**
     * The index into Matrix4 for column 2, row 3.
     * @memberof Matrix4
     */
    Matrix4.COLUMN2ROW3 = 11;

    /**
     * The index into Matrix4 for column 3, row 0.
     * @memberof Matrix4
     */
    Matrix4.COLUMN3ROW0 = 12;

    /**
     * The index into Matrix4 for column 3, row 1.
     * @memberof Matrix4
     */
    Matrix4.COLUMN3ROW1 = 13;

    /**
     * The index into Matrix4 for column 3, row 2.
     * @memberof Matrix4
     */
    Matrix4.COLUMN3ROW2 = 14;

    /**
     * The index into Matrix4 for column 3, row 3.
     * @memberof Matrix4
     */
    Matrix4.COLUMN3ROW3 = 15;

    /**
     * Duplicates the provided Matrix4 instance.
     * @memberof Matrix4
     *
     * @param {Matrix4} [result] The object onto which to store the result.
     * @return {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.
     */
    Matrix4.prototype.clone = function(result) {
        return Matrix4.clone(this, result);
    };

    /**
     * Computes an Array from this Matrix4 instance.
     * @memberof Matrix4
     *
     * @param {Array} [result] The Array onto which to store the result.
     * @return {Array} The modified Array parameter or a new Array instance if none was provided.
     */
    Matrix4.prototype.toArray = function(result) {
        return Matrix4.toArray(this, result);
    };

    /**
     * Retrieves a copy of the matrix column at the provided index as a Cartesian4 instance.
     * @memberof Matrix4
     *
     * @param {Number} index The zero-based index of the column to retrieve.
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The modified result parameter or a new Cartesian4 instance if none was provided.
     *
     * @exception {DeveloperError} index is required and must be 0, 1, 2, or 3.
     *
     * @see Cartesian4
     */
    Matrix4.prototype.getColumn = function(index, result) {
        return Matrix4.getColumn(this, index, result);
    };

    /**
     * Computes a new matrix that replaces the specified column in this matrix with the provided Cartesian4 instance.
     * @memberof Matrix4
     *
     * @param {Number} index The zero-based index of the column to set.
     * @param {Cartesian4} cartesian The Cartesian whose values will be assigned to the specified column.
     *
     * @exception {DeveloperError} cartesian is required.
     * @exception {DeveloperError} index is required and must be 0, 1, 2, or 3.
     *
     * @see Cartesian4
     */
    Matrix4.prototype.setColumn = function(index, cartesian, result) {
        return Matrix4.setColumn(this, index, cartesian, result);
    };

    /**
     * Retrieves a copy of the matrix row at the provided index as a Cartesian4 instance.
     * @memberof Matrix4
     *
     * @param {Number} index The zero-based index of the row to retrieve.
     * @param {Cartesian4} [result] The object onto which to store the result.
     * @return {Cartesian4} The modified result parameter or a new Cartesian4 instance if none was provided.
     *
     * @exception {DeveloperError} index is required and must be 0, 1, 2, or 3.
     *
     * @see Cartesian4
     */
    Matrix4.prototype.getRow = function(index, result) {
        return Matrix4.getRow(this, index, result);
    };

    /**
     * Computes a new matrix that replaces the specified row in this matrix with the provided Cartesian4 instance.
     * @memberof Matrix4
     *
     * @param {Number} index The zero-based index of the row to set.
     * @param {Cartesian4} cartesian The Cartesian whose values will be assigned to the specified row.
     *
     * @exception {DeveloperError} cartesian is required.
     * @exception {DeveloperError} index is required and must be 0, 1, 2, or 3.
     *
     * @see Cartesian4
     */
    Matrix4.prototype.setRow = function(index, cartesian, result) {
        return Matrix4.setRow(this, index, cartesian, result);
    };

    /**
     * Computes the product of this matrix and the provided matrix.
     * @memberof Matrix4
     *
     * @param {Matrix4} right The right hand side matrix.
     * @param {Matrix4} [result] The object onto which to store the result.
     * @return {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.
     *
     * @exception {DeveloperError} right is required.
     */
    Matrix4.prototype.multiply = function(right, result) {
        return Matrix4.multiply(this, right, result);
    };

    /**
     * Computes the product of this matrix and a column vector.
     * @memberof Matrix4
     *
     * @param {Cartesian4} cartesian The column.
     * @param {Matrix4} [result] The object onto which to store the result.
     * @return {Matrix4} The modified result parameter or a new Cartesian4 instance if none was provided.
     *
     * @exception {DeveloperError} cartesian is required.
     */
    Matrix4.prototype.multiplyByVector = function(cartesian, result) {
        return Matrix4.multiplyByVector(this, cartesian, result);
    };

    /**
     * Computes the product of this matrix and a scalar.
     * @memberof Matrix4
     *
     * @param {Number} scalar The number to multiply by.
     * @param {Matrix4} [result] The object onto which to store the result.
     * @return {Matrix4} The modified result parameter or a new Cartesian4 instance if none was provided.
     *
     * @exception {DeveloperError} scalar is required and must be a number.
     */
    Matrix4.prototype.multiplyByScalar = function(scalar, result) {
        return Matrix4.multiplyByScalar(this, scalar, result);
    };
    /**
     * Computes a negated copy of this matrix.
     * @memberof Matrix4
     *
     * @param {Matrix4} matrix The matrix to negate.
     * @param {Matrix4} [result] The object onto which to store the result.
     * @return {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.
     *
     * @exception {DeveloperError} matrix is required.
     */
    Matrix4.prototype.negate = function(result) {
        return Matrix4.negate(this, result);
    };

    /**
     * Computes the transpose of this matrix.
     * @memberof Matrix4
     *
     * @param {Matrix4} [result] The object onto which to store the result.
     * @return {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.
     */
    Matrix4.prototype.transpose = function(result) {
        return Matrix4.transpose(this, result);
    };

    /**
     * Compares this matrix to the provided matrix componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @memberof Matrix4
     *
     * @param {Matrix4} [right] The right hand side matrix.
     * @return {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
     */
    Matrix4.prototype.equals = function(right) {
        return Matrix4.equals(this, right);
    };

    /**
     * Compares this matrix to the provided matrix componentwise and returns
     * <code>true</code> if they are within the provided epsilon,
     * <code>false</code> otherwise.
     * @memberof Matrix4
     *
     * @param {Matrix4} [right] The right hand side matrix.
     * @param {Number} epsilon The epsilon to use for equality testing.
     * @return {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
     *
     * @exception {DeveloperError} epsilon is required and must be a number.
     */
    Matrix4.prototype.equalsEpsilon = function(right, epsilon) {
        return Matrix4.equalsEpsilon(this, right, epsilon);
    };

    /**
     * Computes a string representing this Matrix with each row being
     * on a separate line and in the format '(column0, column1, column2, column3)'.
     * @memberof Matrix4
     *
     * @return {String} A string representing the provided Matrix with each row being on a separate line and in the format '(column0, column1, column2, column3)'.
     */
    Matrix4.prototype.toString = function() {
        return '(' + this[0] + ', ' + this[4] + ', ' + this[8] + ', ' + this[12] +')\n' +
               '(' + this[1] + ', ' + this[5] + ', ' + this[9] + ', ' + this[13] +')\n' +
               '(' + this[2] + ', ' + this[6] + ', ' + this[10] + ', ' + this[14] +')\n' +
               '(' + this[3] + ', ' + this[7] + ', ' + this[11] + ', ' + this[15] +')';
    };

    /**
     * Gets the translation portion of this matrix, assuming the matrix is a affine transformation matrix.
     * @memberof Matrix4
     *
     * @param {Cartesian3} [result] The object onto which to store the result.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
     *
     * @see Cartesian3
     */
    Matrix4.prototype.getTranslation = function(result) {
        return Matrix4.getTranslation(this, result);
    };

    /**
     * Gets the upper left 3x3 rotation matrix of this matrix, assuming the matrix is a affine transformation matrix.
     * @memberof Matrix4
     *
     * @param {Matrix3} [result] The object onto which to store the result.
     * @return {Matrix3} The modified result parameter or a new Cartesian3 instance if none was provided.
     *
     * @see Matrix3
     */
    Matrix4.prototype.getRotation = function(result) {
        return Matrix4.getRotation(this, result);
    };

    /**
     * Computes the inverse of this matrix using Cramers Rule.
     * If the determinant is zero, the matrix can not be inverted, and an exception is thrown.
     * If the matrix is an affine transformation matrix, it is more efficient
     * to invert it with {@link #inverseTransformation}.
     * @memberof Matrix4
     *
     * @param {Matrix4} [result] The object onto which to store the result.
     * @return {Matrix4} The modified result parameter or a new Cartesian3 instance if none was provided.
     *
     * @exception {RuntimeError} matrix is not invertible because its determinate is zero.
     */
    Matrix4.prototype.inverse = function(result) {
        return Matrix4.inverse(this, result);
    };

    /**
     * Computes the inverse of this matrix assuming it is
     * an affine transformation matrix, where the upper left 3x3 elements
     * are a rotation matrix, and the upper three elements in the fourth
     * column are the translation.  The bottom row is assumed to be [0, 0, 0, 1].
     * The matrix is not verified to be in the proper form.
     * This method is faster than computing the inverse for a general 4x4
     * matrix using {@link #inverse}.
     * @memberof Matrix4
     *
     * @param {Matrix4} [result] The object onto which to store the result.
     * @return {Matrix4} The modified result parameter or a new Cartesian3 instance if none was provided.
     */
    Matrix4.prototype.inverseTransformation = function(result) {
        return Matrix4.inverseTransformation(this, result);
    };

    return Matrix4;
});

/*global define*/
define('Core/Spherical',[],function() {
    

    /**
     * A set of curvilinear 3-dimensional coordinates.
     *
     * @alias Spherical
     * @constructor
     *
     * @param {Number} [clock=0.0] The angular coordinate lying in the xy-plane measured from the positive x-axis and toward the positive y-axis.
     * @param {Number} [cone=0.0] The angular coordinate measured from the positive z-axis and toward the negative z-axis.
     * @param {Number} [magnitude=1.0] The linear coordinate measured from the origin.
     */
    var Spherical = function(clock, cone, magnitude) {
        this.clock = typeof clock === 'undefined' ? 0.0 : clock;
        this.cone = typeof cone === 'undefined' ? 0.0 : cone;
        this.magnitude = typeof magnitude === 'undefined' ? 1.0 : magnitude;
    };

    /**
     * Converts the provided Cartesian3 into Spherical coordinates.
     * @memberof Spherical
     *
     * @param {Cartesian3} cartesian3 The Cartesian3 to be converted to Spherical.
     * @param {Spherical} [spherical] The object in which the result will be stored, if undefined a new instance will be created.
     *
     * @returns The modified result parameter, or a new instance if none was provided.
     */
    Spherical.fromCartesian3 = function(cartesian3, result) {
        if (typeof result === 'undefined') {
            result = new Spherical();
        }
        var x = cartesian3.x;
        var y = cartesian3.y;
        var z = cartesian3.z;
        var radialSquared = x * x + y * y;
        result.clock = Math.atan2(y, x);
        result.cone = Math.atan2(Math.sqrt(radialSquared), z);
        result.magnitude = Math.sqrt(radialSquared + z * z);
        return result;
    };

    /**
     * Creates a duplicate of a Spherical.
     * @memberof Spherical
     *
     * @param {Spherical} spherical The spherical to clone.
     * @param {Spherical} [result] The object to store the result into, if undefined a new instance will be created.
     *
     * @return The modified result parameter or a new instance if result was undefined.
     */
    Spherical.clone = function(spherical, result) {
        if (typeof result === 'undefined') {
            result = new Spherical();
        }
        result.clock = spherical.clock;
        result.cone = spherical.cone;
        result.magnitude = spherical.magnitude;
        return result;
    };

    /**
     * Computes the normalized version of the provided spherical.
     * @memberof Spherical
     *
     * @param {Spherical} spherical The spherical to be normalized.
     * @param {Spherical} [result] The object to store the result into, if undefined a new instance will be created.
     *
     * @return The modified result parameter or a new instance if result was undefined.
     */
    Spherical.normalize = function(spherical, result) {
        if (typeof result === 'undefined') {
            result = new Spherical();
        }
        result.clock = spherical.clock;
        result.cone = spherical.cone;
        result.magnitude = 1.0;
        return result;
    };

    /**
     * Returns true if the first spherical is equal to the second spherical, false otherwise.
     * @memberof Spherical
     *
     * @param {Spherical} left The first Spherical to be compared.
     * @param {Spherical} right The second Spherical to be compared.
     *
     * @return true if the first spherical is equal to the second spherical, false otherwise.
     */
    Spherical.equals = function(left, right) {
        return (left === right) ||
               ((typeof left !== 'undefined') &&
                (typeof right !== 'undefined') &&
                (left.clock === right.clock) &&
                (left.cone === right.cone) &&
                (left.magnitude === right.magnitude));
    };

    /**
     * Returns true if the first spherical is within the provided epsilon of the second spherical, false otherwise.
     * @memberof Spherical
     *
     * @param {Spherical} left The first Spherical to be compared.
     * @param {Spherical} right The second Spherical to be compared.
     * @param {Number} [epsilon=0.0] The epsilon to compare against.
     *
     * @return true if the first spherical is within the provided epsilon of the second spherical, false otherwise.
     */
    Spherical.equalsEpsilon = function(left, right, epsilon) {
        epsilon = typeof epsilon === 'undefined' ? 0.0 : epsilon;
        return (left === right) ||
               ((typeof left !== 'undefined') &&
                (typeof right !== 'undefined') &&
                (Math.abs(left.clock - right.clock) <= epsilon) &&
                (Math.abs(left.cone - right.cone) <= epsilon) &&
                (Math.abs(left.magnitude - right.magnitude) <= epsilon));
    };

    /**
     * Returns a string representing the provided instance in the format (clock, cone, magnitude).
     * @memberof Spherical
     *
     * @param {Spherical} spherical The object to be converted.
     *
     * @return A string representing the provided instance.
     */
    Spherical.toString = function(spherical) {
        return '(' + spherical.clock + ', ' + spherical.cone + ', ' + spherical.magnitude + ')';
    };

    /**
     * Creates a duplicate of this Spherical.
     * @memberof Spherical
     *
     * @param {Spherical} [result] The object to store the result into, if undefined a new instance will be created.
     *
     * @return The modified result parameter or a new instance if result was undefined.
     */
    Spherical.prototype.clone = function(result) {
        return Spherical.clone(this, result);
    };

    /**
     * Computes the normalized version of this spherical.
     * @memberof Spherical
     *
     * @param {Spherical} [result] The object to store the result into, if undefined a new instance will be created.
     *
     * @return The modified result parameter or a new instance if result was undefined.
     */
    Spherical.prototype.normalize = function(result) {
        return Spherical.normalize(this, result);
    };

    /**
     * Returns true if this spherical is equal to the provided spherical, false otherwise.
     * @memberof Spherical
     *
     * @param {Spherical} other The Spherical to be compared.
     *
     * @return true if this spherical is equal to the provided spherical, false otherwise.
     */
    Spherical.prototype.equals = function(other) {
        return Spherical.equals(this, other);
    };

    /**
     * Returns true if this spherical is within the provided epsilon of the provided spherical, false otherwise.
     * @memberof Spherical
     *
     * @param {Spherical} other The Spherical to be compared.
     * @param {Number} epsilon The epsilon to compare against.
     *
     * @return true if this spherical is within the provided epsilon of the provided spherical, false otherwise.
     */
    Spherical.prototype.equalsEpsilon = function(other, epsilon) {
        return Spherical.equalsEpsilon(this, other, epsilon);
    };

    /**
     * Returns a string representing this instance in the format (clock, cone, magnitude).
     * @memberof Spherical
     *
     * @return A string representing this instance.
     */
    Spherical.prototype.toString = function() {
        return Spherical.toString(this);
    };

    return Spherical;
});

/*global define*/
define('Core/TimeConstants',[],function() {
    

    /**
     * Constants for time conversions like those done by {@link JulianDate}.
     *
     * @exports TimeConstants
     *
     * @see JulianDate
     */
    var TimeConstants = {
        /**
         * The number of seconds in one millisecond: <code>0.001</code>
         * @constant
         * @type {Number}
         */
        SECONDS_PER_MILLISECOND : 0.001,

        /**
         * The number of seconds in one minute: <code>60</code>.
         * @constant
         * @type {Number}
         */
        SECONDS_PER_MINUTE : 60.0,

        /**
         * The number of minutes in one hour: <code>60</code>.
         * @constant
         * @type {Number}
         */
        MINUTES_PER_HOUR : 60.0,

        /**
         * The number of hours in one day: <code>24</code>.
         * @constant
         * @type {Number}
         */
        HOURS_PER_DAY : 24.0,

        /**
         * The number of seconds in one hour: <code>3600</code>.
         * @constant
         * @type {Number}
         */
        SECONDS_PER_HOUR : 3600.0,

        /**
         * The number of minutes in one day: <code>1440</code>.
         * @constant
         * @type {Number}
         */
        MINUTES_PER_DAY : 1440.0,

        /**
         * The number of seconds in one day, ignoring leap seconds: <code>86400</code>.
         * @constant
         * @type {Number}
         */
        SECONDS_PER_DAY : 86400.0,

        /**
         * The number of days in one Julian century: <code>36525</code>.
         * @constant
         * @type {Number}
         */
        DAYS_PER_JULIAN_CENTURY : 36525.0,

        /**
         * One trillionth of a second.
         * @constant
         * @type {Number}
         */
        PICOSECOND : 0.000000001,

        /**
         * DOC_TBA
         * @constant
         * @type {Number}
         */
        MODIFIED_JULIAN_DATE_DIFFERENCE : 2400000.5
    };

    return TimeConstants;
});
/*global define*/
define('Core/TimeStandard',[],function() {
    

    /**
     * Provides the type of time standards which JulianDate can take as input.
     *
     * @exports TimeStandard
     *
     * @see JulianDate
     */
    var TimeStandard = {
        /**
         * Represents the coordinated Universal Time (UTC) time standard.
         *
         * UTC is related to TAI according to the relationship
         * <code>UTC = TAI - deltaT</code> where <code>deltaT</code> is the number of leap
         * seconds which have been introduced as of the time in TAI.
         *
         */
        UTC : 0,

        /**
         * Represents the International Atomic Time (TAI) time standard.
         * TAI is the principal time standard to which the other time standards are related.
         */
        TAI : 1
    };

    return TimeStandard;
});
/*global define*/
define('Core/Tipsify',['./DeveloperError'], function(DeveloperError) {
    

    /**
     * Encapsulates an algorithm to optimize triangles for the post
     * vertex-shader cache.  This is based on the 2007 SIGGRAPH paper
     * 'Fast Triangle Reordering for Vertex Locality and Reduced Overdraw.'
     * The runtime is linear but several passes are made.
     *
     * @exports Tipsify
     *
     * @see <a href='http://gfx.cs.princeton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf'>
     * Fast Triangle Reordering for Vertex Locality and Reduced Overdraw</a>
     * by Sander, Nehab, and Barczak
     */
    var Tipsify = {};

    /**
     * Calculates the average cache miss ratio (ACMR) for a given set of indices.
     *
     * @param {Array} description.indices Lists triads of numbers corresponding to the indices of the vertices
     *                        in the vertex buffer that define the mesh's triangles.
     * @param {Number} [description.maximumIndex] The maximum value of the elements in <code>args.indices</code>.
     *                                     If not supplied, this value will be computed.
     * @param {Number} [description.cacheSize=24] The number of vertices that can be stored in the cache at any one time.
     *
     * @exception {DeveloperError} indices is required.
     * @exception {DeveloperError} indices length must be a multiple of three.
     * @exception {DeveloperError} cacheSize must be greater than two.
     *
     * @return {Number} The average cache miss ratio (ACMR).
     *
     * @example
     * var indices = [0, 1, 2, 3, 4, 5];
     * var maxIndex = 5;
     * var cacheSize = 3;
     * var acmr = Tipsify.calculateACMR(indices, maxIndex, cacheSize);
     */
    Tipsify.calculateACMR = function(description) {
        description = description || {};
        var indices = description.indices;
        var maximumIndex = description.maximumIndex;
        var cacheSize = description.cacheSize || 24;

        if (!indices) {
            throw new DeveloperError('indices is required.');
        }

        var numIndices = indices.length;

        if ((numIndices < 3) || (numIndices % 3 !== 0)) {
            throw new DeveloperError('indices length must be a multiple of three.');
        }
        if (maximumIndex <= 0) {
            throw new DeveloperError('maximumIndex must be greater than zero.');
        }
        if (cacheSize < 3) {
            throw new DeveloperError('cacheSize must be greater than two.');
        }

        // Compute the maximumIndex if not given
        if(!maximumIndex) {
            maximumIndex = 0;
            var currentIndex = 0;
            var intoIndices = indices[currentIndex];
            while (currentIndex < numIndices) {
                if (intoIndices > maximumIndex) {
                    maximumIndex = intoIndices;
                }
                ++currentIndex;
                intoIndices = indices[currentIndex];
            }
        }

        // Vertex time stamps
        var vertexTimeStamps = [];
        for ( var i = 0; i < maximumIndex + 1; i++) {
            vertexTimeStamps[i] = 0;
        }

        // Cache processing
        var s = cacheSize + 1;
        for ( var j = 0; j < numIndices; ++j) {
            if ((s - vertexTimeStamps[indices[j]]) > cacheSize) {
                vertexTimeStamps[indices[j]] = s;
                ++s;
            }
        }

        return (s - cacheSize + 1) / (numIndices / 3);
    };

    /**
     * Optimizes triangles for the post-vertex shader cache.
     *
     * @param {Array} description.indices Lists triads of numbers corresponding to the indices of the vertices
     *                        in the vertex buffer that define the mesh's triangles.
     * @param {Number} [description.maximumIndex] The maximum value of the elements in <code>args.indices</code>.
     *                                     If not supplied, this value will be computed.
     * @param {Number} [description.cacheSize=24] The number of vertices that can be stored in the cache at any one time.
     *
     * @exception {DeveloperError} indices is required.
     * @exception {DeveloperError} indices length must be a multiple of three.
     * @exception {DeveloperError} cacheSize must be greater than two.
     *
     * @return {Array} A list of the input indices in an optimized order.
     *
     * @example
     * var indices = [0, 1, 2, 3, 4, 5];
     * var maxIndex = 5;
     * var cacheSize = 3;
     * var reorderedIndices = Tipsify.tipsify(indices, maxIndex, cacheSize);
     */
    Tipsify.tipsify = function(description) {
        description = description || {};
        var indices = description.indices;
        var maximumIndex = description.maximumIndex;
        var cacheSize = description.cacheSize || 24;

        var cursor;

        function skipDeadEnd(vertices, deadEnd, indices, maximumIndexPlusOne) {
            while (deadEnd.length >= 1) {
                // while the stack is not empty
                var d = deadEnd[deadEnd.length - 1]; // top of the stack
                deadEnd.splice(deadEnd.length - 1, 1); // pop the stack

                if (vertices[d].numLiveTriangles > 0) {
                    return d;
                }
            }

            while (cursor < maximumIndexPlusOne) {
                if (vertices[cursor].numLiveTriangles > 0) {
                    ++cursor;
                    return cursor - 1;
                }
                ++cursor;
            }
            return -1;
        }

        function getNextVertex(indices, cacheSize, oneRing, vertices, s, deadEnd, maximumIndexPlusOne) {
            var n = -1;
            var p;
            var m = -1;
            var itOneRing = 0;
            while (itOneRing < oneRing.length) {
                var index = oneRing[itOneRing];
                if (vertices[index].numLiveTriangles) {
                    p = 0;
                    if ((s - vertices[index].timeStamp + (2 * vertices[index].numLiveTriangles)) <= cacheSize) {
                        p = s - vertices[index].timeStamp;
                    }
                    if ((p > m) || (m === -1)) {
                        m = p;
                        n = index;
                    }
                }
                ++itOneRing;
            }
            if (n === -1) {
                return skipDeadEnd(vertices, deadEnd, indices, maximumIndexPlusOne);
            }
            return n;
        }

        if (!indices) {
            throw new DeveloperError('indices is required.');
        }
        var numIndices = indices.length;

        if ((numIndices < 3) || (numIndices % 3 !== 0)) {
            throw new DeveloperError('indices length must be a multiple of three.');
        }
        if (maximumIndex <= 0) {
            throw new DeveloperError('maximumIndex must be greater than zero.');
        }
        if (cacheSize < 3) {
            throw new DeveloperError('cacheSize must be greater than two.');
        }

        // Determine maximum index
        var maximumIndexPlusOne = 0;
        var currentIndex = 0;
        var intoIndices = indices[currentIndex];
        var endIndex = numIndices;
        if (maximumIndex) {
            maximumIndexPlusOne = maximumIndex + 1;
        } else {
            while (currentIndex < endIndex) {
                if (intoIndices > maximumIndexPlusOne) {
                    maximumIndexPlusOne = intoIndices;
                }
                ++currentIndex;
                intoIndices = indices[currentIndex];
            }
            if (maximumIndexPlusOne === -1) {
                return 0;
            }
            ++maximumIndexPlusOne;
        }

        // Vertices
        var vertices = [];
        for ( var i = 0; i < maximumIndexPlusOne; i++) {
            vertices[i] = {
                numLiveTriangles : 0,
                timeStamp : 0,
                vertexTriangles : []
            };
        }
        currentIndex = 0;
        var triangle = 0;
        while (currentIndex < endIndex) {
            (vertices[indices[currentIndex]]).vertexTriangles.push(triangle);
            ++(vertices[indices[currentIndex]]).numLiveTriangles;
            (vertices[indices[currentIndex + 1]]).vertexTriangles.push(triangle);
            ++(vertices[indices[currentIndex + 1]]).numLiveTriangles;
            (vertices[indices[currentIndex + 2]]).vertexTriangles.push(triangle);
            ++(vertices[indices[currentIndex + 2]]).numLiveTriangles;
            ++triangle;
            currentIndex += 3;
        }

        // Starting index
        var f = 0;

        // Time Stamp
        var s = cacheSize + 1;
        cursor = 1;

        // Process
        var oneRing = [];
        var deadEnd = []; //Stack
        var vertex;
        var intoVertices;
        var currentOutputIndex = 0;
        var outputIndices = [];
        var numTriangles = numIndices / 3;
        var triangleEmitted = [];
        for (i = 0; i < numTriangles; i++) {
            triangleEmitted[i] = false;
        }
        var index;
        var limit;
        while (f !== -1) {
            oneRing = [];
            intoVertices = vertices[f];
            limit = intoVertices.vertexTriangles.length;
            for ( var k = 0; k < limit; ++k) {
                triangle = intoVertices.vertexTriangles[k];
                if (!triangleEmitted[triangle]) {
                    triangleEmitted[triangle] = true;
                    currentIndex = triangle + triangle + triangle;
                    for ( var j = 0; j < 3; ++j) {
                        // Set this index as a possible next index
                        index = indices[currentIndex];
                        oneRing.push(index);
                        deadEnd.push(index);

                        // Output index
                        outputIndices[currentOutputIndex] = index;
                        ++currentOutputIndex;

                        // Cache processing
                        vertex = vertices[index];
                        --vertex.numLiveTriangles;
                        if ((s - vertex.timeStamp) > cacheSize) {
                            vertex.timeStamp = s;
                            ++s;
                        }
                        ++currentIndex;
                    }
                }
            }
            f = getNextVertex(indices, cacheSize, oneRing, vertices, s, deadEnd, maximumIndexPlusOne);
        }

        return outputIndices;
    };

    return Tipsify;
});

/*global define*/
define('Core/TridiagonalSystemSolver',['./DeveloperError'], function(DeveloperError) {
    

    /**
     * Uses the Tridiagonal Matrix Algorithm, also known as the Thomas Algorithm, to solve
     * a system of linear equations where the coefficient matrix is a tridiagonal matrix.
     *
     * @exports TridiagonalSystemSolver
     */
    var TridiagonalSystemSolver = {};

    /**
     * Solves a tridiagonal system of linear equations.
     *
     * @param {Array} diagonal An array with length <code>n</code> that contains the diagonal of the coefficient matrix.
     * @param {Array} lower An array with length <code>n - 1</code> that contains the lower diagonal of the coefficient matrix.
     * @param {Array} upper An array with length <code>n - 1</code> that contains the upper diagonal of the coefficient matrix.
     * @param {Array} right An array of Cartesians with length <code>n</code> that is the right side of the system of equations.
     *
     * @exception {DeveloperError} The array lower is required.
     * @exception {DeveloperError} The array diagonal is required.
     * @exception {DeveloperError} The array upper is required.
     * @exception {DeveloperError} The array right is required.
     * @exception {DeveloperError} diagonal and right must have the same lengths.
     * @exception {DeveloperError} lower and upper must have the same lengths.
     * @exception {DeveloperError} lower and upper must be one less than the length of diagonal.
     *
     * @returns {Array} An array of Cartesians with length <code>n</code> that is the solution to the tridiagonal system of equations.
     *
     * @performance Linear time.
     *
     * @example
     * var lowerDiagonal = [1.0, 1.0, 1.0, 1.0];
     * var diagonal = [2.0, 4.0, 4.0, 4.0, 2.0];
     * var upperDiagonal = [1.0, 1.0, 1.0, 1.0];
     * var rightHandSide = [
     *     new Cartesian3(410757.0, -1595711.0, 1375302.0),
     *     new Cartesian3(-5986705.0, -2190640.0, 1099600.0),
     *     new Cartesian3(-12593180.0, 288588.0, -1755549.0),
     *     new Cartesian3(-5349898.0, 2457005.0, -2685438.0),
     *     new Cartesian3(845820.0, 1573488.0, -1205591.0)
     * ];
     *
     * var solution = TridiagonalSystemSolver.solve(lowerDiagonal, diagonal, upperDiagonal, rightHandSide);
     */
    TridiagonalSystemSolver.solve = function(lower, diagonal, upper, right) {
        if (!lower || !(lower instanceof Array)) {
            throw new DeveloperError('The array lower is required.');
        }

        if (!diagonal || !(diagonal instanceof Array)) {
            throw new DeveloperError('The array diagonal is required.');
        }

        if (!upper || !(upper instanceof Array)) {
            throw new DeveloperError('The array upper is required.');
        }

        if (!right || !(right instanceof Array)) {
            throw new DeveloperError('The array right is required.');
        }

        if (diagonal.length !== right.length) {
            throw new DeveloperError('diagonal and right must have the same lengths.');
        }

        if (lower.length !== upper.length) {
            throw new DeveloperError('lower and upper must have the same lengths.');
        } else if (lower.length !== diagonal.length - 1) {
            throw new DeveloperError('lower and upper must be one less than the length of diagonal.');
        }

        var c = [], d = [], x = [];
        c.length = upper.length;
        d.length = x.length = right.length;

        c[0] = upper[0] / diagonal[0];
        d[0] = right[0].multiplyByScalar(1.0 / diagonal[0]);

        var scalar, i = 1;
        for (; i < c.length; ++i) {
            scalar = 1.0 / (diagonal[i] - c[i - 1] * lower[i - 1]);
            c[i] = upper[i] * scalar;
            d[i] = right[i].subtract(d[i - 1].multiplyByScalar(lower[i - 1]));
            d[i] = d[i].multiplyByScalar(scalar);
        }

        scalar = 1.0 / (diagonal[i] - c[i - 1] * lower[i - 1]);
        d[i] = right[i].subtract(d[i - 1].multiplyByScalar(lower[i - 1]));
        d[i] = d[i].multiplyByScalar(scalar);

        x[x.length - 1] = d[d.length - 1];
        for (i = x.length - 2; i >= 0; --i) {
            x[i] = d[i].subtract(x[i + 1].multiplyByScalar(c[i]));
        }

        return x;
    };

    return TridiagonalSystemSolver;
});

/*global define*/
define('Core/HermiteSpline',[
        './DeveloperError',
        './Matrix4',
        './Cartesian4',
        './TridiagonalSystemSolver'
    ],
    function(
        DeveloperError,
        Matrix4,
        Cartesian4,
        TridiagonalSystemSolver) {
    

    /**
     * A Hermite spline is a cubic interpolating spline. Positions, tangents, and times must be defined
     * for each control point. If no tangents are specified by the control points, the end and interior
     * tangents are generated, creating a natural cubic spline. If the only tangents specified are at
     * the end control points, the interior tangents will be generated as well, creating a clamped cubic
     * spline. Otherwise, it is assumed that each control point defines a tangent at that point.
     *
     * Natural and clamped cubic splines are in the class C<sup>2</sup>.
     *
     * @alias HermiteSpline
     * @constructor
     *
     * @param {Array} controlPoints An array, of at least length 3, of objects with <code>point</code>,
     * <code>time</code>, and <code>tangent</code> properties.
     *
     * @exception {DeveloperError} controlPoints is required.
     * @exception {DeveloperError} controlPoints must be an array of at least length 3.
     *
     * @see CatmullRomSpline
     *
     * @example
     * // Example 1.
     * // Create a natural cubic spline above the earth from Philadelphia to Los Angeles.
     * var controlPoints = [
     *     {point: new Cartesian3(1235398.0, -4810983.0, 4146266.0), time: 0.0},
     *     {point: new Cartesian3(1372574.0, -5345182.0, 4606657.0), time: 1.5},
     *     {point: new Cartesian3(-757983.0, -5542796.0, 4514323.0), time: 3.0},
     *     {point: new Cartesian3(-2821260.0, -5248423.0, 4021290.0), time: 4.5},
     *     {point: new Cartesian3(-2539788.0, -4724797.0, 3620093.0), time: 6.0}
     * ];
     * var spline = new HermiteSpline(controlPoints);
     *
     * // Example 2.
     * // Create a Catmull-Rom spline above the earth from Philadelphia to Los Angeles.
     * var controlPoints = [
     *     {point: new Cartesian3(1235398.0, -4810983.0, 4146266.0), time: 0.0},
     *     {point: new Cartesian3(1372574.0, -5345182.0, 4606657.0), time: 1.5},
     *     {point: new Cartesian3(-757983.0, -5542796.0, 4514323.0), time: 3.0},
     *     {point: new Cartesian3(-2821260.0, -5248423.0, 4021290.0), time: 4.5},
     *     {point: new Cartesian3(-2539788.0, -4724797.0, 3620093.0), time: 6.0}
     * ];
     *
     * // Add tangents
     * controlPoints[0].tangent = new Cartesian3(1125196, -161816, 270551);
     * for (var i = 1; i < controlPoints.length - 1; ++i) {
     *     controlPoints[i].tangent = controlPoints[i + 1].point.subtract(controlPoints[i - 1].point).multiplyByScalar(0.5);
     * }
     * controlPoints[controlPoints.length - 1].tangent = new Cartesian3(1165345, 112641, 47281);
     *
     * var spline = new HermiteSpline(controlPoints);
     */
    var HermiteSpline = function(controlPoints) {
        if (!controlPoints || !(controlPoints instanceof Array) || controlPoints.length < 3) {
            throw new DeveloperError('controlPoints is required. It must be an array with at least a length of 3.');
        }

        this._points = controlPoints;

        this._lastTimeIndex = 0;

        if (!this._points[0].tangent || !this._points[this._points.length - 1].tangent) {
            this._generateNatural();
        } else if (this._points[0].tangent && !this._points[1].tangent && this._points[this._points.length - 1].tangent && !this._points[this._points.length - 2].tangent) {
            this._generateClamped();
        }
    };

    HermiteSpline.hermiteCoefficientMatrix = new Matrix4(
             2.0, -3.0,  0.0,  1.0,
            -2.0,  3.0,  0.0,  0.0,
             1.0, -2.0,  1.0,  0.0,
             1.0, -1.0,  0.0,  0.0);

    HermiteSpline.prototype._findIndex = function(time) {
        // Take advantage of temporal coherence by checking current, next and previous intervals
        // for containment of time.
        var i = this._lastTimeIndex || 0;
        if (time >= this._points[i].time) {
            if (i + 1 < this._points.length && time < this._points[i + 1].time) {
                return i;
            } else if (i + 2 < this._points.length && time < this._points[i + 2].time) {
                this._lastTimeIndex = i + 1;
                return this._lastTimeIndex;
            }
        } else if (i - 1 >= 0 && time >= this._points[i - 1].time) {
            this._lastTimeIndex = i - 1;
            return this._lastTimeIndex;
        }

        // The above failed so do a linear search. For the use cases so far, the
        // length of the list is less than 10. In the future, if there is a bottle neck,
        // it might be here.
        for (i = 0; i < this._points.length - 1; ++i) {
            if (time >= this._points[i].time && time < this._points[i + 1].time) {
                break;
            }
        }

        if (i === this._points.length - 1) {
            i = this._points.length - 2;
        }

        this._lastTimeIndex = i;
        return this._lastTimeIndex;
    };

    HermiteSpline.prototype._generateClamped = function() {
        var l = [], d = [], u = [], r = [];
        l.length = u.length = this._points.length - 1;
        d.length = r.length = this._points.length;

        var i;
        l[0] = d[0] = 1.0;
        u[0] = 0.0;
        r[0] = this._points[0].tangent;
        for (i = 1; i < l.length - 1; ++i) {
            l[i] = u[i] = 1.0;
            d[i] = 4.0;
            r[i] = this._points[i + 1].point.subtract(this._points[i - 1].point).multiplyByScalar(3.0);
        }
        l[i] = 0.0;
        u[i] = 1.0;
        d[i] = 4.0;
        r[i] = this._points[i + 1].point.subtract(this._points[i - 1].point).multiplyByScalar(3.0);
        d[i + 1] = 1.0;
        r[i + 1] = this._points[i + 1].tangent;

        var tangents = TridiagonalSystemSolver.solve(l, d, u, r);
        for (i = 0; i < this._points.length; ++i) {
            this._points[i].tangent = tangents[i];
        }
    };

    HermiteSpline.prototype._generateNatural = function() {
        var l = [], d = [], u = [], r = [];
        l.length = u.length = this._points.length - 1;
        d.length = r.length = this._points.length;

        var i;
        l[0] = u[0] = 1.0;
        d[0] = 2.0;
        r[0] = this._points[1].point.subtract(this._points[0].point).multiplyByScalar(3.0);
        for (i = 1; i < l.length; ++i) {
            l[i] = u[i] = 1.0;
            d[i] = 4.0;
            r[i] = this._points[i + 1].point.subtract(this._points[i - 1].point).multiplyByScalar(3.0);
        }
        d[i] = 2.0;
        r[i] = this._points[i].point.subtract(this._points[i - 1].point).multiplyByScalar(3.0);

        var tangents = TridiagonalSystemSolver.solve(l, d, u, r);
        for (i = 0; i < this._points.length; ++i) {
            this._points[i].tangent = tangents[i];
        }
    };

    /**
     * Returns the array of control points.
     *
     * @memberof HermiteSpline
     * @return {Array} The array of control points.
     */
    HermiteSpline.prototype.getControlPoints = function() {
        return this._points;
    };

    /**
     * Evaluates the curve at a given time.
     *
     * @memberof HermiteSpline
     *
     * @param {Number} time The time at which to evaluate the curve.
     *
     * @exception {DeveloperError} time is required.
     * @exception {DeveloperError} time must be in the range <code>[a<sub>0</sub>, a<sub>n</sub>]</code>,
     * where <code>a<sub>0</sub></code> and <code>a<sub>n</sub></code> are the time properties of first and
     * last elements in the array given during construction, respectively.
     *
     * @return {Cartesian3} The point on the curve at the given <code>time</code>.
     *
     * @example
     * // spline above the earth from Philadelphia to Los Angeles
     * var controlPoints = [
     *     {point: new Cartesian3(1235398.0, -4810983.0, 4146266.0), time: 0.0},
     *     {point: new Cartesian3(1372574.0, -5345182.0, 4606657.0), time: 1.5},
     *     {point: new Cartesian3(-757983.0, -5542796.0, 4514323.0), time: 3.0},
     *     {point: new Cartesian3(-2821260.0, -5248423.0, 4021290.0), time: 4.5},
     *     {point: new Cartesian3(-2539788.0, -4724797.0, 3620093.0), time: 6.0}
     * ];
     * var spline = new HermiteSpline(controlPoints);
     *
     * // some position above Los Angeles
     * var position = spline.evaluate(5.0);
     */
    HermiteSpline.prototype.evaluate = function(time) {
        if (typeof time === 'undefined') {
            throw new DeveloperError('time is required.');
        }

        if (time < this._points[0].time || time > this._points[this._points.length - 1].time) {
            throw new DeveloperError('time is out of range.');
        }

        var i = this._findIndex(time);
        var u = (time - this._points[i].time) / (this._points[i + 1].time - this._points[i].time);

        var timeVec = new Cartesian4(0.0, u * u, u, 1.0);
        timeVec.x = timeVec.y * u;

        var coefs = HermiteSpline.hermiteCoefficientMatrix.multiplyByVector(timeVec);
        var p0 = this._points[i].point.multiplyByScalar(coefs.x);
        var p1 = this._points[i + 1].point.multiplyByScalar(coefs.y);
        var p2 = this._points[i].tangent.multiplyByScalar(coefs.z);
        var p3 = this._points[i + 1].tangent.multiplyByScalar(coefs.w);

        return p0.add(p1.add(p2.add(p3)));
    };

    return HermiteSpline;
});

/*global define*/
define('Core/CatmullRomSpline',[
        './DeveloperError',
        './Matrix4',
        './Cartesian3',
        './Cartesian4',
        './HermiteSpline'
    ],
    function(
        DeveloperError,
        Matrix4,
        Cartesian3,
        Cartesian4,
        HermiteSpline) {
    

    /**
     * A Catmull-Rom spline is a cubic spline where the tangent at control points,
     * except the first and last, are computed using the previous and next control points.
     * Catmull-Rom splines are in the class C<sup>1</sup>.
     *
     * @alias CatmullRomSpline
     * @constructor
     *
     * @param {Array} controlPoints The array of control points. Each element of the array should be an object with <code>point</code> and <code>time</code> properties.
     * @param {Cartesian3} firstTangent The tangent of the curve at the first control point.
     * If the tangent is not given, it will be estimated.
     * @param {Cartesian3} lastTangent The tangent of the curve at the last control point.
     * If the tangent is not given, it will be estimated.
     *
     * @exception {DeveloperError} controlPoints is required.
     * @exception {DeveloperError} controlPoints must be an array of at least length 3.
     *
     * @see HermiteSpline
     *
     * @example
     * // spline above the earth from Philadelphia to Los Angeles
     * var controlPoints = [
     *     {point: new Cartesian3(1235398.0, -4810983.0, 4146266.0), time: 0.0},
     *     {point: new Cartesian3(1372574.0, -5345182.0, 4606657.0), time: 1.5},
     *     {point: new Cartesian3(-757983.0, -5542796.0, 4514323.0), time: 3.0},
     *     {point: new Cartesian3(-2821260.0, -5248423.0, 4021290.0), time: 4.5},
     *     {point: new Cartesian3(-2539788.0, -4724797.0, 3620093.0), time: 6.0}
     * ];
     * var spline = new CatmullRomSpline(controlPoints);
     */
    var CatmullRomSpline = function(controlPoints, firstTangent, lastTangent) {
        if (!controlPoints || !(controlPoints instanceof Array) || controlPoints.length < 3) {
            throw new DeveloperError('controlPoints is required and must be an array of objects with point and time properties, with a length of at least 3.');
        }

        this._points = controlPoints;
        this._lastTimeIndex = 0;

        if (firstTangent) {
            this._ti = Cartesian3.clone(firstTangent);
        } else {
            var controlPoint0 = Cartesian3.clone(controlPoints[0].point);
            var controlPoint1 = Cartesian3.clone(controlPoints[1].point);
            var controlPoint2 = Cartesian3.clone(controlPoints[2].point);

            this._ti = controlPoint1
                           .multiplyByScalar(2.0)
                           .subtract(controlPoint2)
                           .subtract(controlPoint0)
                           .multiplyByScalar(0.5);
        }

        if (firstTangent) {
            this._to = Cartesian3.clone(lastTangent);
        } else {
            var n = controlPoints.length - 1;

            var controlPointn0 = Cartesian3.clone(controlPoints[n].point);
            var controlPointn1 = Cartesian3.clone(controlPoints[n - 1].point);
            var controlPointn2 = Cartesian3.clone(controlPoints[n - 2].point);

            this._to = controlPointn0
                           .subtract(controlPointn1.multiplyByScalar(2.0))
                           .add(controlPointn2)
                           .multiplyByScalar(0.5);
        }
    };

    CatmullRomSpline.catmullRomCoefficientMatrix = new Matrix4(
            -0.5,  1.0, -0.5,  0.0,
             1.5, -2.5,  0.0,  1.0,
            -1.5,  2.0,  0.5,  0.0,
             0.5, -0.5,  0.0,  0.0);

    /**
     * Returns the array of control points.
     *
     * @memberof CatmullRomSpline
     * @return {Array} The array of control points.
     */
    CatmullRomSpline.prototype.getControlPoints = function() {
        return this._points;
    };

    /**
     * Returns the tangent of the first control point.
     *
     * @memberof CatmullRomSpline
     *
     * @return {Cartesian3} The tangent of the first control point.
     *
     * @see CatmullRomSpline#getEndTangent
     */
    CatmullRomSpline.prototype.getStartTangent = function() {
        return this._ti;
    };

    /**
     * Returns the tangent of the last control point.
     *
     * @memberof CatmullRomSpline
     *
     * @return {Cartesian3} The tangent of the last control point.
     *
     * @see CatmullRomSpline#getStartTangent
     */
    CatmullRomSpline.prototype.getEndTangent = function() {
        return this._to;
    };

    CatmullRomSpline.prototype._findIndex = function(time) {
        // Take advantage of temporal coherence by checking current, next and previous intervals
        // for containment of time.
        var i = this._lastTimeIndex || 0;
        if (time >= this._points[i].time) {
            if (i + 1 < this._points.length && time < this._points[i + 1].time) {
                return i;
            } else if (i + 2 < this._points.length && time < this._points[i + 2].time) {
                this._lastTimeIndex = i + 1;
                return this._lastTimeIndex;
            }
        } else if (i - 1 >= 0 && time >= this._points[i - 1].time) {
            this._lastTimeIndex = i - 1;
            return this._lastTimeIndex;
        }

        // The above failed so do a linear search. For the use cases so far, the
        // length of the list is less than 10. In the future, if there is a bottle neck,
        // it might be here.
        for (i = 0; i < this._points.length - 1; ++i) {
            if (time >= this._points[i].time && time < this._points[i + 1].time) {
                break;
            }
        }

        if (i === this._points.length - 1) {
            i = this._points.length - 2;
        }

        this._lastTimeIndex = i;
        return this._lastTimeIndex;
    };

    /**
     * Evaluates the curve at a given time.
     *
     * @memberof CatmullRomSpline
     *
     * @param {Number} time The time at which to evaluate the curve.
     *
     * @exception {DeveloperError} time is required.
     * @exception {DeveloperError} time must be in the range <code>[a<sub>0</sub>, a<sub>n</sub>]</code>,
     * where <code>a<sub>0</sub></code> and <code>a<sub>n</sub></code> are the time properties of first and
     * last elements in the array given during construction, respectively.
     *
     * @return {Cartesian3} The point on the curve at the given <code>time</code>.
     *
     * @example
     * // spline above the earth from Philadelphia to Los Angeles
     * var controlPoints = [
     *     {point: new Cartesian3(1235398.0, -4810983.0, 4146266.0), time: 0.0},
     *     {point: new Cartesian3(1372574.0, -5345182.0, 4606657.0), time: 1.5},
     *     {point: new Cartesian3(-757983.0, -5542796.0, 4514323.0), time: 3.0},
     *     {point: new Cartesian3(-2821260.0, -5248423.0, 4021290.0), time: 4.5},
     *     {point: new Cartesian3(-2539788.0, -4724797.0, 3620093.0), time: 6.0}
     * ];
     * var spline = new CatmullRomSpline(controlPoints);
     *
     * // some position above Los Angeles
     * var position = spline.evaluate(5.0);
     */
    CatmullRomSpline.prototype.evaluate = function(time) {
        if (typeof time === 'undefined') {
            throw new DeveloperError('time is required.');
        }

        if (time < this._points[0].time || time > this._points[this._points.length - 1].time) {
            throw new DeveloperError('time is out of range.');
        }

        var i = this._findIndex(time);
        var u = (time - this._points[i].time) / (this._points[i + 1].time - this._points[i].time);

        var timeVec = new Cartesian4(0.0, u * u, u, 1.0);
        timeVec.x = timeVec.y * u;

        var p0, p1, p2, p3, coefs;
        if (i === 0) {
            p0 = this._points[0].point;
            p1 = this._points[1].point;
            p2 = this._ti;
            p3 = this._points[2].point.subtract(p0).multiplyByScalar(0.5);
            coefs = HermiteSpline.hermiteCoefficientMatrix.multiplyByVector(timeVec);
        } else if (i === this._points.length - 2) {
            p0 = this._points[i].point;
            p1 = this._points[i + 1].point;
            p2 = p1.subtract(this._points[i - 1].point).multiplyByScalar(0.5);
            p3 = this._to;
            coefs = HermiteSpline.hermiteCoefficientMatrix.multiplyByVector(timeVec);
        } else {
            p0 = this._points[i - 1].point;
            p1 = this._points[i].point;
            p2 = this._points[i + 1].point;
            p3 = this._points[i + 2].point;
            coefs = CatmullRomSpline.catmullRomCoefficientMatrix.multiplyByVector(timeVec);
        }
        p0 = p0.multiplyByScalar(coefs.x);
        p1 = p1.multiplyByScalar(coefs.y);
        p2 = p2.multiplyByScalar(coefs.z);
        p3 = p3.multiplyByScalar(coefs.w);

        return p0.add(p1.add(p2.add(p3)));
    };

    return CatmullRomSpline;
});

/*global define*/
define('Core/Visibility',['./Enumeration'], function(Enumeration) {
    

    /**
     * This enumerated type is used in determining to what extent an object, the occludee,
     * is visible during horizon culling. An occluder may fully block an occludee, in which case
     * it has no visibility, may partially block an occludee from view, or may not block it at all,
     * leading to full visibility.
     *
     * @exports Visibility
     */
    var Visibility = {
        /**
         * Represents that no part of an object is visible.
         *
         * @constant
         * @type {Enumeration}
         */
        NONE : new Enumeration(-1, 'NONE'),
        /**
        * Represents that part, but not all, of an object is visible
        *
        * @constant
        * @type {Enumeration}
        */
        PARTIAL : new Enumeration(0, 'PARTIAL'),
        /**
        * Represents that an object is visible in its entirety.
        *
        * @constant
        * @type {Enumeration}
        */
        FULL : new Enumeration(1, 'FULL')
    };

    return Visibility;
});
/*global define*/
define('Core/Occluder',[
        './DeveloperError',
        './Math',
        './Cartesian3',
        './Visibility'
    ], function(
        DeveloperError,
        CesiumMath,
        Cartesian3,
        Visibility) {
    

    /**
     * Creates an Occluder derived from an object's position and radius, as well as the camera position.
     * The occluder can be used to determine whether or not other objects are visible or hidden behind the
     * visible horizon defined by the occluder and camera position.
     *
     * @alias Occluder
     *
     * @param {BoundingSphere} occluderBoundingSphere The bounding sphere surrounding the occluder.
     * @param {Cartesian3} cameraPosition The coordinate of the viewer/camera.
     *
     * @exception {DeveloperError} <code>occluderBoundingSphere</code> is required.
     * @exception {DeveloperError} <code>cameraPosition</code> is required.
     *
     * @constructor
     *
     * @example
     * // Construct an occluder one unit away from the origin with a radius of one.
     * var cameraPosition = new Cartesian3.ZERO;
     * var occluderBoundingSphere = new BoundingSphere(new Cartesian3(0, 0, -1), 1);
     * var occluder = new Occluder(occluderBoundingSphere, cameraPosition);
     */
    var Occluder = function(occluderBoundingSphere, cameraPosition) {
        if (!occluderBoundingSphere) {
            throw new DeveloperError('occluderBoundingSphere is required.');
        }

        if (!cameraPosition) {
            throw new DeveloperError('camera position is required.');
        }

        this._occluderPosition = occluderBoundingSphere.center.clone();
        this._occluderRadius = occluderBoundingSphere.radius;

        this._horizonDistance = 0.0;
        this._horizonPlaneNormal = undefined;
        this._horizonPlanePosition = undefined;
        this._cameraPosition = undefined;

        // setCameraPosition fills in the above values
        this.setCameraPosition(cameraPosition);
    };

    /**
     * Returns the position of the occluder.
     *
     * @memberof Occluder
     *
     * @return {Cartesian3} The position of the occluder.
     */
    Occluder.prototype.getPosition = function() {
        return this._occluderPosition;
    };

    /**
     * Returns the radius of the occluder.
     *
     * @return {Number} The radius of the occluder.
     */
    Occluder.prototype.getRadius = function() {
        return this._occluderRadius;
    };

    /**
     * Sets the position of the camera.
     *
     * @param {Cartesian3} cameraPosition The new position of the camera.
     */
    Occluder.prototype.setCameraPosition = function(cameraPosition) {
        cameraPosition = Cartesian3.clone(cameraPosition);

        var cameraToOccluderVec = this._occluderPosition.subtract(cameraPosition);
        var invCameraToOccluderDistance = cameraToOccluderVec.magnitudeSquared();
        var occluderRadiusSqrd = this._occluderRadius * this._occluderRadius;

        var horizonDistance;
        var horizonPlaneNormal;
        var horizonPlanePosition;
        if (invCameraToOccluderDistance > occluderRadiusSqrd) {
            horizonDistance = Math.sqrt(invCameraToOccluderDistance - occluderRadiusSqrd);
            invCameraToOccluderDistance = 1.0 / Math.sqrt(invCameraToOccluderDistance);
            horizonPlaneNormal = cameraToOccluderVec.multiplyByScalar(invCameraToOccluderDistance);
            var nearPlaneDistance = horizonDistance * horizonDistance * invCameraToOccluderDistance;
            horizonPlanePosition = cameraPosition.add(horizonPlaneNormal.multiplyByScalar(nearPlaneDistance));
        } else {
            horizonDistance = Number.MAX_VALUE;
        }

        this._horizonDistance = horizonDistance;
        this._horizonPlaneNormal = horizonPlaneNormal;
        this._horizonPlanePosition = horizonPlanePosition;
        this._cameraPosition = cameraPosition;
    };

    /**
    * Determines whether or not an object, the <code>occludee</code>, is hidden from view by the occluder.
    *
    * @memberof Occluder
    *
    * @param {BoundingSphere} occludeeBS The bounding sphere surrounding the occludee object.
    *
    * @return {boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.
    *
    * @example
    * var cameraPosition = new Cartesian3(0, 0, 0);
    * var littleSphere = new BoundingSphere(new Cartesian3(0, 0, -1), 0.25);
    * var occluder = new Occluder(littleSphere, cameraPosition);
    * var bigSphere = new BoundingSphere(new Cartesian3(0, 0, -3), 1);
    * occluder.isVisible(bigSphere); //returns true
    *
    * @see Occluder#getVisibility
    */
    Occluder.prototype.isVisible = function(occludeeBS) {
        var occludeePosition = occludeeBS.center.clone();
        var occludeeRadius = occludeeBS.radius;

        if (this._horizonDistance !== Number.MAX_VALUE) {
            var tempVec = occludeePosition.subtract(this._occluderPosition);
            var temp = this._occluderRadius - occludeeRadius;
            temp = tempVec.magnitudeSquared() - (temp * temp);
            if (occludeeRadius < this._occluderRadius) {
                if (temp > 0.0) {
                    temp = Math.sqrt(temp) + this._horizonDistance;
                    tempVec = occludeePosition.subtract(this._cameraPosition);
                    return ((temp * temp) + (occludeeRadius * occludeeRadius)) > tempVec.magnitudeSquared();
                }
                return false;
            }

            // Prevent against the case where the occludee radius is larger than the occluder's; since this is
            // an uncommon case, the following code should rarely execute.
            if (temp > 0.0) {
                tempVec = occludeePosition.subtract(this._cameraPosition);
                var tempVecMagnitudeSquared = tempVec.magnitudeSquared();
                var occluderRadiusSquared = this._occluderRadius * this._occluderRadius;
                var occludeeRadiusSquared = occludeeRadius * occludeeRadius;
                if ((((this._horizonDistance * this._horizonDistance) + occluderRadiusSquared) * occludeeRadiusSquared) >
                    (tempVecMagnitudeSquared * occluderRadiusSquared)) {
                    // The occludee is close enough that the occluder cannot possible occlude the occludee
                    return true;
                }
                temp = Math.sqrt(temp) + this._horizonDistance;
                return ((temp * temp) + occludeeRadiusSquared) > tempVecMagnitudeSquared;
            }

            // The occludee completely encompasses the occluder
            return true;
        }

        return false;
    };

    /**
     * Determine to what extent an occludee is visible (not visible, partially visible,  or fully visible).
     *
     * @memberof Occluder
     *
     * @param {BoundingSphere} occludeeBS
     *
     * @return {Enumeration} Visibility.NONE if the occludee is not visible,
     *                       Visibility.PARTIAL if the occludee is partially visible, or
     *                       Visibility.FULL if the occludee is fully visible.
     * @example
     * var sphere1 = new BoundingSphere(new Cartesian3(0, 0, -1.5), 0.5);
     * var sphere2 = new BoundingSphere(new Cartesian3(0, 0, -2.5), 0.5);
     * var cameraPosition = new Cartesian3(0, 0, 0);
     * var occluder = new Occluder(sphere1, cameraPosition);
     * occluder.getVisibility(sphere2); //returns Visibility.NONE
     *
     * @see Occluder#isVisible
     */
    Occluder.prototype.getVisibility = function(occludeeBS) {
        // If the occludee radius is larger than the occluders, this will return that
        // the entire ocludee is visible, even though that may not be the case, though this should
        // not occur too often.
        var occludeePosition = occludeeBS.center.clone();
        var occludeeRadius = occludeeBS.radius;

        if (occludeeRadius > this._occluderRadius) {
            return Visibility.FULL;
        }

        if (this._horizonDistance !== Number.MAX_VALUE) {
            // The camera is outside the occluder
            var tempVec = occludeePosition.subtract(this._occluderPosition);
            var temp = this._occluderRadius - occludeeRadius;
            var occluderToOccludeeDistSqrd = tempVec.magnitudeSquared();
            temp = occluderToOccludeeDistSqrd - (temp * temp);
            if (temp > 0.0) {
                // The occludee is not completely inside the occluder
                // Check to see if the occluder completely hides the occludee
                temp = Math.sqrt(temp) + this._horizonDistance;
                tempVec = occludeePosition.subtract(this._cameraPosition);
                var cameraToOccludeeDistSqrd = tempVec.magnitudeSquared();
                if (((temp * temp) + (occludeeRadius * occludeeRadius)) < cameraToOccludeeDistSqrd) {
                    return Visibility.NONE;
                }

                // Check to see whether the occluder is fully or partially visible
                // when the occludee does not intersect the occluder
                temp = this._occluderRadius + occludeeRadius;
                temp = occluderToOccludeeDistSqrd - (temp * temp);
                if (temp > 0.0) {
                    // The occludee does not intersect the occluder.
                    temp = Math.sqrt(temp) + this._horizonDistance;
                    return (cameraToOccludeeDistSqrd < ((temp * temp)) + (occludeeRadius * occludeeRadius)) ? Visibility.FULL : Visibility.PARTIAL;
                }

                //Check to see if the occluder is fully or partially visible when the occludee DOES
                //intersect the occluder
                tempVec = occludeePosition.subtract(this._horizonPlanePosition);
                return (tempVec.dot(this._horizonPlaneNormal) > -occludeeRadius) ? Visibility.PARTIAL : Visibility.FULL;
            }
        }
        return Visibility.NONE;
    };

    /**
     * Computes a point that can be used as the occludee position to the visibility functions.
     * Use a radius of zero for the occludee radius.  Typically, a user computes a bounding sphere around
     * an object that is used for visibility; however it is also possible to compute a point that if
     * seen/not seen would also indicate if an object is visible/not visible.  This function is better
     * called for objects that do not move relative to the occluder and is large, such as a chunk of
     * terrain.  You are better off not calling this and using the object's bounding sphere for objects
     * such as a satellite or ground vehicle.
     *
     * @memberof Occluder
     *
     * @param {BoundingSphere} occluderBoundingSphere The bounding sphere surrounding the occluder.
     * @param {Cartesian3} occludeePosition The point where the occludee (bounding sphere of radius 0) is located.
     * @param {Array} positions List of altitude points on the horizon near the surface of the occluder.
     *
     * @exception {DeveloperError} <code>positions</code> is a required, non-empty array.
     * @exception {DeveloperError} <code>occluderBoundingSphere</code> is required.
     * @exception {DeveloperError} <code>occludeePosition</code> must have a value other than <code>occluderBoundingSphere.center</code>.
     *
     * @return {Object} An object containing two attributes: <code>occludeePoint</code> and <code>valid</code>
     * which is a boolean value.
     *
     * @example
     * var cameraPosition = new Cartesian3(0, 0, 0);
     * var occluderBoundingSphere = new BoundingSphere(new Cartesian3(0, 0, -8), 2);
     * var occluder = new Occluder(occluderBoundingSphere, cameraPosition);
     * var positions = [new Cartesian3(-0.25, 0, -5.3), new Cartesian3(0.25, 0, -5.3)];
     * var tileOccluderSphere = new BoundingSphere(positions);
     * var occludeePosition = tileOccluderSphere.center;
     * var occludeePt = occluder.getOccludeePoint(occluderBoundingSphere, occludeePosition, positions);
     *
     */
    Occluder.getOccludeePoint = function(occluderBoundingSphere, occludeePosition, positions) {
        // Validate input data
        if (!occluderBoundingSphere) {
            throw new DeveloperError('occluderBoundingSphere is required.');
        }

        if (!positions) {
            throw new DeveloperError('positions is required.');
        }

        if (positions.length === 0) {
            throw new DeveloperError('positions must contain at least one element');
        }

        var occludeePos = Cartesian3.clone(occludeePosition);
        var occluderPosition = occluderBoundingSphere.center.clone();
        var occluderRadius = occluderBoundingSphere.radius;
        var numPositions = positions.length;

        if (occluderPosition.equals(occludeePosition)) {
            throw new DeveloperError('occludeePosition must be different than occluderBoundingSphere.center');
        }

        var valid = true;

        // Compute a plane with a normal from the occluder to the occludee position.
        var occluderPlaneNormal = occludeePos.subtract(occluderPosition).normalize();
        var occluderPlaneD = -(occluderPlaneNormal.dot(occluderPosition));

        //For each position, determine the horizon intersection. Choose the position and intersection
        //that results in the greatest angle with the occcluder plane.
        var aRotationVector = Occluder._anyRotationVector(occluderPosition, occluderPlaneNormal, occluderPlaneD);
        var dot = Occluder._horizonToPlaneNormalDotProduct(occluderBoundingSphere, occluderPlaneNormal, occluderPlaneD, aRotationVector, positions[0]);
        if (!dot) {
            //The position is inside the mimimum radius, which is invalid
            valid = false;
        }
        var tempDot;
        for ( var i = 1; i < numPositions; ++i) {
            tempDot = Occluder._horizonToPlaneNormalDotProduct(occluderBoundingSphere, occluderPlaneNormal, occluderPlaneD, aRotationVector, positions[i]);
            if (!tempDot) {
                //The position is inside the minimum radius, which is invalid
                valid = false;
                break;
            }
            if (tempDot < dot) {
                dot = tempDot;
            }
        }
        //Verify that the dot is not near 90 degress
        if (dot < 0.00174532836589830883577820272085) {
            valid = false;
        }

        var distance = occluderRadius / dot;
        var occludeePoint = occluderPosition.add(occluderPlaneNormal.multiplyByScalar(distance));
        return {
            occludeePoint : occludeePoint,
            valid : valid
        };
    };

    Occluder._anyRotationVector = function(occluderPosition, occluderPlaneNormal, occluderPlaneD) {
        var tempVec0 = occluderPlaneNormal.clone().abs();
        var majorAxis = tempVec0.x > tempVec0.y ? 0 : 1;
        if (((majorAxis === 0) && (tempVec0.z > tempVec0.x)) || ((majorAxis === 1) && (tempVec0.z > tempVec0.y))) {
            majorAxis = 2;
        }
        var tempVec1 = new Cartesian3();
        if (majorAxis === 0) {
            tempVec0.x = occluderPosition.x;
            tempVec0.y = occluderPosition.y + 1.0;
            tempVec0.z = occluderPosition.z + 1.0;
            tempVec1 = Cartesian3.UNIT_X;
        } else if (majorAxis === 1) {
            tempVec0.x = occluderPosition.x + 1.0;
            tempVec0.y = occluderPosition.y;
            tempVec0.z = occluderPosition.z + 1.0;
            tempVec1 = Cartesian3.UNIT_Y;
        } else {
            tempVec0.x = occluderPosition.x + 1.0;
            tempVec0.y = occluderPosition.y + 1.0;
            tempVec0.z = occluderPosition.z;
            tempVec1 = Cartesian3.UNIT_Z;
        }
        var u = ((occluderPlaneNormal.dot(tempVec0)) + occluderPlaneD) / -(occluderPlaneNormal.dot(tempVec1));
        return ((tempVec0.add(tempVec1.multiplyByScalar(u))).subtract(occluderPosition)).normalize();
    };

    Occluder._rotationVector = function(occluderPosition, occluderPlaneNormal, occluderPlaneD, position, anyRotationVector) {
        //Determine the angle between the occluder plane normal and the position direction
        var positionDirection = position.subtract(occluderPosition);
        positionDirection = positionDirection.normalize();
        if (occluderPlaneNormal.dot(positionDirection) < 0.99999998476912904932780850903444) {
            var crossProduct = occluderPlaneNormal.cross(positionDirection);
            var length = crossProduct.magnitude();
            if (length > CesiumMath.EPSILON13) {
                return crossProduct.normalize();
            }
        }
        //The occluder plane normal and the position direction are colinear. Use any
        //vector in the occluder plane as the rotation vector
        return anyRotationVector;
    };

    Occluder._horizonToPlaneNormalDotProduct = function(occluderBS, occluderPlaneNormal, occluderPlaneD, anyRotationVector, position) {
        var pos = Cartesian3.clone(position);
        var occluderPosition = occluderBS.center.clone();
        var occluderRadius = occluderBS.radius;

        //Verify that the position is outside the occluder
        var positionToOccluder = occluderPosition.subtract(pos);
        var occluderToPositionDistanceSquared = positionToOccluder.magnitudeSquared();
        var occluderRadiusSquared = occluderRadius * occluderRadius;
        if (occluderToPositionDistanceSquared < occluderRadiusSquared) {
            return false;
        }

        //Horizon parameters
        var horizonDistanceSquared = occluderToPositionDistanceSquared - occluderRadiusSquared;
        var horizonDistance = Math.sqrt(horizonDistanceSquared);
        var occluderToPositionDistance = Math.sqrt(occluderToPositionDistanceSquared);
        var invOccluderToPositionDistance = 1.0 / occluderToPositionDistance;
        var cosTheta = horizonDistance * invOccluderToPositionDistance;
        var horizonPlaneDistance = cosTheta * horizonDistance;
        positionToOccluder = positionToOccluder.normalize();
        var horizonPlanePosition = pos.add(positionToOccluder.multiplyByScalar(horizonPlaneDistance));
        var horizonCrossDistance = Math.sqrt(horizonDistanceSquared - (horizonPlaneDistance * horizonPlaneDistance));

        //Rotate the position to occluder vector 90 degrees
        var tempVec = this._rotationVector(occluderPosition, occluderPlaneNormal, occluderPlaneD, pos, anyRotationVector);
        var horizonCrossDirection = new Cartesian3(
                (tempVec.x * tempVec.x * positionToOccluder.x) + ((tempVec.x * tempVec.y - tempVec.z) * positionToOccluder.y) + ((tempVec.x * tempVec.z + tempVec.y) * positionToOccluder.z),
                ((tempVec.x * tempVec.y + tempVec.z) * positionToOccluder.x) + (tempVec.y * tempVec.y * positionToOccluder.y) + ((tempVec.y * tempVec.z - tempVec.x) * positionToOccluder.z),
                ((tempVec.x * tempVec.z - tempVec.y) * positionToOccluder.x) + ((tempVec.y * tempVec.z + tempVec.x) * positionToOccluder.y) + (tempVec.z * tempVec.z * positionToOccluder.z));
        horizonCrossDirection = horizonCrossDirection.normalize();

        //Horizon positions
        var offset = horizonCrossDirection.multiplyByScalar(horizonCrossDistance);
        tempVec = ((horizonPlanePosition.add(offset)).subtract(occluderPosition)).normalize();
        var dot0 = occluderPlaneNormal.dot(tempVec);
        tempVec = ((horizonPlanePosition.subtract(offset)).subtract(occluderPosition)).normalize();
        var dot1 = occluderPlaneNormal.dot(tempVec);
        return (dot0 < dot1) ? dot0 : dot1;
    };

    return Occluder;
});
/*global define*/
define('Core/WindingOrder',['./Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports WindingOrder
     */
    var WindingOrder = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        CLOCKWISE : new Enumeration(0x0900, 'CLOCKWISE'), // WebGL: CW
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        COUNTER_CLOCKWISE : new Enumeration(0x0901, 'COUNTER_CLOCKWISE'), // WebGL CCW

        /**
         * DOC_TBA
         *
         * @param windingOrder
         *
         * @returns {Boolean}
         */
        validate : function(windingOrder) {
            return ((windingOrder === WindingOrder.CLOCKWISE) ||
                    (windingOrder === WindingOrder.COUNTER_CLOCKWISE));
        }
    };

    return WindingOrder;
});
/*global define*/
define('Core/binarySearch',['./DeveloperError'], function(DeveloperError) {
    

    /**
     * Finds an item in a sorted array.
     *
     * @exports binarySearch
     *
     * @param {Array} array The sorted array to search.
     * @param {Object} itemToFind The item to find in the array.
     *
     * @param {Function} comparator The function to use to compare the item to elements in the array.
     *        The first parameter passed to the comparator function is an item in the array, the
     *        second is <code>itemToFind</code>.  If the array item is less than <code>itemToFind</code>,
     *        the function should return a negative value.  If it is greater, the function should return
     *        a positive value.  If the items are equal, it should return 0.
     *
     * @return {Number} The index of <code>itemToFind</code> in the array, if it exists.  If <code>itemToFind</code>
     *        does not exist, the return value is a negative number which is the bitwise complement (~)
     *        of the index before which the itemToFind should be inserted in order to maintain the
     *        sorted order of the array.
     *
     * @exception {DeveloperError} <code>array</code> is required.
     * @exception {DeveloperError} <code>toFind</code> is required.
     * @exception {DeveloperError} <code>comparator</code> is required.
     *
     * @example
     * // Create a comparator function to search through an array of numbers.
     * var comparator = function (a, b){
     *     return a - b;
     * };
     * var numbers = [0, 2, 4, 6, 8];
     * var index = binarySearch(numbers, 6, comparator); // 3
     */
    var binarySearch = function(array, itemToFind, comparator) {
        if (!array) {
            throw new DeveloperError('array is required.');
        }
        if (!itemToFind) {
            throw new DeveloperError('itemToFind is required.');
        }
        if (!comparator) {
            throw new DeveloperError('comparator is required.');
        }

        var low = 0;
        var high = array.length - 1;
        var i;
        var comparison;

        while (low <= high) {
            i = ~~((low + high) / 2);
            comparison = comparator(array[i], itemToFind);
            if (comparison < 0) {
                low = i + 1;
                continue;
            }
            if (comparison > 0) {
                high = i - 1;
                continue;
            }
            return i;
        }
        return ~(high + 1);
    };

    return binarySearch;
});
/*global define*/
define('Core/AnimationController',[
    './binarySearch',
    './DeveloperError'
], function(
    binarySearch,
    DeveloperError
) {
    

    /**
     * This controls animation by manipulating a Clock object.
     * @alias AnimationController
     * @constructor
     *
     * @param {Clock} clock The clock that will be controlled.
     *
     * @see Clock
     */
    var AnimationController = function(clock) {
        this.clock = clock;
        this._animating = true;
        if (typeof clock !== 'object') {
            throw new DeveloperError('Clock parameter required to construct AnimationController.');
        }
    };

    var typicalMultipliers = [0.001, 0.002, 0.005, 0.01, 0.02, 0.05, 0.1, 0.25, 0.5, 1.0, 2.0, 5.0, 10.0, 15.0, 30.0, 60.0, 120.0, 300.0, 600.0, 900.0, 1800.0, 3600.0, 7200.0, 14400.0, 21600.0,
                              43200.0, 86400.0];

    /**
     * Test if the AnimationController is playing or paused.
     * @memberof AnimationController
     *
     * @returns Boolean <code>true</code> if the AnimationController is animating in either direction.
     */
    AnimationController.prototype.isAnimating = function() {
        return this._animating;
    };

    /**
     * Stop animating, and reset the clock back to the start time.
     * @memberof AnimationController
     */
    AnimationController.prototype.reset = function() {
        this.clock.currentTime = this.clock.startTime;
        this._animating = false;
    };

    /**
     * Update the clock to the appropriate animation time.  This function
     * should be called exactly once per animation frame, prior to updating
     * any other objects that depend on the animation time.
     * @memberof AnimationController
     *
     * @returns {JulianDate} The updated time if animating, or <code>currentTime</code> if paused.
     */
    AnimationController.prototype.update = function() {
        return this._animating ? this.clock.tick() : this.clock.currentTime;
    };

    /**
     * Stop animating, and hold on the current time.
     * @memberof AnimationController
     */
    AnimationController.prototype.pause = function() {
        this._animating = false;
    };

    /**
     * Begin or resume animating in a forward direction.
     * @memberof AnimationController
     */
    AnimationController.prototype.play = function() {
        this._animating = true;
        var clock = this.clock;
        if (clock.multiplier < 0) {
            clock.multiplier = -clock.multiplier;
        }
        this.clock.tick(0);
    };

    /**
     * Begin or resume animating in a reverse direction.
     * @memberof AnimationController
     */
    AnimationController.prototype.playReverse = function() {
        this._animating = true;
        var clock = this.clock;
        if (clock.multiplier > 0) {
            clock.multiplier = -clock.multiplier;
        }
        this.clock.tick(0);
    };

    /**
     * Slow down the speed of animation, so time appears to pass more slowly.
     * @memberof AnimationController
     */
    AnimationController.prototype.slower = function() {
        var clock = this.clock;
        var multiplier = clock.multiplier > 0 ? clock.multiplier : -clock.multiplier;
        var index = binarySearch(typicalMultipliers, multiplier, function(left, right) {
            return left - right;
        });

        if (index < 0) {
            index = ~index;
        }
        index--;

        if (index === -1) {
            clock.multiplier *= 0.5;
        } else if (clock.multiplier >= 0) {
            clock.multiplier = typicalMultipliers[index];
        } else {
            clock.multiplier = -typicalMultipliers[index];
        }
    };

    /**
     * Speed up the animation, so time appears to pass more quickly.
     * @memberof AnimationController
     */
    AnimationController.prototype.faster = function() {
        var clock = this.clock;
        var multiplier = clock.multiplier > 0 ? clock.multiplier : -clock.multiplier;
        var index = binarySearch(typicalMultipliers, multiplier, function(left, right) {
            return left - right;
        });

        if (index < 0) {
            index = ~index;
        } else {
            index++;
        }

        if (index === typicalMultipliers.length) {
            clock.multiplier *= 2.0;
        } else if (clock.multiplier >= 0) {
            clock.multiplier = typicalMultipliers[index];
        } else {
            clock.multiplier = -typicalMultipliers[index];
        }
    };

    return AnimationController;
});
/*global define*/
define('Core/clone',[],function() {
    

    function clone(object) {
        if (object === null || typeof object !== 'object') {
            return object;
        }

        var temp = new object.constructor();
        for ( var key in object) {
            if (object.hasOwnProperty(key)) {
                temp[key] = clone(object[key]);
            }
        }

        return temp;
    }

    return clone;
});

/*global define*/
define('Core/combine',[
        './DeveloperError'
    ], function(
        DeveloperError) {
    

    /**
     * Combines the objects passed as arguments into a single result object containing
     * all properties from all objects.
     *
     * @exports combine
     *
     * @exception {DeveloperError} Duplicate member.
     */
    var combine = function() {
        var composite = {};

        for ( var i = 0, length = arguments.length; i < length; ++i) {
            var object = arguments[i];

            // Shallow copy
            for ( var key in object) {
                if (object.hasOwnProperty(key)) {
                    if (typeof composite[key] !== 'undefined') {
                        throw new DeveloperError('Duplicate member: ' + key);
                    }

                    composite[key] = object[key];
                }
            }
        }

        return composite;
    };

    return combine;
});
/*global define*/
define('Core/createGuid',[],function() {
    

    /**
     * Creates a Globally unique identifier (GUID) string.  A GUID is 128 bits long, and can guarantee uniqueness across space and time.
     *
     * @exports createGuid
     *
     * @see <a href='http://www.ietf.org/rfc/rfc4122.txt'>RFC 4122 A Universally Unique IDentifier (UUID) URN Namespace</a>
     *
     * @example
     * this.guid = createGuid();
     */
    var createGuid = function() {
        // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            var r = Math.random() * 16 | 0;
            var v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    };

    return createGuid;
});
/*global define*/
define('Core/defaultValue',[],function() {
    

    /**
     * Returns the first parameter if not undefined, otherwise the second parameter.
     * Useful for setting a default value for a parameter.
     *
     * @exports defaultValue
     *
     * @example
     * param = defaultValue(param, 'default');
     */
    var defaultValue = function(a, b) {
        if (typeof a !== 'undefined') {
            return a;
        }
        return b;
    };

    return defaultValue;
});
/*global define*/
define('Core/Cartographic',[
        './defaultValue',
        './DeveloperError',
        './Math'
    ], function(
        defaultValue,
        DeveloperError,
        CesiumMath) {
    

    /**
     * A position defined by longitude, latitude, and height.
     * @alias Cartographic
     * @constructor
     *
     * @param {Number} [longitude=0.0] The longitude, in radians.
     * @param {Number} [latitude=0.0] The latitude, in radians.
     * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.
     *
     * @see Ellipsoid
     */
    var Cartographic = function(longitude, latitude, height) {
        /**
         * The longitude, in radians.
         * @type Number
         */
        this.longitude = defaultValue(longitude, 0.0);

        /**
         * The latitude, in radians.
         * @type Number
         */
        this.latitude = defaultValue(latitude, 0.0);

        /**
         * The height, in meters, above the ellipsoid.
         * @type Number
         */
        this.height = defaultValue(height, 0.0);
    };

    /**
     * Creates a new Cartographic instance from longitude and latitude
     * specified in degrees.  The values in the resulting object will
     * be in radians.
     * @memberof Cartographic
     *
     * @param {Number} [longitude=0.0] The longitude, in degrees.
     * @param {Number} [latitude=0.0] The latitude, in degrees.
     * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.
     * @param {Cartographic} [result] The object onto which to store the result.
     * @return {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.
     */
    Cartographic.fromDegrees = function(longitude, latitude, height, result) {
        longitude = CesiumMath.toRadians(defaultValue(longitude, 0.0));
        latitude = CesiumMath.toRadians(defaultValue(latitude, 0.0));
        height = defaultValue(height, 0.0);

        if (typeof result === 'undefined') {
            return new Cartographic(longitude, latitude, height);
        }

        result.longitude = longitude;
        result.latitude = latitude;
        result.height = height;
        return result;
    };

    /**
     * Duplicates a Cartographic instance.
     * @memberof Cartographic
     *
     * @param {Cartographic} cartographic The cartographic to duplicate.
     * @param {Cartographic} [result] The object onto which to store the result.
     * @return {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.
     *
     * @exception {DeveloperError} cartographic is required.
     */
    Cartographic.clone = function(cartographic, result) {
        if (typeof cartographic === 'undefined') {
            throw new DeveloperError('cartographic is required');
        }
        if (typeof result === 'undefined') {
            return new Cartographic(cartographic.longitude, cartographic.latitude, cartographic.height);
        }
        result.longitude = cartographic.longitude;
        result.latitude = cartographic.latitude;
        result.height = cartographic.height;
        return result;
    };

    /**
     * Compares the provided cartographics componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @memberof Cartographic
     *
     * @param {Cartographic} [left] The first cartographic.
     * @param {Cartographic} [right] The second cartographic.
     * @return {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    Cartographic.equals = function(left, right) {
        return (left === right) ||
                ((typeof left !== 'undefined') &&
                 (typeof right !== 'undefined') &&
                 (left.longitude === right.longitude) &&
                 (left.latitude === right.latitude) &&
                 (left.height === right.height));
    };

    /**
     * Compares the provided cartographics componentwise and returns
     * <code>true</code> if they are within the provided epsilon,
     * <code>false</code> otherwise.
     * @memberof Cartographic
     *
     * @param {Cartographic} [left] The first cartographic.
     * @param {Cartographic} [right] The second cartographic.
     * @param {Number} epsilon The epsilon to use for equality testing.
     * @return {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
     *
     * @exception {DeveloperError} epsilon is required and must be a number.
     */
    Cartographic.equalsEpsilon = function(left, right, epsilon) {
        if (typeof epsilon !== 'number') {
            throw new DeveloperError('epsilon is required and must be a number.');
        }
        return (left === right) ||
               ((typeof left !== 'undefined') &&
                (typeof right !== 'undefined') &&
                (Math.abs(left.longitude - right.longitude) <= epsilon) &&
                (Math.abs(left.latitude - right.latitude) <= epsilon) &&
                (Math.abs(left.height - right.height) <= epsilon));
    };

    /**
     * Creates a string representing the provided cartographic in the format '(longitude, latitude, height)'.
     * @memberof Cartographic
     *
     * @param {Cartographic} cartographic The cartographic to stringify.
     * @return {String} A string representing the provided cartographic in the format '(longitude, latitude, height)'.
     *
     * @exception {DeveloperError} cartographic is required.
     */
    Cartographic.toString = function(cartographic) {
        if (typeof cartographic === 'undefined') {
            throw new DeveloperError('cartographic is required');
        }
        return '(' + cartographic.longitude + ', ' + cartographic.latitude + ', ' + cartographic.height + ')';
    };

    /**
     * An immutable Cartographic instance initialized to (0.0, 0.0, 0.0).
     *
     * @memberof Cartographic
     */
    Cartographic.ZERO = Object.freeze(new Cartographic(0.0, 0.0, 0.0));

    /**
     * Duplicates this instance.
     * @memberof Cartographic
     *
     * @param {Cartographic} [result] The object onto which to store the result.
     * @return {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.
     */
    Cartographic.prototype.clone = function(result) {
        return Cartographic.clone(this, result);
    };

    /**
     * Compares the provided against this cartographic componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @memberof Cartographic
     *
     * @param {Cartographic} [right] The second cartographic.
     * @return {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    Cartographic.prototype.equals = function(right) {
        return Cartographic.equals(this, right);
    };

    /**
     * Compares the provided against this cartographic componentwise and returns
     * <code>true</code> if they are within the provided epsilon,
     * <code>false</code> otherwise.
     * @memberof Cartographic
     *
     * @param {Cartographic} [right] The second cartographic.
     * @param {Number} epsilon The epsilon to use for equality testing.
     * @return {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
     *
     * @exception {DeveloperError} epsilon is required and must be a number.
     */
    Cartographic.prototype.equalsEpsilon = function(right, epsilon) {
        return Cartographic.equalsEpsilon(this, right, epsilon);
    };

    /**
     * Creates a string representing this cartographic in the format '(longitude, latitude, height)'.
     * @memberof Cartographic
     *
     * @return {String} A string representing the provided cartographic in the format '(longitude, latitude, height)'.
     */
    Cartographic.prototype.toString = function() {
        return Cartographic.toString(this);
    };

    return Cartographic;
});

/*global define*/
define('Core/Ellipsoid',[
        './DeveloperError',
        './Math',
        './Cartesian3',
        './Cartographic'
    ], function(
        DeveloperError,
        CesiumMath,
        Cartesian3,
        Cartographic) {
    

    /**
     * DOC_TBA
     * @alias Ellipsoid
     *
     * @param {Cartesian3} radii The ellipsoid's radius in the x, y, and z ds.
     *
     * @constructor
     * @immutable
     *
     * @exception {DeveloperError} radii is required.
     * @exception {DeveloperError} All radii components must be greater than or equal to zero.
     */
    var Ellipsoid = function(radii) {
        if (arguments.length === 0) {
            throw new DeveloperError('radii is required.');
        }

        if (radii.x < 0 || radii.y < 0 || radii.z < 0) {
            throw new DeveloperError('All radii components must be greater than or equal to zero.');
        }

        radii = Cartesian3.clone(radii);
        var x = radii.x;
        var y = radii.y;
        var z = radii.z;

        this._radii = radii;
        this._radiiSquared = new Cartesian3(
                x * x,
                y * y,
                z * z);
        this._radiiToTheFourth = new Cartesian3(
                x * x * x * x,
                y * y * y * y,
                z * z * z * z);
        this._oneOverRadii = new Cartesian3(
                1.0 / x,
                1.0 / y,
                1.0 / z);
        this._oneOverRadiiSquared = new Cartesian3(
                1.0 / (x * x),
                1.0 / (y * y),
                1.0 / (z * z));
    };

    /**
     * DOC_TBA
     *
     * @memberof Ellipsoid
     *
     * @return {Ellipsoid} DOC_TBA
     *
     * @see agi_getWgs84EllipsoidEC
     */
    Ellipsoid.WGS84 = Object.freeze(new Ellipsoid(new Cartesian3(6378137.0, 6378137.0, 6356752.314245)));

    /**
     * DOC_TBA
     *
     * @memberof Ellipsoid
     *
     * @return {Ellipsoid} DOC_TBA
     */
    Ellipsoid.UNIT_SPHERE = Object.freeze(new Ellipsoid(new Cartesian3(1.0, 1.0, 1.0)));

    /**
     * DOC_TBA
     *
     * @memberof Ellipsoid
     *
     * @return {Cartesian3} DOC_TBA
     */
    Ellipsoid.prototype.getRadii = function() {
        return this._radii;
    };

    /**
     * DOC_TBA
     *
     * @memberof Ellipsoid
     *
     * @return {Cartesian3} DOC_TBA
     */
    Ellipsoid.prototype.getRadiiSquared = function() {
        return this._radiiSquared;
    };

    /**
     * DOC_TBA
     *
     * @memberof Ellipsoid
     *
     * @return {Cartesian3} DOC_TBA
     */
    Ellipsoid.prototype.getRadiiToTheFourth = function() {
        return this._radiiToTheFourth;
    };

    /**
     * DOC_TBA
     *
     * @memberof Ellipsoid
     *
     * @return {Cartesian3} DOC_TBA
     */
    Ellipsoid.prototype.getOneOverRadii = function() {
        return this._oneOverRadii;
    };

    /**
     * DOC_TBA
     *
     * @memberof Ellipsoid
     *
     * @return {Cartesian3} DOC_TBA
     */
    Ellipsoid.prototype.getOneOverRadiiSquared = function() {
        return this._oneOverRadiiSquared;
    };

    /**
     * DOC_TBA
     *
     * @memberof Ellipsoid
     *
     * @return {Number} DOC_TBA
     */
    Ellipsoid.prototype.getMinimumRadius = function() {
        var radii = this.getRadii();
        return Math.min(radii.x, Math.min(radii.y, radii.z));
    };

    /**
     * DOC_TBA
     *
     * @memberof Ellipsoid
     *
     * @return {Number} DOC_TBA
     */
    Ellipsoid.prototype.getMaximumRadius = function() {
        var radii = this.getRadii();
        return Math.max(radii.x, Math.max(radii.y, radii.z));
    };

    /**
     * DOC_TBA
     *
     * @memberof Ellipsoid
     *
     * @param {Cartesian3} positionOnEllipsoid DOC_TBA
     *
     * @return {Cartesian3} DOC_TBA
     */
    Ellipsoid.geocentricSurfaceNormal = function(positionOnEllipsoid) {
        var position = Cartesian3.clone(positionOnEllipsoid);
        return position.normalize();
    };

    /**
     * DOC_TBA
     *
     * @memberof Ellipsoid
     *
     * @param {Cartesian3} positionOnEllipsoid DOC_TBA
     *
     * @return {Cartesian3} DOC_TBA
     */
    Ellipsoid.prototype.geodeticSurfaceNormal = function(positionOnEllipsoid) {
        var position = Cartesian3.clone(positionOnEllipsoid);
        return (position.multiplyComponents(this.getOneOverRadiiSquared())).normalize();
    };

    /**
     * DOC_TBA
     *
     * @memberof Ellipsoid
     *
     * @param {Cartographic} position DOC_TBA
     * @return {Cartesian3} DOC_TBA
     */
    Ellipsoid.prototype.geodeticSurfaceNormalc = function(position) {
        var cosLatitude = Math.cos(position.latitude);

        return new Cartesian3(
                cosLatitude * Math.cos(position.longitude),
                cosLatitude * Math.sin(position.longitude),
                Math.sin(position.latitude));
    };

    /**
     * DOC_TBA
     *
     * @memberof Ellipsoid
     *
     * @param position Input is Cartographic.
     */
    Ellipsoid.prototype.cartographicToCartesian = function(position) {
        var n = this.geodeticSurfaceNormalc(position);
        var k = this.getRadiiSquared().multiplyComponents(n);
        var gamma = Math.sqrt((k.x * n.x) + (k.y * n.y) + (k.z * n.z));

        var rSurface = k.divideByScalar(gamma);
        return rSurface.add(n.multiplyByScalar(position.height || 0.0));
    };

    /**
     * DOC_TBA
     *
     * @memberof Ellipsoid
     *
     * @param positions Input is array of Cartographic.
     */
    Ellipsoid.prototype.cartographicArrayToCartesianArray = function(positions) {
        var length = positions.length;
        var cartesians = new Array(length);
        for ( var i = 0; i < length; ++i) {
            cartesians[i] = this.cartographicToCartesian(positions[i]);
        }
        return cartesians;
    };

    /**
     * DOC_TBA
     *
     * @memberof Ellipsoid
     *
     * @param {Cartesian3} position DOC_TBA
     * @return {Cartographic} DOC_TBA
     */
    Ellipsoid.prototype.cartesianToCartographic = function(position) {
        var pos = Cartesian3.clone(position);
        var n = this.geodeticSurfaceNormal(pos);
        var p = this.scaleToGeodeticSurface(pos);
        var h = position.subtract(p);
        var height = CesiumMath.sign(h.dot(pos)) * h.magnitude();
        return new Cartographic(Math.atan2(n.y, n.x), Math.asin(n.z / n.magnitude()), height);
    };

    /**
     * DOC_TBA
     *
     * @memberof Ellipsoid
     */
    Ellipsoid.prototype.cartesianArrayToCartographicArray = function(positions) {
        if (positions) {
            var cartographics = [];
            var length = positions.length;
            for ( var i = 0; i < length; ++i) {
                cartographics.push(this.cartesianToCartographic(positions[i]));
            }
            return cartographics;
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof Ellipsoid
     *
     * @param {Cartesian3} position DOC_TBA
     * @return {Cartesian3} DOC_TBA
     */
    Ellipsoid.prototype.scaleToGeodeticSurface = function(position) {
        var pos = Cartesian3.clone(position);
        var positionX = position.x;
        var positionY = position.y;
        var positionZ = position.z;

        var oneOverRadiiSquared = this.getOneOverRadiiSquared();
        var oneOverRadiiSquaredX = oneOverRadiiSquared.x;
        var oneOverRadiiSquaredY = oneOverRadiiSquared.y;
        var oneOverRadiiSquaredZ = oneOverRadiiSquared.z;

        var radiiSquared = this.getRadiiSquared();
        var radiiSquaredX = radiiSquared.x;
        var radiiSquaredY = radiiSquared.y;
        var radiiSquaredZ = radiiSquared.z;

        var radiiToTheFourth = this.getRadiiToTheFourth();
        var radiiToTheFourthX = radiiToTheFourth.x;
        var radiiToTheFourthY = radiiToTheFourth.y;
        var radiiToTheFourthZ = radiiToTheFourth.z;

        var beta = 1.0 / Math.sqrt(
                (positionX * positionX) * oneOverRadiiSquaredX +
                (positionY * positionY) * oneOverRadiiSquaredY +
                (positionZ * positionZ) * oneOverRadiiSquaredZ);
        var n = new Cartesian3(
                beta * positionX * oneOverRadiiSquaredX,
                beta * positionY * oneOverRadiiSquaredY,
                beta * positionZ * oneOverRadiiSquaredZ).magnitude();
        var alpha = (1.0 - beta) * (pos.magnitude() / n);

        var x2 = positionX * positionX;
        var y2 = positionY * positionY;
        var z2 = positionZ * positionZ;

        var da = 0.0;
        var db = 0.0;
        var dc = 0.0;

        var s = 0.0;
        var dSdA = 1.0;

        do {
            alpha -= (s / dSdA);

            da = 1.0 + (alpha * oneOverRadiiSquaredX);
            db = 1.0 + (alpha * oneOverRadiiSquaredY);
            dc = 1.0 + (alpha * oneOverRadiiSquaredZ);

            var da2 = da * da;
            var db2 = db * db;
            var dc2 = dc * dc;

            var da3 = da * da2;
            var db3 = db * db2;
            var dc3 = dc * dc2;

            s = x2 / (radiiSquaredX * da2) +
                y2 / (radiiSquaredY * db2) +
                z2 / (radiiSquaredZ * dc2) - 1.0;

            dSdA = -2.0 *
                    (x2 / (radiiToTheFourthX * da3) +
                     y2 / (radiiToTheFourthY * db3) +
                     z2 / (radiiToTheFourthZ * dc3));
        } while (Math.abs(s) > CesiumMath.EPSILON10);

        return new Cartesian3(
                positionX / da,
                positionY / db,
                positionZ / dc);
    };

    /**
     * DOC_TBA
     *
     * @memberof Ellipsoid
     *
     * @param {Cartesian3} position DOC_TBA
     * @return {Cartesian3} DOC_TBA
     */
    Ellipsoid.prototype.scaleToGeocentricSurface = function(position) {
        var pos = Cartesian3.clone(position);
        var positionX = position.x;
        var positionY = position.y;
        var positionZ = position.z;
        var oneOverRadiiSquared = this.getOneOverRadiiSquared();

        var beta = 1.0 / Math.sqrt(
                (positionX * positionX) * oneOverRadiiSquared.x +
                (positionY * positionY) * oneOverRadiiSquared.y +
                (positionZ * positionZ) * oneOverRadiiSquared.z);

        return pos.multiplyByScalar(beta);
    };

    /**
     * Returns <code>true</code> if this ellipsoid equals <code>other</code>, meaning their radii are equal.
     *
     * @memberof Ellipsoid
     *
     * @param {Ellipsoid} other The Ellipsoid to compare for equality.
     *
     * @return {Boolean} <code>true</code> if the ellipsoids are equal; otherwise, <code>false</code>.
     */
    Ellipsoid.prototype.equals = function(other) {
        return this._radii.equals(other._radii);
    };

    return Ellipsoid;
});

/*global define*/
define('Core/Transforms',[
        './DeveloperError',
        './Math',
        './Matrix3',
        './Matrix4',
        './Cartesian2',
        './Cartesian3',
        './Cartesian4',
        './TimeConstants',
        './Ellipsoid'
    ],
    function(
        DeveloperError,
        CesiumMath,
        Matrix3,
        Matrix4,
        Cartesian2,
        Cartesian3,
        Cartesian4,
        TimeConstants,
        Ellipsoid) {
    

    var gmstConstant0 = 6 * 3600 + 41 * 60 + 50.54841;
    var gmstConstant1 = 8640184.812866;
    var gmstConstant2 = 0.093104;
    var gmstConstant3 = -6.2E-6;
    var rateCoef = 1.1772758384668e-19;
    var wgs84WRPrecessing = 7.2921158553E-5;
    var twoPiOverSecondsInDay = CesiumMath.TWO_PI / 86400.0;

    /**
     * @exports Transforms
     *
     * DOC_TBA
     */
    var Transforms = {
        /**
         * Creates a 4x4 transformation matrix from a reference frame center at <code>position</code>
         * with local east-north-up axes to the ellipsoid's fixed reference frame, e.g., WGS84 coordinates
         * for Earth.  The local axes are defined as:
         * <ul>
         * <li>The <code>x</code> axis points in the local east direction.</li>
         * <li>The <code>y</code> axis points in the local north direction.</li>
         * <li>The <code>z</code> axis points in the direction of the ellipsoid surface normal which passes through the position.</li>
         * </ul>
         *
         * DOC_TBA:  Add images
         *
         * @param {Cartesian3} position The center point of the local reference frame.
         * @param {Ellipsoid} [ellipsoid] The ellipsoid whose fixed frame is used in the transform.
         *
         * @see Transforms.northEastDownToFixedFrame
         *
         * @exception {DeveloperError} position is required.
         *
         * @example
         * // Get the transform from local east-north-up at cartographic (0.0, 0.0) to Earth's fixed frame.
         * var ellipsoid = Ellipsoid.WGS84;
         * var center = ellipsoid.cartographicToCartesian(Cartographic.ZERO);
         * var transform = Transforms.eastNorthUpToFixedFrame(center);
         */
        eastNorthUpToFixedFrame : function(position, ellipsoid) {
            if (!position) {
                throw new DeveloperError('position is required.');
            }

            ellipsoid = ellipsoid || Ellipsoid.WGS84;

            if (CesiumMath.equalsEpsilon(position.x, 0.0, CesiumMath.EPSILON14) &&
                    CesiumMath.equalsEpsilon(position.y, 0.0, CesiumMath.EPSILON14)) {
                // The poles are special cases.  If x and y are zero, assume position is at a pole.
                var sign = CesiumMath.sign(position.z);
                return new Matrix4(
                    0.0, sign * -1.0,        0.0, position.x,
                    1.0,         0.0,        0.0, position.y,
                    0.0,         0.0, sign * 1.0, position.z,
                    0.0,         0.0,        0.0, 1.0);
            }

            var normal = ellipsoid.geodeticSurfaceNormal(position);
            var tangent = new Cartesian3(-position.y, position.x, 0.0).normalize();
            var bitangent = normal.cross(tangent);

            return new Matrix4(
                tangent.x, bitangent.x, normal.x, position.x,
                tangent.y, bitangent.y, normal.y, position.y,
                tangent.z, bitangent.z, normal.z, position.z,
                0.0,       0.0,         0.0,      1.0);
        },

        /**
         * Creates a 4x4 transformation matrix from a reference frame center at <code>position</code>
         * with local north-east-down axes to the ellipsoid's fixed reference frame, e.g., WGS84 coordinates
         * for Earth.  The local axes are defined as:
         * <ul>
         * <li>The <code>x</code> axis points in the local north direction.</li>
         * <li>The <code>y</code> axis points in the local east direction.</li>
         * <li>The <code>z</code> axis points in the opposite direction of the ellipsoid surface normal which passes through the position.</li>
         * </ul>
         *
         * DOC_TBA:  Add images
         *
         * @param {Cartesian3} position The center point of the local reference frame.
         * @param {Ellipsoid} [ellipsoid] The ellipsoid whose fixed frame is used in the transform.
         *
         * @see Transforms.eastNorthUpToFixedFrame
         *
         * @exception {DeveloperError} position is required.
         *
         * @example
         * // Get the transform from local north-east-down at cartographic (0.0, 0.0) to Earth's fixed frame.
         * var ellipsoid = Ellipsoid.WGS84;
         * var center = ellipsoid.cartographicToCartesian(Cartographic.ZERO);
         * var transform = Transforms.northEastDownToFixedFrame(center);
         */
        northEastDownToFixedFrame : function(position, ellipsoid) {
            if (!position) {
                throw new DeveloperError('position is required.');
            }

            ellipsoid = ellipsoid || Ellipsoid.WGS84;

            if (CesiumMath.equalsEpsilon(position.x, 0.0, CesiumMath.EPSILON14) &&
                    CesiumMath.equalsEpsilon(position.y, 0.0, CesiumMath.EPSILON14)) {
                // The poles are special cases.  If x and y are zero, assume position is at a pole.
                var sign = CesiumMath.sign(position.z);
                return new Matrix4(
                    sign * -1.0, 0.0, 0.0, position.x,
                    0.0, 1.0,         0.0, position.y,
                    0.0, 0.0, sign * -1.0, position.z,
                    0.0, 0.0,         0.0, 1.0);
            }

            var normal = ellipsoid.geodeticSurfaceNormal(position);
            var tangent = new Cartesian3(-position.y, position.x, 0.0).normalize();
            var bitangent = normal.cross(tangent);

            return new Matrix4(
                bitangent.x, tangent.x, -normal.x, position.x,
                bitangent.y, tangent.y, -normal.y, position.y,
                bitangent.z, tangent.z, -normal.z, position.z,
                0.0,         0.0,        0.0,      1.0);
        },

        /**
         * Computes a rotation matrix to transform a point or vector from True Equator Mean Equinox (TEME) axes to the
         * pseudo-fixed axes at a given time.  This method treats the UT1 time standard as equivalent to UTC.
         *
         * @param {JulianDate} date The time at which to compute the rotation matrix.
         *
         * @exception {DeveloperError} date is required.
         *
         * @return {Matrix3} A rotation matrix that transforms a vector in the TEME axes to the pseudo-fixed axes at the given {@code date}.
         *
         * @example
         * scene.setAnimation(function() {
         *     var time = new Cesium.JulianDate();
         *     scene.setSunPosition(Cesium.SunPosition.compute(time).position);
         *     scene.getCamera().transform = Cesium.Matrix4.fromRotationTranslation(Cesium.Transforms.computeTemeToPseudoFixedMatrix(time), Cesium.Cartesian3.ZERO);
         * });
         */
        computeTemeToPseudoFixedMatrix : function (date) {
            if (typeof date === 'undefined') {
                throw new DeveloperError('date is required.');
            }

            // GMST is actually computed using UT1.  We're using UTC as an approximation of UT1.
            // We do not want to use the function like convertTaiToUtc in JulianDate because
            // we explicitly do not want to fail when inside the leap second.

            var dateInUtc = date.addSeconds(-date.getTaiMinusUtc());

            var t;
            var diffDays = dateInUtc.getJulianDayNumber() - 2451545;
            if (dateInUtc.getSecondsOfDay() >= 43200.0) {
                t = (diffDays + 0.5) / TimeConstants.DAYS_PER_JULIAN_CENTURY;
            } else {
                t = (diffDays - 0.5) / TimeConstants.DAYS_PER_JULIAN_CENTURY;
            }

            var gmst0 = gmstConstant0 + t * (gmstConstant1 + t * (gmstConstant2 + t * gmstConstant3));
            var angle = (gmst0 * twoPiOverSecondsInDay) % CesiumMath.TWO_PI;
            var ratio = wgs84WRPrecessing + rateCoef * (dateInUtc.getJulianDayNumber() - 0.5 - 2451545);

            var secondsSinceMidnight = (dateInUtc.getSecondsOfDay() + TimeConstants.SECONDS_PER_DAY / 2.0) % 86400.0;

            var gha = angle + (ratio * secondsSinceMidnight);

            var cosGha = Math.cos(gha);
            var sinGha = Math.sin(gha);
            return new Matrix3(cosGha, sinGha, 0.0, -sinGha, cosGha, 0.0, 0.0, 0.0, 1.0);
        },

        /**
         * Transform a point from model coordinates to window coordinates.
         *
         * @param {Matrix4} modelViewProjectionMatrix The 4x4 model-view-projection matrix.
         * @param {Matrix4} viewportTransformation The 4x4 viewport transformation.
         * @param {Cartesian3} point The point to transform.
         *
         * @returns {Cartesian2} The point in window coordinates.
         *
         * @see UniformState#getModelViewProjection
         * @see agi_modelViewProjection
         * @see UniformState#getViewportTransformation
         * @see agi_viewportTransformation
         *
         * @exception {DeveloperError} modelViewProjectionMatrix is required.
         * @exception {DeveloperError} viewportTransformation is required.
         * @exception {DeveloperError} point is required.
         */
        pointToWindowCoordinates : function (modelViewProjectionMatrix, viewportTransformation, point) {
            if (typeof modelViewProjectionMatrix === 'undefined') {
                throw new DeveloperError('modelViewProjectionMatrix is required.');
            }

            if (typeof viewportTransformation === 'undefined') {
                throw new DeveloperError('viewportTransformation is required.');
            }

            if (typeof point === 'undefined') {
                throw new DeveloperError('point is required.');
            }

            var pnt = new Cartesian4(point.x, point.y, point.z, 1.0);
            pnt = modelViewProjectionMatrix.multiplyByVector(pnt);
            pnt = pnt.multiplyByScalar(1.0 / pnt.w);
            pnt = viewportTransformation.multiplyByVector(pnt);
            return Cartesian2.fromCartesian4(pnt);
        }
    };

    return Transforms;
});

/*global define*/
define('Core/EllipsoidTangentPlane',[
        './DeveloperError',
        './Transforms',
        './AxisAlignedBoundingBox',
        './IntersectionTests',
        './Cartesian2',
        './Cartesian3',
        './Ray'
    ], function(
        DeveloperError,
        Transforms,
        AxisAlignedBoundingBox,
        IntersectionTests,
        Cartesian2,
        Cartesian3,
        Ray) {
    

    /**
     * DOC_TBA
     * @alias EllipsoidTangentPlane
     * @constructor
     *
     * @param {Ellipsoid} ellipsoid
     * @param {Cartesian3} origin
     */
    var EllipsoidTangentPlane = function (ellipsoid, origin) {
        var o = Cartesian3.clone(origin);
        var eastNorthUp = Transforms.eastNorthUpToFixedFrame(o, ellipsoid);

        this.origin = o;
        this.xAxis = Cartesian3.fromCartesian4(eastNorthUp.getColumn(0));
        this.yAxis = Cartesian3.fromCartesian4(eastNorthUp.getColumn(1));
        this.normal = Cartesian3.fromCartesian4(eastNorthUp.getColumn(2));
        this.d = -o.dot(o);
        this.ellipsoid = ellipsoid;
    };

    /**
     * DOC_TBA
     * @memberof EllipsoidTangentPlane
     */
    EllipsoidTangentPlane.create = function(ellipsoid, positions) {
        if (!ellipsoid || !positions) {
            throw new DeveloperError('ellipsoid and positions are required.');
        }

        var box = new AxisAlignedBoundingBox(positions);
        var origin = ellipsoid.scaleToGeodeticSurface(box.center);
        return new EllipsoidTangentPlane(ellipsoid, origin);
    };

    /**
     * DOC_TBA
     * @memberof EllipsoidTangentPlane
     */
    EllipsoidTangentPlane.prototype.projectPointsOntoPlane = function(positions) {
        if (!positions) {
            throw new DeveloperError('positions is required.');
        }

        var positionsOnPlane = [];

        var length = positions.length;
        for ( var i = 0; i < length; ++i) {
            var p = this.projectPointOntoPlane(positions[i]);
            if (p) {
                positionsOnPlane.push(p);
            }
        }

        return positionsOnPlane;
    };

    /**
     * DOC_TBA
     * @memberof EllipsoidTangentPlane
     */
    EllipsoidTangentPlane.prototype.projectPointOntoPlane = function(position) {
        if (position) {
            var pos = Cartesian3.clone(position);
            var intersectionPoint = IntersectionTests.rayPlane(new Ray(pos, pos.normalize()), this.normal, this.d);

            if (intersectionPoint) {
                var v = intersectionPoint.subtract(this.origin);
                return new Cartesian2(this.xAxis.dot(v), this.yAxis.dot(v));
            }
        }
    };

    /**
     * DOC_TBA
     * @memberof EllipsoidTangentPlane
     */
    EllipsoidTangentPlane.prototype.projectPointsOntoEllipsoid = function(positions) {
        if (!positions) {
            throw new DeveloperError('positions is required.');
        }

        var positionsOnEllipsoid = [];

        var length = positions.length;
        for ( var i = 0; i < length; ++i) {
            var p = this.origin;
            p = p.add(this.xAxis.multiplyByScalar(positions[i].x));
            p = p.add(this.yAxis.multiplyByScalar(positions[i].y));

            positionsOnEllipsoid.push(this.ellipsoid.scaleToGeocentricSurface(p));
        }

        return positionsOnEllipsoid;
    };

    return EllipsoidTangentPlane;
});
/*global define*/
define('Core/Shapes',[
        './DeveloperError',
        './Math',
        './Cartesian2',
        './Cartesian3',
        './Quaternion',
        './Matrix3',
        './EllipsoidTangentPlane'
    ], function(
        DeveloperError,
        CesiumMath,
        Cartesian2,
        Cartesian3,
        Quaternion,
        Matrix3,
        EllipsoidTangentPlane) {
    

    function _computeEllipseQuadrant(cb, cbRadius, aSqr, bSqr, ab, ecc, mag, unitPos, eastVec, northVec, bearing,
                                     thetaPts, thetaPtsIndex, offset, clockDir, ellipsePts, ellipsePtsIndex, numPts) {
        var angle;
        var theta;
        var radius;
        var azimuth;
        var temp;
        var temp2;
        var rotAxis;
        var tempVec;

        for (var i = 0; i < numPts; i++, thetaPtsIndex += clockDir, ++ellipsePtsIndex) {
            theta = (clockDir > 0) ? (thetaPts[thetaPtsIndex] + offset) : (offset - thetaPts[thetaPtsIndex]);

            azimuth = theta + bearing;

            temp = -Math.cos(azimuth);

            rotAxis = eastVec.multiplyByScalar(temp);

            temp = Math.sin(azimuth);
            tempVec = northVec.multiplyByScalar(temp);

            rotAxis = rotAxis.add(tempVec);

            temp = Math.cos(theta);
            temp = temp * temp;

            temp2 = Math.sin(theta);
            temp2 = temp2 * temp2;

            radius = ab / Math.sqrt(bSqr * temp + aSqr * temp2);
            angle = radius / cbRadius;

            // Create the quaternion to rotate the position vector to the boundary of the ellipse.
            temp = Math.sin(angle / 2.0);

            var unitQuat = (new Quaternion(rotAxis.x * temp, rotAxis.y * temp, rotAxis.z * temp, Math.cos(angle / 2.0))).normalize();
            var rotMtx = Matrix3.fromQuaternion(unitQuat);

            var tmpEllipsePts = rotMtx.multiplyByVector(unitPos);
            var unitCart = tmpEllipsePts.normalize();
            tmpEllipsePts = unitCart.multiplyByScalar(mag);
            ellipsePts[ellipsePtsIndex] = tmpEllipsePts;
        }
    }

    /**
     * Functions to compute the boundary positions for shapes, such as circles,
     * drawn on the ellipsoid.
     *
     * @exports Shapes
     */
    var Shapes = {
        /**
         * Computes boundary points for a circle on the ellipsoid.
         * <br /><br />
         * The <code>granularity</code> determines the number of points
         * in the boundary.  A lower granularity results in more points and a more
         * exact circle.
         * <br /><br />
         * An outlined circle is rendered by passing the result of this function call to
         * {@link Polyline#setPositions}.  A filled circle is rendered by passing
         * the result to {@link Polygon#setPositions}.
         *
         * @param {Ellipsoid} ellipsoid The ellipsoid the circle will be on.
         * @param {Cartesian3} center The circle's center point in the fixed frame.
         * @param {Number} radius The radius in meters.
         * @param {Number} [granularity] The angular distance between points on the circle.
         *
         * @exception {DeveloperError} ellipsoid, center, and radius are required.
         * @exception {DeveloperError} radius must be greater than zero.
         * @exception {DeveloperError} granularity must be greater than zero.
         *
         * @see Polyline#setPositions
         * @see Polygon#setPositions
         *
         * @example
         * // Create a polyline of a circle
         * var polyline = new Polyline();
         * polyline.setPositions(Shapes.computeCircleBoundary(
         *   ellipsoid, ellipsoid.cartographicToCartesian(
         *     Cartographic.fromDegrees(-75.59777, 40.03883, 0.0)), 100000.0));
         */
        computeCircleBoundary : function(ellipsoid, center, radius, granularity) {
            if (!ellipsoid || !center || !radius) {
                throw new DeveloperError('ellipsoid, center, and radius are required.');
            }

            if (radius <= 0.0) {
                throw new DeveloperError('radius must be greater than zero.');
            }

            granularity = granularity || CesiumMath.toRadians(1.0);
            if (granularity <= 0.0) {
                throw new DeveloperError('granularity must be greater than zero.');
            }

            return this.computeEllipseBoundary(ellipsoid, center, radius, radius, 0, granularity);
        },

        /**
         * Computes boundary points for an ellipse on the ellipsoid.
         * <br /><br />
         * The <code>granularity</code> determines the number of points
         * in the boundary.  A lower granularity results in more points and a more
         * exact circle.
         * <br /><br />
         * An outlined ellipse is rendered by passing the result of this function call to
         * {@link Polyline#setPositions}.  A filled ellipse is rendered by passing
         * the result to {@link Polygon#setPositions}.
         *
         * @param {Ellipsoid} ellipsoid The ellipsoid the ellipse will be on.
         * @param {Cartesian3} center The ellipse's center point in the fixed frame.
         * @param {Number} semiMajorAxis The length of the ellipse's semi-major axis in meters.
         * @param {Number} semiMinorAxis The length of the ellipse's semi-minor axis in meters.
         * @param {Number} [bearing] The angle from north (counter-clockwise) in radians. The default is zero.
         * @param {Number} [granularity] The angular distance between points on the circle.
         *
         * @exception {DeveloperError} ellipsoid, center, semiMajorAxis, and semiMinorAxis are required.
         * @exception {DeveloperError} Semi-major and semi-minor axes must be greater than zero.
         * @exception {DeveloperError} granularity must be greater than zero.
         *
         * @see Polyline#setPositions
         * @see Polygon#setPositions
         *
         * @return The set of points that form the ellipse's boundary.
         *
         * @example
         * // Create a filled ellipse.
         * var polygon = new Cesium.Polygon();
         * polygon.setPositions(Cesium.Shapes.computeEllipseBoundary(
         *   ellipsoid, ellipsoid.cartographicToCartesian(
         *      Cartographic.fromDegrees(-75.59777, 40.03883)), 500000.0, 300000.0, Cesium.Math.toRadians(60)));
         */
        computeEllipseBoundary : function(ellipsoid, center, semiMajorAxis, semiMinorAxis, bearing, granularity) {
            if (!ellipsoid || !center || !semiMajorAxis || !semiMinorAxis) {
                throw new DeveloperError('ellipsoid, center, semiMajorAxis, and semiMinorAxis are required.');
            }

            if (semiMajorAxis <= 0.0 || semiMinorAxis <= 0.0) {
                throw new DeveloperError('Semi-major and semi-minor axes must be greater than zero.');
            }

            bearing = bearing || 0.0;
            granularity = granularity || CesiumMath.toRadians(1.0);

            if (granularity <= 0.0) {
                throw new DeveloperError('granularity must be greater than zero.');
            }

            if (semiMajorAxis < semiMinorAxis) {
               var t = semiMajorAxis;
               semiMajorAxis = semiMinorAxis;
               semiMinorAxis = t;
            }

            var MAX_ANOMALY_LIMIT = 2.31;

            var aSqr = semiMajorAxis * semiMajorAxis;
            var bSqr = semiMinorAxis * semiMinorAxis;
            var ab = semiMajorAxis * semiMinorAxis;

            var value = 1.0 - (bSqr / aSqr);
            var ecc = Math.sqrt(value);

            var surfPos = Cartesian3.clone(center);
            var mag = surfPos.magnitude();

            var tempVec = new Cartesian3(0.0, 0.0, 1);
            var temp = 1.0 / mag;

            var unitPos = surfPos.multiplyByScalar(temp);
            var eastVec = tempVec.cross(surfPos).normalize();
            var northVec = unitPos.cross(eastVec);

            var numQuadrantPts = 1 + Math.ceil(CesiumMath.PI_OVER_TWO / granularity);
            var deltaTheta = MAX_ANOMALY_LIMIT / (numQuadrantPts - 1);
            var thetaPts = [];
            var thetaPtsIndex = 0;

            var sampleTheta = 0.0;
            for (var i = 0; i < numQuadrantPts; i++, sampleTheta += deltaTheta, ++thetaPtsIndex) {
                thetaPts[thetaPtsIndex] = sampleTheta - ecc * Math.sin(sampleTheta);
                if (thetaPts[thetaPtsIndex] >= CesiumMath.PI_OVER_TWO) {
                    thetaPts[thetaPtsIndex] = CesiumMath.PI_OVER_TWO;
                    numQuadrantPts = i + 1;
                    break;
                }
            }

            var ellipsePts = [];

            _computeEllipseQuadrant(ellipsoid, surfPos.magnitude(), aSqr, bSqr, ab, ecc, mag, unitPos, eastVec, northVec, bearing,
                                   thetaPts, 0.0, 0.0, 1, ellipsePts, 0, numQuadrantPts - 1);

            _computeEllipseQuadrant(ellipsoid, surfPos.magnitude(), aSqr, bSqr, ab, ecc, mag, unitPos, eastVec, northVec, bearing,
                                   thetaPts, numQuadrantPts - 1, Math.PI, -1, ellipsePts, numQuadrantPts - 1, numQuadrantPts - 1);

            _computeEllipseQuadrant(ellipsoid, surfPos.magnitude(), aSqr, bSqr, ab, ecc, mag, unitPos, eastVec, northVec, bearing,
                                   thetaPts, 0.0, Math.PI, 1, ellipsePts, (2 * numQuadrantPts) - 2, numQuadrantPts - 1);

            _computeEllipseQuadrant(ellipsoid, surfPos.magnitude(), aSqr, bSqr, ab, ecc, mag, unitPos, eastVec, northVec, bearing,
                                   thetaPts, numQuadrantPts - 1, CesiumMath.TWO_PI, -1, ellipsePts, (3 * numQuadrantPts) - 3, numQuadrantPts);

            ellipsePts.push(ellipsePts[0].clone()); // Duplicates first and last point for polyline

            return ellipsePts;
        }
    };

    return Shapes;
});
/*global define*/
define('Core/EquidistantCylindricalProjection',[
        './Math',
        './Cartesian3',
        './Cartographic',
        './Ellipsoid'
    ], function(
        CesiumMath,
        Cartesian3,
        Cartographic,
        Ellipsoid) {
    

    /**
     * DOC_TBA
     * @alias EquidistantCylindricalProjection
     * @constructor
     *
     * @immutable
     */
    var EquidistantCylindricalProjection = function(ellipsoid) {
        ellipsoid = ellipsoid || Ellipsoid.WGS84;

        var radii = ellipsoid.getRadii();

        this._ellipsoid = ellipsoid;
        this._halfEquatorCircumference = Math.PI * (Math.max(radii.x, radii.y));
        this._quarterPolarCircumference = 0.5 * Math.PI * radii.z;
    };

    /**
     * DOC_TBA
     * @memberof EquidistantCylindricalProjection
     */
    EquidistantCylindricalProjection.prototype.getEllipsoid = function() {
        return this._ellipsoid;
    };

    /**
     * DOC_TBA
     * @memberof EquidistantCylindricalProjection
     */
    EquidistantCylindricalProjection.prototype.project = function(cartographic) {
        // Scale to [-1, 1]
        var lon = cartographic.longitude / Math.PI;
        var lat = cartographic.latitude / CesiumMath.PI_OVER_TWO;

        // Actually this is the special case of equidistant cylindrical called the plate carree
        return new Cartesian3(lon * this._halfEquatorCircumference, lat * this._quarterPolarCircumference, cartographic.height);
    };

    /**
     * DOC_TBA
     * @memberof EquidistantCylindricalProjection
     */
    EquidistantCylindricalProjection.prototype.unproject = function(cartesian) {
        var lon = cartesian.x / this._halfEquatorCircumference;
        var lat = cartesian.y / this._quarterPolarCircumference;

        return new Cartographic(lon * Math.PI, lat * CesiumMath.PI_OVER_TWO, cartesian.z);
    };

    return EquidistantCylindricalProjection;
});

/*global define*/
define('Core/MeshFilters',[
        './DeveloperError',
        './Cartesian3',
        './EquidistantCylindricalProjection',
        './ComponentDatatype',
        './PrimitiveType',
        './Tipsify'
    ], function(
        DeveloperError,
        Cartesian3,
        EquidistantCylindricalProjection,
        ComponentDatatype,
        PrimitiveType,
        Tipsify) {
    

    /**
     * DOC_TBA
     *
     * @exports MeshFilters
     *
     * @see Context#createVertexArrayFromMesh
     */
    var MeshFilters = {};

    /**
     * Converts a mesh's triangle indices to line indices.  Each list of indices in the mesh's <code>indexList</code> with
     * a primitive type of <code>triangles</code>, <code>triangleStrip</code>, or <code>trangleFan</code> is converted to a
     * list of indices with a primitive type of <code>lines</code>.  Lists of indices with other primitive types remain unchanged.
     * <br /><br />
     * The <code>mesh</code> argument should use the standard layout like the mesh returned by {@link BoxTessellator}.
     * <br /><br />
     * This filter is commonly used to create a wireframe mesh for visual debugging.
     *
     * @param {Object} mesh The mesh to filter, which is modified in place.
     *
     * @returns The modified <code>mesh</code> argument, with its triangle indices converted to lines.
     *
     * @see BoxTessellator
     *
     * @example
     * var mesh = BoxTessellator.compute();
     * mesh = MeshFilters.toWireframeInPlace(mesh);
     */
    MeshFilters.toWireframeInPlace = function(mesh) {
        function addTriangle(lines, i0, i1, i2) {
            lines.push(i0);
            lines.push(i1);

            lines.push(i1);
            lines.push(i2);

            lines.push(i2);
            lines.push(i0);
        }

        function trianglesToLines(triangles) {
            var lines = [];
            var count = triangles.length;
            for ( var i = 0; i < count; i += 3) {
                addTriangle(lines, triangles[i], triangles[i + 1], triangles[i + 2]);
            }

            return lines;
        }

        function triangleStripToLines(triangles) {
            var lines = [];
            var count = triangles.length;

            if (count >= 3) {
                addTriangle(lines, triangles[0], triangles[1], triangles[2]);

                for ( var i = 3; i < count; ++i) {
                    addTriangle(lines, triangles[i - 1], triangles[i], triangles[i - 2]);
                }
            }

            return lines;
        }

        function triangleFanToLines(triangles) {
            var lines = [];

            if (triangles.length > 0) {
                var base = triangles[0];
                var count = triangles.length - 1;
                for ( var i = 1; i < count; ++i) {
                    addTriangle(lines, base, triangles[i], triangles[i + 1]);
                }
            }

            return lines;
        }

        if (mesh) {
            var indexLists = mesh.indexLists;
            if (indexLists) {
                var count = indexLists.length;
                for ( var i = 0; i < count; ++i) {
                    var indices = indexLists[i];

                    switch (indices.primitiveType) {
                        case PrimitiveType.TRIANGLES:
                            indices.primitiveType = PrimitiveType.LINES;
                            indices.values = trianglesToLines(indices.values);
                            break;
                        case PrimitiveType.TRIANGLE_STRIP:
                            indices.primitiveType = PrimitiveType.LINES;
                            indices.values = triangleStripToLines(indices.values);
                            break;
                        case PrimitiveType.TRIANGLE_FAN:
                            indices.primitiveType = PrimitiveType.LINES;
                            indices.values = triangleFanToLines(indices.values);
                            break;
                    }
                }
            }
        }

        return mesh;
    };

    /**
     * DOC_TBA
     */
    MeshFilters.createAttributeIndices = function(mesh) {
        var indices = {};

        if (mesh) {
            var attributes = mesh.attributes;
            var j = 0;

            for ( var name in attributes) {
                if (attributes.hasOwnProperty(name)) {
                    indices[name] = j++;
                }
            }
        }

        return indices;
    };

    /**
     * DOC_TBA
     */
    MeshFilters.mapAttributeIndices = function(indices, map) {
        var mappedIndices = {};

        if (indices && map) {
            for ( var name in map) {
                if (map.hasOwnProperty(name)) {
                    mappedIndices[map[name]] = indices[name];
                }
            }
        }

        return mappedIndices;
    };

    MeshFilters._computeNumberOfAttributes = function(mesh) {
        var numberOfVertices = -1;
        for ( var property in mesh.attributes) {
            if (mesh.attributes.hasOwnProperty(property) && mesh.attributes[property].values) {
                var attribute = mesh.attributes[property];
                var num = attribute.values.length / attribute.componentsPerAttribute;
                if ((numberOfVertices !== num) && (numberOfVertices !== -1)) {
                    throw new DeveloperError('All mesh attribute lists must have the same number of attributes.');
                }
                numberOfVertices = num;
            }
        }

        return numberOfVertices;
    };

    /**
     * Reorders a mesh's indices to achieve better performance from the GPU's pre-vertex-shader cache.
     * Each list of indices in the mesh's <code>indexList</code> is reordered to keep the same index-vertex correspondence.
     * <br /><br />
     * The <code>mesh</code> argument should use the standard layout like the mesh returned by {@link BoxTessellator}.
     * <br /><br />

     * @param {Object} mesh The mesh to filter, which is modified in place.
     *
     * @exception {DeveloperError} All mesh attribute lists must have the same number of attributes.
     *
     * @returns The modified <code>mesh</code> argument, with its vertices and indices reordered for the GPU's pre-vertex-shader cache.
     *
     * @see MeshFilters.reorderForPostVertexCache
     *
     * @example
     * var mesh = CubeMapEllipsoidTessellator.compute(...);
     * mesh = MeshFilters.reorderForPreVertexCache(mesh);
     */
    MeshFilters.reorderForPreVertexCache = function(mesh) {
        if (mesh) {
            var numVertices = MeshFilters._computeNumberOfAttributes(mesh);

            var indexCrossReferenceOldToNew = [];
            for ( var i = 0; i < numVertices; i++) {
                indexCrossReferenceOldToNew[i] = -1;
            }

            //Construct cross reference and reorder indices
            var indexLists = mesh.indexLists;
            if (indexLists) {
                var count = indexLists.length;
                for ( var j = 0; j < count; ++j) {
                    var indicesIn = indexLists[j].values;
                    var numIndices = indicesIn.length;
                    var indicesOut = [];
                    var intoIndicesIn = 0;
                    var intoIndicesOut = 0;
                    var nextIndex = 0;
                    var tempIndex;
                    while (intoIndicesIn < numIndices) {
                        tempIndex = indexCrossReferenceOldToNew[indicesIn[intoIndicesIn]];
                        if (tempIndex !== -1) {
                            indicesOut[intoIndicesOut] = tempIndex;
                        } else {
                            tempIndex = indicesIn[intoIndicesIn];
                            if (tempIndex >= numVertices) {
                                throw new DeveloperError('Input indices contains a value greater than or equal to the number of vertices');
                            }
                            indexCrossReferenceOldToNew[tempIndex] = nextIndex;

                            indicesOut[intoIndicesOut] = nextIndex;
                            ++nextIndex;
                        }
                        ++intoIndicesIn;
                        ++intoIndicesOut;
                    }
                    indexLists[j].values = indicesOut;
                }
            }

            //Reorder Vertices
            var attributes = mesh.attributes;
            if (attributes) {
                for ( var property in attributes) {
                    if (attributes.hasOwnProperty(property) && attributes[property].values) {
                        var elementsIn = attributes[property].values;
                        var intoElementsIn = 0;
                        var numComponents = attributes[property].componentsPerAttribute;
                        var elementsOut = [];
                        while (intoElementsIn < numVertices) {
                            var temp = indexCrossReferenceOldToNew[intoElementsIn];
                            for (i = 0; i < numComponents; i++) {
                                elementsOut[numComponents * temp + i] = elementsIn[numComponents * intoElementsIn + i];
                            }
                            ++intoElementsIn;
                        }
                        attributes[property].values = elementsOut;
                    }
                }
            }
        }
        return mesh;
    };

    /**
     * Reorders a mesh's indices to achieve better performance from the GPU's post vertex-shader cache by using the Tipsify algorithm.
     * Each list of indices in the mesh's <code>indexList</code> is optimally reordered.
     * <br /><br />
     * The <code>mesh</code> argument should use the standard layout like the mesh returned by {@link BoxTessellator}.
     * <br /><br />

     * @param {Object} mesh The mesh to filter, which is modified in place.
     * @param {Number} [cacheCapacity=24] The number of vertices that can be held in the GPU's vertex cache.
     *
     * @exception {DeveloperError} Mesh's index list must be defined.
     * @exception {DeveloperError} Mesh's index lists' lengths must each be a multiple of three.
     * @exception {DeveloperError} Mesh's index list's maximum index value must be greater than zero.
     * @exception {DeveloperError} cacheCapacity must be greater than two.
     *
     * @returns The modified <code>mesh</code> argument, with its indices optimally reordered for the post-vertex-shader cache.
     *
     * @see MeshFilters.reorderForPreVertexCache
     * @see Tipsify
     * @see <a href='http://gfx.cs.princeton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf'>
     * Fast Triangle Reordering for Vertex Locality and Reduced Overdraw</a>
     * by Sander, Nehab, and Barczak
     *
     * @example
     * var mesh = CubeMapEllipsoidTessellator.compute(...);
     * mesh = MeshFilters.reorderForPostVertexCache(mesh);
     */
    MeshFilters.reorderForPostVertexCache = function(mesh, cacheCapacity) {
        if (mesh) {
            var indexLists = mesh.indexLists;
            if (indexLists) {
                var count = indexLists.length;
                for ( var i = 0; i < count; i++) {
                    var indices = indexLists[i].values;
                    var numIndices = indices.length;
                    var maximumIndex = 0;
                    for ( var j = 0; j < numIndices; j++) {
                        if (indices[j] > maximumIndex) {
                            maximumIndex = indices[j];
                        }
                    }
                    indexLists[i].values = Tipsify.tipsify({indices : indices,
                                                            maximumIndex : maximumIndex,
                                                            cacheSize : cacheCapacity});
                }
            }
        }
        return mesh;
    };

    MeshFilters._verifyTrianglesPrimitiveType = function(indexLists) {
        var length = indexLists.length;
        for ( var i = 0; i < length; ++i) {
            if (indexLists[i].primitiveType !== PrimitiveType.TRIANGLES) {
                throw new DeveloperError('indexLists must have PrimitiveType equal to PrimitiveType.TRIANGLES.');
            }
        }
    };

    MeshFilters._copyAttributesDescriptions = function(attributes) {
        var newAttributes = {};

        for ( var attribute in attributes) {
            if (attributes.hasOwnProperty(attribute) && attributes[attribute].values) {
                var attr = attributes[attribute];
                newAttributes[attribute] = {
                    componentDatatype : attr.componentDatatype,
                    componentsPerAttribute : attr.componentsPerAttribute,
                    values : []
                };
            }
        }

        return newAttributes;
    };

    MeshFilters._copyVertex = function(destinationAttributes, sourceAttributes, index) {
        for ( var attribute in sourceAttributes) {
            if (sourceAttributes.hasOwnProperty(attribute) && sourceAttributes[attribute].values) {
                var attr = sourceAttributes[attribute];

                for ( var k = 0; k < attr.componentsPerAttribute; ++k) {
                    destinationAttributes[attribute].values.push(attr.values[(index * attr.componentsPerAttribute) + k]);
                }
            }
        }
    };

    /**
     * DOC_TBA.  Old mesh is not guaranteed to be copied.
     *
     * @exception {DeveloperError} The mesh's index-lists must have PrimitiveType equal to PrimitiveType.TRIANGLES.
     * @exception {DeveloperError} All mesh attribute lists must have the same number of attributes.
     */
    MeshFilters.fitToUnsignedShortIndices = function(mesh) {
        function createMesh(attributes, primitiveType, indices) {
            return {
                attributes : attributes,
                indexLists : [{
                    primitiveType : primitiveType,
                    values : indices
                }]
            };
        }

        var meshes = [];

        if (mesh) {
            MeshFilters._verifyTrianglesPrimitiveType(mesh.indexLists);

            var numberOfVertices = MeshFilters._computeNumberOfAttributes(mesh);

            // If there's an index list and more than 64K attributes, it is possible that
            // some indices are outside the range of unsigned short [0, 64K - 1]
            var sixtyFourK = 64 * 1024;
            var indexLists = mesh.indexLists;
            if (indexLists && (numberOfVertices > sixtyFourK)) {
                // PERFORMANCE_IDEA:  If an input mesh has more than one index-list.  This creates
                // at least one vertex-array per index-list.  A more sophisticated implementation
                // may create less vertex-arrays.
                var length = indexLists.length;
                for ( var i = 0; i < length; ++i) {
                    var oldToNewIndex = [];
                    var newIndices = [];
                    var currentIndex = 0;
                    var newAttributes = MeshFilters._copyAttributesDescriptions(mesh.attributes);

                    var originalIndices = indexLists[i].values;
                    var numberOfIndices = originalIndices.length;

                    for ( var j = 0; j < numberOfIndices; j += 3) {
                        // It would be easy to extend this inter-loop to support all primitive-types.

                        var x0 = originalIndices[j];
                        var x1 = originalIndices[j + 1];
                        var x2 = originalIndices[j + 2];

                        var i0 = oldToNewIndex[x0];
                        if (typeof i0 === 'undefined') {
                            i0 = currentIndex++;
                            oldToNewIndex[x0] = i0;

                            MeshFilters._copyVertex(newAttributes, mesh.attributes, x0);
                        }

                        var i1 = oldToNewIndex[x1];
                        if (typeof i1 === 'undefined') {
                            i1 = currentIndex++;
                            oldToNewIndex[x1] = i1;

                            MeshFilters._copyVertex(newAttributes, mesh.attributes, x1);
                        }

                        var i2 = oldToNewIndex[x2];
                        if (typeof i2 === 'undefined') {
                            i2 = currentIndex++;
                            oldToNewIndex[x2] = i2;

                            MeshFilters._copyVertex(newAttributes, mesh.attributes, x2);
                        }

                        newIndices.push(i0);
                        newIndices.push(i1);
                        newIndices.push(i2);

                        if (currentIndex + 3 > sixtyFourK) {
                            meshes.push(createMesh(newAttributes, indexLists[i].primitiveType, newIndices));

                            // Reset for next vertex-array
                            oldToNewIndex = [];
                            newIndices = [];
                            currentIndex = 0;
                            newAttributes = MeshFilters._copyAttributesDescriptions(mesh.attributes);
                        }
                    }

                    if (newIndices.length !== 0) {
                        meshes.push(createMesh(newAttributes, indexLists[i].primitiveType, newIndices));
                    }
                }
            } else {
                // No need to split into multiple meshes
                meshes.push(mesh);
            }
        }

        return meshes;
    };

    ///////////////////////////////////////////////////////////////////////////

    /**
     * DOC_TBA
     */
    MeshFilters.projectTo2D = function(mesh, projection) {
        if (mesh && mesh.attributes && mesh.attributes.position) {
            projection = projection || new EquidistantCylindricalProjection();
            var ellipsoid = projection.getEllipsoid();

            // Project original positions to 2D.
            var wgs84Positions = mesh.attributes.position.values;
            var projectedPositions = [];

            for ( var i = 0; i < wgs84Positions.length; i += 3) {
                var lonLat = ellipsoid.cartesianToCartographic(new Cartesian3(wgs84Positions[i], wgs84Positions[i + 1], wgs84Positions[i + 2]));
                var projectedLonLat = projection.project(lonLat);
                projectedPositions.push(projectedLonLat.x, projectedLonLat.y);
            }

            // Rename original positions to WGS84 Positions.
            mesh.attributes.position3D = mesh.attributes.position;

            // Replace original positions with 2D projected positions
            mesh.attributes.position2D = {
                componentDatatype : ComponentDatatype.FLOAT,
                componentsPerAttribute : 2,
                values : projectedPositions
            };
            delete mesh.attributes.position;
        }

        return mesh;
    };

    return MeshFilters;
});

/*global define*/
define('Core/MercatorProjection',[
        './Math',
        './Cartesian3',
        './Cartographic',
        './Ellipsoid'
    ], function(
        CesiumMath,
        Cartesian3,
        Cartographic,
        Ellipsoid) {
    

    /**
     * @alias MercatorProjection
     *
     * @constructor
     *
     * @immutable
     */
    var MercatorProjection = function(ellipsoid) {
        ellipsoid = ellipsoid || Ellipsoid.WGS84;

        var radii = ellipsoid.getRadii();

        this._ellipsoid = ellipsoid;
        this._halfEquatorCircumference = Math.PI * (Math.max(radii.x, radii.y));
        this._quarterPolarCircumference = 0.5 * Math.PI * radii.z;
    };

    /**
     * DOC_TBA
     * @memberof MercatorProjection
     */
    MercatorProjection.prototype.getEllipsoid = function() {
        return this._ellipsoid;
    };

    /**
     * DOC_TBA
     * @memberof MercatorProjection
     */
    MercatorProjection.prototype.project = function(cartographic) {
        // Scale to [-1, 1]
        var lon = cartographic.longitude / Math.PI;
        var lat = cartographic.latitude / CesiumMath.PI_OVER_TWO;

        // TODO: Deal with latitude outside ~(-85, 85) degrees
        return new Cartesian3(lon * this._halfEquatorCircumference, Math.log((1.0 + Math.sin(lat)) / Math.cos(lat)) * this._quarterPolarCircumference, cartographic.height);
    };

    /**
     * DOC_TBA
     * @memberof MercatorProjection
     */
    MercatorProjection.prototype.unproject = function(cartesian) {
        var lon = cartesian.x / this._halfEquatorCircumference;

        var lat = Math.exp(cartesian.y / this._quarterPolarCircumference);
        lat = 2.0 * Math.atan((lat - 1.0) / (lat + 1.0));

        return new Cartographic(lon * Math.PI, lat * CesiumMath.PI_OVER_TWO, cartesian.z);
    };

    return MercatorProjection;
});
/*global define*/
define('Core/PolylinePipeline',['./Cartographic',
        './Cartesian3'
    ], function(
        Cartographic,
        Cartesian3) {
    

    /**
     * DOC_TBA
     *
     * @exports PolylinePipeline
     */
    var PolylinePipeline = {
        /*
         * DOC_TBA
         */
        wrapLongitude : function(ellipsoid, positions) {
            var segments = [];

            if (positions && (positions.length > 0)) {
                var length = positions.length;

                var currentSegment = [{
                    cartesian : Cartesian3.clone(positions[0]),
                    cartographic : ellipsoid.cartesianToCartographic(positions[0]),
                    index : 0
                }];

                var prev = currentSegment[0].cartographic;

                for ( var i = 1; i < length; ++i) {
                    var cur = ellipsoid.cartesianToCartographic(positions[i]);

                    if (Math.abs(prev.longitude - cur.longitude) > Math.PI) {
                        var interpolatedLongitude = prev.longitude < 0.0 ? -Math.PI : Math.PI;
                        var longitude = cur.longitude + (2.0 * interpolatedLongitude);
                        var ratio = (interpolatedLongitude - prev.longitude) / (longitude - prev.longitude);
                        var interpolatedLatitude = prev.latitude + (cur.latitude - prev.latitude) * ratio;
                        var interpolatedHeight = prev.height + (cur.height - prev.height) * ratio;

                        currentSegment.push({
                            cartesian : ellipsoid.cartographicToCartesian(new Cartographic(interpolatedLongitude, interpolatedLatitude, interpolatedHeight)),
                            cartographic : new Cartographic(interpolatedLongitude, interpolatedLatitude, interpolatedHeight),
                            index : i
                        });
                        segments.push(currentSegment);

                        currentSegment = [];
                        currentSegment.push({
                            cartesian : ellipsoid.cartographicToCartesian(new Cartographic(-interpolatedLongitude, interpolatedLatitude, interpolatedHeight)),
                            cartographic : new Cartographic(-interpolatedLongitude, interpolatedLatitude, interpolatedHeight),
                            index : i
                        });
                    }

                    currentSegment.push({
                        cartesian : Cartesian3.clone(positions[i]),
                        cartographic : ellipsoid.cartesianToCartographic(positions[i]),
                        index : i
                    });

                    prev = cur.clone();
                }

                if (currentSegment.length > 1) {
                    segments.push(currentSegment);
                }
            }

            return segments;
        }
    };

    return PolylinePipeline;
});
/*global define*/
define('Core/Color',[
        './defaultValue'
    ], function(
        defaultValue) {
    

    /**
     * A color, specified using red, green, blue, and alpha values,
     * which range from <code>0</code> (no intensity) to <code>1.0</code> (full intensity).
     * @param {Number} [red=1.0] The red component.
     * @param {Number} [green=1.0] The green component.
     * @param {Number} [blue=1.0] The blue component.
     * @param {Number} [alpha=1.0] The alpha component.
     *
     * @constructor
     * @alias Color
     */
    var Color = function(red, green, blue, alpha) {
        /**
         * The red component.
         */
        this.red = defaultValue(red, 1.0);
        /**
         * The green component.
         */
        this.green = defaultValue(green, 1.0);
        /**
         * The blue component.
         */
        this.blue = defaultValue(blue, 1.0);
        /**
         * The alpha component.
         */
        this.alpha = defaultValue(alpha, 1.0);
    };

    /**
     * Creates a new Color specified using red, green, blue, and alpha values
     * that are in the range of 0 to 255, converting them internally to a
     * range of 0.0 to 1.0.
     * @memberof Color
     *
     * @param {Number} [red=255] The red component.
     * @param {Number} [green=255] The green component.
     * @param {Number} [blue=255] The blue component.
     * @param {Number} [alpha=255] The alpha component.
     * @returns {Color} A new color instance.
     */
    Color.fromBytes = function(red, green, blue, alpha) {
        red = defaultValue(red, 255.0);
        green = defaultValue(green, 255.0);
        blue = defaultValue(blue, 255.0);
        alpha = defaultValue(alpha, 255.0);
        return new Color(red / 255.0, green / 255.0, blue / 255.0, alpha / 255.0);
    };

    /**
     * Converts a 'byte' color component in the range of 0 to 255 into
     * a 'float' color component range of 0 to 1.0.
     * @memberof Color
     *
     * @param {Number} number The number to be converted.
     * @returns {number} The converted number.
     */
    Color.byteToFloat = function(number) {
        return number / 255.0;
    };

    /**
     * Converts a 'float' color component in the range of 0 to 1.0 into
     * a 'byte' color component range of 0 to 255.
     * @memberof Color
     *
     * @param {Number} number The number to be converted.
     * @returns {number} The converted number.
     */
    Color.floatToByte = function(number) {
        return number === 1.0 ? 255.0 : (number * 256.0) | 0;
    };

    /**
     * Duplicates a Color.
     * @memberof Color
     *
     * @param {Color} color The Color to duplicate.
     * @param {Color} [result] The object to store the result in, if undefined a new instance will be created.
     * @return {Color} The modified result parameter or a new instance if result was undefined.
     */
    Color.clone = function(color, result) {
        if (typeof result === 'undefined') {
            return new Color(color.red, color.green, color.blue, color.alpha);
        }
        result.red = color.red;
        result.green = color.green;
        result.blue = color.blue;
        result.alpha = color.alpha;
        return result;
    };

    /**
     * Returns true if the first Color equals the second color.
     * @memberof Color
     *
     * @param {Color} left The first Color to compare for equality.
     * @param {Color} right The second Color to compare for equality.
     * @return {Boolean} <code>true</code> if the Colors are equal; otherwise, <code>false</code>.
     */
    Color.equals = function(left, right) {
        return (left === right) ||
               (typeof left !== 'undefined' &&
                typeof right !== 'undefined' &&
                left.red === right.red &&
                left.green === right.green &&
                left.blue === right.blue &&
                left.alpha === right.alpha);

    };

    /**
     * Returns a duplicate of a Color instance.
     * @memberof Color
     *
     * @param {Color} [result] The object to store the result in, if undefined a new instance will be created.
     * @return {Color} The modified result parameter or a new instance if result was undefined.
     */
    Color.prototype.clone = function(result) {
        return Color.clone(this, result);
    };

    /**
     * Returns true if this Color equals other.
     * @memberof Color
     *
     * @param {Color} other The Color to compare for equality.
     * @return {Boolean} <code>true</code> if the Colors are equal; otherwise, <code>false</code>.
     */
    Color.prototype.equals = function(other) {
        return Color.equals(this, other);
    };

    /**
     * Returns <code>true</code> if this Color equals other componentwise within the specified epsilon.
     * @memberof Color
     *
     * @param {Color} other The Color to compare for equality.
     * @param {Number} [epsilon=0.0] The epsilon to use for equality testing.
     * @return {Boolean} <code>true</code> if the Colors are equal within the specified epsilon; otherwise, <code>false</code>.
     */
    Color.prototype.equalsEpsilon = function(other, epsilon) {
        return (this === other) ||
                ((typeof other !== 'undefined') &&
                 (Math.abs(this.red - other.red) <= epsilon) &&
                 (Math.abs(this.green - other.green) <= epsilon) &&
                 (Math.abs(this.blue - other.blue) <= epsilon) &&
                 (Math.abs(this.alpha - other.alpha) <= epsilon));
    };

    /**
     * Creates a string containing the CSS color value for this color.
     * @memberof Color
     *
     * @return {String} The CSS equivalent of this color.
     * @see <a href="http://www.w3.org/TR/css3-color/#rgba-color">CSS RGBA color values</a>
     */
    Color.prototype.toCSSColor = function() {
        var r = Color.floatToByte(this.red);
        var g = Color.floatToByte(this.green);
        var b = Color.floatToByte(this.blue);
        return 'rgba(' + r + ',' + g + ',' + b + ',' + this.alpha + ')';
    };

    /**
     * An immutable Color instance initialized to white, RGBA (1.0, 1.0, 1.0, 1.0).
     * @memberof Color
     */
    Color.WHITE = Object.freeze(new Color(1.0, 1.0, 1.0, 1.0));

    /**
     * An immutable Color instance initialized to black, RGBA (0.0, 0.0, 0.0, 1.0).
     * @memberof Color
     */
    Color.BLACK = Object.freeze(new Color(0.0, 0.0, 0.0, 1.0));

    /**
     * An immutable Color instance initialized to red, RGBA (1.0, 0.0, 0.0, 1.0).
     * @memberof Color
     */
    Color.RED = Object.freeze(new Color(1.0, 0.0, 0.0, 1.0));

    /**
     * An immutable Color instance initialized to green, RGBA (0.0, 1.0, 0.0, 1.0).
     * @memberof Color
     */
    Color.GREEN = Object.freeze(new Color(0.0, 1.0, 0.0, 1.0));

    /**
     * An immutable Color instance initialized to blue, RGBA (0.0, 0.0, 1.0, 1.0).
     * @memberof Color
     */
    Color.BLUE = Object.freeze(new Color(0.0, 0.0, 1.0, 1.0));

    /**
     * An immutable Color instance initialized to yellow, RGBA (1.0, 1.0, 0.0, 1.0).
     * @memberof Color
     */
    Color.YELLOW = Object.freeze(new Color(1.0, 1.0, 0.0, 1.0));

    /**
     * An immutable Color instance initialized to magenta, RGBA (1.0, 0.0, 1.0, 1.0).
     * @memberof Color
     */
    Color.MAGENTA = Object.freeze(new Color(1.0, 0.0, 1.0, 1.0));

    /**
     * An immutable Color instance initialized to cyan, RGBA (0.0, 1.0, 1.0, 1.0).
     * @memberof Color
     */
    Color.CYAN = Object.freeze(new Color(0.0, 1.0, 1.0, 1.0));

    return Color;
});

/*global define*/
define('Core/Extent',[
        '../Core/defaultValue',
        '../Core/BoundingSphere',
        '../Core/Cartesian3',
        '../Core/Cartographic',
        '../Core/DeveloperError',
        '../Core/Ellipsoid',
        '../Core/Math',
        '../Core/Occluder',
        '../Core/Rectangle'
    ], function(
        defaultValue,
        BoundingSphere,
        Cartesian3,
        Cartographic,
        DeveloperError,
        Ellipsoid,
        CesiumMath,
        Occluder,
        Rectangle) {
    

    /**
     * A two dimensional region specified as longitude and latitude coordinates.
     *
     * @alias Extent
     * @constructor
     *
     * @param {Number} west The westernmost longitude in the range [-Pi, Pi].
     * @param {Number} south The southernmost latitude in the range [-Pi/2, Pi/2].
     * @param {Number} east The easternmost longitude in the range [-Pi, Pi].
     * @param {Number} north The northernmost latitude in the range [-Pi/2, Pi/2].
     *
     * @exception {DeveloperError} One of the parameters is out of range.
     */
    var Extent = function(west, south, east, north) {
        /**
         * The northernmost latitude.
         *
         * @type Number
         */
        this.north = north;

        /**
         * The southernmost latitude.
         *
         * @type Number
         */
        this.south = south;

        /**
         * The westernmost longitude.
         *
         * @type Number
         */
        this.west = west;

        /**
         * The easternmost longitude.
         *
         * @type Number
         */
        this.east = east;

        Extent.validate(this);
    };

    /**
     * Returns a duplicate of this Extent.
     *
     * @return {Extent} A new Extent instance.
     */
    Extent.prototype.clone = function() {
        return new Extent(this.west, this.south, this.east, this.north);
    };

    /**
     * Checks that an {@link Extent}'s members are in the proper ranges, north is greater than
     * south and east is greater than west.
     *
     * @param {Extent} extent The extent to be checked for validity.
     *
     * @exception {DeveloperError} <code>extent</code> is required and must have north, south, east and west attributes.
     * @exception {DeveloperError} <code>extent.north</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].
     * @exception {DeveloperError} <code>extent.south</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].
     * @exception {DeveloperError} <code>extent.east</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].
     * @exception {DeveloperError} <code>extent.west</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].
     */
    Extent.validate = function(extent) {
        if (typeof extent === 'undefined') {
            throw new DeveloperError('extent is required.');
        }

        var north = extent.north;
        if (typeof north === 'undefined') {
            throw new DeveloperError('extent.north is required.');
        }

        if (north < -CesiumMath.PI_OVER_TWO || north > CesiumMath.PI_OVER_TWO) {
            throw new DeveloperError('extent.north must be in the interval [-Pi/2, Pi/2].');
        }

        var south = extent.south;
        if (typeof south === 'undefined') {
            throw new DeveloperError('extent.south is required.');
        }

        if (south < -CesiumMath.PI_OVER_TWO || south > CesiumMath.PI_OVER_TWO) {
            throw new DeveloperError('extent.south must be in the interval [-Pi/2, Pi/2].');
        }

        var west = extent.west;
        if (typeof west === 'undefined') {
            throw new DeveloperError('extent.west is required.');
        }

        if (west < -Math.PI || west > Math.PI) {
            throw new DeveloperError('extent.west must be in the interval [-Pi, Pi].');
        }

        var east = extent.east;
        if (typeof east === 'undefined') {
            throw new DeveloperError('extent.east is required.');
        }

        if (east < -Math.PI || east > Math.PI) {
            throw new DeveloperError('extent.east must be in the interval [-Pi, Pi].');
        }
    };

    function getPosition(lla, ellipsoid, time, projection) {
        if (typeof time === 'undefined' || time === 0.0 || typeof projection === 'undefined') {
            return ellipsoid.cartographicToCartesian(lla);
        }

        var twod = projection.project(lla);
        twod = new Cartesian3(0.0, twod.x, twod.y);
        return twod.lerp(ellipsoid.cartographicToCartesian(lla), time);
    }

    function computePositions(extent, ellipsoid, time, projection) {
        if (typeof extent === 'undefined') {
            throw new DeveloperError('extent is required.');
        }

        Extent.validate(extent);

        ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);
        var positions = [];

        var lla = new Cartographic(extent.west, extent.north, 0.0);
        positions.push(getPosition(lla, ellipsoid, time, projection));
        lla.longitude = extent.east;
        positions.push(getPosition(lla, ellipsoid, time, projection));
        lla.latitude = extent.south;
        positions.push(getPosition(lla, ellipsoid, time, projection));
        lla.longitude = extent.west;
        positions.push(getPosition(lla, ellipsoid, time, projection));

        if (extent.north < 0.0) {
            lla.latitude = extent.north;
        } else if (extent.south > 0.0) {
            lla.latitude = extent.south;
        } else {
            lla.latitude = 0.0;
        }

        for ( var i = 1; i < 8; ++i) {
            var temp = -Math.PI + i * CesiumMath.PI_OVER_TWO;
            if (extent.west < temp && temp < extent.east) {
                lla.longitude = temp;
                positions.push(getPosition(lla, ellipsoid, time, projection));
            }
        }

        if (lla.latitude === 0.0) {
            lla.longitude = extent.west;
            positions.push(getPosition(lla, ellipsoid, time, projection));
            lla.longitude = extent.east;
            positions.push(getPosition(lla, ellipsoid, time, projection));
        }

        return positions;
    }

    /**
     * DOC_TBA
     *
     * @param {Extent} extent DOC_TBA
     * @param {Ellipsoid} ellipsoid DOC_TBA
     * @param {Number} time DOC_TBA
     * @param {Object} projection DOC_TBA
     *
     * @returns {BoundingSphere} DOC_TBA
     */
    Extent.computeMorphBoundingSphere = function(extent, ellipsoid, time, projection) {
        return new BoundingSphere(computePositions(extent, ellipsoid, time, projection));
    };

    /**
     * DOC_TBA
     *
     * @param {Extent} extent DOC_TBA
     * @param {Ellipsoid} ellipsoid DOC_TBA
     * @returns {BoundingSphere} DOC_TBA
     */
    Extent.compute3DBoundingSphere = function(extent, ellipsoid) {
        return new BoundingSphere(computePositions(extent, ellipsoid));
    };

    /**
     * DOC_TBA
     *
     * @param {Extent} extent DOC_TBA
     * @param {Ellipsoid} ellipsoid DOC_TBA
     *
     * @returns {Object} DOC_TBA
     */
    Extent.computeOccludeePoint = function(extent, ellipsoid) {
        ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);
        var positions = computePositions(extent, ellipsoid);
        var bs = new BoundingSphere(positions);

        // TODO: get correct ellipsoid center
        var ellipsoidCenter = Cartesian3.ZERO;
        if (!ellipsoidCenter.equals(bs.center)) {
            return Occluder.getOccludeePoint(new BoundingSphere(ellipsoidCenter, ellipsoid.getMinimumRadius()), bs.center, positions);
        }
        return {
            valid : false
        };
    };

    /**
     * DOC_TBA
     *
     * @param {Extent} extent DOC_TBA
     * @param {Object} projection DOC_TBA
     * @returns {Rectangle} DOC_TBA
     */
    Extent.computeBoundingRectangle = function(extent, projection) {
        if (typeof extent === 'undefined') {
            throw new DeveloperError('extent is required.');
        }

        Extent.validate(extent);

        if (typeof projection === 'undefined') {
            throw new DeveloperError('projection is required.');
        }

        var lla = new Cartographic(extent.west, extent.south);
        var lowerLeft = projection.project(lla);
        lla.longitude = extent.east;
        lla.latitude = extent.north;
        var upperRight = projection.project(lla);

        var diagonal = upperRight.subtract(lowerLeft);
        return new Rectangle(lowerLeft.x, lowerLeft.y, diagonal.x, diagonal.y);
    };

    /**
     * DOC_TBA
     *
     * @param {Extent} extent DOC_TBA
     * @param {Object} projection DOC_TBA
     * @returns {BoundingSphere} DOC_TBA
     */
    Extent.compute2DBoundingSphere = function(extent, projection) {
        var rect = Extent.computeBoundingRectangle(extent, projection);
        var center = new Cartesian3((2.0 * rect.x + rect.width) * 0.5, (2.0 * rect.y + rect.height) * 0.5, 0.0);
        var radius = Math.sqrt(rect.width * rect.width + rect.height * rect.height) * 0.5;
        return new BoundingSphere(center, radius);
    };

    /**
     * Gets a {@link Cartographic} containing the southwest corner of this extent.
     */
    Extent.prototype.getSouthwest = function() {
        return new Cartographic(this.west, this.south);
    };

    /**
     * Gets a {@link Cartographic} containing the northwest corner of this extent.
     */
    Extent.prototype.getNorthwest = function() {
        return new Cartographic(this.west, this.north);
    };

    /**
     * Gets a {@link Cartographic} containing the northeast corner of this extent.
     */
    Extent.prototype.getNortheast = function() {
        return new Cartographic(this.east, this.north);
    };

    /**
     * Gets a {@link Cartographic} containing the southeast corner of this extent.
     */
    Extent.prototype.getSoutheast = function() {
        return new Cartographic(this.east, this.south);
    };

    /**
     * The largest possible extent.
     */
    Extent.MAX_VALUE = Object.freeze(new Extent(-Math.PI, -CesiumMath.PI_OVER_TWO, Math.PI, CesiumMath.PI_OVER_TWO));

    return Extent;
});
/*global define*/
define('Core/ExtentTessellator',[
        './DeveloperError',
        './Math',
        './Ellipsoid',
        './Extent',
        './Cartesian3',
        './Cartographic',
        './ComponentDatatype',
        './PrimitiveType'
    ], function(
        DeveloperError,
        CesiumMath,
        Ellipsoid,
        Extent,
        Cartesian3,
        Cartographic,
        ComponentDatatype,
        PrimitiveType) {
    

    /**
     * Contains class functions to create a mesh or vertex array from a cartographic extent.
     *
     * @exports ExtentTessellator
     *
     * @see CubeMapEllipsoidTessellator
     * @see BoxTessellator
     * @see PlaneTessellator
     */
    var ExtentTessellator = {};

    ExtentTessellator._computeVertices = function(description) {
        var desc = description || {};

        var extent = desc.extent.clone();
        var boundExtent = desc.boundaryExtent;
        var ellipsoid = desc.ellipsoid;
        var granularity = desc.granularity;
        var altitude = desc.altitude;
        var genTexCoords = desc.generateTextureCoords;
        var interleave = desc.interleave;
        var relativeToCenter = desc.relativeToCenter;

        var vertices = desc.vertices;
        var texCoords = desc.texCoords;
        var indices = desc.indices;

        if (boundExtent.south > boundExtent.north) {
            boundExtent.north += CesiumMath.TWO_PI;
            extent.north += CesiumMath.TWO_PI;
        }

        if (boundExtent.west > boundExtent.east) {
            boundExtent.east += CesiumMath.TWO_PI;
            extent.east += CesiumMath.TWO_PI;
        }

        // for computing texture coordinates
        var lonScalar = 1.0 / (extent.east - extent.west);
        var latScalar = 1.0 / (extent.north - extent.south);

        var i;
        var j;
        var rows = 0;
        var cols = 0;

        for (i = boundExtent.north;; i = i - granularity) {
            if (i < boundExtent.south) {
                i = boundExtent.south;
            }

            cols = 0;
            for (j = boundExtent.west;; j = j + granularity) {
                if (j > boundExtent.east) {
                    j = boundExtent.east;
                }

                var cartPosition = new Cartographic(j, i, altitude);
                var position = ellipsoid.cartographicToCartesian(cartPosition).subtract(relativeToCenter);
                vertices.push(position.x, position.y, position.z);

                if (genTexCoords) {
                    var u = (j - extent.west) * lonScalar;
                    var v = (i - extent.south) * latScalar;
                    if (interleave) {
                        vertices.push(u, v);
                    } else {
                        texCoords.push(u, v);
                    }
                }

                ++cols;

                if (j === boundExtent.east) {
                    break;
                }
            }
            ++rows;

            if (i === boundExtent.south) {
                break;
            }
        }

        var index = 0;
        for (i = 0; i < rows - 1; ++i) {
            for (j = 0; j < cols - 1; ++j) {
                var upperLeft = index;
                var lowerLeft = upperLeft + cols;
                var lowerRight = lowerLeft + 1;
                var upperRight = upperLeft + 1;

                indices.push(upperLeft, lowerLeft, upperRight);
                indices.push(upperRight, lowerLeft, lowerRight);

                ++index;
            }
            ++index;
        }
    };

    /**
     * Creates a mesh from a cartographic extent.
     *
     * @param {Ellipsoid} description.ellipsoid The ellipsoid on which the extent lies. Defaults to a WGS84 ellipsoid.
     * @param {Extent} description.extent A cartographic extent with north, south, east and west properties in radians.
     * @param {Number} description.granularity The distance, in radians, between each latitude and longitude.
     * Determines the number of positions in the buffer. Defaults to 0.1.
     * @param {Number} description.altitude The height from the surface of the ellipsoid. Defaults to 0.
     * @param {Boolean} description.generateTextureCoords A truthy value will cause texture coordinates to be generated.
     * @param {Cartesian3} description.relativetoCenter If this parameter is provided, the positions will be
     * computed as <code>worldPosition.subtract(relativeToCenter)</code>. Defaults to (0, 0, 0).
     *
     * @exception {DeveloperError} <code>description.extent</code> is required and must have north, south, east and west attributes.
     * @exception {DeveloperError} <code>description.extent.north</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].
     * @exception {DeveloperError} <code>description.extent.south</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].
     * @exception {DeveloperError} <code>description.extent.east</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].
     * @exception {DeveloperError} <code>description.extent.west</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].
     * @exception {DeveloperError} <code>description.extent.north</code> must be greater than <code>extent.south</code>.
     * @exception {DeveloperError} <code>description.extent.east</code> must be greater than <code>extent.west</code>.
     * @exception {DeveloperError} <code>description.context</code> is required.
     *
     * @return {Object} A mesh containing attributes for positions, possibly texture coordinates and indices
     * from the extent for creating a vertex array.
     *
     * @see Context#createVertexArrayFromMesh
     * @see MeshFilters#createAttributeIndices
     * @see MeshFilters#toWireframeInPlace
     * @see Extent
     *
     * @example
     * // Create a vertex array for rendering a wireframe extent.
     * var mesh = ExtentTessellator.compute({
     *     ellipsoid : Ellipsoid.WGS84,
     *     extent : new Extent(
     *         CesiumMath.toRadians(-80.0),
     *         CesiumMath.toRadians(39.0),
     *         CesiumMath.toRadians(-74.0),
     *         CesiumMath.toRadians(42.0)
     *     ),
     *     granularity : 0.01,
     *     altitude : 10000.0
     * });
     * mesh = MeshFilters.toWireframeInPlace(mesh);
     * var va = context.createVertexArrayFromMesh({
     *     mesh             : mesh,
     *     attributeIndices : MeshFilters.createAttributeIndices(mesh)
     * });
     */
    ExtentTessellator.compute = function(description) {
        var desc = description || {};

        Extent.validate(desc.extent);

        desc.ellipsoid = desc.ellipsoid || Ellipsoid.WGS84;
        desc.granularity = (desc.granularity && desc.granularity > 0.0) ? desc.granularity : 0.1;
        desc.altitude = (desc.altitude && desc.altitude > 0.0) ? desc.altitude : 0.0;
        desc.relativeToCenter = (desc.relativeToCenter) ? Cartesian3.clone(desc.relativeToCenter) : Cartesian3.ZERO;
        desc.boundaryWidth = desc.boundaryWidth || 0; // NOTE: may want to expose in the future.
        desc.interleave = false;
        desc.positionName = desc.positionName || 'position';
        desc.textureCoordName = desc.textureCoordName || 'textureCoordinates';

        var vertices = [];
        var indices = [];
        var texCoords = [];

        desc.vertices = vertices;
        desc.texCoords = texCoords;
        desc.indices = indices;
        desc.boundaryExtent = new Extent(
            desc.extent.west - desc.granularity * desc.boundaryWidth,
            desc.extent.south - desc.granularity * desc.boundaryWidth,
            desc.extent.east + desc.granularity * desc.boundaryWidth,
            desc.extent.north + desc.granularity * desc.boundaryWidth
        );

        ExtentTessellator._computeVertices(desc);

        var mesh = {};
        mesh.attributes = {};
        mesh.indexLists = [];

        mesh.attributes[desc.positionName] = {
            componentDatatype : ComponentDatatype.FLOAT,
            componentsPerAttribute : 3,
            values : vertices
        };

        if (desc.generateTextureCoords) {
            mesh.attributes[desc.textureCoordName] = {
                componentDatatype : ComponentDatatype.FLOAT,
                componentsPerAttribute : 2,
                values : texCoords
            };
        }

        mesh.indexLists.push({
            primitiveType : PrimitiveType.TRIANGLES,
            values : indices
        });

        return mesh;
    };

    /**
     * Creates arrays of vertex attributes and indices from a cartographic extent.
     *
     * @param {Ellipsoid} description.ellipsoid The ellipsoid on which the extent lies. Defaults to a WGS84 ellipsoid.
     * @param {Extent} description.extent A cartographic extent with north, south, east and west properties in radians.
     * @param {Number} description.granularity The distance, in radians, between each latitude and longitude.
     * Determines the number of positions in the buffer. Defaults to 0.1.
     * @param {Number} description.altitude The height from the surface of the ellipsoid. Defaults to 0.
     * @param {Boolean} description.generateTextureCoords A truthy value will cause texture coordinates to be generated.
     * @param {Boolean} description.interleave If both this parameter and <code>generateTextureCoords</code> are truthy,
     * the positions and texture coordinates will be interleaved in a single buffer.
     * @param {Object} description.attributeIndices An object with possibly two numeric attributes, <code>position</code>
     * and <code>textureCoordinates</code>, used to index the shader attributes of the same names.
     * <code>position</code> defaults to 0 and <code>textureCoordinates</code> defaults to 1.
     * @param {Cartesian3} description.relativetoCenter If this parameter is provided, the positions will be
     * computed as <code>worldPosition.subtract(relativeToCenter)</code>. Defaults to (0, 0, 0).
     *
     * @exception {DeveloperError} <code>description.extent</code> is required and must have north, south, east and west attributes.
     * @exception {DeveloperError} <code>description.extent.north</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].
     * @exception {DeveloperError} <code>description.extent.south</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].
     * @exception {DeveloperError} <code>description.extent.east</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].
     * @exception {DeveloperError} <code>description.extent.west</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].
     * @exception {DeveloperError} <code>description.extent.north</code> must be greater than <code>extent.south</code>.     *
     * @exception {DeveloperError} <code>description.extent.east</code> must be greater than <code>extent.west</code>.
     *
     * @return {Object} An object with flattened arrays for vertex attributes and indices.
     *
     * @example
     * // Example 1:
     * // Create a vertex array for a solid extent, with separate positions and texture coordinates.
     * var buffers = ExtentTessellator.computeBuffers({
     *     ellipsoid : ellipsoid,
     *     extent : extent,
     *     generateTextureCoords : true
     * });
     *
     * var datatype = ComponentDatatype.FLOAT;
     * var usage = BufferUsage.STATIC_DRAW;
     * var positionBuffer = context.createVertexBuffer(datatype.toTypedArray(buffers.positions), usage);
     * var texCoordBuffer = context.createVertexBuffer(datatype.toTypedArray(buffers.textureCoords), usage);
     * attributes = [{
     *         index : attributeIndices.position,
     *         vertexBuffer : positionBuffer,
     *         componentDatatype : datatype,
     *         componentsPerAttribute : 3
     *     }, {
     *         index : attributeIndices.textureCoordinates,
     *         vertexBuffer : texCoordBuffer,
     *         componentDatatype : datatype,
     *         componentsPerAttribute : 2
     *     }];
     * var indexBuffer = context.createIndexBuffer(new Uint16Array(buffers.indices), usage, IndexDatatype.UNSIGNED_SHORT);
     * var va = context.createVertexArray(attributes, indexBuffer);
     *
     * @example
     * // Example 2:
     * // Create a vertex array for a solid extent, with interleaved positions and texture coordinates.
     * var buffers = ExtentTessellator.computeBuffers({
     *     ellipsoid : ellipsoid,
     *     extent : extent,
     *     generateTextureCoords : true,
     *     interleave : true
     * });
     *
     * var datatype = ComponentDatatype.FLOAT;
     * var usage = BufferUsage.STATIC_DRAW;
     * var typedArray = datatype.toTypedArray(buffers.vertices);
     * var buffer = context.createVertexBuffer(typedArray, usage);
     * var stride = 5 * datatype.sizeInBytes;
     * var attributes = [{
     *         index : attributeIndices.position3D,
     *         vertexBuffer : buffer,
     *         componentDatatype : datatype,
     *         componentsPerAttribute : 3,
     *         normalize : false,
     *         offsetInBytes : 0,
     *         strideInBytes : stride
     *     }, {
     *         index : attributeIndices.textureCoordinates,
     *         vertexBuffer : buffer,
     *         componentDatatype : datatype,
     *         componentsPerAttribute : 2,
     *         normalize : false,
     *         offsetInBytes : 3 * datatype.sizeInBytes,
     *         strideInBytes : stride
     *     }];
     * var indexBuffer = context.createIndexBuffer(new Uint16Array(buffers.indices), usage, IndexDatatype.UNSIGNED_SHORT);
     * var vacontext.createVertexArray(attributes, indexBuffer);
     *
     */
    ExtentTessellator.computeBuffers = function(description) {
        var desc = description || {};

        Extent.validate(desc.extent);

        desc.ellipsoid = desc.ellipsoid || Ellipsoid.WGS84;
        desc.granularity = (typeof desc.granularity !== 'undefined' && desc.granularity > 0.0) ? desc.granularity : 0.1;
        desc.altitude = (typeof desc.altitude !== 'undefined' && desc.altitude > 0.0) ? desc.altitude : 0.0;
        desc.relativeToCenter = (desc.relativeToCenter) ? Cartesian3.clone(desc.relativeToCenter) : Cartesian3.ZERO;
        desc.boundaryWidth = desc.boundaryWidth || 0; // NOTE: may want to expose in the future.

        desc.vertices = [];
        desc.texCoords = [];
        desc.indices = [];
        desc.boundaryExtent = new Extent(
            desc.extent.west - desc.granularity * desc.boundaryWidth,
            desc.extent.south - desc.granularity * desc.boundaryWidth,
            desc.extent.east + desc.granularity * desc.boundaryWidth,
            desc.extent.north + desc.granularity * desc.boundaryWidth
        );

        ExtentTessellator._computeVertices(desc);

        var result = {};
        if (desc.interleave) {
            result.vertices = desc.vertices;
        } else {
            result.positions = desc.vertices;
            if (desc.generateTextureCoords) {
                result.textureCoords = desc.texCoords;
            }
        }

        result.indices = desc.indices;
        return result;
    };

    return ExtentTessellator;
});

/*global define*/
define('Core/destroyObject',[
        './defaultValue',
        './DeveloperError'
    ], function(
        defaultValue,
        DeveloperError) {
    

    function returnTrue() {
        return true;
    }

    /**
     * Destroys an object.  Each of the object's functions, including functions in its prototype,
     * is replaced with a function that throws a {@link DeveloperError}, except for the object's
     * <code>isDestroyed</code> function, which is set to a function that returns <code>true</code>.
     * The object's properties are removed with <code>delete</code>.
     * <br /><br />
     * This function is used by objects that hold native resources, e.g., WebGL resources, which
     * need to be explicitly released.  Client code calls an object's <code>destroy</code> function,
     * which then releases the native resource and calls <code>destroyObject</code> to put itself
     * in a destroyed state.
     *
     * @exports destroyObject
     *
     * @param {Object} object The object to destroy.
     * @param {String} [message] The message to include in the exception that is thrown if
     *                           a destroyed object's function is called.
     *
     * @see DeveloperError
     *
     * @example
     * // How a texture would destroy itself.
     * this.destroy = function () {
     *     _gl.deleteTexture(_texture);
     *     return destroyObject(this);
     * };
     */
    var destroyObject = function(object, message) {
        message = defaultValue(message, 'This object was destroyed, i.e., destroy() was called.');

        function throwOnDestroyed() {
            throw new DeveloperError(message);
        }

        for ( var key in object) {
            if (typeof object[key] === 'function') {
                object[key] = throwOnDestroyed;
            } else {
                delete object[key];
            }
        }

        object.isDestroyed = returnTrue;

        return undefined;
    };

    return destroyObject;
});
/*global define*/
define('Core/Cache',[
        './DeveloperError',
        './destroyObject'
    ], function(
        DeveloperError,
        destroyObject) {
    

    /**
     * A software cache implementation.
     *
     * @alias Cache
     *
     * @constructor
     *
     * @param {Object} policy A cache replacement policy.
     *
     * @exception {DeveloperError} policy is required.
     * @exception {DeveloperError} policy.hit must be a function.
     * @exception {DeveloperError} policy.miss must be a function.
     *
     * @see CachePolicy.LRU
     */
    var Cache = function(policy) {
        if (!policy) {
            throw new DeveloperError('policy is required.');
        }

        if (!policy.hit || typeof policy.hit !== 'function') {
            throw new DeveloperError('policy.hit must be a function.');
        }

        if (!policy.miss || typeof policy.miss !== 'function') {
            throw new DeveloperError('policy.miss must be a function.');
        }

        this._cache = {};
        this._policy = policy;
    };

    /**
     * Returns the object at key in the cache. It is the responsibility of the cache replacement policy
     * to fetch items not stored in the cache, which will be stored in the cache and returned.
     *
     * @memberof Cache
     *
     * @param {Object} key The key of the object to remove from the cache.
     *
     * @exception {DeveloperError} key is required.
     * @exception {DeveloperError} key must be a string, have a string property called 'key', or
     * have a function called 'getKey' that returns a string.
     *
     * @return {Object} The object stored in the cache at <code>key</code>.
     *
     * @see Cache#remove
     */
    Cache.prototype.find = function(key) {
        if (!key) {
            throw new DeveloperError('key is required.');
        }

        var name = key;
        if (typeof key !== 'string') {
            name = key.key || (key.getKey && key.getKey());
        }

        if (!name) {
            throw new DeveloperError('key must be a string, or an object with a string key property or getKey function.');
        }

        var element = this._cache[name];
        if (element) {
            return this._policy.hit(element);
        }

        return this._policy.miss(name, key, this._cache);
    };

    /**
     * Removes the object at key from the cache.
     *
     * @memberof Cache
     *
     * @param {Object} key The key of the object to remove from the cache.
     *
     * @return {Boolean} <code>true</code> is the object was removed from the cache, <code>false</code>
     * if the object was not found and not removed.
     *
     * @see Cache#find
     */
    Cache.prototype.remove = function(key) {
        if (!key) {
            return false;
        }

        var name = key;
        if (typeof key !== 'string') {
            name = key.key || (key.getKey && key.getKey());
        }

        if (!name) {
            return false;
        }

        if (this._cache[name]) {
            delete this._cache[name];
            return true;
        }

        return false;
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof Cache
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see Cache.destroy
     */
    Cache.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof Cache
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see Cache#isDestroyed
     *
     * @example
     * cache = cache && cache.destroy();
     */
    Cache.prototype.destroy = function() {
        var keys = Object.keys(this._cache);
        for ( var i = 0; i < keys.length; ++i) {
            var e = keys[i];
            if (e && e.isDestroyed && !e.isDestroyed() && e.destroy) {
                e.destroy();
            }
        }
        return destroyObject(this);
    };

    return Cache;
});

/*global define*/
define('Core/isLeapYear',[
        './DeveloperError'
    ], function(
        DeveloperError) {
    

    /**
     * Determines if a given date is a leap year.
     *
     * @exports isLeapYear
     *
     * @param {Number} year The year to be tested.
     *
     * @return {Boolean} True if <code>year</code> is a leap yer.
     *
     * @exception {DeveloperError} year is required and must be a number.
     *
     * @example
     * var leapYear = isLeapYear(2000); // true
     */
    function isLeapYear(year) {
        if (year === null || isNaN(year)) {
            throw new DeveloperError('year is required and must be a number.');
        }
        return ((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0);
    }

    return isLeapYear;
});

/*global define*/
define('Core/JulianDate',[
        './DeveloperError',
        './binarySearch',
        './TimeConstants',
        './LeapSecond',
        './TimeStandard',
        './isLeapYear'
    ], function(
        DeveloperError,
        binarySearch,
        TimeConstants,
        LeapSecond,
        TimeStandard,
        isLeapYear) {
    

    var daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    var daysInLeapFeburary = 29;

    function convertUtcToTai(julianDate) {
        //Even though julianDate is in UTC, we'll treat it as TAI and
        //search the leap second table for it.
        var toFind = new LeapSecond(julianDate, 0.0);
        var leapSeconds = LeapSecond.getLeapSeconds();
        var index = binarySearch(leapSeconds, toFind, LeapSecond.compareLeapSecondDate);

        if (index < 0) {
            index = ~index;
        }

        if (index >= leapSeconds.length) {
            index = leapSeconds.length - 1;
        }

        var offset = leapSeconds[index].offset;
        if (index > 0) {
            //Now we have the index of the closest leap second that comes on or after our UTC time.
            //However, if the difference between the UTC date being converted and the TAI
            //defined leap second is greater than the offset, we are off by one and need to use
            //the previous leap second.
            var difference = julianDate.getSecondsDifference(leapSeconds[index].julianDate);
            if (difference > offset) {
                index--;
                offset = leapSeconds[index].offset;
            }
        }

        julianDate.addSeconds(offset, julianDate);
    }

    function convertTaiToUtc(julianDate, result) {
        var toFind = new LeapSecond(julianDate, 0.0);
        var leapSeconds = LeapSecond.getLeapSeconds();
        var index = binarySearch(leapSeconds, toFind, LeapSecond.compareLeapSecondDate);
        if (index < 0) {
            index = ~index;
        }

        //All times before our first leap second get the first offset.
        if (index === 0) {
            return julianDate.addSeconds(-leapSeconds[0].offset, result);
        }

        //All times after our leap second get the last offset.
        if (index >= leapSeconds.length) {
            return julianDate.addSeconds(-leapSeconds[index - 1].offset, result);
        }

        //Compute the difference between the found leap second and the time we are converting.
        var difference = julianDate.getSecondsDifference(leapSeconds[index].julianDate);

        if (difference === 0) {
            //The date is in our leap second table.
            return julianDate.addSeconds(-leapSeconds[index].offset, result);
        }

        if (difference <= 1.0) {
            //The requested date is during the moment of a leap second, then we cannot convert to UTC
            return undefined;
        }

        //The time is in between two leap seconds, undex is the leap second after the date
        //we're converting, so we subtract one to get the correct LeapSecond instance.
        return julianDate.addSeconds(-leapSeconds[--index].offset, result);
    }

    function setComponents(wholeDays, secondsOfDay, julianDate) {
        var extraDays = (secondsOfDay / TimeConstants.SECONDS_PER_DAY) | 0;
        wholeDays += extraDays;
        secondsOfDay -= TimeConstants.SECONDS_PER_DAY * extraDays;

        if (secondsOfDay < 0) {
            wholeDays--;
            secondsOfDay += TimeConstants.SECONDS_PER_DAY;
        }

        if (typeof julianDate === 'undefined') {
            return new JulianDate(wholeDays, secondsOfDay, TimeStandard.TAI);
        }

        julianDate._julianDayNumber = wholeDays;
        julianDate._secondsOfDay = secondsOfDay;
        return julianDate;
    }

    function computeJulianDateComponents(year, month, day, hour, minute, second, millisecond) {
        // Algorithm from page 604 of the Explanatory Supplement to the
        // Astronomical Almanac (Seidelmann 1992).

        var a = ((month - 14) / 12) | 0;
        var b = year + 4800 + a;
        var dayNumber = (((1461 * b) / 4) | 0) + (((367 * (month - 2 - 12 * a)) / 12) | 0) - (((3 * ((b + 100) / 100)) / 4) | 0) + day - 32075;

        // JulianDates are noon-based
        hour = hour - 12;
        if (hour < 0) {
            hour += 24;
        }

        var secondsOfDay = second + ((hour * TimeConstants.SECONDS_PER_HOUR) + (minute * TimeConstants.SECONDS_PER_MINUTE) + (millisecond * TimeConstants.SECONDS_PER_MILLISECOND));

        if (secondsOfDay >= 43200.0) {
            dayNumber -= 1;
        }

        return [dayNumber, secondsOfDay];
    }

    function computeJulianDateComponentsFromDate(date) {
        return computeJulianDateComponents(date.getUTCFullYear(), date.getUTCMonth() + 1, date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date
                .getUTCMilliseconds());
    }

    //Regular expressions used for ISO8601 date parsing.
    //YYYY
    var matchCalendarYear = /^(\d{4})$/;
    //YYYY-MM (YYYYMM is invalid)
    var matchCalendarMonth = /^(\d{4})-(\d{2})$/;
    //YYYY-DDD or YYYYDDD
    var matchOrdinalDate = /^(\d{4})-?(\d{3})$/;
    //YYYY-Www or YYYYWww or YYYY-Www-D or YYYYWwwD
    var matchWeekDate = /^(\d{4})-?W(\d{2})-?(\d{1})?$/;
    //YYYY-MM-DD or YYYYMMDD
    var matchCalendarDate = /^(\d{4})-?(\d{2})-?(\d{2})$/;
    // Match utc offset
    var utcOffset = /([Z+\-])?(\d{2})?:?(\d{2})?$/;
    // Match hours HH or HH.xxxxx
    var matchHours = /^(\d{2})(\.\d+)?/.source + utcOffset.source;
    // Match hours/minutes HH:MM HHMM.xxxxx
    var matchHoursMinutes = /^(\d{2}):?(\d{2})(\.\d+)?/.source + utcOffset.source;
    // Match hours/minutes HH:MM:SS HHMMSS.xxxxx
    var matchHoursMinutesSeconds = /^(\d{2}):?(\d{2}):?(\d{2})(\.\d+)?/.source + utcOffset.source;

    var iso8601ErrorMessage = 'Valid ISO 8601 date string required.';

    /**
     * Constructs a JulianDate instance from a Julian day number, the number of seconds elapsed
     * into that day, and the time standard which the parameters are in.  Passing no parameters will
     * construct a JulianDate that represents the current system time.
     *
     * An astronomical Julian Date is the number of days since noon on January 1, -4712 (4713 BC).
     * For increased precision, this class stores the whole number part of the date and the seconds
     * part of the date in separate components.  In order to be safe for arithmetic and represent
     * leap seconds, the date is always stored in the International Atomic Time standard
     * {@link TimeStandard.TAI}.
     *
     * @alias JulianDate
     * @constructor
     * @immutable
     *
     * @param {Number} julianDayNumber The Julian Day Number representing the number of whole days.  Fractional days will also be handled correctly.
     * @param {Number} julianSecondsOfDay The number of seconds into the current Julian Day Number.  Fractional seconds, negative seconds and seconds greater than a day will be handled correctly.
     * @param {TimeStandard} [timeStandard = TimeStandard.UTC] The time standard in which the first two parameters are defined.
     *
     * @exception {DeveloperError} timeStandard is not a known TimeStandard.
     * @exception {DeveloperError} julianDayNumber is required.
     * @exception {DeveloperError} julianSecondsOfDay is required.
     *
     * @see JulianDate.fromDate
     * @see JulianDate.fromTotalDays
     * @see JulianDate.fromIso8601
     * @see TimeStandard
     * @see LeapSecond
     *
     * @example
     * // Example 1. Construct a Julian date representing the current system time.
     * var julianDate = new JulianDate();
     *
     * // Example 2. Construct a Julian date from a Julian day number and seconds of the day.
     * var julianDayNumber = 2448257;   // January 1, 1991
     * var secondsOfDay = 21600;        // 06:00:00
     * var julianDate = new JulianDate(julianDayNumber, secondsOfDay, TimeStandard.UTC);
     */
    var JulianDate = function(julianDayNumber, julianSecondsOfDay, timeStandard) {
        this._julianDayNumber = undefined;
        this._secondsOfDay = undefined;

        var wholeDays;
        var secondsOfDay;
        //If any of the properties are defined, then we are constructing from components.
        if (typeof julianDayNumber !== 'undefined' || typeof julianSecondsOfDay !== 'undefined' || typeof timeStandard !== 'undefined') {
            if (typeof timeStandard === 'undefined') {
                timeStandard = TimeStandard.UTC;
            } else if ((timeStandard !== TimeStandard.UTC) && (timeStandard !== TimeStandard.TAI)) {
                throw new DeveloperError('timeStandard is not a known TimeStandard.');
            }

            if (julianDayNumber === null || isNaN(julianDayNumber)) {
                throw new DeveloperError('julianDayNumber is required.');
            }

            if (julianSecondsOfDay === null || isNaN(julianSecondsOfDay)) {
                throw new DeveloperError('julianSecondsOfDay is required.');
            }

            //coerce to integer
            wholeDays = julianDayNumber | 0;
            //If julianDayNumber was fractional, add the number of seconds the fraction represented
            secondsOfDay = julianSecondsOfDay + (julianDayNumber - wholeDays) * TimeConstants.SECONDS_PER_DAY;
        } else {
            //Create a new date from the current time.
            var date = new Date();
            var components = computeJulianDateComponentsFromDate(date);
            wholeDays = components[0];
            secondsOfDay = components[1];
            timeStandard = TimeStandard.UTC;
        }

        setComponents(wholeDays, secondsOfDay, this);

        if (timeStandard === TimeStandard.UTC) {
            convertUtcToTai(this);
        }
    };

    /**
     * Duplicates a JulianDate instance.
     * @memberof JulianDate
     *
     * @param {Cartesian3} date The JulianDate to duplicate.
     * @param {Cartesian3} [result] The object onto which to store the JulianDate.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
     *
     * @exception {DeveloperError} date is required.
     */
    JulianDate.clone = function(date, result) {
        if (typeof date === 'undefined') {
            throw new DeveloperError('date is required.');
        }
        if (typeof result === 'undefined') {
            return new JulianDate(date._julianDayNumber, date._secondsOfDay, TimeStandard.TAI);
        }
        result._julianDayNumber = date._julianDayNumber;
        result._secondsOfDay = date._secondsOfDay;
        return result;
    };

    /**
     * Creates a JulianDate instance from a JavaScript Date object.
     * While the JavaScript Date object defaults to the system's local time zone,
     * the Julian date is computed using the UTC values.
     *
     * @memberof JulianDate
     *
     * @param {Date} date The JavaScript Date object representing the time to be converted to a Julian date.
     * @param {TimeStandard} [timeStandard = TimeStandard.UTC] Indicates the time standard in which this Julian date is represented.
     *
     * @return {JulianDate} The new {@Link JulianDate} instance.
     *
     * @exception {DeveloperError} date must be a valid JavaScript Date.
     *
     * @see JulianDate
     * @see JulianDate.fromTotalDays
     * @see JulianDate.fromIso8601
     * @see TimeStandard
     * @see LeapSecond
     * @see <a href='http://www.w3schools.com/js/js_obj_date.asp'>JavaScript Date Object on w3schools</a>.
     * @see <a href='http://www.w3schools.com/jsref/jsref_obj_date.asp'>JavaScript Date Object Reference on w3schools</a>.
     *
     * @example
     * // Construct a Julian date specifying the UTC time standard
     * var date = new Date('January 1, 2011 12:00:00 EST');
     * var julianDate = JulianDate.fromDate(date, TimeStandard.UTC);
     */
    JulianDate.fromDate = function(date, timeStandard) {
        if (typeof date === 'undefined' || date === null || isNaN(date.getTime())) {
            throw new DeveloperError('date must be a valid JavaScript Date.');
        }

        var components = computeJulianDateComponentsFromDate(date);
        return new JulianDate(components[0], components[1], timeStandard);
    };

    /**
     * Creates a JulianDate instance from an ISO 8601 date string.  Unlike Date.parse,
     * this method properly accounts for all valid formats defined by the ISO 8601
     * specification.  It also properly handles leap seconds and sub-millisecond times.
     *
     * @memberof JulianDate
     *
     * @param {String} iso8601String The ISO 8601 date string representing the time to be converted to a Julian date.
     *
     * @return {JulianDate} The new {@Link JulianDate} instance.
     *
     * @exception {DeveloperError} Valid ISO 8601 date string required.
     *
     * @see JulianDate
     * @see JulianDate.fromTotalDays
     * @see JulianDate.fromDate
     * @see LeapSecond
     * @see <a href='http://en.wikipedia.org/wiki/ISO_8601'>ISO 8601 on Wikipedia</a>.
     *
     * @example
     * // Example 1. Construct a Julian date in UTC at April 24th, 2012 6:08PM UTC
     * var julianDate = JulianDate.fromIso8601('2012-04-24T18:08Z');
     * // Example 2. Construct a Julian date in local time April 24th, 2012 12:00 AM
     * var localDay = JulianDate.fromIso8601('2012-04-24');
     * // Example 3. Construct a Julian date 5 hours behind UTC April 24th, 2012 5:00 pm UTC
     * var localDay = JulianDate.fromIso8601('2012-04-24T12:00-05:00');
     */
    JulianDate.fromIso8601 = function(iso8601String) {
        if (typeof iso8601String !== 'string') {
            throw new DeveloperError(iso8601ErrorMessage);
        }

        //Comma and decimal point both indicate a fractional number according to ISO 8601,
        //start out by blanket replacing , with . which is the only valid such symbol in JS.
        iso8601String = iso8601String.replace(',', '.');

        //Split the string into its date and time components, denoted by a mandatory T
        var tokens = iso8601String.split('T'), year, month = 1, day = 1, hours = 0, minutes = 0, seconds = 0, milliseconds = 0;

        //Lacking a time is okay, but a missing date is illegal.
        var date = tokens[0];
        var time = tokens[1];
        var tmp, inLeapYear;
        if (typeof date === 'undefined') {
            throw new DeveloperError(iso8601ErrorMessage);
        }

        var dashCount;

        //First match the date against possible regular expressions.
        tokens = date.match(matchCalendarDate);
        if (tokens !== null) {
            dashCount = date.split('-').length - 1;
            if (dashCount > 0 && dashCount !== 2) {
                throw new DeveloperError(iso8601ErrorMessage);
            }
            year = +tokens[1];
            month = +tokens[2];
            day = +tokens[3];
        } else {
            tokens = date.match(matchCalendarMonth);
            if (tokens !== null) {
                year = +tokens[1];
                month = +tokens[2];
            } else {
                tokens = date.match(matchCalendarYear);
                if (tokens !== null) {
                    year = +tokens[1];
                } else {
                    //Not a year/month/day so it must be an ordinal date.
                    var dayOfYear;
                    tokens = date.match(matchOrdinalDate);
                    if (tokens !== null) {

                        year = +tokens[1];
                        dayOfYear = +tokens[2];
                        inLeapYear = isLeapYear(year);

                        //This validation is only applicable for this format.
                        if (dayOfYear < 1 || (inLeapYear && dayOfYear > 366) || (!inLeapYear && dayOfYear > 365)) {
                            throw new DeveloperError(iso8601ErrorMessage);
                        }
                    } else {
                        tokens = date.match(matchWeekDate);
                        if (tokens !== null) {
                            //ISO week date to ordinal date from
                            //http://en.wikipedia.org/w/index.php?title=ISO_week_date&oldid=474176775
                            year = +tokens[1];
                            var weekNumber = +tokens[2];
                            var dayOfWeek = +tokens[3] || 0;

                            dashCount = date.split('-').length - 1;
                            if (dashCount > 0 &&
                               ((typeof tokens[3] === 'undefined' && dashCount !== 1) ||
                               (typeof tokens[3] !== 'undefined' && dashCount !== 2))) {
                                throw new DeveloperError(iso8601ErrorMessage);
                            }

                            var january4 = new Date(Date.UTC(year, 0, 4));
                            dayOfYear = (weekNumber * 7) + dayOfWeek - january4.getUTCDay() - 3;
                        } else {
                            //None of our regular expressions succeeded in parsing the date properly.
                            throw new DeveloperError(iso8601ErrorMessage);
                        }
                    }
                    //Split an ordinal date into month/day.
                    tmp = new Date(Date.UTC(year, 0, 1));
                    tmp.setUTCDate(dayOfYear);
                    month = tmp.getUTCMonth() + 1;
                    day = tmp.getUTCDate();
                }
            }
        }

        //Now that we have all of the date components, validate them to make sure nothing is out of range.
        inLeapYear = isLeapYear(year);
        if (month < 1 || month > 12 || day < 1 || ((month !== 2 || !inLeapYear) && day > daysInMonth[month - 1]) || (inLeapYear && month === 2 && day > daysInLeapFeburary)) {
            throw new DeveloperError(iso8601ErrorMessage);
        }

        //Not move onto the time string, which is much simpler.
        var offsetIndex;
        if (typeof time !== 'undefined') {
            tokens = time.match(matchHoursMinutesSeconds);
            if (tokens !== null) {
                dashCount = time.split(':').length - 1;
                if (dashCount > 0 && dashCount !== 2) {
                    throw new DeveloperError(iso8601ErrorMessage);
                }

                hours = +tokens[1];
                minutes = +tokens[2];
                seconds = +tokens[3];
                milliseconds = +(tokens[4] || 0) * 1000.0;
                offsetIndex = 5;
            } else {
                tokens = time.match(matchHoursMinutes);
                if (tokens !== null) {
                    dashCount = time.split(':').length - 1;
                    if (dashCount > 0 && dashCount !== 1) {
                        throw new DeveloperError(iso8601ErrorMessage);
                    }

                    hours = +tokens[1];
                    minutes = +tokens[2];
                    seconds = +(tokens[3] || 0) * 60.0;
                    offsetIndex = 4;
                } else {
                    tokens = time.match(matchHours);
                    if (tokens !== null) {
                        hours = +tokens[1];
                        minutes = +(tokens[2] || 0) * 60.0;
                        offsetIndex = 3;
                    } else {
                        throw new DeveloperError(iso8601ErrorMessage);
                    }
                }
            }

            //Validate that all values are in proper range.  Minutes and hours have special cases at 60 and 24.
            if (minutes >= 60 || seconds >= 61 || hours > 24 || (hours === 24 && (minutes > 0 || seconds > 0 || milliseconds > 0))) {
                throw new DeveloperError(iso8601ErrorMessage);
            }

            //Check the UTC offset value, if no value exists, use local time
            //a Z indicates UTC, + or - are offsets.
            var offset = tokens[offsetIndex];
            var offsetHours = +(tokens[offsetIndex + 1]);
            var offsetMinutes = +(tokens[offsetIndex + 2] || 0);
            switch (offset) {
            case '+':
                hours = hours - offsetHours;
                minutes = minutes - offsetMinutes;
                break;
            case '-':
                hours = hours + offsetHours;
                minutes = minutes + offsetMinutes;
                break;
            case 'Z':
                break;
            default:
                minutes = minutes + new Date(Date.UTC(year, month - 1, day, hours, minutes)).getTimezoneOffset();
                break;
            }
        } else {
            //If no time is specified, it is considered the beginning of the day, local time.
            minutes = minutes + new Date(Date.UTC(year, month - 1, day)).getTimezoneOffset();
        }

        //ISO8601 denotes a leap second by any time having a seconds component of 60 seconds.
        //If that's the case, we need to temporarily subtract a second in order to build a UTC date.
        //Then we add it back in after converting to TAI.
        var isLeapSecond = seconds === 60;
        if (isLeapSecond) {
            seconds--;
        }

        //Even if we successfully parsed the string into its components, after applying UTC offset or
        //special cases like 24:00:00 denoting midnight, we need to normalize the data appropriately.

        //milliseconds can never be greater than 1000, and seconds can't be above 60, so we start with minutes
        while (minutes >= 60) {
            minutes -= 60;
            hours++;
        }

        while (hours >= 24) {
            hours -= 24;
            day++;
        }

        tmp = (inLeapYear && month === 2) ? daysInLeapFeburary : daysInMonth[month - 1];
        while (day > tmp) {
            day -= tmp;
            month++;

            if (month > 12) {
                month -= 12;
                year++;
            }

            tmp = (inLeapYear && month === 2) ? daysInLeapFeburary : daysInMonth[month - 1];
        }

        //If UTC offset is at the beginning/end of the day, minutes can be negative.
        while (minutes < 0) {
            minutes += 60;
            hours--;
        }

        while (hours < 0) {
            hours += 24;
            day--;
        }

        while (day < 1) {
            tmp = (inLeapYear && month === 2) ? daysInLeapFeburary : daysInMonth[month - 1];
            day += tmp;
            month--;

            if (month < 1) {
                month += 12;
                year--;
            }
        }

        //Now create the JulianDate components from the Gregorian date and actually create our instance.
        var components = computeJulianDateComponents(year, month, day, hours, minutes, seconds, milliseconds);
        var result = new JulianDate(components[0], components[1], TimeStandard.UTC);

        //If we were on a leap second, add it back.
        if (isLeapSecond) {
            result.addSeconds(1, result);
        }

        return result;
    };

    /**
     * Creates a JulianDate instance from a single number representing the Julian day and fractional day.
     *
     * @memberof JulianDate
     *
     * @param {Number} totalDays The combined Julian Day Number and fractional day.
     * @param {TimeStandard} [timeStandard = TimeStandard.UTC] Indicates the time standard in which the first parameter is defined.
     *
     * @return {JulianDate} The new {@Link JulianDate} instance.
     *
     * @exception {DeveloperError} totalDays is required.
     *
     * @see JulianDate
     * @see JulianDate.fromDate
     * @see JulianDate.fromIso8601
     * @see TimeStandard
     * @see LeapSecond
     *
     * @example
     * // Construct a date which corresponds to January 1, 1991 06:00:00 UTC.
     * var julianDate = JulianDate.fromTotalDays(2448257.75, TimeStandard.UTC);
     */
    JulianDate.fromTotalDays = function(totalDays, timeStandard) {
        if (totalDays === null || isNaN(totalDays)) {
            throw new DeveloperError('totalDays is required.');
        }
        return new JulianDate(totalDays, 0, timeStandard);
    };

    /**
     * Compares two {JulianDate} instances.
     *
     * @memberof JulianDate
     *
     * @param {JulianDate} a The first instance.
     * @param {JulianDate} b The second instance.
     * @return {Number} A negative value if a is less than b, a positive value if
     *                   a is greater than b, and zero if a and b are equal.
     */
    JulianDate.compare = function(a, b) {
        var dayDifference = (a._julianDayNumber - b._julianDayNumber);
        if (dayDifference !== 0) {
            return dayDifference;
        }
        return a._secondsOfDay - b._secondsOfDay;
    };

    /**
     * Duplicates this JulianDate.
     * @memberof JulianDate
     *
     * @param {Cartesian3} [result] The object onto which to store the JulianDate.
     * @return {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
     */
    JulianDate.prototype.clone = function(result) {
        return JulianDate.clone(this, result);
    };

    /**
     * Returns the total number of whole and fractional days represented by this astronomical Julian date.
     *
     * @memberof JulianDate
     *
     * @return {Number} The Julian date as single floating point number.
     *
     * @see JulianDate#getJulianDayNumber
     * @see JulianDate#getJulianTimeFraction
     */
    JulianDate.prototype.getTotalDays = function() {
        return this._julianDayNumber + (this._secondsOfDay / TimeConstants.SECONDS_PER_DAY);
    };

    /**
     * Returns the whole number component of the Julian date.
     *
     * @memberof JulianDate
     *
     * @return {Number} A whole number representing the Julian day number.
     *
     * @see JulianDate#getTotalDays
     * @see JulianDate#getJulianTimeFraction
     */
    JulianDate.prototype.getJulianDayNumber = function() {
        return this._julianDayNumber;
    };

    /**
     * Returns the floating point component of the Julian date representing the time of day.
     *
     * @memberof JulianDate
     *
     * @return {Number} The floating point component of the Julian date representing the time of day.
     *
     * @see JulianDate#getTotalDays
     * @see JulianDate#getJulianDayNumber
     */
    JulianDate.prototype.getJulianTimeFraction = function() {
        return this._secondsOfDay / TimeConstants.SECONDS_PER_DAY;
    };

    /**
     * Return the number of seconds elapsed into the current Julian day (starting at noon).
     *
     * @memberof JulianDate
     *
     * @return {Number} The number of seconds elapsed into the current day.
     *
     * @see JulianDate#getJulianDayNumber
     */
    JulianDate.prototype.getSecondsOfDay = function() {
        return this._secondsOfDay;
    };

    var toDateScratch = new JulianDate(0, 0, TimeStandard.TAI);
    /**
     * Creates a new JavaScript Date object equivalent to the Julian date
     * (accurate to the nearest millisecond in the UTC time standard).
     *
     * @memberof JulianDate
     *
     * @return {Date} A new JavaScript Date equivalent to this Julian date.
     */
    JulianDate.prototype.toDate = function() {
        //Attempt to convert to UTC; if we are on a leap second, this will
        //return undefined.  Since JavaScript Date doesn't support leap second
        //we can just add second and re-convert.
        var thisUtc = convertTaiToUtc(this, toDateScratch);
        if (typeof thisUtc === 'undefined') {
            this.addSeconds(1, toDateScratch);
            thisUtc = convertTaiToUtc(toDateScratch, toDateScratch);
        }

        var julianDayNumber = thisUtc._julianDayNumber;
        var secondsOfDay = thisUtc._secondsOfDay;

        if (secondsOfDay >= 43200.0) {
            julianDayNumber += 1;
        }

        // Algorithm from page 604 of the Explanatory Supplement to the
        // Astronomical Almanac (Seidelmann 1992).
        var L = (julianDayNumber + 68569) | 0;
        var N = (4 * L / 146097) | 0;
        L = (L - (((146097 * N + 3) / 4) | 0)) | 0;
        var I = ((4000 * (L + 1)) / 1461001) | 0;
        L = (L - (((1461 * I) / 4) | 0) + 31) | 0;
        var J = ((80 * L) / 2447) | 0;
        var day = (L - (((2447 * J) / 80) | 0)) | 0;
        L = (J / 11) | 0;
        var month = (J + 2 - 12 * L) | 0;
        var year = (100 * (N - 49) + I + L) | 0;

        month--; // month field is zero-indexed

        var hours = (secondsOfDay / TimeConstants.SECONDS_PER_HOUR) | 0;
        var remainingSeconds = secondsOfDay - (hours * TimeConstants.SECONDS_PER_HOUR);
        var minutes = (remainingSeconds / TimeConstants.SECONDS_PER_MINUTE) | 0;
        remainingSeconds = remainingSeconds - (minutes * TimeConstants.SECONDS_PER_MINUTE);
        var seconds = remainingSeconds | 0;
        var milliseconds = ((remainingSeconds - seconds) / TimeConstants.SECONDS_PER_MILLISECOND) | 0;

        // JulianDates are noon-based
        hours += 12;
        if (hours > 23) {
            hours -= 24;
        }

        return new Date(Date.UTC(year, month, day, hours, minutes, seconds, milliseconds));
    };

    /**
     * Computes the number of seconds that have elapsed from this Julian date to the <code>other</code>
     * Julian date.
     *
     * @memberof JulianDate
     *
     * @param {JulianDate} other The other Julian date, which is the end of the interval.
     *
     * @return {Number} The number of seconds that have elpased from this Julian date to the other Julian date.
     *
     * @see JulianDate#getMinutesDifference
     *
     * @example
     * var start = JulianDate.fromDate(new Date('July 4, 2011 12:00:00'));
     * var end = JulianDate.fromDate(new Date('July 5, 2011 12:01:00'));
     * var difference = start.getSecondsDifference(end);    // 86460.0 seconds
     */
    JulianDate.prototype.getSecondsDifference = function(other) {
        var julianDate1 = this;
        var julianDate2 = other;
        var dayDifference = (julianDate2.getJulianDayNumber() - julianDate1.getJulianDayNumber()) * TimeConstants.SECONDS_PER_DAY;
        return (dayDifference + (julianDate2.getSecondsOfDay() - julianDate1.getSecondsOfDay()));
    };

    /**
     * Computes the number of minutes that have elapsed from this Julian date to the <code>other</code>
     * Julian date.
     *
     * @memberof JulianDate
     *
     * @param {JulianDate} other The other Julian date, which is the end of the interval.
     *
     * @return {Number} The number of seconds that have elpased from this Julian date to the other Julian date.
     *
     * @see JulianDate#getSecondsDifference
     *
     * @example
     * var start = JulianDate.fromDate(new Date('July 4, 2011 12:00:00'));
     * var end = JulianDate.fromDate(new Date('July 5, 2011 12:01:00'));
     * var difference = start.getMinutesDifference(end);    // 1441.0 minutes
     */
    JulianDate.prototype.getMinutesDifference = function(other) {
        return this.getSecondsDifference(other) / TimeConstants.SECONDS_PER_MINUTE;
    };

    /**
     * Returns the number of seconds this TAI date is ahead of UTC.
     *
     * @memberof JulianDate
     *
     * @return {Number} The number of seconds this TAI date is ahead of UTC
     *
     * @see LeapSecond
     * @see TimeStandard
     *
     * @example
     * var date = new Date('August 1, 2012 12:00:00 UTC');
     * var julianDate = JulianDate.fromDate(date);
     * var difference = julianDate.getTaiMinusUtc(); //35
     */
    JulianDate.prototype.getTaiMinusUtc = function() {
        var toFind = new LeapSecond(this, 0.0);
        var leapSeconds = LeapSecond.getLeapSeconds();
        var index = binarySearch(leapSeconds, toFind, LeapSecond.compareLeapSecondDate);
        if (index < 0) {
            index = ~index;
            --index;
            if (index < 0) {
                index = 0;
            }
        }
        return leapSeconds[index].offset;
    };

    /**
     * Returns a new Julian date representing a time <code>duration</code> seconds later
     * (or earlier in the case of a negative amount).
     *
     * @memberof JulianDate
     *
     * @param {Number} seconds The number of seconds to add or subtract.
     * @param {JulianDate} [result] The JulianDate to store the result into.
     *
     * @return {JulianDate} The modified result parameter or a new JulianDate instance if it was not provided.
     *
     * @exception {DeveloperError} seconds is required and must be a number.
     *
     * @see JulianDate#addMinutes
     * @see JulianDate#addHours
     * @see JulianDate#addDays
     *
     * @example
     * var date = new Date();
     * date.setUTCFullYear(2011, 6, 4);     // July 4, 2011 @ 12:00:00 UTC
     * date.setUTCHours(12, 0, 00, 0);
     * var start = JulianDate.fromDate(date);
     * var end = start.addSeconds(95);      // July 4, 2011 @ 12:01:35 UTC
     */
    JulianDate.prototype.addSeconds = function(seconds, result) {
        if (seconds === null || isNaN(seconds)) {
            throw new DeveloperError('seconds is required and must be a number.');
        }
        return setComponents(this._julianDayNumber, this._secondsOfDay + seconds, result);
    };

    /**
     * Returns a new Julian date representing a time <code>duration</code> minutes later
     * (or earlier in the case of a negative amount).
     *
     * @memberof JulianDate
     *
     * @param {Number} duration An integer number of minutes to add or subtract.
     *
     * @return {JulianDate} A new Julian date object
     *
     * @exception {DeveloperError} duration is required and must be a number.
     *
     * @see JulianDate#addSeconds
     * @see JulianDate#addHours
     * @see JulianDate#addDays
     *
     * @example
     * var date = new Date();
     * date.setUTCFullYear(2011, 6, 4);     // July 4, 2011 @ 12:00 UTC
     * date.setUTCHours(12, 0, 0, 0);
     * var start = JulianDate.fromDate(date);
     * var end = start.addMinutes(65);      // July 4, 2011 @ 13:05 UTC
     */
    JulianDate.prototype.addMinutes = function(duration) {
        if (duration === null || isNaN(duration)) {
            throw new DeveloperError('duration is required and must be a number.');
        }
        var newSecondsOfDay = this._secondsOfDay + (duration * TimeConstants.SECONDS_PER_MINUTE);
        return new JulianDate(this._julianDayNumber, newSecondsOfDay, TimeStandard.TAI);
    };

    /**
     * Returns a new Julian date representing a time <code>duration</code> hours later
     * (or earlier in the case of a negative amount).
     *
     * @memberof JulianDate
     *
     * @param {Number} duration An integer number of hours to add or subtract.
     *
     * @return {JulianDate} A new Julian date object
     *
     * @exception {DeveloperError} duration is required and must be a number.
     *
     * @see JulianDate#addSeconds
     * @see JulianDate#addMinutes
     * @see JulianDate#addDays
     *
     * @example
     * var date = new Date();
     * date.setUTCFullYear(2011, 6, 4);     // July 4, 2011 @ 12:00 UTC
     * date.setUTCHours(12, 0, 0, 0);
     * var start = JulianDate.fromDate(date);
     * var end = start.addHours(6);         // July 4, 2011 @ 18:00 UTC
     */
    JulianDate.prototype.addHours = function(duration) {
        if (duration === null || isNaN(duration)) {
            throw new DeveloperError('duration is required and must be a number.');
        }
        var newSecondsOfDay = this._secondsOfDay + (duration * TimeConstants.SECONDS_PER_HOUR);
        return new JulianDate(this._julianDayNumber, newSecondsOfDay, TimeStandard.TAI);
    };

    /**
     * Returns a new Julian date representing a time <code>duration</code> days later
     * (or earlier in the case of a negative amount).
     *
     * @memberof JulianDate
     *
     * @param {Number} duration An integer number of days to add or subtract.
     *
     * @return {JulianDate} A new Julian date object
     *
     * @exception {DeveloperError} duration is required and must be a number.
     *
     * @see JulianDate#addSeconds
     * @see JulianDate#addMinutes
     * @see JulianDate#addHours
     *
     * @example
     * var date = new Date();
     * date.setUTCFullYear(2011, 6, 4);     // July 4, 2011 @ 12:00 UTC
     * date.setUTCHours(12, 0, 0, 0);
     * var start = JulianDate.fromDate(date);
     * var end = start.addDays(5);         // July 9, 2011 @ 12:00 UTC
     */
    JulianDate.prototype.addDays = function(duration) {
        if (duration === null || isNaN(duration)) {
            throw new DeveloperError('duration is required and must be a number.');
        }
        var newJulianDayNumber = this._julianDayNumber + duration;
        return new JulianDate(newJulianDayNumber, this._secondsOfDay, TimeStandard.TAI);
    };

    /**
     * Returns true if <code>other</code> occurs after this Julian date.
     *
     * @memberof JulianDate
     *
     * @param {JulianDate} other The Julian date to be compared.
     *
     * @return {Boolean} <code>true</code> if this JulianDate is chronologically earlier than <code>other</code>; otherwise, <code>false</code>.
     *
     * @see JulianDate#lessThanOrEquals
     * @see JulianDate#greaterThan
     * @see JulianDate#greaterThanOrEquals
     *
     * @example
     * var start = JulianDate.fromDate(new Date('July 6, 1991 12:00:00'));
     * var end = JulianDate.fromDate(new Date('July 6, 2011 12:01:00'));
     * start.lessThan(end);     // true
     */
    JulianDate.prototype.lessThan = function(other) {
        return JulianDate.compare(this, other) < 0;
    };

    /**
     * Returns true if <code>other</code> occurs at or after this Julian date.
     *
     * @memberof JulianDate
     *
     * @param {JulianDate} other The Julian date to be compared.
     *
     * @return {Boolean} <code>true</code> if this JulianDate is chronologically less than or equal to<code>other</code>; otherwise, <code>false</code>.
     *
     * @see JulianDate#lessThan
     * @see JulianDate#greaterThan
     * @see JulianDate#greaterThanOrEquals
     *
     * @example
     * var start = JulianDate.fromDate(new Date('July 6, 1991 12:00:00'));
     * var end = JulianDate.fromDate(new Date('July 6, 2011 12:00:00'));
     * start.lessThanOrEquals(end);     // true
     */
    JulianDate.prototype.lessThanOrEquals = function(other) {
        return JulianDate.compare(this, other) <= 0;
    };

    /**
     * Returns true if <code>other</code> occurs before this Julian date.
     *
     * @memberof JulianDate
     *
     * @param {JulianDate} other The Julian date to be compared.
     *
     * @return {Boolean} <code>true</code> if this JulianDate is chronologically later than <code>other</code>; otherwise, <code>false</code>.
     *
     * @see JulianDate#lessThan
     * @see JulianDate#lessThanOrEquals
     * @see JulianDate#greaterThanOrEquals
     *
     * @example
     * var start = JulianDate.fromDate(new Date('July 6, 1991 12:00:00'));
     * var end = JulianDate.fromDate(new Date('July 6, 2011 12:01:00'));
     * end.greaterThan(start);      // true
     */
    JulianDate.prototype.greaterThan = function(other) {
        return JulianDate.compare(this, other) > 0;
    };

    /**
     * Returns true if <code>other</code> occurs at or before this Julian date.
     *
     * @memberof JulianDate
     *
     * @param {JulianDate} other The Julian date to be compared.
     *
     * @return {Boolean} <code>true</code> if this JulianDate is chronologically later than or equal to <code>other</code>; otherwise, <code>false</code>.
     *
     * @see JulianDate#lessThan
     * @see JulianDate#lessThanOrEquals
     * @see JulianDate#greaterThan
     *
     * @example
     * var start = JulianDate.fromDate(new Date('July 6, 1991 12:00:00'));
     * var end = JulianDate.fromDate(new Date('July 6, 2011 12:00:00'));
     * end.greaterThanOrEquals(start);      // true
     */
    JulianDate.prototype.greaterThanOrEquals = function(other) {
        return JulianDate.compare(this, other) >= 0;
    };

    /**
     * Returns <code>true</code> if this date is equivalent to the specified date.
     *
     * @memberof JulianDate
     *
     * @param {JulianDate} other The JulianDate to be compared.
     * @param {Number} epsilon The number of seconds that should separate the two JulianDates
     *
     * @return {Boolean} <code>true</code> if the two JulianDates are equal; otherwise <code>false</code>.
     *
     * @see JulianDate#equalsEpsilon
     *
     * @example
     * var original = JulianDate.fromDate(new Date('July 4, 2011 12:00:00'));
     * var clone = JulianDate.fromDate(new Date('July 4, 2011 12:00:00'));
     * original.equals(clone);      // true
     */
    JulianDate.prototype.equals = function(other) {
        return JulianDate.compare(this, other) === 0;
    };

    /**
     * Returns <code>true</code> if this date is within <code>epsilon</code> seconds of the
     * specified date.  That is, in order for the dates to be considered equal (and for
     * this function to return <code>true</code>), the absolute value of the difference between them, in
     * seconds, must be less than <code>epsilon</code>.
     *
     * @memberof JulianDate
     *
     * @param {JulianDate} other The JulianDate to be compared.
     * @param {Number} epsilon The number of seconds that should separate the two JulianDates
     *
     * @return {Boolean} <code>true</code> if the two JulianDates are within <code>epsilon</code> seconds of each other; otherwise <code>false</code>.
     *
     * @exception {DeveloperError} epsilon is required and must be number.
     *
     * @see JulianDate#equals
     *
     * @example
     * var original = JulianDate.fromDate(new Date('July 4, 2011 12:00:00'));
     * var clone = JulianDate.fromDate(new Date('July 4, 2011 12:00:01'));
     * original.equalsEpsilon(clone, 2);    // true
     */
    JulianDate.prototype.equalsEpsilon = function(other, epsilon) {
        if (epsilon === null || isNaN(epsilon)) {
            throw new DeveloperError('epsilon is required and must be number.');
        }
        return Math.abs(this.getSecondsDifference(other)) <= epsilon;
    };

    //To avoid circular dependencies, we load the default list of leap seconds
    //here, rather than in the LeapSecond class itself.
    if (LeapSecond.getLeapSeconds().length === 0) {
        LeapSecond.setLeapSeconds([
                                   new LeapSecond(new JulianDate(2441317, 43210.0, TimeStandard.TAI), 10), // January 1, 1972 00:00:00 UTC
                                   new LeapSecond(new JulianDate(2441499, 43211.0, TimeStandard.TAI), 11), // July 1, 1972 00:00:00 UTC
                                   new LeapSecond(new JulianDate(2441683, 43212.0, TimeStandard.TAI), 12), // January 1, 1973 00:00:00 UTC
                                   new LeapSecond(new JulianDate(2442048, 43213.0, TimeStandard.TAI), 13), // January 1, 1974 00:00:00 UTC
                                   new LeapSecond(new JulianDate(2442413, 43214.0, TimeStandard.TAI), 14), // January 1, 1975 00:00:00 UTC
                                   new LeapSecond(new JulianDate(2442778, 43215.0, TimeStandard.TAI), 15), // January 1, 1976 00:00:00 UTC
                                   new LeapSecond(new JulianDate(2443144, 43216.0, TimeStandard.TAI), 16), // January 1, 1977 00:00:00 UTC
                                   new LeapSecond(new JulianDate(2443509, 43217.0, TimeStandard.TAI), 17), // January 1, 1978 00:00:00 UTC
                                   new LeapSecond(new JulianDate(2443874, 43218.0, TimeStandard.TAI), 18), // January 1, 1979 00:00:00 UTC
                                   new LeapSecond(new JulianDate(2444239, 43219.0, TimeStandard.TAI), 19), // January 1, 1980 00:00:00 UTC
                                   new LeapSecond(new JulianDate(2444786, 43220.0, TimeStandard.TAI), 20), // July 1, 1981 00:00:00 UTC
                                   new LeapSecond(new JulianDate(2445151, 43221.0, TimeStandard.TAI), 21), // July 1, 1982 00:00:00 UTC
                                   new LeapSecond(new JulianDate(2445516, 43222.0, TimeStandard.TAI), 22), // July 1, 1983 00:00:00 UTC
                                   new LeapSecond(new JulianDate(2446247, 43223.0, TimeStandard.TAI), 23), // July 1, 1985 00:00:00 UTC
                                   new LeapSecond(new JulianDate(2447161, 43224.0, TimeStandard.TAI), 24), // January 1, 1988 00:00:00 UTC
                                   new LeapSecond(new JulianDate(2447892, 43225.0, TimeStandard.TAI), 25), // January 1, 1990 00:00:00 UTC
                                   new LeapSecond(new JulianDate(2448257, 43226.0, TimeStandard.TAI), 26), // January 1, 1991 00:00:00 UTC
                                   new LeapSecond(new JulianDate(2448804, 43227.0, TimeStandard.TAI), 27), // July 1, 1992 00:00:00 UTC
                                   new LeapSecond(new JulianDate(2449169, 43228.0, TimeStandard.TAI), 28), // July 1, 1993 00:00:00 UTC
                                   new LeapSecond(new JulianDate(2449534, 43229.0, TimeStandard.TAI), 29), // July 1, 1994 00:00:00 UTC
                                   new LeapSecond(new JulianDate(2450083, 43230.0, TimeStandard.TAI), 30), // January 1, 1996 00:00:00 UTC
                                   new LeapSecond(new JulianDate(2450630, 43231.0, TimeStandard.TAI), 31), // July 1, 1997 00:00:00 UTC
                                   new LeapSecond(new JulianDate(2451179, 43232.0, TimeStandard.TAI), 32), // January 1, 1999 00:00:00 UTC
                                   new LeapSecond(new JulianDate(2453736, 43233.0, TimeStandard.TAI), 33), // January 1, 2006 00:00:00 UTC
                                   new LeapSecond(new JulianDate(2454832, 43234.0, TimeStandard.TAI), 34), // January 1, 2009 00:00:00 UTC
                                   new LeapSecond(new JulianDate(2456109, 43235.0, TimeStandard.TAI), 35)  // July 1, 2012 00:00:00 UTC
                                 ]);
    }

    return JulianDate;
});
/*global define*/
define('Core/CachePolicy',[
        './DeveloperError',
        './JulianDate'
    ], function(
        DeveloperError,
        JulianDate) {
    

    /**
     * Defines cache replacement policies.
     *
     * @exports CachePolicy
     *
     * @see Cache
     */
    var CachePolicy = {};

    /**
     * Least recently used cache replacement policy that replaces the least recently used
     * item from the cache first.
     *
     *
     * @param {Function} description.fetchFunc A function that given the key will return an object to store in the cache.
     * @param {Function} description.removeFunc A optional function that will be called when the object will be removed from the cache.
     * @param {Number} description.limit  The maximum number of objects that can be stored in the cache, defaults to 128.
     *
     * @exception {DeveloperError} description.fetchFunc is required.
     */
    CachePolicy.LRU = function(description) {
        var desc = description || {};

        if (!desc.fetchFunc || typeof desc.fetchFunc !== 'function') {
            throw new DeveloperError('description.fetchFunc is a required function.');
        }

        this._limit = desc.limit || 128;
        this._count = 0;
        this._fetchFunc = desc.fetchFunc;
        this._removeFunc = (typeof desc.removeFunc === 'function') ? desc.removeFunc : null;
    };

    /**
     * This function is called by the cache when an object is requested and is stored in the cache.
     * Updates the object as used recently.
     *
     * @param {Object} object The value stored in the cache that was requested by its key.
     */
    CachePolicy.LRU.prototype.hit = function(object) {
        object.lastHit = new JulianDate();
        return object.value;
    };

    /**
     * This function is called by the cache when an object is requested and is not stored in the cache.
     * Replaces the LRU object with the object returned by the fetch function given to the constructor.
     *
     * @param {String} name The string name used as a key into the hash.
     * @param {Object} key The object that was used as a key into the cache;
     * @param {Object} object An object used as a hash table. The key/value pairs are elements store in the cache.
     */
    CachePolicy.LRU.prototype.miss = function(name, key, object) {
        var property = {
            key : key,
            value : null,
            lastHit : null
        };

        property.value = this._fetchFunc(key);
        var lruTime = new JulianDate();
        property.lastHit = lruTime;

        if (this._count < this._limit) {
            ++this._count;
            object[name] = property;
            return property.value;
        }

        var element;
        var index = '';
        var keys = Object.keys(object);
        for ( var i = 0; i < keys.length; ++i) {
            element = object[keys[i]];
            if (element.lastHit.lessThan(lruTime)) {
                lruTime = element.lastHit;
                index = keys[i];
            }
        }
        element = object[index];
        if (this._removeFunc) {
            this._removeFunc(element.key);
        }
        delete object[index];

        object[name] = property;
        return property.value;
    };

    return CachePolicy;
});

/*global define*/
define('Core/Clock',[
        './DeveloperError',
        './JulianDate',
        './ClockStep',
        './ClockRange'
       ], function(
         DeveloperError,
         JulianDate,
         ClockStep,
         ClockRange) {
    

    /**
     * A simple clock for keeping track of simulated time.
     * @alias Clock
     * @constructor
     *
     * @param {Object} [template] The template object containing the properties to be set on the clock.
     * @exception {DeveloperError} startTime must come before stopTime.
     *
     * @see ClockStep
     * @see ClockRange
     * @see JulianDate
     * @see AnimationController
     *
     * @example
     * //Create a clock that loops on Christmas day 2012 and runs
     * //in real-time.  currentTime will default to startTime.
     * var clock = new Clock({
     *    startTime : JulianDate.fromIso8601("12-25-2012");
     *    stopTime : JulianDate.fromIso8601("12-26-2012");
     *    clockRange : ClockRange.LOOP;
     * });
     */
    var Clock = function(template) {
        var t = template;
        if (typeof t === 'undefined') {
            t = {};
        }

        var startTime = t.startTime;
        var startTimeUndefined = typeof startTime === 'undefined';

        var stopTime = t.stopTime;
        var stopTimeUndefined = typeof stopTime === 'undefined';

        var currentTime = t.currentTime;
        var currentTimeUndefined = typeof currentTime === 'undefined';

        if (startTimeUndefined && stopTimeUndefined && currentTimeUndefined) {
            currentTime = new JulianDate();
            startTime = currentTime.clone();
            stopTime = currentTime.addDays(1.0);
        } else if (startTimeUndefined && stopTimeUndefined) {
            startTime = currentTime.clone();
            stopTime = currentTime.addDays(1.0);
        } else if (startTimeUndefined && currentTimeUndefined) {
            startTime = stopTime.addDays(-1.0);
            currentTime = startTime.clone();
        } else if (currentTimeUndefined && stopTimeUndefined) {
            currentTime = startTime.clone();
            stopTime = startTime.addDays(1.0);
        } else if (currentTimeUndefined) {
            currentTime = startTime.clone();
        } else if (stopTimeUndefined) {
            stopTime = currentTime.addDays(1.0);
        } else if (startTimeUndefined) {
            startTime = currentTime.clone();
        }

        if (startTime.greaterThan(stopTime)) {
            throw new DeveloperError('startTime must come before stopTime.');
        }

        var multiplier = t.multiplier;
        if (typeof multiplier === 'undefined') {
            multiplier = 1.0;
        }

        var clockStep = t.clockStep;
        if (typeof clockStep === 'undefined') {
            clockStep = ClockStep.SYSTEM_CLOCK_DEPENDENT;
        }

        var clockRange = t.clockRange;
        if (typeof clockRange === 'undefined') {
            clockRange = ClockRange.UNBOUNDED;
        }

        /**
         * The start time of the clock.
         * @type JulianDate
         */
        this.startTime = startTime;

        /**
         * The stop time of the clock.
         * @type JulianDate
         */
        this.stopTime = stopTime;

        /**
         * The current time.
         * @type JulianDate
         */
        this.currentTime = currentTime;

        /**
         * Determines how much time advances when tick is called, negative values allow for advancing backwards.
         * If <code>clockStep</code> is set to ClockStep.TICK_DEPENDENT this is the number of seconds to advance.
         * If <code>clockStep</code> is set to ClockStep.SYSTEM_CLOCK_DEPENDENT this value is multiplied by the
         * elapsed system time since the last call to tick.
         * @type Number
         */
        this.multiplier = multiplier;

        /**
         * Determines if calls to <code>tick</code> are frame dependent or system clock dependent.
         * @type ClockStep
         */
        this.clockStep = clockStep;

        /**
         * Determines how tick should behave when <code>startTime</code> or <code>stopTime</code> is reached.
         * @type ClockRange
         */
        this.clockRange = clockRange;

        this._lastCpuTime = new Date().getTime();
    };

    /**
     * Advances the clock from the currentTime based on the current configuration options.
     * @memberof Clock
     *
     * @param {Number} [secondsToTick] optional parameter to force the clock to tick the provided number of seconds,
     * regardless of the value of <code>clockStep</code> and <code>multiplier</code>.
     * @returns {JulianDate} The new value of the <code>currentTime</code> property.
     */
    Clock.prototype.tick = function(secondsToTick) {
        return this._tick(secondsToTick, this.multiplier);
    };

    /**
     * Advances the clock in the opposite direction of the current <code>multiplier</code>.
     * If <code>multiplier</code> is positive this will advance the clock backwards one tick.
     * If <code>multiplier</code> is negative this will advance the clock forward one tick.
     * @memberof Clock
     *
     * @returns {JulianDate} The new value of Clock.currentTime
     */
    Clock.prototype.reverseTick = function() {
        return this._tick(undefined, -this.multiplier);
    };

    Clock.prototype._tick = function(secondsToTick, multiplier) {
        var startTime = this.startTime;
        var stopTime = this.stopTime;
        var currentTime = this.currentTime;
        var currentCpuTime = new Date().getTime();

        if (typeof secondsToTick === 'undefined') {
            if (this.clockStep === ClockStep.TICK_DEPENDENT) {
                currentTime = currentTime.addSeconds(multiplier);
            } else {
                var milliseconds = currentCpuTime - this._lastCpuTime;
                currentTime = currentTime.addSeconds(multiplier * (milliseconds / 1000.0));
            }
        } else {
            currentTime = currentTime.addSeconds(secondsToTick);
        }

        if (this.clockRange === ClockRange.CLAMPED) {
            if (currentTime.lessThan(startTime)) {
                currentTime = startTime;
            } else if (currentTime.greaterThan(stopTime)) {
                currentTime = stopTime;
            }
        } else if (this.clockRange === ClockRange.LOOP) {
            while (currentTime.lessThan(startTime)) {
                currentTime = stopTime.addSeconds(startTime.getSecondsDifference(currentTime));
            }
            while (currentTime.greaterThan(stopTime)) {
                currentTime = startTime.addSeconds(stopTime.getSecondsDifference(currentTime));
            }
        }

        this.currentTime = currentTime;
        this._lastCpuTime = currentCpuTime;
        return currentTime;
    };

    return Clock;
});
/*global define*/
define('Core/EventHandler',[
        './DeveloperError',
        './destroyObject',
        './Cartesian2',
        './JulianDate',
        './MouseEventType',
        './EventModifier'
    ], function(
        DeveloperError,
        destroyObject,
        Cartesian2,
        JulianDate,
        MouseEventType,
        EventModifier) {
    

    /**
     * Handles user input events. Custom functions can be added to be executed on
     * when the user enters input.
     *
     * @alias EventHandler
     *
     * @param {DOC_TBA} element The element to add events to. Defaults to document.
     * @constructor
     */
    var EventHandler = function(element) {
        this._mouseEvents = {};
        for ( var button in MouseEventType) {
            if (MouseEventType.hasOwnProperty(button)) {
                this._mouseEvents[button] = 0;
            }
        }

        this._modifiedMouseEvents = {};
        for ( var modifier in EventModifier) {
            if (EventModifier.hasOwnProperty(modifier)) {
                this._modifiedMouseEvents[modifier] = {};
                for (button in MouseEventType) {
                    if (MouseEventType.hasOwnProperty(button)) {
                        this._modifiedMouseEvents[modifier][button] = 0;
                    }
                }
            }
        }

        this._leftMouseButtonDown = false;
        this._middleMouseButtonDown = false;
        this._rightMouseButtonDown = false;
        this._seenAnyTouchEvents = false;
        this._lastMouseX = 0;
        this._lastMouseY = 0;
        this._totalPixels = 0;

        // TODO: Revisit when doing mobile development. May need to be configurable
        // or determined based on the platform?
        this._clickPixelTolerance = 5;

        this._element = element || document;

        this._register();
    };

    EventHandler.prototype._getPosition = function(event) {
        if (this._element === document) {
            return {
                x : event.clientX,
                y : event.clientY
            };
        }

        var rect = this._element.getBoundingClientRect();
        return {
            x : event.clientX - rect.left,
            y : event.clientY - rect.top
        };
    };

    /**
     * Set a function to be executed on a mouse event.
     *
     * @memberof EventHandler
     *
     * @param {Function} action Function to be executed when the mouse event occurs.
     * @param {Enumeration} type The MouseEventType of mouse event.
     * @param {Enumeration} modifier A EventModifier key that is held when a <code>type</code>
     * event occurs.
     *
     * @exception {DeveloperError} action is required.
     * @exception {DeveloperError} type is required.
     *
     * @see EventHandler#getMouseAction
     * @see EventHandler#removeMouseAction
     */
    EventHandler.prototype.setMouseAction = function(action, type, modifier) {
        if (!action) {
            throw new DeveloperError('action is required.');
        }

        if (!type) {
            throw new DeveloperError('type is required.');
        }

        var mouseEvents;
        if (modifier && modifier.name) {
            mouseEvents = this._modifiedMouseEvents[modifier.name];
        } else {
            mouseEvents = this._mouseEvents;
        }

        if (type && type.name && mouseEvents) {
            mouseEvents[type.name] = action;
        }
    };

    /**
     * Returns the function to be executed on a mouse event.
     *
     * @memberof EventHandler
     *
     * @param {Enumeration} type The MouseEventType of mouse event.
     * @param {Enumeration} modifier A EventModifier key that is held when a <code>type</code>
     * event occurs.
     *
     * @exception {DeveloperError} type is required.
     *
     * @see EventHandler#setMouseAction
     * @see EventHandler#removeMouseAction
     */
    EventHandler.prototype.getMouseAction = function(type, modifier) {
        if (!type) {
            throw new DeveloperError('type is required.');
        }

        var mouseEvents;
        if (modifier && modifier.name) {
            mouseEvents = this._modifiedMouseEvents[modifier.name];
        } else {
            mouseEvents = this._mouseEvents;
        }

        if (type && type.name && mouseEvents) {
            return mouseEvents[type.name];
        }

        return undefined;
    };

    /**
     * Removes the function to be executed on a mouse event.
     *
     * @memberof EventHandler
     *
     * @param {Enumeration} type The MouseEventType of mouse event.
     * @param {Enumeration} modifier A EventModifier key that is held when a <code>type</code>
     * event occurs.
     *
     * @exception {DeveloperError} type is required.
     *
     * @see EventHandler#getMouseAction
     * @see EventHandler#setMouseAction
     */
    EventHandler.prototype.removeMouseAction = function(type, modifier) {
        if (!type) {
            throw new DeveloperError('type is required.');
        }

        var mouseEvents;
        if (modifier && modifier.name) {
            mouseEvents = this._modifiedMouseEvents[modifier.name];
        } else {
            mouseEvents = this._mouseEvents;
        }

        if (type && type.name && mouseEvents && mouseEvents[type.name]) {
            delete mouseEvents[type.name];
        }
    };

    EventHandler.prototype._getModifier = function(event) {
        if (event.shiftKey) {
            return EventModifier.SHIFT;
        } else if (event.ctrlKey) {
            return EventModifier.CTRL;
        } else if (event.altKey) {
            return EventModifier.ALT;
        }

        return undefined;
    };

    EventHandler.prototype._handleMouseDown = function(event) {
        var pos = this._getPosition(event);
        this._lastMouseX = pos.x;
        this._lastMouseY = pos.y;
        this._totalPixels = 0;
        if (this._seenAnyTouchEvents) {
            return;
        }

        var modifier = this._getModifier(event);
        var action;

        // IE_TODO:  On some versions of IE, the left-button is 1, and the right-button is 4.
        // See: http://www.unixpapa.com/js/mouse.html
        // This is not the case in Chrome Frame, so we are OK for now, but are there
        // constants somewhere?
        if (event.button === 0) {
            this._leftMouseButtonDown = true;
            action = this.getMouseAction(MouseEventType.LEFT_DOWN, modifier);
        } else if (event.button === 1) {
            this._middleMouseButtonDown = true;
            action = this.getMouseAction(MouseEventType.MIDDLE_DOWN, modifier);
        } else if (event.button === 2) {
            this._rightMouseButtonDown = true;
            action = this.getMouseAction(MouseEventType.RIGHT_DOWN, modifier);
        }

        if (action) {
            action({
                position : new Cartesian2(pos.x, pos.y)
            });
        }
        event.preventDefault();
    };

    EventHandler.prototype._handleMouseUp = function(event) {
        var modifier = this._getModifier(event);
        var action, clickAction;
        if (this._seenAnyTouchEvents) {
            return;
        }

        // IE_TODO:  On some versions of IE, the left-button is 1, and the right-button is 4.
        // See: http://www.unixpapa.com/js/mouse.html
        // This is not the case in Chrome Frame, so we are OK for now, but are there
        // constants somewhere?
        if (event.button === 0) {
            this._leftMouseButtonDown = false;
            action = this.getMouseAction(MouseEventType.LEFT_UP, modifier);
            clickAction = this.getMouseAction(MouseEventType.LEFT_CLICK, modifier);
        } else if (event.button === 1) {
            this._middleMouseButtonDown = false;
            action = this.getMouseAction(MouseEventType.MIDDLE_UP, modifier);
            clickAction = this.getMouseAction(MouseEventType.MIDDLE_CLICK, modifier);
        } else if (event.button === 2) {
            this._rightMouseButtonDown = false;
            action = this.getMouseAction(MouseEventType.RIGHT_UP, modifier);
            clickAction = this.getMouseAction(MouseEventType.RIGHT_CLICK, modifier);
        }

        var pos = this._getPosition(event);

        var xDiff = this._lastMouseX - pos.x;
        var yDiff = this._lastMouseY - pos.y;
        this._totalPixels += Math.sqrt(xDiff * xDiff + yDiff * yDiff);

        if (action) {
            action({
                position : new Cartesian2(pos.x, pos.y)
            });
        }

        if (clickAction && this._totalPixels < this._clickPixelTolerance) {
            clickAction({
                position : new Cartesian2(pos.x, pos.y)
            });
        }
    };

    EventHandler.prototype._handleMouseMove = function(event) {
        var pos = this._getPosition(event);
        if (this._seenAnyTouchEvents) {
            return;
        }

        var xDiff = this._lastMouseX - pos.x;
        var yDiff = this._lastMouseY - pos.y;
        this._totalPixels += Math.sqrt(xDiff * xDiff + yDiff * yDiff);

        var movement = {
            startPosition : new Cartesian2(this._lastMouseX, this._lastMouseY),
            endPosition : new Cartesian2(pos.x, pos.y),
            motion : new Cartesian2(0.0, 0.0)
        };

        var modifier = this._getModifier(event);
        var action = this.getMouseAction(MouseEventType.MOVE, modifier);
        if (action) {
            action(movement);
        }

        this._lastMouseX = movement.endPosition.x;
        this._lastMouseY = movement.endPosition.y;

        if (this._leftMouseButtonDown || this._middleMouseButtonDown || this._rightMouseButtonDown) {
            event.preventDefault();
        }
    };

    EventHandler.prototype._handleTouchStart = function(event) {
        var pos, numberOfTouches = event.touches.length;
        this._seenAnyTouchEvents = true;

        if (numberOfTouches === 1) {
            pos = this._getPosition(event.touches[0]);
            this._lastMouseX = pos.x;
            this._lastMouseY = pos.y;
            this._totalPixels = 0;

            var modifier = this._getModifier(event);
            var action;

            this._leftMouseButtonDown = true;
            action = this.getMouseAction(MouseEventType.LEFT_DOWN, modifier);

            if (action) {
                action({
                    position : new Cartesian2(pos.x, pos.y)
                });
            }
            event.preventDefault();
        } else if (this._leftMouseButtonDown) {
            this._handleTouchEnd(event);
        }
    };

    EventHandler.prototype._handleTouchEnd = function(event) {
        var numberOfTouches = event.touches.length;
        var numberOfTargetTouches = event.targetTouches.length;
        var modifier = this._getModifier(event);
        var action, clickAction;

        if (this._leftMouseButtonDown) {
            this._leftMouseButtonDown = false;
            action = this.getMouseAction(MouseEventType.LEFT_UP, modifier);
            clickAction = this.getMouseAction(MouseEventType.LEFT_CLICK, modifier);
        }

        if (numberOfTargetTouches > 0) {
            var pos = this._getPosition(event.targetTouches[0]);

            var xDiff = this._lastMouseX - pos.x;
            var yDiff = this._lastMouseY - pos.y;
            this._totalPixels += Math.sqrt(xDiff * xDiff + yDiff * yDiff);

            if (action) {
                action({
                    position : new Cartesian2(pos.x, pos.y)
                });
            }

            if (clickAction && this._totalPixels < this._clickPixelTolerance) {
                clickAction({
                    position : new Cartesian2(pos.x, pos.y)
                });
            }
        }

        if (numberOfTouches === 1) {
            this._handleTouchStart(event);
        }
    };

    EventHandler.prototype._handleTouchMove = function(event) {
        if (this._leftMouseButtonDown && (event.touches.length === 1)) {
            var pos = this._getPosition(event.touches[0]);

            var xDiff = this._lastMouseX - pos.x;
            var yDiff = this._lastMouseY - pos.y;
            this._totalPixels += Math.sqrt(xDiff * xDiff + yDiff * yDiff);

            var movement = {
                startPosition : new Cartesian2(this._lastMouseX, this._lastMouseY),
                endPosition : new Cartesian2(pos.x, pos.y),
                motion : new Cartesian2(0.0, 0.0)
            };

            var modifier = this._getModifier(event);
            var action = this.getMouseAction(MouseEventType.MOVE, modifier);
            if (action) {
                action(movement);
            }

            this._lastMouseX = movement.endPosition.x;
            this._lastMouseY = movement.endPosition.y;

            if (this._leftMouseButtonDown || this._middleMouseButtonDown || this._rightMouseButtonDown) {
                event.preventDefault();
            }
        }
    };

    EventHandler.prototype._handleMouseWheel = function(event) {
        // Some browsers use event.detail to count the number of clicks. The sign
        // of the integer is the direction the wheel is scrolled. In that case, convert
        // to the angle it was rotated in degrees.
        var delta = event.detail ? event.detail * -120 : event.wheelDelta;

        var modifier = this._getModifier(event);
        var type = MouseEventType.WHEEL;
        var action = this.getMouseAction(type, modifier);

        if (action) {
            event.preventDefault();
            action(delta);
        }
    };

    EventHandler.prototype._handleMouseDblClick = function(event) {
        var modifier = this._getModifier(event);
        var action;
        var pos = this._getPosition(event);

        // IE_TODO:  On some versions of IE, the left-button is 1, and the right-button is 4.
        // See: http://www.unixpapa.com/js/mouse.html
        // This is not the case in Chrome Frame, so we are OK for now, but are there
        // constants somewhere?
        if (event.button === 0) {
            action = this.getMouseAction(MouseEventType.LEFT_DOUBLE_CLICK, modifier);
        } else if (event.button === 1) {
            action = this.getMouseAction(MouseEventType.MIDDLE_DOUBLE_CLICK, modifier);
        } else if (event.button === 2) {
            action = this.getMouseAction(MouseEventType.RIGHT_DOUBLE_CLICK, modifier);
        }

        if (action) {
            action({
                position : new Cartesian2(pos.x, pos.y)
            });
        }
    };

    EventHandler.prototype._register = function() {
        var that = this, useDoc = true;

        this._callbacks = [];
        if (typeof this._element.disableRootEvents !== 'undefined') {
            useDoc = false;
        }

        this._callbacks.push({
            name : 'mousedown',
            onDoc : false,
            action : function(e) {
                that._handleMouseDown(e);
            }
        });
        this._callbacks.push({
            name : 'mouseup',
            onDoc : useDoc,
            action : function(e) {
                that._handleMouseUp(e);
            }
        });
        this._callbacks.push({
            name : 'mousemove',
            onDoc : useDoc,
            action : function(e) {
                that._handleMouseMove(e);
            }
        });
        this._callbacks.push({
            name : 'dblclick',
            onDoc : false,
            action : function(e) {
                that._handleMouseDblClick(e);
            }
        });
        this._callbacks.push({
            name : 'touchstart',
            onDoc : false,
            action : function(e) {
                that._handleTouchStart(e);
            }
        });
        this._callbacks.push({
            name : 'touchend',
            onDoc : useDoc,
            action : function(e) {
                that._handleTouchEnd(e);
            }
        });
        this._callbacks.push({
            name : 'touchmove',
            onDoc : useDoc,
            action : function(e) {
                that._handleTouchMove(e);
            }
        });

        // Firefox calls the mouse wheel event 'DOMMouseScroll', all others use 'mousewheel'
        this._callbacks.push({
            name : 'mousewheel',
            onDoc : false,
            action : function(e) {
                that._handleMouseWheel(e);
            }
        });
        this._callbacks.push({
            name : 'DOMMouseScroll',
            onDoc : false,
            action : function(e) {
                that._handleMouseWheel(e);
            }
        });

        for ( var i = 0; i < this._callbacks.length; i++) {
            var cback = this._callbacks[i];
            if (cback.onDoc) {
                document.addEventListener(cback.name, cback.action, false);
            } else {
                this._element.addEventListener(cback.name, cback.action, false);
            }
        }
    };

    EventHandler.prototype._unregister = function() {
        for ( var i = 0; i < this._callbacks.length; i++) {
            var cback = this._callbacks[i];
            if (cback.onDoc) {
                document.removeEventListener(cback.name, cback.action, false);
            } else {
                this._element.removeEventListener(cback.name, cback.action, false);
            }
        }
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof EventHandler
     *
     * @return {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     *
     * @see EventHandler#destroy
     */
    EventHandler.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Removes mouse listeners held by this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof EventHandler
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see EventHandler#isDestroyed
     *
     * @example
     * handler = handler && handler.destroy();
     */
    EventHandler.prototype.destroy = function() {
        this._unregister();
        return destroyObject(this);
    };

    return EventHandler;
});

/*global define*/
define('Core/SunPosition',[
        './Math',
        './Cartesian3',
        './Cartographic',
        './Matrix3',
        './JulianDate'
    ],
    function(
        CesiumMath,
        Cartesian3,
        Cartographic,
        Matrix3,
        JulianDate) {
    

    /**
     * DOC_TBA.
     *
     * @exports SunPosition
     */
    var SunPosition = {
        /**
         * Computes the approximate sun position, in the WGS84 coordinate system (Earth's fixed frame), for a given julian date.
         *
         * @param {JulianDate} [julianDate] The julian date to compute the sun's position for.
         *
         * @example
         * // Compute the current sun position
         * var position = SunPosition.compute().position;
         */
        compute : function(julianDate) {
            julianDate = julianDate || new JulianDate();

            var AU_TO_METERS = 149597870700.0;

            function isLeapYear(year) {
                return ((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0);
            }

            function toGregorianDate(julianDate) {
                var j = julianDate + 32044;
                var g = Math.floor(j / 146097);
                var dg = j - Math.floor(j / 146097) * 146097;
                var c = Math.floor((Math.floor(dg / 36524 + 1) * 3) / 4);
                var dc = dg - c * 36524;
                var b = Math.floor(dc / 1461);
                var db = dc - Math.floor(dc / 1461) * 1461;
                var a = Math.floor((Math.floor(db / 365 + 1) * 3) / 4);
                var da = db - a * 365;
                var y = g * 400 + c * 100 + b * 4 + a;
                var m = Math.floor((da * 5 + 308) / 153) - 2;
                var d = da - Math.floor(((m + 4) * 153) / 5) + 122;
                var year = y - 4800 + Math.floor((m + 2) / 12);
                var month = (m + 2) - Math.floor((m + 2) / 12) * 12 + 1;
                var day = Math.floor(d + 1.5);
                return {
                    month : month,
                    day : day,
                    year : year
                };
            }

            var T = (julianDate.getTotalDays() - 2451545.0) / 36525;
            var meanAnomaly = CesiumMath.convertLongitudeRange(CesiumMath.toRadians(357.5277233 + 35999.05034 * T));
            var distanceToSunInAU = 1.000140612 - 0.016708617 * Math.cos(meanAnomaly) - 0.000139589 * Math.cos(2 * meanAnomaly);

            var date = toGregorianDate(julianDate.getTotalDays());
            var dayNumber = 0;
            switch (date.month) {
            case 1:
                dayNumber = date.day;
                break;
            case 2:
                dayNumber = date.day + 31;
                break;
            case 3:
                dayNumber = date.day + 59;
                break;
            case 4:
                dayNumber = date.day + 90;
                break;
            case 5:
                dayNumber = date.day + 120;
                break;
            case 6:
                dayNumber = date.day + 151;
                break;
            case 7:
                dayNumber = date.day + 181;
                break;
            case 8:
                dayNumber = date.day + 212;
                break;
            case 9:
                dayNumber = date.day + 243;
                break;
            case 10:
                dayNumber = date.day + 273;
                break;
            case 11:
                dayNumber = date.day + 304;
                break;
            case 12:
                dayNumber = date.day + 334;
                break;
            }

            if (isLeapYear(date.year) && date.month > 2) {
                dayNumber++;
            }

            var temp = CesiumMath.toRadians((360.0 / 365.0) * (dayNumber - 81.0));
            var equationOfTime = 9.87 * Math.sin(2 * temp) - 7.53 * Math.cos(temp) - 1.5 * Math.sin(temp);
            var timeFraction = julianDate.getJulianTimeFraction();
            var localTime;
            if (timeFraction >= 0.5) {
                localTime = timeFraction * 24.0 - 12.0;
            } else {
                localTime = 12.0 + timeFraction * 24.0;
            }
            var localSolarTime = localTime + (equationOfTime / 60.0);
            var hourAngle = CesiumMath.toRadians(15.0 * (12.0 - localSolarTime));
            var declinationAngle = Math.asin(0.39795 * Math.cos(CesiumMath.toRadians(0.98563 * (dayNumber - 173.0))));
            var x = Math.cos(declinationAngle) * Math.cos(hourAngle);
            var y = Math.cos(declinationAngle) * Math.sin(hourAngle);
            var z = Math.sin(declinationAngle);
            var latitudeAngle = 0.0;

            var transform = new Matrix3(
                    Math.cos(latitudeAngle),        0.0, Math.sin(latitudeAngle),
                    0.0,                            1.0, 0.0,
                    -1.0 * Math.sin(latitudeAngle), 0.0, Math.cos(latitudeAngle));

            var direction = transform.multiplyByVector(new Cartesian3(x, y, z));
            var distance = distanceToSunInAU * AU_TO_METERS;

            /**
             * DOC_TBA
             */
            return {
                /**
                 * The approximate coordinates of the sun's position in the earth's fixed frame.
                 *
                 * @type Cartesian3
                 */
                position : direction.multiplyByScalar(distance),

                /**
                 * The cartographic position, in radians, of the sun's position projected onto Earth.  This is accurate to within less than a degree of the true position.
                 *
                 * @type Cartographic
                 */
                cartographicPosition : new Cartographic(hourAngle, declinationAngle, 0.0),

                /**
                 * Returns a unit vector, in Earth's fixed frame, pointing to the sun.
                 *
                 * @type Cartesian3
                 */
                direction : direction,

                /**
                 * The approximate distance from the center of the Earth to the center of the Sun in meters.
                 *
                 * @type Number
                 */
                distance : distance
            };
        }
    };

    return SunPosition;
});

/*global define*/
define('Core/TimeInterval',[
        './JulianDate',
        './TimeStandard',
        './DeveloperError'
    ], function(
        JulianDate,
        TimeStandard,
        DeveloperError) {
    

    /**
     * An interval defined by a start date and a stop date.  The end points are optionally included
     * in the interval.  The interval should be treated as immutable.
     *
     * @alias TimeInterval
     * @constructor
     *
     * @param {JulianDate} start The start date of the interval.
     * @param {JulianDate} stop The stop date of the interval.
     * @param {Boolean} [isStartIncluded=true] <code>true</code> if the start date is included in the interval, <code>false</code> otherwise.
     * @param {Boolean} [isStopIncluded=true] <code>true</code> if the stop date is included in the interval, <code>false</code> otherwise.
     * @param {Object} [data The data associated with this interval.
     *
     * @exception {DeveloperError} start must be specified.
     * @exception {DeveloperError} stop must be specified.
     *
     * @see TimeInterval.fromIso8601
     * @see TimeIntervalCollection
     * @see JulianDate
     *
     * @example
     * // Construct an Timeinterval closed on one end with a Color payload.
     * var interval = new TimeInterval(JulianDate.fromTotalDays(1000), JulianDate.fromTotalDays(1001), true, false, Color.WHITE);
     */
    var TimeInterval = function(start, stop, isStartIncluded, isStopIncluded, data) {
        if (typeof start === 'undefined') {
            throw new DeveloperError('start must be specified.');
        }

        if (typeof stop === 'undefined') {
            throw new DeveloperError('stop must be specified.');
        }

        if (typeof isStartIncluded === 'undefined') {
            isStartIncluded = true;
        }

        if (typeof isStopIncluded === 'undefined') {
            isStopIncluded = true;
        }

        var stopComparedToStart = JulianDate.compare(stop, start);

        /**
         * The start time of the interval.
         */
        this.start = start;
        /**
         * The stop time of the interval.
         */
        this.stop = stop;
        /**
         * The data associated with this interval.
         */
        this.data = data;
        /**
         * Indicates if <code>start</code> is included in the interval or not.
         */
        this.isStartIncluded = isStartIncluded;
        /**
         * Indicates if <code>stop</code> is included in the interval or not.
         */
        this.isStopIncluded = isStopIncluded;
        /**
         * Indicates if the interval is empty.
         */
        this.isEmpty = stopComparedToStart < 0 || (stopComparedToStart === 0 && (!isStartIncluded || !isStopIncluded));
    };

    /**
     * Creates an immutable TimeInterval from an ISO 8601 interval string.
     *
     * @memberof TimeInterval
     *
     * @param {String} iso8601String A valid ISO8601 interval.
     * @param {Boolean} [isStartIncluded=true] <code>true</code> if the start date is included in the interval, <code>false</code> otherwise.
     * @param {Boolean} [isStopIncluded=true] <code>true</code> if the stop date is included in the interval, <code>false</code> otherwise.
     * @param {Object} [data] The data associated with this interval.
     *
     * @return {TimeInterval} The new {@Link TimeInterval} instance or <code>undefined</code> if an invalid ISO8601 string is provided.
     *
     * @see TimeInterval
     * @see TimeIntervalCollection
     * @see JulianDate
     * @see <a href='http://en.wikipedia.org/wiki/ISO_8601'>ISO 8601 on Wikipedia</a>.
     *
     * @example
     * // Construct an open Timeinterval with a Cartesian data payload.
     * var interval = TimeInterval.fromIso8601('2012-03-15T11:02:24.55Z/2012-03-15T12:28:24.03Z', false, false, new Cartesian3(1,2,3));
     */
    TimeInterval.fromIso8601 = function(iso8601String, isStartIncluded, isStopIncluded, data) {
        var iso8601Interval = iso8601String.split('/');
        var intervalStart = JulianDate.fromIso8601(iso8601Interval[0]);
        var intervalStop = JulianDate.fromIso8601(iso8601Interval[1]);
        return new TimeInterval(intervalStart, intervalStop, isStartIncluded, isStopIncluded, data);
    };

    /**
     * Creates a copy of this TimeInterval.
     *
     * @returns A new TimeInterval that is equal to this interval.
     *
     * @memberof TimeInterval
     */
    TimeInterval.prototype.clone = function() {
        return new TimeInterval(this.start, this.stop, this.isStartIncluded, this.isStopIncluded, this.data);
    };

    /**
     * An empty interval.
     *
     * @memberof TimeInterval
     *
     */
    TimeInterval.EMPTY = Object.freeze(new TimeInterval(new JulianDate(0, 0, TimeStandard.TAI), new JulianDate(0, 0, TimeStandard.TAI), false, false));

    /**
     * Computes an interval which is the intersection of this interval with another while
     * also providing a means to merge the data of the two intervals.
     *
     * @param {TimeInterval} other The interval to intersect with this interval.
     * @param {Function} [mergeCallback] A callback which takes the data property from
     * both intervals as input and merges it into a single new value. If the callback is undefined,
     * this will intersect the two intervals and return the new interval with the data from this
     * interval.
     *
     * @return {TimeInterval} The new {@Link TimeInterval} that is the intersection of the two intervals,
     * with its data representing the merge of the data in the two existing intervals.
     */
    TimeInterval.prototype.intersect = function(other, mergeCallback) {
        if (typeof other === 'undefined') {
            return TimeInterval.EMPTY;
        }

        var otherStart = other.start;
        var otherStop = other.stop;
        var otherIsStartIncluded = other.isStartIncluded;
        var otherIsStopIncluded = other.isStopIncluded;

        var thisStart = this.start;
        var thisStop = this.stop;
        var thisIsStartIncluded = this.isStartIncluded;
        var thisIsStopIncluded = this.isStopIncluded;

        var outputData;
        var isStartIncluded;
        var isStopIncluded;

        if (otherStart.greaterThanOrEquals(thisStart) && thisStop.greaterThanOrEquals(otherStart)) {

            isStartIncluded = (!otherStart.equals(thisStart) && otherIsStartIncluded) || (thisIsStartIncluded && otherIsStartIncluded);

            isStopIncluded = thisIsStopIncluded && otherIsStopIncluded;

            outputData = typeof mergeCallback !== 'undefined' ? mergeCallback(this.data, other.data) : this.data;

            if (thisStop.greaterThanOrEquals(otherStop)) {
                isStopIncluded = isStopIncluded || (!otherStop.equals(thisStop) && otherIsStopIncluded);
                return new TimeInterval(otherStart, otherStop, isStartIncluded, isStopIncluded, outputData);
            }

            isStopIncluded = isStopIncluded || thisIsStopIncluded;
            return new TimeInterval(otherStart, thisStop, isStartIncluded, isStopIncluded, outputData);
        }

        if (otherStart.lessThanOrEquals(thisStart) && thisStart.lessThanOrEquals(otherStop)) {

            isStartIncluded = (otherStart.equals(thisStart) === false && thisIsStartIncluded) || (thisIsStartIncluded && otherIsStartIncluded);

            isStopIncluded = thisIsStopIncluded && otherIsStopIncluded;

            outputData = typeof mergeCallback !== 'undefined' ? mergeCallback(this.data, other.data) : this.data;
            if (thisStop.greaterThanOrEquals(otherStop)) {
                isStopIncluded = isStopIncluded || (otherStop.equals(thisStop) === false && otherIsStopIncluded);
                return new TimeInterval(thisStart, otherStop, isStartIncluded, isStopIncluded, outputData);
            }

            isStopIncluded = isStopIncluded || thisIsStopIncluded;
            return new TimeInterval(thisStart, thisStop, isStartIncluded, isStopIncluded, outputData);
        }

        return TimeInterval.EMPTY;
    };

    /**
     * Returns <code>true</code> if this interval contains the specified date.
     *
     * @memberof TimeInterval
     *
     * @param {JulianDate} date The date to check for.
     *
     * @return {Boolean} <code>true</code> if the TimeInterval contains the specified date, <code>false</code> otherwise.
     */
    TimeInterval.prototype.contains = function(date) {
        if (this.isEmpty) {
            return false;
        }

        var startComparedToDate = JulianDate.compare(this.start, date);
        // if (start == date)
        if (startComparedToDate === 0) {
            return this.isStartIncluded;
        }

        var dateComparedToStop = JulianDate.compare(date, this.stop);
        // if (date == stop)
        if (dateComparedToStop === 0) {
            return this.isStopIncluded;
        }

        // return start < date && date < stop
        return startComparedToDate < 0 && dateComparedToStop < 0;
    };

    /**
     * Returns true if this TimeInterval equals <code>other</code> componentwise.
     *
     * @memberof TimeInterval
     * @param {TimeInterval} other The TimeInterval to compare for equality.
     * @return {Boolean} <code>true</code> if the TimeIntervals are equal componentwise, <code>false</code> otherwise.
     */
    TimeInterval.prototype.equals = function(other) {
        return typeof other !== 'undefined' &&
               ((this.isEmpty && other.isEmpty) ||
                (this.isStartIncluded === other.isStartIncluded &&
                this.isStopIncluded === other.isStopIncluded &&
                this.start.equals(other.start) &&
                this.stop.equals(other.stop)));
    };

    /**
     * Returns <code>true</code> if this TimeInterval equals other componentwise
     * within the specified epsilon.
     *
     * @memberof TimeInterval
     *
     * @param {TimeInterval} other The TimeInterval to compare for equality.
     * @param {Number} [epsilon=0.0] The epsilon to use for equality testing.
     *
     * @return {Boolean} <code>true</code> if the TimeIntervals are equal within the specified epsilon, <code>false</code> otherwise.
     */
    TimeInterval.prototype.equalsEpsilon = function(other, epsilon) {
        return typeof other !== 'undefined' &&
               ((this.isEmpty && other.isEmpty) ||
                (this.isStartIncluded === other.isStartIncluded &&
                 this.isStopIncluded === other.isStopIncluded &&
                 this.start.equalsEpsilon(other.start, epsilon) &&
                 this.stop.equalsEpsilon(other.stop, epsilon)));
    };

    return TimeInterval;
});

/*global define*/
define('Core/Iso8601',['./JulianDate',
        './TimeInterval'
       ], function(
       JulianDate,
       TimeInterval) {
    

    var MINIMUM_VALUE = Object.freeze(JulianDate.fromDate(new Date(Date.UTC(-1, 0, 1, 0, 0, 0))));
    var MAXIMUM_VALUE = Object.freeze(JulianDate.fromDate(new Date(Date.UTC(10000, 0, 1, 0, 0, 0))));

    /**
     * Constants related to ISO8601 support.
     * @exports Iso8601
     *
     * @see <a href='http://en.wikipedia.org/wiki/ISO_8601'>ISO 8601 on Wikipedia</a>.
     * @see JulianDate
     * @see TimeInterval
     */
    var Iso8601 = {

        /**
         * A {@link JulianDate} representing the earliest time representable by an ISO8601 date.
         * This is equivalent to the date string '0000-01-01T00:00:00Z'
         */
        MINIMUM_VALUE : MINIMUM_VALUE,

        /**
         * A {@link JulianDate} representing the latest time representable by an ISO8601 date.
         * This is equivalent to the date string '9999-12-31T24:00:00Z'
         */
        MAXIMUM_VALUE : MAXIMUM_VALUE,

        /**
         * A {@link TimeInterval} representing the largest interval representable by an ISO8601 interval.
         * This is equivalent to the interval string '0000-01-01T00:00:00Z/9999-12-31T24:00:00Z'
         */
        MAXIMUM_INTERVAL : Object.freeze(new TimeInterval(MINIMUM_VALUE, MAXIMUM_VALUE, true, true))
    };
    return Iso8601;
});
/*global define*/
define('Core/TimeIntervalCollection',[
        './DeveloperError',
        './binarySearch',
        './TimeInterval',
        './JulianDate'
       ], function(
         DeveloperError,
         binarySearch,
         TimeInterval,
         JulianDate) {
    

    function compareIntervalStartTimes(left, right) {
        return JulianDate.compare(left.start, right.start);
    }

    /**
     * A non-overlapping collection of TimeIntervals sorted by start date.
     *
     * @alias TimeIntervalCollection
     * @constructor
     *
     * @see TimeInterval
     * @see JulianDate
     *
     */
     var TimeIntervalCollection = function() {
        this._intervals = [];
    };

    /**
     * Gets the interval at the specified index.
     *
     * @memberof TimeIntervalCollection
     * @param {Number} index The index of the interval to retrieve.
     * @return {TimeInterval} The TimeInterval at the specified index, or undefined if no such index exists.
     * @exception {DeveloperError} index must be a number.
     */
    TimeIntervalCollection.prototype.get = function(index) {
        if (isNaN(index)) {
            throw new DeveloperError('index must be a number.');
        }
        return this._intervals[index];
    };

    /**
     * Gets the start date of the collection.
     *
     * @memberof TimeIntervalCollection
     * @return {JulianDate} The start date of the collection or undefined if the collection is empty.
     */
    TimeIntervalCollection.prototype.getStart = function() {
        var thisIntervals = this._intervals;
        return thisIntervals.length === 0 ? undefined : thisIntervals[0].start;
    };

    /**
     * Gets the stop date of the collection.
     *
     * @memberof TimeIntervalCollection
     * @return {JulianDate} The stop date of the collection or undefined if the collection is empty.
     */
    TimeIntervalCollection.prototype.getStop = function() {
        var thisIntervals = this._intervals;
        var length = thisIntervals.length;
        return length === 0 ? undefined : thisIntervals[length - 1].stop;
    };

    /**
     * Gets the number of intervals in the collection.
     *
     * @memberof TimeIntervalCollection
     * @return {Number} The number of intervals in the collection.
     */
    TimeIntervalCollection.prototype.getLength = function() {
        return this._intervals.length;
    };

    /**
     * Clears the collection.
     *
     * @memberof TimeIntervalCollection
     */
    TimeIntervalCollection.prototype.clear = function() {
        this._intervals = [];
    };

    /**
     * Returns true if the collection is empty, false otherwise.
     *
     * @memberof TimeIntervalCollection
     *
     * @returns true if the collection is empty, false otherwise.
     */
    TimeIntervalCollection.prototype.isEmpty = function() {
        return this._intervals.length === 0;
    };

    /**
     * Returns the interval which contains the specified date.
     *
     * @param {JulianDate} date The date to search for.
     *
     * @memberof TimeIntervalCollection
     *
     * @returns The interval containing the specified date, undefined if no such interval exists.
     *
     * @exception {DeveloperError} date is required.
     */
    TimeIntervalCollection.prototype.findIntervalContainingDate = function(date) {
        var index = this.indexOf(date);
        return index >= 0 ? this._intervals[index] : undefined;
    };

    /**
     * Returns true if the specified date is contained in the interval collection.
     *
     * @param {JulianDate} date The date to search for.
     *
     * @memberof TimeIntervalCollection
     *
     * @returns True if the specified date is contained in the interval collection, undefined otherwise.
     *
     * @exception {DeveloperError} date is required.
     */
    TimeIntervalCollection.prototype.contains = function(date) {
        return this.indexOf(date) >= 0;
    };

    /**
     * Returns the index of the interval in the collection that contains the specified date.
     *
     * @param {JulianDate} date The date to search for.
     *
     * @memberof TimeIntervalCollection
     *
     * @returns The index of the interval which contains the specified date, if no such interval exists,
     * it returns a negative number which is the bitwise complement of the index of the next interval that
     * starts after the date, or if no interval starts after the specified date, the bitwise complement of
     * the length of the collection.
     *
     * @exception {DeveloperError} date is required.
     */
    TimeIntervalCollection.prototype.indexOf = function(date) {
        if (typeof date === 'undefined') {
            throw new DeveloperError('date required');
        }
        var thisIntervals = this._intervals;
        var index = binarySearch(thisIntervals, new TimeInterval(date, date, true, true), compareIntervalStartTimes);
        if (index >= 0) {
            if (thisIntervals[index].isStartIncluded) {
                return index;
            }

            if (index > 0 &&
                thisIntervals[index - 1].stop.equals(date) &&
                thisIntervals[index - 1].isStopIncluded) {
                return index - 1;
            }
            return ~index;
        }

        index = ~index;
        if (index > 0 && (index - 1) < thisIntervals.length && thisIntervals[index - 1].contains(date)) {
            return index - 1;
        }
        return ~index;
    };

    /**
     * Returns the first interval in the collection that matches the specified parameters.
     * All parameters are optional and undefined parameters are treated as a don't care condition.
     *
     * @param {JulianDate} [start] The start of the interval.
     * @param {JulianDate} [stop] The end of the interval.
     * @param {JulianDate} [isStartIncluded] True if the start date is included.
     * @param {JulianDate} [isStopIncluded] True if the stop date is included.
     *
     * @memberof TimeIntervalCollection
     *
     * @returns The first interval in the collection that matches the specified parameters.
     */
    TimeIntervalCollection.prototype.findInterval = function(start, stop, isStartIncluded, isStopIncluded) {
        var thisIntervals = this._intervals, interval;
        for ( var i = 0, len = thisIntervals.length; i < len; i++) {
            interval = thisIntervals[i];
            if ((typeof start === 'undefined' || interval.start.equals(start)) &&
                (typeof stop === 'undefined' || interval.stop.equals(stop)) &&
                (typeof isStartIncluded === 'undefined' || interval.isStartIncluded === isStartIncluded) &&
                (typeof isStopIncluded === 'undefined' || interval.isStopIncluded === isStopIncluded)) {
                return thisIntervals[i];
            }
        }
        return undefined;
    };

    /**
     * Adds an interval to the collection, merging intervals that contain the same data and
     * splitting intervals of different data as needed in order to maintain a non-overlapping collection.
     * The data in the new interval takes precedence over any existing intervals in the collection.
     *
     * @param {TimeInterval} interval The interval to add.
     * @param {Function} [equalsCallback] An optional function which takes the data from two
     * TimeIntervals and returns true if they are equal, false otherwise.  If this function
     * is not provided, the Javascript equality operator is used.
     *
     * @memberof TimeIntervalCollection
     *
     * @exception {DeveloperError} interval is required.
     */
    TimeIntervalCollection.prototype.addInterval = function(interval, equalsCallback) {
        if (typeof interval === 'undefined') {
            throw new DeveloperError("interval is required");
        }
        if (!interval.isEmpty) {
            var comparison, index;
            var thisIntervals = this._intervals;

            // Handle the common case quickly: we're adding a new interval which is after all existing intervals.
            if (thisIntervals.length === 0 ||
                interval.start.greaterThan(thisIntervals[thisIntervals.length - 1].stop)) {
                thisIntervals.push(interval);
                return;
            }

            // Keep the list sorted by the start date
            index = binarySearch(thisIntervals, interval, compareIntervalStartTimes);
            if (index < 0) {
                index = ~index;
            } else {
                // interval's start date exactly equals the start date of at least one interval in the collection.
                // It could actually equal the start date of two intervals if one of them does not actually
                // include the date.  In that case, the binary search could have found either.  We need to
                // look at the surrounding intervals and their IsStartIncluded properties in order to make sure
                // we're working with the correct interval.
                if (index > 0 &&
                    interval.isStartIncluded &&
                    thisIntervals[index - 1].isStartIncluded &&
                    thisIntervals[index - 1].start.equals(interval.start)) {
                    --index;
                } else if (index < thisIntervals.length &&
                           !interval.isStartIncluded &&
                           thisIntervals[index].isStartIncluded &&
                           thisIntervals[index].start.equals(interval.start)) {
                    ++index;
                }
            }

            if (index > 0) {
                // Not the first thing in the list, so see if the interval before this one
                // overlaps this one.
                comparison = JulianDate.compare(thisIntervals[index - 1].stop, interval.start);
                if (comparison > 0 || (comparison === 0 && (thisIntervals[index - 1].isStopIncluded || interval.isStartIncluded))) {
                    // There is an overlap
                    if (typeof equalsCallback !== 'undefined' ? equalsCallback(thisIntervals[index - 1].data, interval.data) : (thisIntervals[index - 1].data === interval.data)) {
                        // Overlapping intervals have the same data, so combine them
                        if (interval.stop.greaterThan(thisIntervals[index - 1].stop)) {
                            interval = new TimeInterval(thisIntervals[index - 1].start,
                                                        interval.stop,
                                                        thisIntervals[index - 1].isStartIncluded,
                                                        interval.isStopIncluded,
                                                        interval.data);
                        } else {
                            interval = new TimeInterval(thisIntervals[index - 1].start,
                                                        thisIntervals[index - 1].stop,
                                                        thisIntervals[index - 1].isStartIncluded,
                                                        thisIntervals[index - 1].isStopIncluded || (interval.stop.equals(thisIntervals[index - 1].stop) && interval.isStopIncluded),
                                                        interval.data);
                        }
                        thisIntervals.splice(index - 1, 1);
                        --index;
                    } else {
                        // Overlapping intervals have different data.  The new interval
                        // being added 'wins' so truncate the previous interval.
                        // If the existing interval extends past the end of the new one,
                        // split the existing interval into two intervals.
                        comparison = JulianDate.compare(thisIntervals[index - 1].stop, interval.stop);
                        if (comparison > 0 || (comparison === 0 && thisIntervals[index - 1].isStopIncluded && !interval.isStopIncluded)) {
                            thisIntervals.splice(index - 1, 1,
                                                 new TimeInterval(thisIntervals[index - 1].start,
                                                                  interval.start,
                                                                  thisIntervals[index - 1].isStartIncluded,
                                                                  !interval.isStartIncluded,
                                                                  thisIntervals[index - 1].data),
                                                 new TimeInterval(interval.stop,
                                                                  thisIntervals[index - 1].stop,
                                                                  !interval.isStopIncluded,
                                                                  thisIntervals[index - 1].isStopIncluded,
                                                                  thisIntervals[index - 1].data));
                        } else {
                            thisIntervals[index - 1] = new TimeInterval(thisIntervals[index - 1].start,
                                                                        interval.start,
                                                                        thisIntervals[index - 1].isStartIncluded,
                                                                        !interval.isStartIncluded, thisIntervals[index - 1].data);
                        }
                    }
                }
            }

            while (index < thisIntervals.length) {
                // Not the last thing in the list, so see if the intervals after this one overlap this one.
                comparison = JulianDate.compare(interval.stop, thisIntervals[index].start);
                if (comparison > 0 ||
                    (comparison === 0 && (interval.isStopIncluded || thisIntervals[index].isStartIncluded))) {
                    // There is an overlap
                    if (typeof equalsCallback !== 'undefined' ? equalsCallback(thisIntervals[index].data, interval.data) : thisIntervals[index].data === interval.data) {
                        // Overlapping intervals have the same data, so combine them
                        interval = new TimeInterval(interval.start,
                                                    thisIntervals[index].stop.greaterThan(interval.stop) ? thisIntervals[index].stop : interval.stop,
                                                    interval.isStartIncluded,
                                                    thisIntervals[index].stop.greaterThan(interval.stop) ? thisIntervals[index].isStopIncluded : interval.isStopIncluded,
                                                    interval.data);
                        thisIntervals.splice(index, 1);
                    } else {
                        // Overlapping intervals have different data.  The new interval
                        // being added 'wins' so truncate the next interval.
                        thisIntervals[index] = new TimeInterval(interval.stop,
                                                                thisIntervals[index].stop,
                                                                !interval.isStopIncluded,
                                                                thisIntervals[index].isStopIncluded,
                                                                thisIntervals[index].data);
                        if (thisIntervals[index].isEmpty) {
                            thisIntervals.splice(index, 1);
                        } else {
                            // Found a partial span, so it is not possible for the next
                            // interval to be spanned at all.  Stop looking.
                            break;
                        }
                    }
                } else {
                    // Found the last one we're spanning, so stop looking.
                    break;
                }
            }

            // Add the new interval
            thisIntervals.splice(index, 0, interval);
        }
    };

    /**
     * Removes the specified interval from this interval collection, creating a hole over the specified interval.
     * The Data property of the input interval is ignored.
     *
     * @param {TimeInterval} interval The interval to remove.
     *
     * @memberof TimeIntervalCollection
     *
     * @returns true if the interval was removed, false if no part of the interval was in the collection.
     *
     * @exception {DeveloperError} interval is required.
     */
    TimeIntervalCollection.prototype.removeInterval = function(interval) {
        if (typeof interval === 'undefined') {
            throw new DeveloperError("interval is required");
        }

        if (interval.isEmpty) {
            return false;
        }

        var result = false;
        var thisIntervals = this._intervals;

        var index = binarySearch(thisIntervals, interval, compareIntervalStartTimes);
        if (index < 0) {
            index = ~index;
        }

        var intervalStart = interval.start;
        var intervalStop = interval.stop;
        var intervalIsStartIncluded = interval.isStartIncluded;
        var intervalIsStopIncluded = interval.isStopIncluded;

        // Check for truncation of the end of the previous interval.
        if (index > 0) {
            var indexMinus1 = thisIntervals[index - 1];
            var indexMinus1Stop = indexMinus1.stop;
            if (indexMinus1Stop.greaterThan(intervalStart) ||
                (indexMinus1Stop.equals(intervalStart) &&
                 indexMinus1.isStopIncluded && intervalIsStartIncluded)) {
                result = true;

                if (indexMinus1Stop.greaterThan(intervalStop) ||
                    (indexMinus1.isStopIncluded && !intervalIsStopIncluded && indexMinus1Stop.equals(intervalStop))) {
                    // Break the existing interval into two pieces
                    thisIntervals.splice(index, 0, new TimeInterval(intervalStop, indexMinus1Stop, !intervalIsStopIncluded, indexMinus1.isStopIncluded, indexMinus1.data));
                }
                thisIntervals[index - 1] = new TimeInterval(indexMinus1.start, intervalStart, indexMinus1.isStartIncluded, !intervalIsStartIncluded, indexMinus1.data);
            }
        }

        // Check if the Start of the current interval should remain because interval.start is the same but
        // it is not included.
        var indexInterval = thisIntervals[index];
        if (index < thisIntervals.length &&
            !intervalIsStartIncluded &&
            indexInterval.isStartIncluded &&
            intervalStart.equals(indexInterval.start)) {
            result = true;

            thisIntervals.splice(index, 0, new TimeInterval(indexInterval.start, indexInterval.start, true, true, indexInterval.data));
            ++index;
            indexInterval = thisIntervals[index];
        }

        // Remove any intervals that are completely overlapped by the input interval.
        while (index < thisIntervals.length &&
                intervalStop.greaterThan(indexInterval.stop)) {
            result = true;
            thisIntervals.splice(index, 1);
        }

        // Check for the case where the input interval ends on the same date
        // as an existing interval.
        if (index < thisIntervals.length && intervalStop.equals(indexInterval.stop)) {
            result = true;

            if (!intervalIsStopIncluded && indexInterval.isStopIncluded) {
                // Last point of interval should remain because the stop date is included in
                // the existing interval but is not included in the input interval.
                if ((index + 1) < thisIntervals.length && thisIntervals[index + 1].start.equals(intervalStop) && indexInterval.data === thisIntervals[index + 1].data) {
                    // Combine single point with the next interval
                    thisIntervals.splice(index, 1);
                    thisIntervals[index] = indexInterval = new TimeInterval(indexInterval.start, indexInterval.stop, true, indexInterval.isStopIncluded, indexInterval.data);
                } else {
                    thisIntervals[index] = indexInterval = new TimeInterval(intervalStop, intervalStop, true, true, indexInterval.data);
                }
            } else {
                // Interval is completely overlapped
                thisIntervals.splice(index, 1);
            }
        }

        // Truncate any partially-overlapped intervals.
        if (index < thisIntervals.length &&
            (intervalStop.greaterThan(indexInterval.start) ||
             (intervalStop.equals(indexInterval.start) &&
              intervalIsStopIncluded &&
              indexInterval.isStartIncluded))) {
            result = true;
            thisIntervals[index] = new TimeInterval(intervalStop, indexInterval.stop, !intervalIsStopIncluded, indexInterval.isStopIncluded, indexInterval.data);
        }

        return result;
    };

    /**
     * Creates a new TimeIntervalCollection which is the intersection of this collection
     * and the provided collection.
     *
     * @param {TimeIntervalCollection} timeIntervalCollection The collection to intersect with.
     * @param {Function} [equalsCallback] An optional function which takes the data from two
     * TimeIntervals and returns true if they are equal, false otherwise.  If this function
     * is not provided, the Javascript equality operator is used.
     * @param {Function} [mergeCallback] An optional function which takes the data from two
     * TimeIntervals and returns a merged version of the data.  If this parameter is omitted,
     * the interval data from <code>this</code> collection will be used.
     *
     * @returns A new TimeIntervalCollection which is the intersection of this collection and the provided collection.
     *
     * @memberof TimeIntervalCollection
     *
     * @exception {DeveloperError} timeIntervalCollection is required.
     */
    TimeIntervalCollection.prototype.intersect = function(timeIntervalCollection, equalsCallback, mergeCallback) {
        if (typeof timeIntervalCollection === 'undefined') {
            throw new DeveloperError('timeIntervalCollection is required.');
        }
        return this._intersectInternal(timeIntervalCollection, equalsCallback, mergeCallback);
    };

    /**
     * Creates a new TimeIntervalCollection which is the intersection of this collection
     * and the provided interval.
     *
     * @param {TimeInterval} interval The interval to intersect with.
     * @param {Function} [equalsCallback] An optional function which takes the data from two
     * TimeIntervals and returns true if they are equal, false otherwise.  If this function
     * is not provided, the equality operator will be used.
     * @param {Function} [mergeCallback] An optional function which takes the data from two
     * TimeIntervals and returns a merged version of the data.  If this parameter is omitted,
     * the interval data from <code>this</code> collection will be used.
     *
     * @returns A new TimeIntervalCollection which is the intersection of this collection and the provided collection.
     *
     * @memberof TimeIntervalCollection
     *
     * @exception {DeveloperError} timeIntervalCollection is required.
     */
    TimeIntervalCollection.prototype.intersectInterval = function(interval, equalsCallback, mergeCallback) {
        if (typeof interval === 'undefined') {
            throw new DeveloperError('interval is required.');
        }
        var intervals = new TimeIntervalCollection();
        intervals.addInterval(interval);
        return this._intersectInternal(intervals, equalsCallback, mergeCallback);
    };

    TimeIntervalCollection.prototype._intersectInternal = function(intervals, equalsCallback, mergeCallback) {
        var left = 0;
        var right = 0;
        var result = new TimeIntervalCollection();
        var thisIntervals = this._intervals;
        var otherIntervals = intervals._intervals;

        while (left < thisIntervals.length && right < otherIntervals.length) {
            var leftInterval = thisIntervals[left];
            var rightInterval = otherIntervals[right];
            if (leftInterval.stop.lessThan(rightInterval.start)) {
                ++left;
            } else if (rightInterval.stop.lessThan(leftInterval.start)) {
                ++right;
            } else {
                // The following will return an intersection whose data is 'merged' if the callback is defined
                if (typeof mergeCallback !== 'undefined' ||
                   ((typeof equalsCallback !== 'undefined' && equalsCallback(leftInterval, rightInterval)) ||
                    (typeof equalsCallback === 'undefined' && rightInterval.data === leftInterval.data))) {

                    var intersection = leftInterval.intersect(rightInterval, mergeCallback);
                    if (!intersection.isEmpty) {
                        // Since we start with an empty collection for 'result', and there are no overlapping intervals in 'this' (as a rule),
                        // the 'intersection' will never overlap with a previous interval in 'result'.  So, no need to do any additional 'merging'.
                        result.addInterval(intersection, equalsCallback);
                    }
                }

                if (leftInterval.stop.lessThan(rightInterval.stop) ||
                    (leftInterval.stop.equals(rightInterval.stop) &&
                     !leftInterval.isStopIncluded &&
                     rightInterval.isStopIncluded)) {
                    ++left;
                } else {
                    ++right;
                }
            }
        }
        return result;
    };

    return TimeIntervalCollection;
});

/*global define*/
define('Core/pointInsideTriangle2D',['./DeveloperError'], function(DeveloperError) {
    

    /**
     * DOC_TBA
     *
     * @param point
     * @param p0
     * @param p1
     * @param p2
     *
     * @exports pointInsideTriangle2D
     *
     * @exception {DeveloperError} point, p0, p1, and p2 are required.
     */
    var pointInsideTriangle2D = function(point, p0, p1, p2) {
        if (!point || !p0 || !p1 || !p2) {
            throw new DeveloperError('point, p0, p1, and p2 are required.');
        }

        // Implementation based on http://www.blackpawn.com/texts/pointinpoly/default.html.
        var v0 = p1.subtract(p0);
        var v1 = p2.subtract(p0);
        var v2 = point.subtract(p0);

        var dot00 = v0.dot(v0);
        var dot01 = v0.dot(v1);
        var dot02 = v0.dot(v2);
        var dot11 = v1.dot(v1);
        var dot12 = v1.dot(v2);

        var q = 1.0 / (dot00 * dot11 - dot01 * dot01);
        var u = (dot11 * dot02 - dot01 * dot12) * q;
        var v = (dot00 * dot12 - dot01 * dot02) * q;

        return (u > 0) && (v > 0) && (u + v < 1);
    };

    return pointInsideTriangle2D;
});

/*global define*/
define('Core/PolygonPipeline',[
        './DeveloperError',
        './Math',
        './Cartesian3',
        './pointInsideTriangle2D',
        './ComponentDatatype',
        './PrimitiveType',
        './Queue',
        './WindingOrder'
    ], function(
        DeveloperError,
        CesiumMath,
        Cartesian3,
        pointInsideTriangle2D,
        ComponentDatatype,
        PrimitiveType,
        Queue,
        WindingOrder) {
    

    function DoublyLinkedList() {
        this.head = null;
        this.tail = null;
        this.length = 0;
    }

    DoublyLinkedList.prototype.add = function(item) {
        if (item) {
            var node = {
                item : item,
                previous : this.tail,
                next : null
            };

            if (this.tail) {
                this.tail.next = node;
                this.tail = node;
            } else {
                // Insert into empty list.
                this.head = node;
                this.tail = node;
            }

            ++this.length;
        }
    };

    DoublyLinkedList.prototype.remove = function(item) {
        if (item) {
            if (item.previous && item.next) {
                item.previous.next = item.next;
                item.next.previous = item.previous;
            } else if (item.previous) {
                // Remove last node.
                item.previous.next = null;
                this.tail = item.previous;
            } else if (item.next) {
                // Remove first node.
                item.next.previous = null;
                this.head = item.next;
            } else {
                // Remove last node in linked list.
                this.head = null;
                this.tail = null;
            }

            --this.length;
        }
    };

    /**
     * DOC_TBA
     *
     * @exports PolygonPipeline
     */
    var PolygonPipeline = {
        /**
         * DOC_TBA
         *
         * Cleans up a simple polygon by removing duplicate adjacent positions and making
         * the first position not equal the last position.
         *
         * @exception {DeveloperError} positions is required.
         * @exception {DeveloperError} At least three positions are required.
         */
        cleanUp : function(positions) {
            if (!positions) {
                throw new DeveloperError('positions is required.');
            }

            var length = positions.length;
            if (length < 3) {
                throw new DeveloperError('At least three positions are required.');
            }

            var cleanedPositions = [];

            for ( var i0 = length - 1, i1 = 0; i1 < length; i0 = i1++) {
                var v0 = positions[i0];
                var v1 = positions[i1];

                if (!v0.equals(v1)) {
                    cleanedPositions.push(v1); // Shallow copy!
                }
            }

            return cleanedPositions;
        },

        /**
         * DOC_TBA
         *
         * @exception {DeveloperError} positions is required.
         * @exception {DeveloperError} At least three positions are required.
         */
        computeArea2D : function(positions) {
            if (!positions) {
                throw new DeveloperError('positions is required.');
            }

            var length = positions.length;
            if (length < 3) {
                throw new DeveloperError('At least three positions are required.');
            }

            var area = 0.0;

            for ( var i0 = length - 1, i1 = 0; i1 < length; i0 = i1++) {
                var v0 = positions[i0];
                var v1 = positions[i1];

                area += (v0.x * v1.y) - (v1.x * v0.y);
            }

            return area * 0.5;
        },

        /**
         * DOC_TBA
         *
         * @return {WindingOrder} DOC_TBA
         *
         * @exception {DeveloperError} positions is required.
         * @exception {DeveloperError} At least three positions are required.
         */
        computeWindingOrder2D : function(positions) {
            var area = PolygonPipeline.computeArea2D(positions);
            return (area >= 0.0) ? WindingOrder.COUNTER_CLOCKWISE : WindingOrder.CLOCKWISE;
        },

        /**
         * DOC_TBA
         *
         * @exception {DeveloperError} positions is required.
         * @exception {DeveloperError} At least three positions are required.
         */
        earClip2D : function(positions) {
            function isTipConvex(p0, p1, p2) {
                var u = p1.subtract(p0);
                var v = p2.subtract(p1);

                // Use the sign of the z component of the cross product
                return ((u.x * v.y) - (u.y * v.x)) >= 0.0;
            }

            // PERFORMANCE_IDEA:  This is slow at n^3.  Make it faster with:
            //   * http://www.geometrictools.com/Documentation/TriangulationByEarClipping.pdf
            //   * http://cgm.cs.mcgill.ca/~godfried/publications/triangulation.held.ps.gz
            //   * http://blogs.agi.com/insight3d/index.php/2008/03/20/triangulation-rhymes-with-strangulation/

            if (!positions) {
                throw new DeveloperError('positions is required.');
            }

            var length = positions.length;
            if (length < 3) {
                throw new DeveloperError('At least three positions are required.');
            }

            var remainingPositions = new DoublyLinkedList();

            for ( var i = 0; i < length; ++i) {
                remainingPositions.add({
                    position : positions[i],
                    index : i
                });
            }

            var indices = [];

            var previousNode = remainingPositions.head;
            var node = previousNode.next;
            var nextNode = node.next;

            var bailCount = length * length;

            while (remainingPositions.length > 3) {
                var p0 = previousNode.item.position;
                var p1 = node.item.position;
                var p2 = nextNode.item.position;

                if (isTipConvex(p0, p1, p2)) {
                    var isEar = true;

                    for (var n = (nextNode.next ? nextNode.next : remainingPositions.head);
                             n !== previousNode;
                             n = (n.next ? n.next : remainingPositions.head)) {
                        if (pointInsideTriangle2D(n.item.position, p0, p1, p2)) {
                            isEar = false;
                            break;
                        }
                    }

                    if (isEar) {
                        indices.push(previousNode.item.index);
                        indices.push(node.item.index);
                        indices.push(nextNode.item.index);

                        remainingPositions.remove(node);

                        node = nextNode;
                        nextNode = nextNode.next ? nextNode.next : remainingPositions.head;
                        continue;
                    }
                }

                previousNode = previousNode.next ? previousNode.next : remainingPositions.head;
                node = node.next ? node.next : remainingPositions.head;
                nextNode = nextNode.next ? nextNode.next : remainingPositions.head;

                if (--bailCount === 0) {
                    break;
                }
            }

            var n0 = remainingPositions.head;
            var n1 = n0.next;
            var n2 = n1.next;
            indices.push(n0.item.index);
            indices.push(n1.item.index);
            indices.push(n2.item.index);

            return indices;
        },

        /**
         * DOC_TBA
         *
         * @param {DOC_TBA} positions DOC_TBA
         * @param {DOC_TBA} indices DOC_TBA
         * @param {Number} [granularity] DOC_TBA
         *
         * @exception {DeveloperError} positions is required.
         * @exception {DeveloperError} indices is required.
         * @exception {DeveloperError} At least three indices are required.
         * @exception {DeveloperError} The number of indices must be divisable by three.
         * @exception {DeveloperError} Granularity must be greater than zero.
         */
        computeSubdivision : function(positions, indices, granularity) {
            if (!positions) {
                throw new DeveloperError('positions is required.');
            }

            if (!indices) {
                throw new DeveloperError('indices is required.');
            }

            if (indices.length < 3) {
                throw new DeveloperError('At least three indices are required.');
            }

            if (indices.length % 3 !== 0) {
                throw new DeveloperError('The number of indices must be divisable by three.');
            }

            granularity = granularity || CesiumMath.toRadians(1.0);
            if (granularity <= 0.0) {
                throw new DeveloperError('granularity must be greater than zero.');
            }

            // Use a queue for triangles that need (or might need) to be subdivided.
            var triangles = new Queue();

            var indicesLength = indices.length;
            for ( var j = 0; j < indicesLength; j += 3) {
                triangles.enqueue({
                    i0 : indices[j],
                    i1 : indices[j + 1],
                    i2 : indices[j + 2]
                });
            }

            // New positions due to edge splits are appended to the positions list.
            var subdividedPositions = positions.slice(0); // shadow copy!
            var subdividedIndices = [];

            // Used to make sure shared edges are not split more than once.
            var edges = {};

            var i;
            while (triangles.length > 0) {
                var triangle = triangles.dequeue();

                var v0 = subdividedPositions[triangle.i0];
                var v1 = subdividedPositions[triangle.i1];
                var v2 = subdividedPositions[triangle.i2];

                var g0 = v0.angleBetween(v1);
                var g1 = v1.angleBetween(v2);
                var g2 = v2.angleBetween(v0);

                var max = Math.max(g0, Math.max(g1, g2));
                var edge;

                if (max > granularity) {
                    if (g0 === max) {
                        edge = Math.min(triangle.i0, triangle.i1).toString() + ' ' + Math.max(triangle.i0, triangle.i1).toString();

                        i = edges[edge];
                        if (!i) {
                            subdividedPositions.push(v0.add(v1).multiplyByScalar(0.5));
                            i = subdividedPositions.length - 1;
                            edges[edge] = i;
                        }

                        triangles.enqueue({
                            i0 : triangle.i0,
                            i1 : i,
                            i2 : triangle.i2
                        });
                        triangles.enqueue({
                            i0 : i,
                            i1 : triangle.i1,
                            i2 : triangle.i2
                        });
                    } else if (g1 === max) {
                        edge = Math.min(triangle.i1, triangle.i2).toString() + ' ' + Math.max(triangle.i1, triangle.i2).toString();

                        i = edges[edge];
                        if (!i) {
                            subdividedPositions.push(v1.add(v2).multiplyByScalar(0.5));
                            i = subdividedPositions.length - 1;
                            edges[edge] = i;
                        }

                        triangles.enqueue({
                            i0 : triangle.i1,
                            i1 : i,
                            i2 : triangle.i0
                        });
                        triangles.enqueue({
                            i0 : i,
                            i1 : triangle.i2,
                            i2 : triangle.i0
                        });
                    } else if (g2 === max) {
                        edge = Math.min(triangle.i2, triangle.i0).toString() + ' ' + Math.max(triangle.i2, triangle.i0).toString();

                        i = edges[edge];
                        if (!i) {
                            subdividedPositions.push(v2.add(v0).multiplyByScalar(0.5));
                            i = subdividedPositions.length - 1;
                            edges[edge] = i;
                        }

                        triangles.enqueue({
                            i0 : triangle.i2,
                            i1 : i,
                            i2 : triangle.i1
                        });
                        triangles.enqueue({
                            i0 : i,
                            i1 : triangle.i0,
                            i2 : triangle.i1
                        });
                    }
                } else {
                    subdividedIndices.push(triangle.i0);
                    subdividedIndices.push(triangle.i1);
                    subdividedIndices.push(triangle.i2);
                }
            }

            // PERFORMANCE_IDEA Rather that waste time re-iterating the entire set of positions
            // here, all of the above code can be refactored to flatten as values are added
            // Removing the need for this for loop.
            var length = subdividedPositions.length;
            var flattenedPositions = new Array(length * 3);
            var q = 0;
            for (i = 0; i < length; i++) {
                var item = subdividedPositions[i];
                flattenedPositions[q++] = item.x;
                flattenedPositions[q++] = item.y;
                flattenedPositions[q++] = item.z;
            }

            return {
                attributes : {
                    position : {
                        componentDatatype : ComponentDatatype.FLOAT,
                        componentsPerAttribute : 3,
                        values : flattenedPositions
                    }
                },

                indexLists : [{
                    primitiveType : PrimitiveType.TRIANGLES,
                    values : subdividedIndices
                }]
            };
        },

        /**
         * DOC_TBA
         *
         * @exception {DeveloperError} ellipsoid is required.
         */
        scaleToGeodeticHeight : function(ellipsoid, mesh, height) {
            if (!ellipsoid) {
                throw new DeveloperError('ellipsoid is required.');
            }

            height = height || 0.0;

            if (mesh && mesh.attributes && mesh.attributes.position) {
                var positions = mesh.attributes.position.values;
                var length = positions.length;

                for ( var i = 0; i < length; i += 3) {
                    var p = new Cartesian3(positions[i], positions[i + 1], positions[i + 2]);
                    p = ellipsoid.scaleToGeodeticSurface(p);

                    var n = ellipsoid.geodeticSurfaceNormal(p);
                    n = n.multiplyByScalar(height);

                    // Translate from surface to height.
                    p = p.add(n);

                    positions[i] = p.x;
                    positions[i + 1] = p.y;
                    positions[i + 2] = p.z;
                }
            }

            return mesh;
        }
    };

    return PolygonPipeline;
});
/*global define*/
define('Core/requestAnimationFrame',[],function() {
    

    /**
     * A browser-independent function to request a new animation frame.  This is used to create
     * an application's draw loop as shown in the example below.
     *
     * @exports requestAnimationFrame
     *
     * @param {Object} callback The function to call when animation is ready.
     *
     * @example
     * // Create a draw loop using requestAnimationFrame. The
     * // tick callback function is called for every animation frame.
     * (function tick() {
     *   scene.render();
     *   requestAnimationFrame(tick);
     * }());
     */
    var requestAnimationFrame = function(callback) {
        //delay the selection of the appropriate function until the first invocation
        requestAnimationFrame =
            window.requestAnimationFrame ||
            window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame ||
            window.oRequestAnimationFrame ||
            window.msRequestAnimationFrame ||
            function(callback) {
                window.setTimeout(callback, 1000.0 / 60.0);
            };
        requestAnimationFrame(callback);
    };

    return requestAnimationFrame;
});

/*global define*/
define('Core/shallowEquals',[],function() {
    

    /**
     * DOC_TBA
     *
     * @exports shallowEquals
     */
    function shallowEquals(left, right) {
        if (left && !right) {
            return false;
        } else if (!left && right) {
            return false;
        } else if (!left && !right) {
            return typeof left === typeof right;
        } else {
            // Assumes left and right have the same properties
            for ( var property in left) {
                if (left.hasOwnProperty(property)) {
                    if (left[property] !== right[property]) {
                        return false;
                    }
                }
            }
        }

        return true;
    }

    return shallowEquals;
});

/*global define*/
define('DynamicScene/CzmlBoolean',[],function() {
    

    /**
     * Provides methods for working with a boolean defined in CZML.
     *
     * @exports CzmlBoolean
     *
     * @see DynamicProperty
     * @see CzmlCartesian2
     * @see CzmlCartesian3
     * @see CzmlCartographic
     * @see CzmlColor
     * @see CzmlHorizontalOrigin
     * @see CzmlLabelStyle
     * @see CzmlNumber
     * @see CzmlString
     * @see CzmlUnitCartesian3
     * @see CzmlUnitQuaternion
     * @see CzmlUnitSpherical
     * @see CzmlVerticalOrigin
     */
    var CzmlBoolean = {
        /**
         * Returns the packed boolean representation contained within the provided CZML interval
         * or undefined if the interval does not contain boolean data.
         *
         * @param {Object} czmlInterval The CZML interval to unwrap.
         */
        unwrapInterval : function(czmlInterval) {
            /*jshint sub:true*/
            var result = czmlInterval['boolean']; // boolean is a JS reserved word
            return typeof result === 'undefined' ? czmlInterval : result;
        },

        /**
         * Since CZML booleans can not be sampled, this method always returns false.
         */
        isSampled : function() {
            return false;
        },

        /**
         * Returns the boolean value contained within the unwrappedInterval.  For booleans
         * this is the unwrappedInterval itself.
         *
         * @param {Object} unwrappedInterval The result of CzmlBoolean.unwrapInterval.
         * @returns The boolean value.
         */
        getValue : function(unwrappedInterval) {
            return unwrappedInterval;
        }
    };

    return CzmlBoolean;
});
/*global define*/
define('DynamicScene/CzmlCartesian2',[
        '../Core/Cartesian2'
       ], function(
         Cartesian2) {
    

    var doublesPerValue = 2;

    /**
     * Provides methods for working with a Cartesian2 defined in CZML.
     *
     * @exports CzmlCartesian2
     *
     * @see Cartesian2
     * @see DynamicProperty
     * @see CzmlBoolean
     * @see CzmlCartesian3
     * @see CzmlCartographic
     * @see CzmlColor
     * @see CzmlHorizontalOrigin
     * @see CzmlLabelStyle
     * @see CzmlNumber
     * @see CzmlString
     * @see CzmlUnitCartesian3
     * @see CzmlUnitQuaternion
     * @see CzmlUnitSpherical
     * @see CzmlVerticalOrigin
     */
    var CzmlCartesian2 = {
        /**
         * The number of doubles per packed Cartesian2 value.
         */
        doublesPerValue : doublesPerValue,

        /**
         * The number of doubles per packed value used for interpolation.
         */
        doublesPerInterpolationValue : doublesPerValue,

        /**
         * Returns the packed Cartesian2 representation contained within the provided CZML interval
         * or undefined if the interval does not contain Cartesian2 data.
         *
         * @param {Object} czmlInterval The CZML interval to unwrap.
         */
        unwrapInterval : function(czmlInterval) {
            return czmlInterval.cartesian2;
        },

        /**
         * Returns true if this interval represents data that should be interpolated by the client
         * or false if it's a single value.
         *
         * @param {Object} unwrappedInterval The result of CzmlCartesian2.unwrapInterval.
         */
        isSampled : function(unwrappedInterval) {
            return Array.isArray(unwrappedInterval) && unwrappedInterval.length > doublesPerValue;
        },

        /**
         * Given a non-sampled unwrapped interval, returns a Cartesian2 instance of the data.
         *
         * @param {Object} unwrappedInterval The result of CzmlCartesian2.unwrapInterval.
         * @param {Cartesian2} result The object to store the result in, if undefined a new instance will be created.
         * @returns The modified result parameter or a new Cartesian2 instance if result was not defined.
         */
        getValue : function(unwrappedInterval, result) {
            if (typeof result === 'undefined') {
                result = new Cartesian2();
            }
            result.x = unwrappedInterval[0];
            result.y = unwrappedInterval[1];
            return result;
        },

        /**
         * Given a packed array of x and y values, extracts a Cartesian2 instance.
         *
         * @param {Array} array A packed array of Cartesian2 values, where every two elements represents an x,y pair.
         * @param {Number} startingIndex The index into the array that contains the x value of the Cartesian2 you would like.
         * @param {Cartesian2} result The object to store the result in, if undefined a new instance will be created.
         * @returns The modified result parameter or a new Cartesian2 instance if result was not defined.
         */
        getValueFromArray : function(array, startingIndex, result) {
            if (typeof result === 'undefined') {
                result = new Cartesian2();
            }
            result.x = array[startingIndex];
            result.y = array[startingIndex + 1];
            return result;
        }
    };

    return CzmlCartesian2;
});
/*global define*/
define('DynamicScene/CzmlCartesian3',[
        '../Core/Cartesian3'
       ], function(
         Cartesian3) {
    

    var doublesPerValue = 3;

    /**
     * Provides methods for working with a Cartesian3 defined in CZML.
     *
     * @exports CzmlCartesian3
     *
     * @see Cartesian3
     * @see DynamicProperty
     * @see DynamicPositionProperty
     * @see CzmlBoolean
     * @see CzmlCartesian2
     * @see CzmlCartographic
     * @see CzmlColor
     * @see CzmlHorizontalOrigin
     * @see CzmlLabelStyle
     * @see CzmlNumber
     * @see CzmlString
     * @see CzmlUnitCartesian3
     * @see CzmlUnitQuaternion
     * @see CzmlUnitSpherical
     * @see CzmlVerticalOrigin
     */
    var CzmlCartesian3 = {
         /**
         * The number of doubles per packed Cartesian3 value.
         */
        doublesPerValue : doublesPerValue,

        /**
         * The number of doubles per packed value used for interpolation.
         */
        doublesPerInterpolationValue : doublesPerValue,

        /**
         * Returns the packed Cartesian3 representation contained within the provided CZML interval
         * or undefined if the interval does not contain Cartesian3 data.
         *
         * @param {Object} czmlInterval The CZML interval to unwrap.
         */
        unwrapInterval : function(czmlInterval) {
            return czmlInterval.cartesian;
        },

        /**
         * Returns true if this interval represents data that should be interpolated by the client
         * or false if it's a single value.
         *
         * @param {Object} unwrappedInterval The result of CzmlCartesian3.unwrapInterval.
         */
        isSampled : function(unwrappedInterval) {
            return Array.isArray(unwrappedInterval) && unwrappedInterval.length > doublesPerValue;
        },

        /**
         * Given a non-sampled unwrapped interval, returns a Cartesian3 instance of the data.
         *
         * @param {Object} unwrappedInterval The result of CzmlCartesian3.unwrapInterval.
         * @param {Cartesian3} result The object to store the result in, if undefined a new instance will be created.
         * @returns The modified result parameter or a new Cartesian3 instance if result was not defined.
         */
        getValue : function(unwrappedInterval, result) {
            if (typeof result === 'undefined') {
                result = new Cartesian3();
            }
            result.x = unwrappedInterval[0];
            result.y = unwrappedInterval[1];
            result.z = unwrappedInterval[2];
            return result;
        },

        /**
         * Given a packed array of x, y, and z values, extracts a Cartesian3 instance.
         *
         * @param {Array} array A packed array of Cartesian3 values, where every three elements represents a Cartesian3.
         * @param {Number} startingIndex The index into the array that contains the x value of the Cartesian3 you would like.
         * @param {Cartesian3} result The object to store the result in, if undefined a new instance will be created.
         * @returns The modified result parameter or a new Cartesian3 instance if result was not defined.
         */
        getValueFromArray : function(array, startingIndex, result) {
            if (typeof result === 'undefined') {
                result = new Cartesian3();
            }
            result.x = array[startingIndex];
            result.y = array[startingIndex + 1];
            result.z = array[startingIndex + 2];
            return result;
        }
    };

    return CzmlCartesian3;
});
/*global define*/
define('DynamicScene/CzmlCartographic',[
        '../Core/Cartographic',
        '../Core/Math'
       ], function(
         Cartographic,
         CesiumMath) {
    

    var doublesPerValue = 3;

    /**
     * Provides methods for working with a Cartographic defined in CZML.
     *
     * @exports CzmlCartographic
     *
     * @see Cartographic
     * @see DynamicProperty
     * @see DynamicPositionProperty
     * @see CzmlBoolean
     * @see CzmlCartesian2
     * @see CzmlCartesian3
     * @see CzmlColor
     * @see CzmlHorizontalOrigin
     * @see CzmlLabelStyle
     * @see CzmlNumber
     * @see CzmlString
     * @see CzmlUnitCartesian3
     * @see CzmlUnitQuaternion
     * @see CzmlUnitSpherical
     * @see CzmlVerticalOrigin
     */
    var CzmlCartographic = {
        /**
         * The number of doubles per packed Cartographic value.
         */
        doublesPerValue : doublesPerValue,

        /**
         * The number of doubles per packed value used for interpolation.
         */
        doublesPerInterpolationValue : doublesPerValue,

        /**
         * Returns the packed Cartographic representation contained within the provided CZML interval
         * or undefined if the interval does not contain Cartographic data.
         *
         * @param {Object} czmlInterval The CZML interval to unwrap.
         */
        unwrapInterval : function(czmlInterval) {
            var cartographic = czmlInterval.cartographicRadians;
            if (typeof cartographic !== 'undefined') {
                return cartographic;
            }

            var cartographicDegrees = czmlInterval.cartographicDegrees;
            if (typeof cartographicDegrees === 'undefined') {
                return undefined;
            }

            if (!this.isSampled(cartographicDegrees)) {
                return [CesiumMath.toRadians(cartographicDegrees[0]),
                        CesiumMath.toRadians(cartographicDegrees[1]),
                        cartographicDegrees[2]];
            }

            var len = cartographicDegrees.length;
            cartographic = new Array(len);
            for ( var i = 0; i < len; i += 4) {
                cartographic[i] = cartographicDegrees[i];
                cartographic[i + 1] = CesiumMath.toRadians(cartographicDegrees[i + 1]);
                cartographic[i + 2] = CesiumMath.toRadians(cartographicDegrees[i + 2]);
                cartographic[i + 3] = cartographicDegrees[i + 3];
            }
            return cartographic;
        },

        /**
         * Returns true if this interval represents data that should be interpolated by the client
         * or false if it's a single value.
         *
         * @param {Object} unwrappedInterval The result of CzmlCartographic.unwrapInterval.
         */
        isSampled : function(unwrappedInterval) {
            return Array.isArray(unwrappedInterval) && unwrappedInterval.length > doublesPerValue;
        },

        /**
         * Given a non-sampled unwrapped interval, returns a Cartographic instance of the data.
         *
         * @param {Object} unwrappedInterval The result of CzmlCartographic.unwrapInterval.
         * @param {Cartographic} result The object to store the result in, if undefined a new instance will be created.
         * @returns The modified result parameter or a new Cartographic instance if result was not defined.
         */
        getValue : function(unwrappedInterval, result) {
            if (typeof result === 'undefined') {
                result = new Cartographic();
            }
            result.longitude = unwrappedInterval[0];
            result.latitude = unwrappedInterval[1];
            result.height = unwrappedInterval[2];
            return result;
        },

        /**
         * Given a packed array of longitude, latitude, and height values, extracts a Cartographic instance.
         *
         * @param {Array} array A packed array of Cartographic values, where every three elements represents a Cartographic.
         * @param {Number} startingIndex The index into the array that contains the longitude value of the Cartographic you would like.
         * @param {Cartographic} result The object to store the result in, if undefined a new instance will be created.
         * @returns The modified result parameter or a new Cartographic instance if result was not defined.
         */
        getValueFromArray : function(array, startingIndex, result) {
            if (typeof result === 'undefined') {
                result = new Cartographic();
            }
            result.longitude = array[startingIndex];
            result.latitude = array[startingIndex + 1];
            result.height = array[startingIndex + 2];
            return result;
        }
    };

    return CzmlCartographic;
});
/*global define*/
define('DynamicScene/CzmlColor',[
        '../Core/Color'
       ], function(
         Color) {
    

    var doublesPerValue = 4;

    /**
     * Provides methods for working with a Color defined in CZML.
     *
     * @exports CzmlColor
     *
     * @see Color
     * @see DynamicProperty
     * @see DynamicPositionProperty
     * @see CzmlBoolean
     * @see CzmlCartesian2
     * @see CzmlCartesian3
     * @see CzmlCartographic
     * @see CzmlHorizontalOrigin
     * @see CzmlLabelStyle
     * @see CzmlNumber
     * @see CzmlString
     * @see CzmlUnitCartesian3
     * @see CzmlUnitQuaternion
     * @see CzmlUnitSpherical
     * @see CzmlVerticalOrigin
     */
    var CzmlColor = {
        /**
         * The number of doubles per packed Color value.
         */
        doublesPerValue : doublesPerValue,

        /**
         * The number of doubles per packed value used for interpolation.
         */
        doublesPerInterpolationValue : doublesPerValue,

        /**
         * Returns the packed Color representation contained within the provided CZML interval
         * or undefined if the interval does not contain Color data.
         *
         * @param {Object} czmlInterval The CZML interval to unwrap.
         */
        unwrapInterval : function(czmlInterval) {
            var rgbaf = czmlInterval.rgbaf;
            if (typeof rgbaf !== 'undefined') {
                return rgbaf;
            }

            var rgba = czmlInterval.rgba;
            if (typeof rgba === 'undefined') {
                return undefined;
            }

            if (!this.isSampled(rgba)) {
                return [Color.byteToFloat(rgba[0]),
                        Color.byteToFloat(rgba[1]),
                        Color.byteToFloat(rgba[2]),
                        Color.byteToFloat(rgba[3])];
            }

            var len = rgba.length;
            rgbaf = new Array(len);
            for ( var i = 0; i < len; i += 5) {
                rgbaf[i] = rgba[i];
                rgbaf[i + 1] = Color.byteToFloat(rgba[i + 1]);
                rgbaf[i + 2] = Color.byteToFloat(rgba[i + 2]);
                rgbaf[i + 3] = Color.byteToFloat(rgba[i + 3]);
                rgbaf[i + 4] = Color.byteToFloat(rgba[i + 4]);
            }
            return rgbaf;
        },

        /**
         * Returns true if this interval represents data that should be interpolated by the client
         * or false if it's a single value.
         *
         * @param {Object} unwrappedInterval The result of CzmlColor.unwrapInterval.
         */
        isSampled : function(unwrappedInterval) {
            return Array.isArray(unwrappedInterval) && unwrappedInterval.length > doublesPerValue;
        },

        /**
         * Given a non-sampled unwrapped interval, returns a Color instance of the data.
         *
         * @param {Object} unwrappedInterval The result of CzmlColor.unwrapInterval.
         * @param {Color} result The object to store the result in, if undefined a new instance will be created.
         * @returns The modified result parameter or a new Color instance if result was not defined.
         */
        getValue : function(unwrappedInterval, result) {
            if (typeof result === 'undefined') {
                result = new Color();
            }
            result.red = unwrappedInterval[0];
            result.green = unwrappedInterval[1];
            result.blue = unwrappedInterval[2];
            result.alpha = unwrappedInterval[3];
            return result;
        },


        /**
         * Given a packed array of red, green, blue, and alpha values, extracts a Color instance.
         *
         * @param {Array} array A packed array of Color values, where every four elements represents a Color.
         * @param {Number} startingIndex The index into the array that contains the red value of the Color you would like.
         * @param {Color} result The object to store the result in, if undefined a new instance will be created.
         * @returns The modified result parameter or a new Color instance if result was not defined.
         */
        getValueFromArray : function(array, startingIndex, result) {
            if (typeof result === 'undefined') {
                result = new Color();
            }
            result.red = array[startingIndex];
            result.green = array[startingIndex + 1];
            result.blue = array[startingIndex + 2];
            result.alpha = array[startingIndex + 3];
            return result;
        }
    };
    return CzmlColor;
});
/*global define*/
define('DynamicScene/CzmlNumber',[],function() {
    

    var doublesPerValue = 1;

    /**
     * Provides methods for working with a number defined in CZML.
     *
     * @exports CzmlNumber
     *
     * @see DynamicProperty
     * @see CzmlBoolean
     * @see CzmlCartesian2
     * @see CzmlCartesian3
     * @see CzmlCartographic
     * @see CzmlColor
     * @see CzmlHorizontalOrigin
     * @see CzmlLabelStyle
     * @see CzmlString
     * @see CzmlUnitCartesian3
     * @see CzmlUnitQuaternion
     * @see CzmlUnitSpherical
     * @see CzmlVerticalOrigin
     */
    var CzmlNumber = {
        /**
         * The number of doubles per packed value.
         */
        doublesPerValue : doublesPerValue,

        /**
         * The number of doubles per packed value used for interpolation.
         */
        doublesPerInterpolationValue : doublesPerValue,

        /**
         * Returns the packed numerical representation contained within the provided CZML interval
         * or undefined if the interval does not contain numerical data.
         *
         * @param {Object} czmlInterval The CZML interval to unwrap.
         */
        unwrapInterval : function(czmlInterval) {
            var result = czmlInterval.number;
            return typeof result === 'undefined' ? czmlInterval : result;
        },

        /**
         * Returns true if this interval represents data that should be interpolated by the client
         * or false if it's a single value.
         *
         * @param {Object} unwrappedInterval The result of CzmlNumber.unwrapInterval.
         */
        isSampled : function(unwrappedInterval) {
            return Array.isArray(unwrappedInterval);
        },

        /**
         * Returns the numerical value contained within the unwrappedInterval.  For numbers
         * this is the unwrappedInterval itself.
         *
         * @param {Object} unwrappedInterval The result of CzmlNumber.unwrapInterval.
         * @returns The boolean value.
         */
        getValue : function(unwrappedInterval) {
            return unwrappedInterval;
        },

        /**
         * Given a packed array of numerical values, returns the number at the given index..
         *
         * @param {Array} array An array of numbers.
         * @param {Number} startingIndex The index into the array that contains the value you would like.
         * @returns The value at the specified index.
         */
        getValueFromArray : function(array, startingIndex) {
            return array[startingIndex];
        }
    };

    return CzmlNumber;
});
/*global define*/
define('DynamicScene/CzmlString',[],function() {
    

    /**
     * Provides methods for working with a string defined in CZML.
     *
     * @exports CzmlString
     *
     * @see DynamicProperty
     * @see CzmlCartesian2
     * @see CzmlCartesian3
     * @see CzmlCartographic
     * @see CzmlColor
     * @see CzmlHorizontalOrigin
     * @see CzmlLabelStyle
     * @see CzmlNumber
     * @see CzmlString
     * @see CzmlUnitCartesian3
     * @see CzmlUnitQuaternion
     * @see CzmlUnitSpherical
     * @see CzmlVerticalOrigin
     */
    var CzmlString = {
        /**
         * Returns the packed string representation contained within the provided CZML interval
         * or undefined if the interval does not contain string data.
         *
         * @param {Object} czmlInterval The CZML interval to unwrap.
         */
        unwrapInterval : function(czmlInterval) {
            var result = czmlInterval.string;
            return typeof result === 'undefined' ? czmlInterval : result;
        },

        /**
         * Since CZML strings can not be sampled, this method always returns false.
         */
        isSampled : function() {
            return false;
        },

        /**
         * Returns the string value contained within the unwrappedInterval.  For strings
         * this is the unwrappedInterval itself.
         *
         * @param {Object} unwrappedInterval The result of CzmlString.unwrapInterval.
         * @returns The string value.
         */
        getValue : function(unwrappedInterval) {
            return unwrappedInterval;
        }
    };

    return CzmlString;
});
/*global define*/
define('DynamicScene/CzmlUnitCartesian3',[
        '../Core/Cartesian3'
       ], function(
         Cartesian3) {
    

    var doublesPerValue = 3;

    /**
     * Provides methods for working with a unit Cartesian3 defined in CZML.
     *
     * @exports CzmlUnitCartesian3
     *
     * @see Cartesian3
     * @see DynamicProperty
     * @see DynamicPositionProperty
     * @see CzmlBoolean
     * @see CzmlCartesian2
     * @see CzmlCartesian3
     * @see CzmlCartographic
     * @see CzmlColor
     * @see CzmlHorizontalOrigin
     * @see CzmlLabelStyle
     * @see CzmlNumber
     * @see CzmlString
     * @see CzmlUnitQuaternion
     * @see CzmlUnitSpherical
     * @see CzmlVerticalOrigin
     */
    var CzmlUnitCartesian3 = {
         /**
         * The number of doubles per packed Cartesian3 value.
         */
        doublesPerValue : doublesPerValue,

        /**
         * The number of doubles per packed value used for interpolation.
         */
        doublesPerInterpolationValue : doublesPerValue,

        /**
         * Returns the packed Cartesian3 representation contained within the provided CZML interval
         * or undefined if the interval does not contain Cartesian3 data.
         *
         * @param {Object} czmlInterval The CZML interval to unwrap.
         */
        unwrapInterval : function(czmlInterval) {
            return czmlInterval.unitCartesian;
        },

        /**
         * Returns true if this interval represents data that should be interpolated by the client
         * or false if it's a single value.
         *
         * @param {Object} unwrappedInterval The result of CzmlUnitCartesian3.unwrapInterval.
         */
        isSampled : function(unwrappedInterval) {
            return Array.isArray(unwrappedInterval) && unwrappedInterval.length > doublesPerValue;
        },

        /**
         * Given a non-sampled unwrapped interval, returns a Cartesian3 instance of the data.
         *
         * @param {Object} unwrappedInterval The result of CzmlUnitCartesian3.unwrapInterval.
         * @param {Cartesian3} result The object to store the result in, if undefined a new instance will be created.
         * @returns The modified result parameter or a new Cartesian3 instance if result was not defined.
         */
        getValue : function(unwrappedInterval, result) {
            if (typeof result === 'undefined') {
                result = new Cartesian3();
            }
            result.x = unwrappedInterval[0];
            result.y = unwrappedInterval[1];
            result.z = unwrappedInterval[2];
            return result.normalize(result);
        },

        /**
         * Given a packed array of x, y, and z values, extracts a Cartesian3 instance.
         *
         * @param {Array} array A packed array of Cartesian3 values, where every three elements represents a Cartesian3.
         * @param {Number} startingIndex The index into the array that contains the x value of the Cartesian3 you would like.
         * @param {Cartesian3} result The object to store the result in, if undefined a new instance will be created.
         * @returns The modified result parameter or a new Cartesian3 instance if result was not defined.
         */
        getValueFromArray : function(array, startingIndex, result) {
            if (typeof result === 'undefined') {
                result = new Cartesian3();
            }
            result.x = array[startingIndex];
            result.y = array[startingIndex + 1];
            result.z = array[startingIndex + 2];
            return result.normalize(result);
        }
    };

    return CzmlUnitCartesian3;
});
/*global define*/
define('DynamicScene/CzmlUnitQuaternion',[
        '../Core/Quaternion',
        '../Core/Cartesian3'
    ], function(
        Quaternion,
        Cartesian3) {
    

    var doublesPerCartesian = 3;
    var doublesPerQuaternion = 4;
    var axis = new Cartesian3();
    var rotationVector = new Cartesian3();
    var tmpQuaternion = new Quaternion();
    var quaternion0 = new Quaternion();
    var quaternion0Conjugate = new Quaternion();

    /**
     * Provides methods for working with a unit Quaternion defined in CZML.
     *
     * @exports CzmlUnitQuaternion
     *
     * @see Quaternion
     * @see DynamicProperty
     * @see CzmlBoolean
     * @see CzmlCartesian2
     * @see CzmlCartesian3
     * @see CzmlCartographic
     * @see CzmlColor
     * @see CzmlHorizontalOrigin
     * @see CzmlLabelStyle
     * @see CzmlNumber
     * @see CzmlString
     * @see CzmlUnitCartesian3
     * @see CzmlUnitSpherical
     * @see CzmlVerticalOrigin
     */
    var CzmlUnitQuaternion = {
        /**
         * The number of doubles per packed Quaternion value.
         */
        doublesPerValue : doublesPerQuaternion,

        /**
         * The number of doubles per packed value used for interpolation.
         */
        doublesPerInterpolationValue : doublesPerCartesian,

        /**
         * Returns the packed Quaternion representation contained within the provided CZML interval
         * or undefined if the interval does not contain Quaternion data.
         *
         * @param {Object} czmlInterval The CZML interval to unwrap.
         */
        unwrapInterval : function(czmlInterval) {
            return czmlInterval.unitQuaternion;
        },

        /**
         * Returns true if this interval represents data that should be interpolated by the client
         * or false if it's a single value.
         *
         * @param {Object} unwrappedInterval The result of CzmlUnitQuaternion.unwrapInterval.
         */
        isSampled : function(unwrappedInterval) {
            return Array.isArray(unwrappedInterval) && unwrappedInterval.length > doublesPerQuaternion;
        },

        /**
         * Given a packed array of x, y, z, and w values, creates a packed array of
         * Cartesian3 axis-angle rotations suitable for interpolation.
         *
         * @param {Array} sourceArray The packed array of quaternion values.
         * @param {Array} destinationArray The array to store the packed axis-angle rotations.
         * @param {Number} firstIndex The index of the first element to be packed.
         * @param {Number} lastIndex The index of the last element to be packed.
         */
        packValuesForInterpolation : function(sourceArray, destinationArray, firstIndex, lastIndex) {
            CzmlUnitQuaternion.getValueFromArray(sourceArray, lastIndex * doublesPerQuaternion, quaternion0Conjugate);
            quaternion0Conjugate.conjugate(quaternion0Conjugate);

            for ( var i = 0, len = lastIndex - firstIndex + 1; i < len; i++) {
                var offset = i * doublesPerCartesian;
                CzmlUnitQuaternion.getValueFromArray(sourceArray, (firstIndex + i) * doublesPerQuaternion, tmpQuaternion);

                tmpQuaternion.multiply(quaternion0Conjugate, tmpQuaternion);

                if (tmpQuaternion.w < 0) {
                    tmpQuaternion = tmpQuaternion.negate();
                }

                tmpQuaternion.getAxis(axis);
                var angle = tmpQuaternion.getAngle();
                destinationArray[offset] = axis.x * angle;
                destinationArray[offset + 1] = axis.y * angle;
                destinationArray[offset + 2] = axis.z * angle;
            }
        },

        /**
         * Given a non-sampled unwrapped interval, returns a Quaternion instance of the data.
         *
         * @param {Object} unwrappedInterval The result of CzmlUnitQuaternion.unwrapInterval.
         * @param {Cartesian3} result The object to store the result in, if undefined a new instance will be created.
         * @returns The modified result parameter or a new Quaternion instance if result was not defined.
         */
        getValue : function(unwrappedInterval, result) {
            if (typeof result === 'undefined') {
                result = new Quaternion();
            }
            result.x = unwrappedInterval[0];
            result.y = unwrappedInterval[1];
            result.z = unwrappedInterval[2];
            result.w = unwrappedInterval[3];
            return result.normalize(result);
        },

        /**
         * Given a packed array of x, y, z, and w values, extracts a Quaternion instance.
         *
         * @param {Array} array A packed array of Quaternion values, where every four elements represents a Cartesian3.
         * @param {Number} startingIndex The index into the array that contains the x value of the Quaternion you would like.
         * @param {Cartesian3} result The object to store the result in, if undefined a new instance will be created.
         * @returns The modified result parameter or a new Quaternion instance if result was not defined.
         */
        getValueFromArray : function(array, startingIndex, result) {
            if (typeof result === 'undefined') {
                result = new Quaternion();
            }
            result.x = array[startingIndex];
            result.y = array[startingIndex + 1];
            result.z = array[startingIndex + 2];
            result.w = array[startingIndex + 3];
            return result.normalize(result);
        },

        /**
         * Given a packed array of axis-angle rotations returned from CzmlUnitQuaternion.packValuesForInterpolation,
         * converts the desired index into a unit Quaternion.
         *
         * @param {Array} array The array containing the packed axis-angle rotations.
         * @param {Quaternion} result The object to store the result in, if undefined a new instance will be created.
         * @param {Array} sourceArray The source array of the original Quaternion values previously passed to CzmlUnitQuaternion.packValuesForInterpolation.
         * @param {Number} firstIndex The index previously passed to CzmlUnitQuaternion.packValuesForInterpolation.
         * @param {Number} lastIndex The index previously passed to CzmlUnitQuaternion.packValuesForInterpolation
         * @returns The modified result parameter or a new Quaternion instance if result was not defined.
         */
        getValueFromInterpolationResult : function(array, result, sourceArray, firstIndex, lastIndex) {
            if (typeof result === 'undefined') {
                result = new Quaternion();
            }
            rotationVector.x = array[0];
            rotationVector.y = array[1];
            rotationVector.z = array[2];
            var magnitude = rotationVector.magnitude();

            CzmlUnitQuaternion.getValueFromArray(sourceArray, lastIndex * doublesPerQuaternion, quaternion0);

            if (magnitude === 0) {
                //Can't just use Quaternion.IDENTITY here because tmpQuaternion may be modified in the future.
                tmpQuaternion.x = tmpQuaternion.y = tmpQuaternion.z = 0.0;
                tmpQuaternion.w = 1.0;
            } else {
                Quaternion.fromAxisAngle(rotationVector, magnitude, tmpQuaternion);
            }

            return result.normalize(tmpQuaternion.multiply(quaternion0, result));
        }
    };

    return CzmlUnitQuaternion;
});
/*global define*/
define('DynamicScene/CzmlUnitSpherical',[
        '../Core/Spherical'
       ], function(
         Spherical) {
    

    var doublesPerValue = 2;

    /**
     * Provides methods for working with a unit Spherical defined in CZML.
     *
     * @exports CzmlUnitSpherical
     *
     * @see Spherical
     * @see DynamicProperty
     * @see CzmlBoolean
     * @see CzmlCartesian2
     * @see CzmlCartesian3
     * @see CzmlCartographic
     * @see CzmlColor
     * @see CzmlHorizontalOrigin
     * @see CzmlLabelStyle
     * @see CzmlNumber
     * @see CzmlString
     * @see CzmlUnitCartesian3
     * @see CzmlUnitQuaternion
     * @see CzmlVerticalOrigin
     */
    var CzmlUnitSpherical = {
        /**
         * The number of doubles per packed Spherical value.
         */
        doublesPerValue : doublesPerValue,

        /**
         * The number of doubles per packed value used for interpolation.
         */
        doublesPerInterpolationValue : doublesPerValue,

        /**
         * Returns the packed Spherical representation contained within the provided CZML interval
         * or undefined if the interval does not contain Spherical data.
         *
         * @param {Object} czmlInterval The CZML interval to unwrap.
         */
        unwrapInterval : function(czmlInterval) {
            return czmlInterval.unitSpherical;
        },

        /**
         * Returns true if this interval represents data that should be interpolated by the client
         * or false if it's a single value.
         *
         * @param {Object} unwrappedInterval The result of CzmlUnitSpherical.unwrapInterval.
         */
        isSampled : function(unwrappedInterval) {
            return Array.isArray(unwrappedInterval) && unwrappedInterval.length > doublesPerValue;
        },

        /**
         * Given a non-sampled unwrapped interval, returns a Spherical instance of the data.
         *
         * @param {Object} unwrappedInterval The result of CzmlUnitSpherical.unwrapInterval.
         * @param {Spherical} result The object to store the result in, if undefined a new instance will be created.
         * @returns The modified result parameter or a new Spherical instance if result was not defined.
         */
        getValue : function(unwrappedInterval, spherical) {
            if (typeof spherical === 'undefined') {
                spherical = new Spherical();
            }
            spherical.clock = unwrappedInterval[0];
            spherical.cone = unwrappedInterval[1];
            spherical.magnitude = 1.0;
            return spherical;
        },

        /**
         * Given a packed array of clock and cone values, extracts a Spherical instance.
         *
         * @param {Array} array A packed array of Spherical values, where every two elements represents a Spherical.
         * @param {Number} startingIndex The index into the array that contains the clock value of the Spherical you would like.
         * @param {Spherical} result The object to store the result in, if undefined a new instance will be created.
         * @returns The modified result parameter or a new Spherical instance if result was not defined.
         */
        getValueFromArray : function(array, startingIndex, spherical) {
            if (typeof spherical === 'undefined') {
                spherical = new Spherical();
            }
            spherical.clock = array[startingIndex];
            spherical.cone = array[startingIndex + 1];
            spherical.magnitude = 1.0;
            return spherical;
        }
    };

    return CzmlUnitSpherical;
});
/*global define*/
define('DynamicScene/DynamicDirectionsProperty',[
        '../Core/JulianDate',
        '../Core/TimeInterval',
        '../Core/TimeIntervalCollection',
        '../Core/Cartesian3',
        '../Core/Spherical',
        '../Core/Iso8601'
    ], function(
        JulianDate,
        TimeInterval,
        TimeIntervalCollection,
        Cartesian3,
        Spherical,
        Iso8601) {
    

    function ValueHolder(czmlInterval) {
        var i;
        var len;
        var values = [];
        var tmp = czmlInterval.unitSpherical;
        if (typeof tmp !== 'undefined') {
            for (i = 0, len = tmp.length; i < len; i += 2) {
                values.push(new Spherical(tmp[i], tmp[i + 1]));
            }
            this.spherical = values;
        }

        tmp = czmlInterval.unitCartesian;
        if (typeof tmp !== 'undefined') {
            for (i = 0, len = tmp.length; i < len; i += 3) {
                values.push(new Cartesian3(tmp[i], tmp[i + 1], tmp[i + 2], true));
            }
            this.cartesian = values;
        }
    }

    ValueHolder.prototype.getValueSpherical = function() {
        var sphericals = this.spherical;
        if (typeof sphericals === 'undefined') {
            sphericals = [];
            this.spherical = sphericals;
            var cartesians = this.cartesian;
            for ( var i = 0, len = cartesians.length; i < len; i++) {
                sphericals.push(Spherical.fromCartesian3(cartesians[i]));
            }
        }
        return sphericals;
    };

    ValueHolder.prototype.getValueCartesian = function() {
        var cartesians = this.cartesian;
        if (typeof cartesians === 'undefined') {
            cartesians = [];
            this.cartesian = cartesians;
            var sphericals = this.spherical;
            for ( var i = 0, len = sphericals.length; i < len; i++) {
                cartesians.push(Cartesian3.fromSpherical(sphericals[i]));
            }
        }
        return cartesians;
    };

    /**
     * A dynamic property which maintains an array of directions that can change over time.
     * The directions can be represented as both Cartesian and Spherical coordinates.
     * Rather than creating instances of this object directly, it's typically
     * created and managed via loading CZML data into a DynamicObjectCollection.
     * Instances of this type are exposed via DynamicObject and it's sub-objects
     * and are responsible for interpreting and interpolating the data for visualization.
     * </p>
     *
     * @alias DynamicDirectionsProperty
     * @constructor
     *
     * @see DynamicObject
     * @see DynamicProperty
     * @see ReferenceProperty
     * @see DynamicMaterialProperty
     * @see DynamicPositionProperty
     * @see DynamicVertexPositionsProperty
     */
    var DynamicDirectionsProperty = function() {
        this._propertyIntervals = new TimeIntervalCollection();
    };

    /**
     * Processes the provided CZML interval or intervals into this property.
     *
     * @memberof DynamicDirectionsProperty
     *
     * @param {Object} czmlIntervals The CZML data to process.
     * @param {TimeInterval} [constrainedInterval] Constrains the processing so that any times outside of this interval are ignored.
     * @param {DynamicObjectCollection} dynamicObjectCollection The DynamicObjectCollection to be used as a target for resolving links within this property.
     */
    DynamicDirectionsProperty.prototype.processCzmlIntervals = function(czmlIntervals, constrainedInterval, dynamicObjectCollection) {
        if (Array.isArray(czmlIntervals)) {
            for ( var i = 0, len = czmlIntervals.length; i < len; i++) {
                this._addCzmlInterval(czmlIntervals[i], constrainedInterval, dynamicObjectCollection);
            }
        } else {
            this._addCzmlInterval(czmlIntervals, constrainedInterval, dynamicObjectCollection);
        }
    };

    /**
     * Retrieves the values at the supplied time as Spherical coordinates.
     * @memberof DynamicDirectionsProperty
     *
     * @param {JulianDate} time The time for which to retrieve the value.
     * @returns An array of spherical coordinates for the provided time.
     */
    DynamicDirectionsProperty.prototype.getValueSpherical = function(time) {
        var interval = this._propertyIntervals.findIntervalContainingDate(time);
        if (typeof interval === 'undefined') {
            return undefined;
        }
        return interval.data.getValueSpherical();
    };

    /**
     * Retrieves the values at the supplied time as unit cartesian coordinates.
     * @memberof DynamicDirectionsProperty
     *
     * @param {JulianDate} time The time for which to retrieve the value.
     * @returns An array of unit cartesian coordinates for the provided time.
     */
    DynamicDirectionsProperty.prototype.getValueCartesian = function(time) {
        var interval = this._propertyIntervals.findIntervalContainingDate(time);
        if (typeof interval === 'undefined') {
            return undefined;
        }
        return interval.data.getValueCartesian();
    };

    DynamicDirectionsProperty.prototype._addCzmlInterval = function(czmlInterval, constrainedInterval, dynamicObjectCollection) {
        var iso8601Interval = czmlInterval.interval;
        if (typeof iso8601Interval === 'undefined') {
            iso8601Interval = Iso8601.MAXIMUM_INTERVAL.clone();
        } else {
            iso8601Interval = TimeInterval.fromIso8601(iso8601Interval);
        }

        if (typeof constrainedInterval !== 'undefined') {
            iso8601Interval = iso8601Interval.intersect(constrainedInterval);
        }

        //See if we already have data at that interval.
        var thisIntervals = this._propertyIntervals;
        var existingInterval = thisIntervals.findInterval(iso8601Interval.start, iso8601Interval.stop);

        //If not, create it.
        if (typeof existingInterval === 'undefined') {
            existingInterval = iso8601Interval;
            thisIntervals.addInterval(existingInterval);
        }

        existingInterval.data = new ValueHolder(czmlInterval);
    };

    return DynamicDirectionsProperty;
});
/*global define*/
define('DynamicScene/DynamicProperty',[
        '../Core/DeveloperError',
        '../Core/JulianDate',
        '../Core/TimeInterval',
        '../Core/TimeIntervalCollection',
        '../Core/Iso8601',
        '../Core/binarySearch',
        '../Core/HermitePolynomialApproximation',
        '../Core/LinearApproximation',
        '../Core/LagrangePolynomialApproximation'
    ], function(
        DeveloperError,
        JulianDate,
        TimeInterval,
        TimeIntervalCollection,
        Iso8601,
        binarySearch,
        HermitePolynomialApproximation,
        LinearApproximation,
        LagrangePolynomialApproximation) {
    

    //CZML_TODO This is more of an idea than a to-do, but currently DynamicProperty requires
    //you know the type of data being loaded up-front by passing valueType.  We could take
    //a similar approach to DynamicMaterialProperty and have a list of potential valueTypes
    //that we check for when we encounter data.  This would make it possible to support
    //properties that are defined in a CZML document but not part of the official spec.  This
    //would be helpful in cases where a CZML document has $ or # links to other properties,
    //but that property itself is not part of another to-spec CZML object.  We could still
    //allow the user to pass a default valueType if they want to make sure the data
    //being processed is only the data of the expected type.

    //Map CZML interval types to their implementation.
    var interpolators = {
            HERMITE : HermitePolynomialApproximation,
            LAGRANGE : LagrangePolynomialApproximation,
            LINEAR : LinearApproximation
        };

    //The data associated with each DynamicProperty interval.
    function IntervalData() {
        this.interpolationAlgorithm = LinearApproximation;
        this.numberOfPoints = LinearApproximation.getRequiredDataPoints(1);
        this.interpolationDegree = 1;
        this.times = undefined;
        this.values = undefined;
        this.isSampled = false;
        this.xTable = undefined;
        this.yTable = undefined;
    }

    //Converts a CZML defined data into a JulianDate, regardless of whether it was
    //specified in epoch seconds or as an ISO8601 string.
    function czmlDateToJulianDate(date, epoch) {
        if (typeof date === 'string') {
            return JulianDate.fromIso8601(date);
        }
        return epoch.addSeconds(date);
    }

    /**
     * <p>
     * DynamicProperty represents a single value that changes over time.
     * Rather than creating instances of this object directly, it's typically
     * created and managed via loading CZML data into a DynamicObjectCollection.
     * Instances of this type are exposed via DynamicObject and it's sub-objects
     * and are responsible for interpreting and interpolating the data for visualization.
     * </p>
     * <p>
     * The type of value exposed by this property must be provided during construction
     * by passing in an object which performs all the necessary operations needed to
     * properly store, retrieve, and interpolate the data.  For more specialized needs
     * other types of dynamic properties exist, such as DynamicMaterialProperty,
     * which as the name implies, handles materials.
     * </p>
     *
     * @alias DynamicProperty
     * @constructor
     *
     * @param {Object} valueType A CZML type object which contains the methods needed to interpret and interpolate CZML data of the same type.
     *
     * @see CzmlBoolean
     * @see CzmlCartesian2
     * @see CzmlCartesian3
     * @see CzmlCartographic
     * @see CzmlColor
     * @see CzmlHorizontalOrigin
     * @see CzmlLabelStyle
     * @see CzmlNumber
     * @see CzmlString
     * @see CzmlUnitCartesian3
     * @see CzmlUnitQuaternion
     * @see CzmlUnitSpherical
     * @see CzmlVerticalOrigin
     * @see DynamicObject
     * @see ReferenceProperty
     * @see DynamicMaterialProperty
     * @see DynamicPositionProperty
     * @see DynamicDirectionsProperty
     * @see DynamicVertexPositionsProperty
     */
    var DynamicProperty = function(valueType) {
        if (typeof valueType === 'undefined') {
            throw new DeveloperError('valueType is required.');
        }
        this.valueType = valueType;
        this._intervals = new TimeIntervalCollection();
        this._cachedDate = undefined;
        this._cachedInterval = undefined;
    };

    /**
     * Processes the provided CZML interval or intervals into this property.
     *
     * @memberof DynamicProperty
     *
     * @param {Object} czmlIntervals The CZML data to process.
     * @param {TimeInterval} [constrainedInterval] Constrains the processing so that any times outside of this interval are ignored.
     * @param {String} [sourceUri] The originating url of the CZML being processed.
     */
    DynamicProperty.prototype.processCzmlIntervals = function(czmlIntervals, constrainedInterval, sourceUri) {
        if (Array.isArray(czmlIntervals)) {
            for ( var i = 0, len = czmlIntervals.length; i < len; i++) {
                this._addCzmlInterval(czmlIntervals[i], constrainedInterval, sourceUri);
            }
        } else {
            this._addCzmlInterval(czmlIntervals, constrainedInterval, sourceUri);
        }
    };

    /**
     * Returns the value of the property at the specified time.
     * @memberof DynamicProperty
     *
     * @param {JulianDate} time The time for which to retrieve the value.
     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
     * @returns The modified result parameter or a new instance if the result parameter was not supplied.
     */
    DynamicProperty.prototype.getValue = function(time, result) {
        var interval = this._cachedInterval;
        var thisValueType = this.valueType;
        var doublesPerValue = thisValueType.doublesPerValue;

        if (this._cachedDate !== time) {
            this._cachedDate = time;
            if (typeof interval === 'undefined' || !interval.contains(time)) {
                interval = this._intervals.findIntervalContainingDate(time);
                this._cachedInterval = interval;
            }
        }

        if (typeof interval === 'undefined') {
            return undefined;
        }

        var intervalData = interval.data;
        var times = intervalData.times;
        var values = intervalData.values;
        if (intervalData.isSampled && times.length >= 0 && values.length > 0) {
            var index = binarySearch(times, time, JulianDate.compare);

            if (index < 0) {
                index = ~index;

                if (index >= times.length) {
                    index = times.length - 1;
                }

                var firstIndex = 0;
                var lastIndex = times.length - 1;

                var degree = intervalData.numberOfPoints - 1;
                var pointsInCollection = lastIndex - firstIndex + 1;

                if (pointsInCollection < degree + 1) {
                    // Use the entire range.
                } else {
                    var computedFirstIndex = index - ((degree / 2) | 0) - 1;
                    if (computedFirstIndex < firstIndex) {
                        computedFirstIndex = firstIndex;
                    }
                    var computedLastIndex = computedFirstIndex + degree;
                    if (computedLastIndex > lastIndex) {
                        computedLastIndex = lastIndex;
                        computedFirstIndex = computedLastIndex - degree;
                        if (computedFirstIndex < firstIndex) {
                            computedFirstIndex = firstIndex;
                        }
                    }

                    firstIndex = computedFirstIndex;
                    lastIndex = computedLastIndex;
                }

                var length = lastIndex - firstIndex + 1;

                var doublesPerInterpolationValue = thisValueType.doublesPerInterpolationValue;
                var xTable = intervalData.xTable;
                var yTable = intervalData.yTable;

                if (typeof xTable === 'undefined') {
                    xTable = intervalData.xTable = new Array(intervalData.numberOfPoints);
                    yTable = intervalData.yTable = new Array(intervalData.numberOfPoints * doublesPerInterpolationValue);
                }

                // Build the tables
                for ( var i = 0; i < length; ++i) {
                    xTable[i] = times[lastIndex].getSecondsDifference(times[firstIndex + i]);
                }
                var specializedPackFunction = thisValueType.packValuesForInterpolation;
                if (typeof specializedPackFunction === 'undefined') {
                    var destinationIndex = 0;
                    var sourceIndex = firstIndex * doublesPerValue;
                    var stop = (lastIndex + 1) * doublesPerValue;

                    while (sourceIndex < stop) {
                        yTable[destinationIndex] = values[sourceIndex];
                        sourceIndex++;
                        destinationIndex++;
                    }
                } else {
                    specializedPackFunction(values, yTable, firstIndex, lastIndex);
                }

                // Interpolate!
                var x = times[lastIndex].getSecondsDifference(time);
                var interpolationResult = intervalData.interpolationAlgorithm.interpolateOrderZero(x, xTable, yTable, doublesPerInterpolationValue);

                var specializedGetFunction = thisValueType.getValueFromInterpolationResult;
                if (typeof specializedGetFunction === 'undefined') {
                    return thisValueType.getValueFromArray(interpolationResult, 0, result);
                }
                return specializedGetFunction(interpolationResult, result, values, firstIndex, lastIndex);
            }
            return thisValueType.getValueFromArray(intervalData.values, index * doublesPerValue, result);
        }
        return thisValueType.getValue(intervalData.values, result);
    };

    DynamicProperty._mergeNewSamples = function(epoch, times, values, newData, doublesPerValue, valueType) {
        var newDataIndex = 0, i, prevItem, timesInsertionPoint, valuesInsertionPoint, timesSpliceArgs, valuesSpliceArgs, currentTime, nextTime;
        while (newDataIndex < newData.length) {
            currentTime = czmlDateToJulianDate(newData[newDataIndex], epoch);
            timesInsertionPoint = binarySearch(times, currentTime, JulianDate.compare);

            if (timesInsertionPoint < 0) {
                //Doesn't exist, insert as many additional values as we can.
                timesInsertionPoint = ~timesInsertionPoint;
                timesSpliceArgs = [timesInsertionPoint, 0];

                valuesInsertionPoint = timesInsertionPoint * doublesPerValue;
                valuesSpliceArgs = [valuesInsertionPoint, 0];
                prevItem = undefined;
                nextTime = times[timesInsertionPoint + 1];
                while (newDataIndex < newData.length) {
                    currentTime = czmlDateToJulianDate(newData[newDataIndex], epoch);
                    if ((typeof prevItem !== 'undefined' && JulianDate.compare(prevItem, currentTime) >= 0) ||
                        (typeof nextTime !== 'undefined' && JulianDate.compare(currentTime, nextTime) >= 0)) {
                        break;
                    }
                    timesSpliceArgs.push(currentTime);
                    newDataIndex = newDataIndex + 1;
                    for (i = 0; i < doublesPerValue; i++) {
                        valuesSpliceArgs.push(newData[newDataIndex]);
                        newDataIndex = newDataIndex + 1;
                    }
                    prevItem = currentTime;
                }

                Array.prototype.splice.apply(values, valuesSpliceArgs);
                Array.prototype.splice.apply(times, timesSpliceArgs);
            } else {
                //Found an exact match
                for (i = 0; i < doublesPerValue; i++) {
                    newDataIndex++;
                    values[(timesInsertionPoint * doublesPerValue) + i] = newData[newDataIndex];
                }
                newDataIndex++;
            }
        }
    };

    DynamicProperty.prototype._addCzmlInterval = function(czmlInterval, constrainedInterval, sourceUri) {
        var iso8601Interval = czmlInterval.interval;
        if (typeof iso8601Interval === 'undefined') {
            iso8601Interval = Iso8601.MAXIMUM_INTERVAL;
        } else {
            iso8601Interval = TimeInterval.fromIso8601(iso8601Interval);
        }

        if (typeof constrainedInterval !== 'undefined') {
            iso8601Interval = iso8601Interval.intersect(constrainedInterval);
        }

        var unwrappedInterval = this.valueType.unwrapInterval(czmlInterval, sourceUri);
        if (typeof unwrappedInterval !== 'undefined') {
            this._addCzmlIntervalUnwrapped(iso8601Interval.start, iso8601Interval.stop, unwrappedInterval, czmlInterval.epoch, czmlInterval.interpolationAlgorithm, czmlInterval.interpolationDegree);
        }
    };

    DynamicProperty.prototype._addCzmlIntervalUnwrapped = function(start, stop, unwrappedInterval, epoch, interpolationAlgorithmType, interpolationDegree) {
        var thisIntervals = this._intervals;
        var existingInterval = thisIntervals.findInterval(start, stop);
        this._cachedDate = undefined;
        this._cachedInterval = undefined;

        var intervalData;
        if (typeof existingInterval === 'undefined') {
            intervalData = new IntervalData();
            existingInterval = new TimeInterval(start, stop, true, true, intervalData);
            thisIntervals.addInterval(existingInterval);
        } else {
            intervalData = existingInterval.data;
        }

        var thisValueType = this.valueType;
        if (thisValueType.isSampled(unwrappedInterval)) {
            var interpolationAlgorithm;
            if (typeof interpolationAlgorithmType !== 'undefined') {
                interpolationAlgorithm = interpolators[interpolationAlgorithmType];
                intervalData.interpolationAlgorithm = interpolationAlgorithm;
            }
            if (typeof interpolationAlgorithm !== 'undefined '&& typeof interpolationDegree !== 'undefined') {
                intervalData.interpolationDegree = interpolationDegree;
                intervalData.xTable = undefined;
                intervalData.yTable = undefined;
            }

            if (!intervalData.isSampled) {
                intervalData.times = [];
                intervalData.values = [];
                intervalData.isSampled = true;
            }
            if (typeof epoch !== 'undefined') {
                epoch = JulianDate.fromIso8601(epoch);
            }
            DynamicProperty._mergeNewSamples(epoch, intervalData.times, intervalData.values, unwrappedInterval, thisValueType.doublesPerValue, thisValueType);
            intervalData.numberOfPoints = Math.min(intervalData.interpolationAlgorithm.getRequiredDataPoints(intervalData.interpolationDegree), intervalData.times.length);
        } else {
            //Packet itself is a constant value
            intervalData.times = undefined;
            intervalData.values = unwrappedInterval;
            intervalData.isSampled = false;
        }
    };

    return DynamicProperty;
});
/*global define*/
define('DynamicScene/DynamicPoint',[
        '../Core/TimeInterval',
        './CzmlBoolean',
        './CzmlNumber',
        './CzmlColor',
        './DynamicProperty'
    ], function(
         TimeInterval,
         CzmlBoolean,
         CzmlNumber,
         CzmlColor,
         DynamicProperty) {
    

    /**
     * Represents a time-dynamic point, typically used in conjunction with DynamicPointVisualizer and
     * DynamicObjectCollection to visualize CZML.
     *
     * @alias DynamicPoint
     * @constructor
     *
     * @see DynamicObject
     * @see DynamicProperty
     * @see DynamicObjectCollection
     * @see DynamicPointVisualizer
     * @see VisualizerCollection
     * @see Billboard
     * @see BillboardCollection
     * @see CzmlDefaults
     */
    var DynamicPoint = function() {
        /**
         * A DynamicProperty of type CzmlColor which determines the point's color.
         */
        this.color = undefined;
        /**
         * A DynamicProperty of type CzmlNumber which determines the point's pixel size.
         */
        this.pixelSize = undefined;
        /**
         * A DynamicProperty of type CzmlColor which determines the point's outline color.
         */
        this.outlineColor = undefined;
        /**
         * A DynamicProperty of type CzmlNumber which determines the point's outline width.
         */
        this.outlineWidth = undefined;
        /**
         * A DynamicProperty of type CzmlBoolean which determines the point's visibility.
         */
        this.show = undefined;
    };

    /**
     * Processes a single CZML packet and merges its data into the provided DynamicObject's point.
     * If the DynamicObject does not have a point, one is created.  This method is not
     * normally called directly, but is part of the array of CZML processing functions that is
     * passed into the DynamicObjectCollection constructor.
     *
     * @param {DynamicObject} dynamicObject The DynamicObject which will contain the point data.
     * @param {Object} packet The CZML packet to process.
     * @returns {Boolean} true if any new properties were created while processing the packet, false otherwise.
     *
     * @see DynamicObject
     * @see DynamicProperty
     * @see DynamicObjectCollection
     * @see CzmlDefaults#updaters
     */
    DynamicPoint.processCzmlPacket = function(dynamicObject, packet) {
        var pointData = packet.point;
        if (typeof pointData === 'undefined') {
            return false;
        }

        var pointUpdated = false;
        var point = dynamicObject.point;
        pointUpdated = typeof point === 'undefined';
        if (pointUpdated) {
            dynamicObject.point = point = new DynamicPoint();
        }

        var interval = pointData.interval;
        if (typeof interval !== 'undefined') {
            interval = TimeInterval.fromIso8601(interval);
        }

        if (typeof pointData.color !== 'undefined') {
            var color = point.color;
            if (typeof color === 'undefined') {
                point.color = color = new DynamicProperty(CzmlColor);
                pointUpdated = true;
            }
            color.processCzmlIntervals(pointData.color, interval);
        }

        if (typeof pointData.pixelSize !== 'undefined') {
            var pixelSize = point.pixelSize;
            if (typeof pixelSize === 'undefined') {
                point.pixelSize = pixelSize = new DynamicProperty(CzmlNumber);
                pointUpdated = true;
            }
            pixelSize.processCzmlIntervals(pointData.pixelSize, interval);
        }

        if (typeof pointData.outlineColor !== 'undefined') {
            var outlineColor = point.outlineColor;
            if (typeof outlineColor === 'undefined') {
                point.outlineColor = outlineColor = new DynamicProperty(CzmlColor);
                pointUpdated = true;
            }
            outlineColor.processCzmlIntervals(pointData.outlineColor, interval);
        }

        if (typeof pointData.outlineWidth !== 'undefined') {
            var outlineWidth = point.outlineWidth;
            if (typeof outlineWidth === 'undefined') {
                point.outlineWidth = outlineWidth = new DynamicProperty(CzmlNumber);
                pointUpdated = true;
            }
            outlineWidth.processCzmlIntervals(pointData.outlineWidth, interval);
        }

        if (typeof pointData.show !== 'undefined') {
            var show = point.show;
            if (typeof show === 'undefined') {
                point.show = show = new DynamicProperty(CzmlBoolean);
                pointUpdated = true;
            }
            show.processCzmlIntervals(pointData.show, interval);
        }
        return pointUpdated;
    };

    /**
     * Given two DynamicObjects, takes the point properties from the second
     * and assigns them to the first, assuming such a property did not already exist.
     * This method is not normally called directly, but is part of the array of CZML processing
     * functions that is passed into the CompositeDynamicObjectCollection constructor.
     *
     * @param {DynamicObject} targetObject The DynamicObject which will have properties merged onto it.
     * @param {DynamicObject} objectToMerge The DynamicObject containing properties to be merged.
     *
     * @see CzmlDefaults
     */
    DynamicPoint.mergeProperties = function(targetObject, objectToMerge) {
        var pointToMerge = objectToMerge.point;
        if (typeof pointToMerge !== 'undefined') {

            var targetPoint = targetObject.point;
            if (typeof targetPoint === 'undefined') {
                targetObject.point = targetPoint = new DynamicPoint();
            }

            targetPoint.color = targetPoint.color || pointToMerge.color;
            targetPoint.pixelSize = targetPoint.pixelSize || pointToMerge.pixelSize;
            targetPoint.outlineColor = targetPoint.outlineColor || pointToMerge.outlineColor;
            targetPoint.outlineWidth = targetPoint.outlineWidth || pointToMerge.outlineWidth;
            targetPoint.show = targetPoint.show || pointToMerge.show;
        }
    };

    /**
     * Given a DynamicObject, undefines the point associated with it.
     * This method is not normally called directly, but is part of the array of CZML processing
     * functions that is passed into the CompositeDynamicObjectCollection constructor.
     *
     * @param {DynamicObject} dynamicObject The DynamicObject to remove the point from.
     *
     * @see CzmlDefaults
     */
    DynamicPoint.undefineProperties = function(dynamicObject) {
        dynamicObject.point = undefined;
    };

    return DynamicPoint;
});
/*global define*/
define('DynamicScene/DynamicPolyline',[
        '../Core/TimeInterval',
        './CzmlBoolean',
        './CzmlNumber',
        './CzmlColor',
        './DynamicProperty'],
function(
        TimeInterval,
        CzmlBoolean,
        CzmlNumber,
        CzmlColor,
        DynamicProperty) {
    

    /**
     * Represents a time-dynamic polyline, typically used in conjunction with DynamicPolylineVisualizer and
     * DynamicObjectCollection to visualize CZML.
     *
     * @alias DynamicPolyline
     * @constructor
     *
     * @see DynamicObject
     * @see DynamicProperty
     * @see DynamicObjectCollection
     * @see DynamicPolylineVisualizer
     * @see VisualizerCollection
     * @see Polyline
     * @see CzmlDefaults
     */
    var DynamicPolyline = function() {
        /**
         * A DynamicProperty of type CzmlColor which determines the line's color.
         */
        this.color = undefined;
        /**
         * A DynamicProperty of type CzmlColor which determines the line's outline color.
         */
        this.outlineColor = undefined;
        /**
         * A DynamicProperty of type CzmlNumber which determines the line's outline width.
         */
        this.outlineWidth = undefined;
        /**
         * A DynamicProperty of type CzmlBoolean which determines the lines's visibility.
         */
        this.show = undefined;
        /**
         * A DynamicProperty of type CzmlNumber which determines the line's width.
         */
        this.width = undefined;
    };

    /**
     * Processes a single CZML packet and merges its data into the provided DynamicObject's polyline.
     * If the DynamicObject does not have a polyline, one is created.  This method is not
     * normally called directly, but is part of the array of CZML processing functions that is
     * passed into the DynamicObjectCollection constructor.
     *
     * @param {DynamicObject} dynamicObject The DynamicObject which will contain the polyline data.
     * @param {Object} packet The CZML packet to process.
     * @returns {Boolean} true if any new properties were created while processing the packet, false otherwise.
     *
     * @see DynamicObject
     * @see DynamicProperty
     * @see DynamicObjectCollection
     * @see CzmlDefaults#updaters
     */
    DynamicPolyline.processCzmlPacket = function(dynamicObject, packet) {
        var polylineData = packet.polyline;
        if (typeof polylineData === 'undefined') {
            return false;
        }

        var polylineUpdated = false;
        var polyline = dynamicObject.polyline;
        polylineUpdated = typeof polyline === 'undefined';
        if (polylineUpdated) {
            dynamicObject.polyline = polyline = new DynamicPolyline();
        }

        var interval = polylineData.interval;
        if (typeof interval !== 'undefined') {
            interval = TimeInterval.fromIso8601(interval);
        }

        if (typeof polylineData.color !== 'undefined') {
            var color = polyline.color;
            if (typeof color === 'undefined') {
                polyline.color = color = new DynamicProperty(CzmlColor);
                polylineUpdated = true;
            }
            color.processCzmlIntervals(polylineData.color, interval);
        }

        if (typeof polylineData.width !== 'undefined') {
            var width = polyline.width;
            if (typeof width === 'undefined') {
                polyline.width = width = new DynamicProperty(CzmlNumber);
                polylineUpdated = true;
            }
            width.processCzmlIntervals(polylineData.width, interval);
        }

        if (typeof polylineData.outlineColor !== 'undefined') {
            var outlineColor = polyline.outlineColor;
            if (typeof outlineColor === 'undefined') {
                polyline.outlineColor = outlineColor = new DynamicProperty(CzmlColor);
                polylineUpdated = true;
            }
            outlineColor.processCzmlIntervals(polylineData.outlineColor, interval);
        }

        if (typeof polylineData.outlineWidth !== 'undefined') {
            var outlineWidth = polyline.outlineWidth;
            if (typeof outlineWidth === 'undefined') {
                polyline.outlineWidth = outlineWidth = new DynamicProperty(CzmlNumber);
                polylineUpdated = true;
            }
            outlineWidth.processCzmlIntervals(polylineData.outlineWidth, interval);
        }

        if (typeof polylineData.show !== 'undefined') {
            var show = polyline.show;
            if (typeof show === 'undefined') {
                polyline.show = show = new DynamicProperty(CzmlBoolean);
                polylineUpdated = true;
            }
            show.processCzmlIntervals(polylineData.show, interval);
        }
        return polylineUpdated;
    };

    /**
     * Given two DynamicObjects, takes the polyline properties from the second
     * and assigns them to the first, assuming such a property did not already exist.
     * This method is not normally called directly, but is part of the array of CZML processing
     * functions that is passed into the CompositeDynamicObjectCollection constructor.
     *
     * @param {DynamicObject} targetObject The DynamicObject which will have properties merged onto it.
     * @param {DynamicObject} objectToMerge The DynamicObject containing properties to be merged.
     *
     * @see CzmlDefaults
     */
    DynamicPolyline.mergeProperties = function(targetObject, objectToMerge) {
        var polylineToMerge = objectToMerge.polyline;
        if (typeof polylineToMerge !== 'undefined') {

            var targetPolyline = targetObject.polyline;
            if (typeof targetPolyline === 'undefined') {
                targetObject.polyline = targetPolyline = new DynamicPolyline();
            }

            targetPolyline.color = targetPolyline.color || polylineToMerge.color;
            targetPolyline.width = targetPolyline.width || polylineToMerge.width;
            targetPolyline.outlineColor = targetPolyline.outlineColor || polylineToMerge.outlineColor;
            targetPolyline.outlineWidth = targetPolyline.outlineWidth || polylineToMerge.outlineWidth;
            targetPolyline.show = targetPolyline.show || polylineToMerge.show;
        }
    };

    /**
     * Given a DynamicObject, undefines the polyline associated with it.
     * This method is not normally called directly, but is part of the array of CZML processing
     * functions that is passed into the CompositeDynamicObjectCollection constructor.
     *
     * @param {DynamicObject} dynamicObject The DynamicObject to remove the polyline from.
     *
     * @see CzmlDefaults
     */
    DynamicPolyline.undefineProperties = function(dynamicObject) {
        dynamicObject.polyline = undefined;
    };

    return DynamicPolyline;
});
/*global define*/
define('DynamicScene/DynamicPositionProperty',[
        '../Core/DeveloperError',
        '../Core/Ellipsoid',
        '../Core/JulianDate',
        '../Core/TimeInterval',
        '../Core/TimeIntervalCollection',
        '../Core/Iso8601',
        '../Core/Cartesian3',
        '../Core/Cartographic',
        './CzmlCartesian3',
        './CzmlCartographic',
        './DynamicProperty'
    ], function(
        DeveloperError,
        Ellipsoid,
        JulianDate,
        TimeInterval,
        TimeIntervalCollection,
        Iso8601,
        Cartesian3,
        Cartographic,
        CzmlCartesian3,
        CzmlCartographic,
        DynamicProperty) {
    

    var wgs84 = Ellipsoid.WGS84;
    var potentialTypes = [CzmlCartesian3, CzmlCartographic];

    /**
     * A dynamic property which stores both Cartesian and Cartographic data
     * and can convert and return the desired type of data for a desired time.
     * Rather than creating instances of this object directly, it's typically
     * created and managed via loading CZML data into a DynamicObjectCollection.
     * Instances of this type are exposed via DynamicObject and it's sub-objects
     * and are responsible for interpreting and interpolating the data for visualization.
     *
     * @alias DynamicPositionProperty
     * @constructor
     *
     * @see DynamicObject
     * @see DynamicProperty
     * @see ReferenceProperty
     * @see DynamicMaterialProperty
     * @see DynamicDirectionsProperty
     * @see DynamicVertexPositionsProperty
     */
    var DynamicPositionProperty = function() {
        this._dynamicProperties = [];
        this._propertyIntervals = new TimeIntervalCollection();
        this._cachedTime = undefined;
        this._cachedInterval = undefined;
    };

    /**
     * Processes the provided CZML interval or intervals into this property.
     *
     * @memberof DynamicPositionProperty
     *
     * @param {Object} czmlIntervals The CZML data to process.
     * @param {TimeInterval} [constrainedInterval] Constrains the processing so that any times outside of this interval are ignored.
     */
    DynamicPositionProperty.prototype.processCzmlIntervals = function(czmlIntervals, constrainedInterval) {
        if (Array.isArray(czmlIntervals)) {
            for ( var i = 0, len = czmlIntervals.length; i < len; i++) {
                this._addCzmlInterval(czmlIntervals[i], constrainedInterval);
            }
        } else {
            this._addCzmlInterval(czmlIntervals, constrainedInterval);
        }
    };

    /**
     * Retrieves the value of the object at the supplied time as a Cartographic.
     * @memberof DynamicPositionProperty
     *
     * @param {JulianDate} time The time for which to retrieve the value.
     * @param {Cartographic} [result] The object to store the result onto, if undefined a new instance will be created.
     * @returns The modified result property, or a new instance if result was undefined.
     */
    DynamicPositionProperty.prototype.getValueCartographic = function(time, result) {
        if (typeof time === 'undefined') {
            throw new DeveloperError('time is required.');
        }

        var interval = this._cachedInterval;
        if (this._cachedTime !== time) {
            this._cachedTime = time;
            if (typeof interval === 'undefined' || !interval.contains(time)) {
                interval = this._propertyIntervals.findIntervalContainingDate(time);
                this._cachedInterval = interval;
            }
        }

        if (typeof interval === 'undefined') {
            return undefined;
        }
        var property = interval.data;
        var valueType = property.valueType;
        if (valueType === CzmlCartographic) {
            return property.getValue(time, result);
        }
        result = interval.cachedValue = property.getValue(time, interval.cachedValue);
        if (typeof result !== 'undefined') {
            result = wgs84.cartesianToCartographic(result);
        }
        return result;
    };

    /**
     * Retrieves the value of the object at the supplied time as a Cartesian3.
     * @memberof DynamicPositionProperty
     *
     * @param {JulianDate} time The time for which to retrieve the value.
     * @param {Cartesian3} [result] The object to store the result onto, if undefined a new instance will be created.
     * @returns The modified result property, or a new instance if result was undefined.
     */
    DynamicPositionProperty.prototype.getValueCartesian = function(time, result) {
        if (typeof time === 'undefined') {
            throw new DeveloperError('time is required.');
        }

        var interval = this._cachedInterval;
        if (this._cachedTime !== time) {
            this._cachedTime = time;
            if (typeof interval === 'undefined' || !interval.contains(time)) {
                interval = this._propertyIntervals.findIntervalContainingDate(time);
                this._cachedInterval = interval;
            }
        }

        if (typeof interval === 'undefined') {
            return undefined;
        }
        var property = interval.data;
        var valueType = property.valueType;
        if (valueType === CzmlCartesian3) {
            return property.getValue(time, result);
        }
        result = interval.cachedValue = property.getValue(time, interval.cachedValue);
        if (typeof result !== 'undefined') {
            result = wgs84.cartographicToCartesian(result);
        }
        return result;
    };

    DynamicPositionProperty.prototype._addCzmlInterval = function(czmlInterval, constrainedInterval) {
        this._cachedTime = undefined;
        this._cachedInterval = undefined;

        var iso8601Interval = czmlInterval.interval, property, valueType, unwrappedInterval;
        if (typeof iso8601Interval === 'undefined') {
            iso8601Interval = Iso8601.MAXIMUM_INTERVAL.clone();
        } else {
            iso8601Interval = TimeInterval.fromIso8601(iso8601Interval);
        }

        if (typeof constrainedInterval !== 'undefined') {
            iso8601Interval = iso8601Interval.intersect(constrainedInterval);
        }

        //See if we already have data at that interval.
        var thisIntervals = this._propertyIntervals;
        var existingInterval = thisIntervals.findInterval(iso8601Interval.start, iso8601Interval.stop);

        if (typeof existingInterval !== 'undefined') {
            //If so, see if the new data is the same type.
            property = existingInterval.data;
            if (typeof property !== 'undefined') {
                valueType = property.valueType;
                unwrappedInterval = valueType.unwrapInterval(czmlInterval);
            }
        } else {
            //If not, create it.
            existingInterval = iso8601Interval;
            thisIntervals.addInterval(existingInterval);
        }

        //If the new data was a different type, unwrapping fails, look for a valueType for this type.
        if (typeof unwrappedInterval === 'undefined') {
            for ( var i = 0, len = potentialTypes.length; i < len; i++) {
                valueType = potentialTypes[i];
                unwrappedInterval = valueType.unwrapInterval(czmlInterval);
                if (typeof unwrappedInterval !== 'undefined') {
                    property = undefined;
                    //Found a valid valueType, but lets check to see if we already have a property with that valueType
                    for ( var q = 0, lenQ = this._dynamicProperties.length; q < lenQ; q++) {
                        if (this._dynamicProperties[q].valueType === valueType) {
                            property = this._dynamicProperties[q];
                            break;
                        }
                    }
                    //If we don't have the property, create it.
                    if (typeof property === 'undefined') {
                        property = new DynamicProperty(valueType);
                        this._dynamicProperties.push(property);
                        //Save the property in our interval.
                        existingInterval.data = property;
                    }
                    break;
                }
            }
        }

        //We could handle the data, add it to the property.
        if (typeof unwrappedInterval !== 'undefined') {
            property._addCzmlIntervalUnwrapped(iso8601Interval.start, iso8601Interval.stop, unwrappedInterval, czmlInterval.epoch, czmlInterval.interpolationAlgorithm,
                    czmlInterval.interpolationDegree);
        }
    };

    return DynamicPositionProperty;
});
/*global define*/
define('DynamicScene/ReferenceProperty',[
        '../Core/DeveloperError'
       ], function(
         DeveloperError) {
    

    function resolve(referenceProperty) {
        var targetProperty = referenceProperty._targetProperty;
        if (typeof targetProperty === 'undefined') {
            var resolveBuffer = referenceProperty._dynamicObjectCollection.compositeCollection || referenceProperty._dynamicObjectCollection;
            var targetObject = resolveBuffer.getObject(referenceProperty._targetObjectId);
            if (typeof targetObject !== 'undefined') {
                targetProperty = targetObject[referenceProperty._targetPropertyName];
                referenceProperty._targetProperty = targetProperty;
            }
        }
        return targetProperty;
    }

    /**
     * A dynamic property which transparently links to another property, which may
     * or may not exist yet.  It is up to the caller to know which kind of property
     * is being linked to.
     *
     * @alias ReferenceProperty
     * @constructor
     *
     * @param {DynamicObjectCollection} dynamicObjectCollection The object collection which will be used to resolve the reference.
     * @param {String} targetObjectId The id of the object which is being referenced.
     * @param {String} targetPropertyName The name of the property on the target object which we will use.
     *
     * @exception {DeveloperError} dynamicObjectCollection is required.
     * @exception {DeveloperError} targetObjectId is required.
     * @exception {DeveloperError} targetPropertyName is required.
     *
     * @see ReferenceProperty#fromString
     * @see DynamicProperty
     * @see DynamicPositionProperty
     * @see DynamicDirectionsProperty
     * @see DynamicVertexPositionsProperty
     * @see DynamicObjectCollection
     * @see CompositeDynamicObjectCollection
     */
    var ReferenceProperty = function(dynamicObjectCollection, targetObjectId, targetPropertyName) {
        if (typeof dynamicObjectCollection === 'undefined') {
            throw new DeveloperError('dynamicObjectCollection is required.');
        }
        if (typeof targetObjectId === 'undefined') {
            throw new DeveloperError('targetObjectId is required.');
        }
        if (typeof targetPropertyName === 'undefined') {
            throw new DeveloperError('targetPropertyName is required.');
        }

        this._targetProperty = undefined;
        this._dynamicObjectCollection = dynamicObjectCollection;
        this._targetObjectId = targetObjectId;
        this._targetPropertyName = targetPropertyName;
    };

    /**
     * Creates a new reference property given the dynamic object collection that will
     * be used to resolve it and a string indicating the target object id and property,
     * delineated by a period.
     *
     * @param {DynamicObject} dynamicObjectCollection
     * @param referenceString
     *
     * @exception {DeveloperError} dynamicObjectCollection is required.
     * @exception {DeveloperError} referenceString is required.
     * @exception {DeveloperError} referenceString must contain a single . delineating the target object ID and property name.
     *
     * @see ReferenceProperty#fromString
     * @see DynamicProperty
     * @see DynamicPositionProperty
     * @see DynamicDirectionsProperty
     * @see DynamicVertexPositionsProperty
     * @see DynamicObjectCollection
     * @see CompositeDynamicObjectCollection
     *
     * @returns A new instance of ReferenceProperty.
     */
    ReferenceProperty.fromString = function(dynamicObjectCollection, referenceString) {
        if (typeof dynamicObjectCollection === 'undefined') {
            throw new DeveloperError('dynamicObjectCollection is required.');
        }

        if (typeof referenceString === 'undefined') {
            throw new DeveloperError('referenceString is required.');
        }

        var parts = referenceString.split('.');
        if (parts.length !== 2) {
            throw new DeveloperError('referenceString must contain a single . delineating the target object ID and property name.');
        }

        return new ReferenceProperty(dynamicObjectCollection, parts[0], parts[1]);
    };

    /**
     * Retrieves the value of the property at the specified time.
     *
     * @param time The time to evaluate the property.
     * @param [result] The object to store the result in, if undefined a new instance will be created.
     * @returns The result parameter or a new instance if the parameter was omitted.
     */
    ReferenceProperty.prototype.getValue = function(time, result) {
        var targetProperty = resolve(this);
        return typeof targetProperty !== 'undefined' ? targetProperty.getValue(time, result) : undefined;
    };

    /**
     * Retrieves the Cartographic value or values of the property at the specified time if the linked property
     * is a DynamicPositionProperty or DynamicVertexPositionsProperty.
     *
     * @param time The time to evaluate the property.
     * @param [result] The object to store the result in, if undefined a new instance will be created.
     * @returns The result parameter or a new instance if the parameter was omitted.
     */
    ReferenceProperty.prototype.getValueCartographic = function(time, result) {
        var targetProperty = resolve(this);
        return typeof targetProperty !== 'undefined' ? targetProperty.getValueCartographic(time, result) : undefined;
    };

    /**
     * Retrieves the Cartesian value or values of the property at the specified time if the linked property
     * is a DynamicPositionProperty, DynamicVertexPositionsProperty, or DynamicDirectionsProperty.
     *
     * @param time The time to evaluate the property.
     * @param [result] The object to store the result in, if undefined a new instance will be created.
     * @returns The result parameter or a new instance if the parameter was omitted.
     */
    ReferenceProperty.prototype.getValueCartesian = function(time, result) {
        var targetProperty = resolve(this);
        return typeof targetProperty !== 'undefined' ? targetProperty.getValueCartesian(time, result) : undefined;
    };

    /**
     * Retrieves the Spherical value or values of the property at the specified time if the linked property
     * is a DynamicDirectionsProperty.
     *
     * @param time The time to evaluate the property.
     * @param [result] The object to store the result in, if undefined a new instance will be created.
     * @returns The result parameter or a new instance if the parameter was omitted.
     */
    ReferenceProperty.prototype.getValueSpherical = function(time, result) {
        var targetProperty = resolve(this);
        return typeof targetProperty !== 'undefined' ? targetProperty.getValueSpherical(time, result) : undefined;
    };

    return ReferenceProperty;
});
/*global define*/
define('DynamicScene/DynamicVertexPositionsProperty',[
        '../Core/JulianDate',
        '../Core/TimeInterval',
        '../Core/TimeIntervalCollection',
        '../Core/Cartesian3',
        '../Core/Cartographic',
        '../Core/Iso8601',
        '../Core/Ellipsoid',
        './ReferenceProperty',
        './DynamicPositionProperty'
    ], function(
        JulianDate,
        TimeInterval,
        TimeIntervalCollection,
        Cartesian3,
        Cartographic,
        Iso8601,
        Ellipsoid,
        ReferenceProperty,
        DynamicPositionProperty) {
    

    var wgs84 = Ellipsoid.WGS84;

    function ValueHolder(czmlInterval) {
        var i, len, values = [], tmp;

        tmp = czmlInterval.cartesian;
        if (typeof tmp !== 'undefined') {
            for (i = 0, len = tmp.length; i < len; i += 3) {
                values.push(new Cartesian3(tmp[i], tmp[i + 1], tmp[i + 2]));
            }
            this.cartesian = values;
        } else {
            tmp = czmlInterval.cartographicRadians;
            if (typeof tmp !== 'undefined') {
                for (i = 0, len = tmp.length; i < len; i += 3) {
                    values.push(new Cartographic(tmp[i], tmp[i + 1], tmp[i + 2]));
                }
                this.cartographic = values;
            } else {
                tmp = czmlInterval.cartographicDegrees;
                if (typeof tmp !== 'undefined') {
                    for (i = 0, len = tmp.length; i < len; i += 3) {
                        values.push(Cartographic.fromDegrees(tmp[i], tmp[i + 1], tmp[i + 2]));
                    }
                    this.cartographic = values;
                }
            }
        }
    }

    ValueHolder.prototype.getValueCartographic = function() {
        if (typeof this.cartographic === 'undefined') {
            this.cartographic = wgs84.cartesianArrayToCartographicArray(this.cartesian);
        }
        return this.cartographic;
    };

    ValueHolder.prototype.getValueCartesian = function() {
        if (typeof this.cartesian === 'undefined') {
            this.cartesian = wgs84.cartographicArrayToCartesianArray(this.cartographic);
        }
        return this.cartesian;
    };

    /**
     * A dynamic property which maintains an array of positions that can change over time.
     * The positions can be represented as both Cartesian and Cartographic coordinates.
     * Rather than creating instances of this object directly, it's typically
     * created and managed via loading CZML data into a DynamicObjectCollection.
     * Instances of this type are exposed via DynamicObject and it's sub-objects
     * and are responsible for interpreting and interpolating the data for visualization.
     *
     * @alias DynamicVertexPositionsProperty
     * @internalconstructor
     *
     * @see DynamicObject
     * @see DynamicProperty
     * @see ReferenceProperty
     * @see DynamicMaterialProperty
     * @see DynamicPositionProperty
     * @see DynamicDirectionsProperty
     */
    var DynamicVertexPositionsProperty = function() {
        this._propertyIntervals = new TimeIntervalCollection();
    };

    /**
     * Processes the provided CZML interval or intervals into this property.
     *
     * @memberof DynamicVertexPositionsProperty
     *
     * @param {Object} czmlIntervals The CZML data to process.
     * @param {TimeInterval} [constrainedInterval] Constrains the processing so that any times outside of this interval are ignored.
     * @param {DynamicObjectCollection} dynamicObjectCollection The DynamicObjectCollection to be used as a target for resolving links within this property.
     */
    DynamicVertexPositionsProperty.prototype.processCzmlIntervals = function(czmlIntervals, constrainedInterval, dynamicObjectCollection) {
        if (Array.isArray(czmlIntervals)) {
            for ( var i = 0, len = czmlIntervals.length; i < len; i++) {
                this._addCzmlInterval(czmlIntervals[i], constrainedInterval, dynamicObjectCollection);
            }
        } else {
            this._addCzmlInterval(czmlIntervals, constrainedInterval, dynamicObjectCollection);
        }
    };

    /**
     * Retrieves the values at the supplied time as Cartographic coordinates.
     * @memberof DynamicVertexPositionsProperty
     *
     * @param {JulianDate} time The time for which to retrieve the value.
     * @returns An array of Cartographic coordinates for the provided time.
     */
    DynamicVertexPositionsProperty.prototype.getValueCartographic = function(time) {
        var interval = this._propertyIntervals.findIntervalContainingDate(time);
        if (typeof interval === 'undefined') {
            return undefined;
        }
        var interval_data = interval.data;
        if (Array.isArray(interval_data)) {
            var result = [];
            for ( var i = 0, len = interval_data.length; i < len; i++) {
                var value = interval_data[i].getValueCartographic(time);
                if (typeof value !== 'undefined') {
                    result.push(value);
                }
            }
            return result;
        }

        return interval_data.getValueCartographic();

    };

    /**
     * Retrieves the values at the supplied time as Cartesian coordinates.
     * @memberof DynamicVertexPositionsProperty
     *
     * @param {JulianDate} time The time for which to retrieve the value.
     * @returns An array of Cartesian coordinates for the provided time.
     */
    DynamicVertexPositionsProperty.prototype.getValueCartesian = function(time) {
        var interval = this._propertyIntervals.findIntervalContainingDate(time);
        if (typeof interval === 'undefined') {
            return undefined;
        }
        var interval_data = interval.data;
        if (Array.isArray(interval_data)) {
            var result = [];
            for ( var i = 0, len = interval_data.length; i < len; i++) {
                var value = interval_data[i].getValueCartesian(time);
                if (typeof value !== 'undefined') {
                    result.push(value);
                }
            }
            return result;
        }

        return interval_data.getValueCartesian();
    };

    DynamicVertexPositionsProperty.prototype._addCzmlInterval = function(czmlInterval, constrainedInterval, dynamicObjectCollection) {
        var iso8601Interval = czmlInterval.interval;
        if (typeof iso8601Interval === 'undefined') {
            iso8601Interval = Iso8601.MAXIMUM_INTERVAL.clone();
        } else {
            iso8601Interval = TimeInterval.fromIso8601(iso8601Interval);
        }

        if (typeof constrainedInterval !== 'undefined') {
            iso8601Interval = iso8601Interval.intersect(constrainedInterval);
        }

        //See if we already have data at that interval.
        var thisIntervals = this._propertyIntervals;
        var existingInterval = thisIntervals.findInterval(iso8601Interval.start, iso8601Interval.stop);

        //If not, create it.
        if (typeof existingInterval === 'undefined') {
            existingInterval = iso8601Interval;
            thisIntervals.addInterval(existingInterval);
        }

        var references = czmlInterval.references;
        if (typeof references === 'undefined') {
            existingInterval.data = new ValueHolder(czmlInterval);
        } else {
            var properties = [];
            for ( var i = 0, len = references.length; i < len; i++) {
                properties.push(ReferenceProperty.fromString(dynamicObjectCollection, references[i]));
            }
            existingInterval.data = properties;
        }
    };

    return DynamicVertexPositionsProperty;
});
/*global define*/
define('DynamicScene/DynamicObject',[
        '../Core/createGuid',
        '../Core/DeveloperError',
        '../Core/TimeInterval',
        './DynamicProperty',
        './DynamicPositionProperty',
        './DynamicVertexPositionsProperty',
        './CzmlUnitQuaternion'
    ], function(
        createGuid,
        DeveloperError,
        TimeInterval,
        DynamicProperty,
        DynamicPositionProperty,
        DynamicVertexPositionsProperty,
        CzmlUnitQuaternion) {
    

    /**
     * DynamicObject instances are the primary data store for processed CZML data.
     * They are used primarily by the visualizers to create and maintain graphic
     * primitives that represent the DynamicObject's properties at a specific time.
     * @alias DynamicObject
     * @constructor
     *
     * @param {Object} [id] A unique identifier for this object.  If no id is provided, a GUID is generated.
     *
     * @see DynamicProperty
     * @see DynamicPositionProperty
     * @see DynamicVertexiPositionsProperty
     * @see DynamicObjectCollection
     * @see CompositeDynamicObjectCollection
     * @see DynamicBillboard
     * @see DynamicCone
     * @see DynamicLabel
     * @see DynamicPoint
     * @see DynamicPolygon
     * @see DynamicPolyline
     * @see DynamicPyramid
     */
    var DynamicObject = function(id) {
        this._cachedAvailabilityDate = undefined;
        this._cachedAvailabilityValue = undefined;

        /**
         * A unique id associated with this object.
         */
        this.id = id || createGuid();

        //Add standard CZML properties.  Even though they won't all be used
        //for each object, having the superset explicitly listed here will allow the
        //compiler to optimize this class.  It also allows us to document them.
        //Any changes to this list should coincide with changes to CzmlDefaults.updaters

        /**
         * The availability TimeInterval, if any, associated with this object.
         * If availability is undefined, it is assumed that this object's
         * other properties will return valid data for any provided time.
         * If availability exists, the objects other properties will only
         * provide valid data if queried within the given interval.
         */
        this.availability = undefined;

        /**
         * The DynamicPositionProperty, if any, associated with this object.
         */
        this.position = undefined;

        /**
         * The DynamicProperty with value type CzmlUnitQuaternion, if any, associated with this object.
         */
        this.orientation = undefined;

        /**
         * The DynamicBillboard, if any, associated with this object.
         */
        this.billboard = undefined;

        /**
         * The DynamicCone, if any, associated with this object.
         */
        this.cone = undefined;

        /**
         * The DynamicLabel, if any, associated with this object.
         */
        this.label = undefined;

        /**
         * The DynamicPoint, if any, associated with this object.
         */
        this.point = undefined;

        /**
         * The DynamicPolygon, if any, associated with this object.
         */
        this.polygon = undefined;

        /**
         * The DynamicPolyline, if any, associated with this object.
         */
        this.polyline = undefined;

        /**
         * The DynamicPyramid, if any, associated with this object.
         */
        this.pyramid = undefined;

        /**
         * The DynamicVertexPositionsProperty, if any, associated with this object.
         */
        this.vertexPositions = undefined;
    };

    /**
     * Given a time, returns true if this object should have data during that time.
     * @param {JulianDate} time The time to check availability for.
     * @exception {DeveloperError} time is required.
     * @returns true if the object should have data during the provided time, false otherwise.
     */
    DynamicObject.prototype.isAvailable = function(time) {
        if (typeof time === 'undefined') {
            throw new DeveloperError('time is required.');
        }
        if (typeof this.availability === 'undefined') {
            return true;
        }
        if (this._cachedAvailabilityDate === time) {
            return this._cachedAvailabilityValue;
        }
        this._cachedAvailabilityDate = time;
        return this._cachedAvailabilityValue = this.availability.contains(time);
    };

    /**
     * Processes a single CZML packet and merges its data into the provided DynamicObject's position
     * property. This method is not normally called directly, but is part of the array of CZML processing
     * functions that is passed into the DynamicObjectCollection constructor.
     *
     * @param {DynamicObject} dynamicObject The DynamicObject which will contain the position data.
     * @param {Object} packet The CZML packet to process.
     * @returns {Boolean} true if the property was newly created while processing the packet, false otherwise.
     *
     * @see DynamicPositionProperty
     * @see DynamicObjectCollection
     * @see CzmlDefaults#updaters
     */
    DynamicObject.processCzmlPacketPosition = function(dynamicObject, packet) {
        var positionData = packet.position;
        if (typeof positionData === 'undefined') {
            return false;
        }

        var position = dynamicObject.position;
        var propertyCreated = typeof position === 'undefined';
        if (propertyCreated) {
            dynamicObject.position = position = new DynamicPositionProperty();
        }
        position.processCzmlIntervals(positionData);
        return propertyCreated;
    };

    /**
     * Processes a single CZML packet and merges its data into the provided DynamicObject's orientation
     * property. This method is not normally called directly, but is part of the array of CZML processing
     * functions that is passed into the DynamicObjectCollection constructor.
     *
     * @param {DynamicObject} dynamicObject The DynamicObject which will contain the orientation data.
     * @param {Object} packet The CZML packet to process.
     * @returns {Boolean} true if the property was newly created while processing the packet, false otherwise.
     *
     * @see DynamicProperty
     * @see DynamicObjectCollection
     * @see CzmlDefaults#updaters
     */
    DynamicObject.processCzmlPacketOrientation = function(dynamicObject, packet) {
        var orientationData = packet.orientation;
        if (typeof orientationData === 'undefined') {
            return false;
        }

        var orientation = dynamicObject.orientation;
        var propertyCreated = typeof orientation === 'undefined';
        if (propertyCreated) {
            dynamicObject.orientation = orientation = new DynamicProperty(CzmlUnitQuaternion);
        }
        orientation.processCzmlIntervals(orientationData);
        return propertyCreated;
    };

    /**
     * Processes a single CZML packet and merges its data into the provided DynamicObject's vertexPositions
     * property. This method is not normally called directly, but is part of the array of CZML processing
     * functions that is passed into the DynamicObjectCollection constructor.
     *
     * @param {DynamicObject} dynamicObject The DynamicObject which will contain the vertexPositions data.
     * @param {Object} packet The CZML packet to process.
     * @param {DynamicObjectCollection} dynamicObjectCollection The collection to use to resolve any CZML properly links.
     * @returns {Boolean} true if the property was newly created while processing the packet, false otherwise.
     *
     * @see DynamicProperty
     * @see DynamicObjectCollection
     * @see CzmlDefaults#updaters
     */
    DynamicObject.processCzmlPacketVertexPositions = function(dynamicObject, packet, dynamicObjectCollection) {
        var vertexPositionsData = packet.vertexPositions;
        if (typeof vertexPositionsData === 'undefined') {
            return false;
        }

        var vertexPositions = dynamicObject.vertexPositions;
        var propertyCreated = typeof dynamicObject.vertexPositions === 'undefined';
        if (propertyCreated) {
            dynamicObject.vertexPositions = vertexPositions = new DynamicVertexPositionsProperty();
        }
        vertexPositions.processCzmlIntervals(vertexPositionsData, undefined, dynamicObjectCollection);
        return propertyCreated;
    };

    /**
     * Processes a single CZML packet and merges its data into the provided DynamicObject's availability
     * property. This method is not normally called directly, but is part of the array of CZML processing
     * functions that is passed into the DynamicObjectCollection constructor.
     *
     * @param {DynamicObject} dynamicObject The DynamicObject which will contain the availability data.
     * @param {Object} packet The CZML packet to process.
     * @returns {Boolean} true if the property was newly created while processing the packet, false otherwise.
     *
     * @see DynamicProperty
     * @see DynamicObjectCollection
     * @see CzmlDefaults#updaters
     */
    DynamicObject.processCzmlPacketAvailability = function(dynamicObject, packet) {
        var availability = packet.availability;
        if (typeof availability === 'undefined') {
            return false;
        }

        var propertyCreated = false;
        var interval = TimeInterval.fromIso8601(availability);
        if (typeof interval !== 'undefined') {
            propertyCreated = typeof dynamicObject.availability === 'undefined';
            dynamicObject._setAvailability(interval);
        }
        return propertyCreated;
    };


    /**
     * Given two DynamicObjects, takes the position, orientation, vertexPositions and availability
     * properties from the second and assigns them to the first, assuming such properties did not
     * already exist. This method is not normally called directly, but is part of the array of CZML
     * processing functions that is passed into the CompositeDynamicObjectCollection constructor.
     *
     * @param {DynamicObject} targetObject The DynamicObject which will have properties merged onto it.
     * @param {DynamicObject} objectToMerge The DynamicObject containing properties to be merged.
     *
     * @see CzmlDefaults
     */
    DynamicObject.mergeProperties = function(targetObject, objectToMerge) {
        targetObject.position = targetObject.position || objectToMerge.position;
        targetObject.orientation = targetObject.orientation || objectToMerge.orientation;
        targetObject.vertexPositions = targetObject.vertexPositions || objectToMerge.vertexPositions;
        targetObject._setAvailability(targetObject.availability || objectToMerge.availability);
    };

    /**
     * Given a DynamicObject, undefines the position, orientation, vertexPositions and availability
     * associated with it. This method is not normally called directly, but is part of the array of
     * CZML processing functions that is passed into the CompositeDynamicObjectCollection constructor.
     *
     * @param {DynamicObject} dynamicObject The DynamicObject to remove the billboard from.
     *
     * @see CzmlDefaults
     */
    DynamicObject.undefineProperties = function(dynamicObject) {
        dynamicObject.position = undefined;
        dynamicObject.orientation = undefined;
        dynamicObject.vertexPositions = undefined;
        dynamicObject._setAvailability(undefined);
    };

    DynamicObject.prototype._setAvailability = function(availability) {
        this.availability = availability;
        this._cachedAvailabilityDate = undefined;
        this._cachedAvailabilityValue = undefined;
    };

    return DynamicObject;
});
/*global define*/
define('DynamicScene/DynamicObjectCollection',[
        '../Core/Event',
        '../Core/TimeInterval',
        '../Core/Iso8601',
        '../Core/DeveloperError',
        './DynamicObject'
       ], function(
        Event,
        TimeInterval,
        Iso8601,
        DeveloperError,
        DynamicObject) {
    

    /**
     * A collection of DynamicObject instances.
     * @alias DynamicObjectCollection
     * @constructor
     */
    var DynamicObjectCollection = function() {
        this._hash = {};
        this._array = [];

        /**
         * The CompositeDynamicObjectCollection, if any, that this collection is in.
         */
        this.compositeCollection = undefined;

        /**
         * An {@link Event} that is fired whenever DynamicObjects in the collection have properties added.
         */
        this.objectPropertiesChanged = new Event();

        /**
         * An {@link Event} that is fired whenever DynamicObjects are removed from the collection.
         */
        this.objectsRemoved = new Event();
    };

    /**
     * Computes the maximum availability of the DynamicObjects in the collection.
     * If the collection contains a mix of infinitely available data and non-infinite data,
     * It will return the interval pertaining to the non-infinite data only.  If all
     * data is infinite, an infinite interval will be returned.
     *
     * @returns {TimeInterval} The availability of DynamicObjects in the collection.
     */
    DynamicObjectCollection.prototype.computeAvailability = function() {
        var startTime = Iso8601.MAXIMUM_VALUE;
        var stopTime = Iso8601.MINIMUM_VALUE;
        var i;
        var len;
        var object;
        var dynamicObjects = this._array;
        for (i = 0, len = dynamicObjects.length; i < len; i++) {
            object = dynamicObjects[i];
            if (typeof object.availability !== 'undefined') {
                if (object.availability.start.lessThan(startTime)) {
                    startTime = object.availability.start;
                }
                if (object.availability.stop.greaterThan(stopTime)) {
                    stopTime = object.availability.stop;
                }
            }
        }
        if (startTime !== Iso8601.MAXIMUM_VALUE && stopTime !== Iso8601.MINIMUM_VALUE) {
            return new TimeInterval(startTime, stopTime, true, true);
        }
        return new TimeInterval(Iso8601.MINIMUM_VALUE, Iso8601.MAXIMUM_VALUE, true, true);
    };

    /**
     * Gets an object with the specified id.
     * @param {Object} id The id of the object to retrieve.
     *
     * @exception {DeveloperError} id is required.
     *
     * @returns The DynamicObject with the provided id, or undefined if no such object exists.
     */
    DynamicObjectCollection.prototype.getObject = function(id) {
        if (typeof id === 'undefined') {
            throw new DeveloperError('id is required.');
        }
        return this._hash[id];
    };

    /**
     * Gets the array of DynamicObject instances in this composite collection.
     * @returns {Array} the array of DynamicObject instances in this composite collection.
     */
    DynamicObjectCollection.prototype.getObjects = function() {
        return this._array;
    };

    /**
     * Gets an object with the specified id or creates it and adds it to the collection if it does not exist.
     * @param {Object} id The id of the object to retrieve.
     *
     * @exception {DeveloperError} id is required.
     *
     * @returns The DynamicObject with the provided id.
     */
    DynamicObjectCollection.prototype.getOrCreateObject = function(id) {
        if (typeof id === 'undefined') {
            throw new DeveloperError('id is required.');
        }
        var obj = this._hash[id];
        if (!obj) {
            obj = new DynamicObject(id);
            this._hash[id] = obj;
            this._array.push(obj);
        }
        return obj;
    };

    /**
     * Removes all objects from the collection.
     */
    DynamicObjectCollection.prototype.clear = function() {
        var removedObjects = this._array;
        this._hash = {};
        this._array = [];
        if (removedObjects.length > 0) {
            this.objectsRemoved.raiseEvent(this, removedObjects);
        }
    };

    return DynamicObjectCollection;
});
/*global define*/
define('Renderer/BlendEquation',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports BlendEquation
     */
    var BlendEquation = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        ADD : new Enumeration(0x8006, 'ADD'), // WebGL: FUNC_ADD

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        SUBTRACT : new Enumeration(0x800A, 'SUBTRACT'), // WebGL: FUNC_SUBTRACT

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        REVERSE_SUBTRACT : new Enumeration(0x800B, 'REVERSE_SUBTRACT'), // WebGL: FUNC_REVERSE_SUBTRACT

        // No min and max like in ColladaFX GLES2 profile

        /**
         * DOC_TBA
         *
         * @param blendEquation
         *
         * @returns {Boolean}
         */
        validate : function(blendEquation) {
            return ((blendEquation === BlendEquation.ADD) ||
                    (blendEquation === BlendEquation.SUBTRACT) ||
                    (blendEquation === BlendEquation.REVERSE_SUBTRACT));
        }
    };

    return BlendEquation;
});
/*global define*/
define('Renderer/BlendFunction',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports BlendFunction
     */
    var BlendFunction = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        ZERO : new Enumeration(0, 'ZERO'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        ONE : new Enumeration(1, 'ONE'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        SOURCE_COLOR : new Enumeration(0x0300, 'SOURCE_COLOR'), // WebGL: SRC_COLOR

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        ONE_MINUS_SOURCE_COLOR : new Enumeration(0x0301, 'ONE_MINUS_SOURCE_COLOR'), // WebGL: ONE_MINUS_SRC_COLOR

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        DESTINATION_COLOR : new Enumeration(0x0306, 'DESTINATION_COLOR'), // WebGL: DEST_COLOR

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        ONE_MINUS_DESTINATION_COLOR : new Enumeration(0x0307, 'ONE_MINUS_DESTINATION_COLOR'), // WebGL: ONE_MINUS_DEST_COLOR

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        SOURCE_ALPHA : new Enumeration(0x0302, 'SOURCE_ALPHA'), // WebGL: SRC_ALPHA

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        ONE_MINUS_SOURCE_ALPHA : new Enumeration(0x0303, 'ONE_MINUS_SOURCE_ALPHA'), // WebGL: ONE_MINUS_SRC_ALPHA

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        DESTINATION_ALPHA : new Enumeration(0x0304, 'DESTINATION_ALPHA'), // WebGL: DST_ALPHA

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        ONE_MINUS_DESTINATION_ALPHA : new Enumeration(0x0305, 'ONE_MINUS_DESTINATION_ALPHA'), // WebGL: ONE_MINUS_DST_ALPHA

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        CONSTANT_COLOR : new Enumeration(0x8001, 'CONSTANT_COLOR'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        ONE_MINUS_CONSTANT_COLOR : new Enumeration(0x8002, 'ONE_MINUS_CONSTANT_COLOR'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        CONSTANT_ALPHA : new Enumeration(0x8003, 'CONSTANT_ALPHA'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        ONE_MINUS_CONSTANT_ALPHA : new Enumeration(0x8004, 'ONE_MINUS_CONSTANT_ALPHA'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        SOURCE_ALPHA_SATURATE : new Enumeration(0x0308, 'SOURCE_ALPHA_SATURATE'), // WebGL: SRC_ALPHA_SATURATE

        /**
         * DOC_TBA
         *
         * @param blendFunction
         *
         * @returns {Boolean}
         */
        validate : function(blendFunction) {
            return ((blendFunction === BlendFunction.ZERO) ||
                    (blendFunction === BlendFunction.ONE) ||
                    (blendFunction === BlendFunction.SOURCE_COLOR) ||
                    (blendFunction === BlendFunction.ONE_MINUS_SOURCE_COLOR) ||
                    (blendFunction === BlendFunction.DESTINATION_COLOR) ||
                    (blendFunction === BlendFunction.ONE_MINUS_DESTINATION_COLOR) ||
                    (blendFunction === BlendFunction.SOURCE_ALPHA) ||
                    (blendFunction === BlendFunction.ONE_MINUS_SOURCE_ALPHA) ||
                    (blendFunction === BlendFunction.DESTINATION_ALPHA) ||
                    (blendFunction === BlendFunction.ONE_MINUS_DESTINATION_ALPHA) ||
                    (blendFunction === BlendFunction.CONSTANT_COLOR) ||
                    (blendFunction === BlendFunction.ONE_MINUS_CONSTANT_COLOR) ||
                    (blendFunction === BlendFunction.CONSTANT_ALPHA) ||
                    (blendFunction === BlendFunction.ONE_MINUS_CONSTANT_ALPHA) ||
                    (blendFunction === BlendFunction.SOURCE_ALPHA_SATURATE));
        }
    };

    return BlendFunction;
});
/*global define*/
define('Renderer/BlendingState',[
        './BlendEquation',
        './BlendFunction'
    ], function(
        BlendEquation,
        BlendFunction) {
    

    /**
     * DOC_TBA
     *
     * @exports BlendingState
     */
    var BlendingState = {
        /**
         * DOC_TBA
         */
        ALPHA_BLEND : {
            enabled : true,
            equationRgb : BlendEquation.ADD,
            equationAlpha : BlendEquation.ADD,
            functionSourceRgb : BlendFunction.SOURCE_ALPHA,
            functionSourceAlpha : BlendFunction.SOURCE_ALPHA,
            functionDestinationRgb : BlendFunction.ONE_MINUS_SOURCE_ALPHA,
            functionDestinationAlpha : BlendFunction.ONE_MINUS_SOURCE_ALPHA
        },

        /**
         * DOC_TBA
         */
        PRE_MULTIPLIED_ALPHA_BLEND : {
            enabled : true,
            equationRgb : BlendEquation.ADD,
            equationAlpha : BlendEquation.ADD,
            functionSourceRgb : BlendFunction.ONE,
            functionSourceAlpha : BlendFunction.ONE,
            functionDestinationRgb : BlendFunction.ONE_MINUS_SOURCE_ALPHA,
            functionDestinationAlpha : BlendFunction.ONE_MINUS_SOURCE_ALPHA
        },

        /**
         * DOC_TBA
         */
        ADDITIVE_BLEND : {
            enabled : true,
            equationRgb : BlendEquation.ADD,
            equationAlpha : BlendEquation.ADD,
            functionSourceRgb : BlendFunction.SOURCE_ALPHA,
            functionSourceAlpha : BlendFunction.SOURCE_ALPHA,
            functionDestinationRgb : BlendFunction.ONE,
            functionDestinationAlpha : BlendFunction.ONE
        }
    };

    return BlendingState;
});
/*global define*/
define('Renderer/Buffer',[
        '../Core/DeveloperError',
        '../Core/destroyObject'
    ], function(
        DeveloperError,
        destroyObject) {
    

    /**
     * DOC_TBA
     *
     * @alias Buffer
     * @internalConstructor
     *
     * @see Context#createVertexBuffer
     * @see Context#createIndexBuffer
     */
    var Buffer = function(gl, bufferTarget, sizeInBytes, usage, buffer) {
        this._gl = gl;
        this._bufferTarget = bufferTarget;
        this._sizeInBytes = sizeInBytes;
        this._usage = usage;
        this._buffer = buffer;
        this._vertexArrayDestroyable = true;
    };

    /**
     * DOC_TBA
     * DOC_TBA: arrayView
     *
     * @memberof Buffer
     * @param {Number} [offsetInBytes=0] DOC_TBA
     *
     * @exception {DeveloperError} arrayView is required.
     * @exception {DeveloperError} This buffer is not large enough.
     * @exception {DeveloperError} This buffer was destroyed, i.e., destroy() was called.
     */
    Buffer.prototype.copyFromArrayView = function(arrayView, offsetInBytes) {
        if (!arrayView) {
            throw new DeveloperError('arrayView is required.');
        }

        offsetInBytes = offsetInBytes || 0;

        if (offsetInBytes + arrayView.byteLength > this._sizeInBytes) {
            throw new DeveloperError('This buffer is not large enough.');
        }

        var gl = this._gl;
        var target = this._bufferTarget;
        gl.bindBuffer(target, this._buffer);
        gl.bufferSubData(target, offsetInBytes, arrayView);
        gl.bindBuffer(target, null);
    };

    Buffer.prototype._getBuffer = function() {
        return this._buffer;
    };

    /**
     * DOC_TBA
     * @memberof Buffer
     *
     * @return {Number} DOC_TBA
     * @exception {DeveloperError} This buffer was destroyed, i.e., destroy() was called.
     */
    Buffer.prototype.getSizeInBytes = function() {
        return this._sizeInBytes;
    };

    /**
     * DOC_TBA
     * @memberof Buffer
     *
     * @return {GLenum} DOC_TBA
     * @exception {DeveloperError} This buffer was destroyed, i.e., destroy() was called.
     */
    Buffer.prototype.getUsage = function() {
        return this._usage;
    };

    /**
     * DOC_TBA
     * @memberof Buffer
     */
    Buffer.prototype.getVertexArrayDestroyable = function() {
        return this._vertexArrayDestroyable;
    };

    /**
     * DOC_TBA
     * @memberof Buffer
     */
    Buffer.prototype.setVertexArrayDestroyable = function(value) {
        this._vertexArrayDestroyable = value;
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof Buffer
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see Buffer.destroy
     */
    Buffer.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof Buffer
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This buffer was destroyed, i.e., destroy() was called.
     *
     * @see Buffer#isDestroyed
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glDeleteBuffers.xml'>glDeleteBuffers</a>
     *
     * @example
     * buffer = buffer && buffer.destroy();
     */
    Buffer.prototype.destroy = function() {
        this._gl.deleteBuffer(this._buffer);
        return destroyObject(this);
    };

    return Buffer;
});
/*global define*/
define('Renderer/BufferUsage',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports BufferUsage
     */
    var BufferUsage = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        STREAM_DRAW : new Enumeration(0x88E0, 'STREAM_DRAW'),
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        STATIC_DRAW : new Enumeration(0x88E4, 'STATIC_DRAW'),
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        DYNAMIC_DRAW : new Enumeration(0x88E8, 'DYNAMIC_DRAW'),

        /**
         * DOC_TBA
         *
         * @param bufferUsage
         *
         * @returns {Boolean}
         */
        validate : function(bufferUsage) {
            return ((bufferUsage === BufferUsage.STREAM_DRAW) ||
                    (bufferUsage === BufferUsage.STATIC_DRAW) ||
                    (bufferUsage === BufferUsage.DYNAMIC_DRAW));
        }
    };

    return BufferUsage;
});
/*global define*/
define('Renderer/CullFace',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports CullFace
     */
    var CullFace = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        FRONT : new Enumeration(0x0404, 'FRONT'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        BACK : new Enumeration(0x0405, 'BACK'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        FRONT_AND_BACK : new Enumeration(0x0408, 'FRONT_AND_BACK'),

        /**
         * DOC_TBA
         *
         * @param cullFace
         *
         * @returns {Boolean}
         */
        validate : function(cullFace) {
            return ((cullFace === CullFace.FRONT) ||
                    (cullFace === CullFace.BACK) ||
                    (cullFace === CullFace.FRONT_AND_BACK));
        }
    };

    return CullFace;
});
/*global define*/
define('Renderer/DepthFunction',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports DepthFunction
     */
    var DepthFunction = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        NEVER : new Enumeration(0x0200, 'NEVER'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        LESS : new Enumeration(0x0201, 'LESS'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        EQUAL : new Enumeration(0x0202, 'EQUAL'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        LESS_OR_EQUAL : new Enumeration(0x0203, 'LEQUAL'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        GREATER : new Enumeration(0x0204, 'GREATER'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        NOT_EQUAL : new Enumeration(0x0205, 'NOTEQUAL'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        GREATER_OR_EQUAL : new Enumeration(0x0206, 'GEQUAL'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        ALWAYS : new Enumeration(0x0207, 'ALWAYS'),

        /**
         * DOC_TBA
         *
         * @param depthFunction
         *
         * @returns {Boolean}
         */
        validate : function(depthFunction) {
            return ((depthFunction === DepthFunction.NEVER) ||
                    (depthFunction === DepthFunction.LESS) ||
                    (depthFunction === DepthFunction.EQUAL) ||
                    (depthFunction === DepthFunction.LESS_OR_EQUAL) ||
                    (depthFunction === DepthFunction.GREATER) ||
                    (depthFunction === DepthFunction.NOT_EQUAL) ||
                    (depthFunction === DepthFunction.GREATER_OR_EQUAL) ||
                    (depthFunction === DepthFunction.ALWAYS));
        }
    };

    return DepthFunction;
});
/*global define*/
define('Renderer/Framebuffer',[
        '../Core/DeveloperError',
        '../Core/destroyObject'
    ], function(
        DeveloperError,
        destroyObject) {
    

    /**
     * DOC_TBA
     *
     * @alias Framebuffer
     *
     * @see Context#createFramebuffer
     *
     * @internalConstructor
     */
    var Framebuffer = function(_gl, description) {
        var _framebuffer;
        var _colorTexture;
        var _colorRenderbuffer;
        var _depthRenderbuffer;
        var _stencilRenderbuffer;
        var _depthStencilRenderbuffer;

        /**
        * DOC_TBA.
        * @exception {DeveloperError} This framebuffer was destroyed, i.e., destroy() was called.
        */
        this.setColorTexture = function(texture) {
            this._bind();

            if (texture) {
                _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, texture._getTarget(), texture._getTexture(), 0);
            } else {
                _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, null, 0);
            }
            this._unBind();

            _colorTexture = texture;
        };

        /**
        * DOC_TBA.
        * @exception {DeveloperError} This framebuffer was destroyed, i.e., destroy() was called.
        */
        this.getColorTexture = function() {
            return _colorTexture;
        };

        /**
         * DOC_TBA.
         * @exception {DeveloperError} This framebuffer was destroyed, i.e., destroy() was called.
         */
        this.setColorRenderbuffer = function(renderbuffer) {
            this._bind();
            if (renderbuffer) {
                _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderbuffer._getRenderbuffer());
            } else {
                _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, null);
            }
            this._unBind();

            _colorRenderbuffer = renderbuffer;
        };

        /**
         * DOC_TBA.
         * @exception {DeveloperError} This framebuffer was destroyed, i.e., destroy() was called.
         */
        this.getColorRenderbuffer = function() {
            return _colorRenderbuffer;
        };

        /**
        * DOC_TBA.
        * @exception {DeveloperError} This framebuffer was destroyed, i.e., destroy() was called.
        */
        this.setDepthRenderbuffer = function(renderbuffer) {
            this._bind();
            if (renderbuffer) {
                _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer._getRenderbuffer());
            } else {
                _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, null);
            }
            this._unBind();

            _depthRenderbuffer = renderbuffer;
        };

        /**
        * DOC_TBA.
        * @exception {DeveloperError} This framebuffer was destroyed, i.e., destroy() was called.
        */
        this.getDepthRenderbuffer = function() {
            return _depthRenderbuffer;
        };

        /**
        * DOC_TBA.
        * @exception {DeveloperError} This framebuffer was destroyed, i.e., destroy() was called.
        */
        this.setStencilRenderbuffer = function(renderbuffer) {
            this._bind();
            if (renderbuffer) {
                _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer._getRenderbuffer());
            } else {
                _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, null);
            }
            this._unBind();

            _stencilRenderbuffer = renderbuffer;
        };

        /**
        * DOC_TBA.
        * @exception {DeveloperError} This framebuffer was destroyed, i.e., destroy() was called.
        */
        this.getStencilRenderbuffer = function() {
            return _stencilRenderbuffer;
        };

        /**
        * DOC_TBA.
        * @exception {DeveloperError} This framebuffer was destroyed, i.e., destroy() was called.
        */
        this.setDepthStencilRenderbuffer = function(renderbuffer) {
            this._bind();
            if (renderbuffer) {
                _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer._getRenderbuffer());
            } else {
                _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, null);
            }
            this._unBind();

            _depthStencilRenderbuffer = renderbuffer;
        };

        /**
        * DOC_TBA.
        * @exception {DeveloperError} This framebuffer was destroyed, i.e., destroy() was called.
        */
        this.getDepthStencilRenderbuffer = function() {
            return _depthStencilRenderbuffer;
        };

        this._bind = function() {
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, _framebuffer);
        };

        this._unBind = function() {
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
        };

        /**
         * Returns true if this object was destroyed; otherwise, false.
         * <br /><br />
         * If this object was destroyed, it should not be used; calling any function other than
         * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
         *
         * @return {Boolean} True if this object was destroyed; otherwise, false.
         *
         * @see Framebuffer.destroy
         */
        this.isDestroyed = function() {
            return false;
        };

        /**
         * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
         * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
         * <br /><br />
         * Only call this if the framebuffer has no attachments or the framebuffer owns its attachments;
         * otherwise, the owner of the textures/renderbuffers is responsible for deleting them.
         * <br /><br />
         * Once an object is destroyed, it should not be used; calling any function other than
         * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
         * assign the return value (<code>undefined</code>) to the object as done in the example.
         * <br /><br />
         * This will fail if the color attachment is a face in a cube map texture.
         *
         * @return {undefined}
         *
         * @exception {DeveloperError} This framebuffer was destroyed, i.e., destroy() was called.
         *
         * @see Framebuffer.isDestroyed
         * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glDeleteFramebuffers.xml'>glDeleteFramebuffers</a>
         * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glDeleteTextures.xml'>glDeleteTextures</a>
         * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glDeleteRenderbuffers.xml'>glDeleteRenderbuffers</a>
         *
         * @example
         * // Destroying the framebuffer implicitly calls destroy for each of its attachments.
         * var texture = context.createTexture2D({ width : 1, height : 1 });
         * framebuffer = context.createFramebuffer({ colorTexture : texture });
         * // ...
         * framebuffer = framebuffer.destroy();
         * // Calling texture.destroy() would throw <code>DeveloperError</code> at this point.
         */
        this.destroy = function() {
            // TODO:  What should the behavior be if the color attachment is a face in a cube map texture?
            _colorTexture = _colorTexture && _colorTexture.destroy();
            _colorRenderbuffer = _colorRenderbuffer && _colorRenderbuffer.destroy();
            _depthRenderbuffer = _depthRenderbuffer && _depthRenderbuffer.destroy();
            _stencilRenderbuffer = _stencilRenderbuffer && _stencilRenderbuffer.destroy();
            _depthStencilRenderbuffer = _depthStencilRenderbuffer && _depthStencilRenderbuffer.destroy();

            _gl.deleteFramebuffer(_framebuffer);
            return destroyObject(this);
        };

        _framebuffer = _gl.createFramebuffer();

        if (description) {
            if (description.colorTexture) {
                this.setColorTexture(description.colorTexture);
            }

            if (description.colorRenderbuffer) {
                this.setColorRenderbuffer(description.colorRenderbuffer);
            }

            if (description.depthRenderbuffer) {
                this.setDepthRenderbuffer(description.depthRenderbuffer);
            }

            if (description.stencilRenderbuffer) {
                this.setStencilRenderbuffer(description.stencilRenderbuffer);
            }

            if (description.depthStencilRenderbuffer) {
                this.setDepthStencilRenderbuffer(description.depthStencilRenderbuffer);
            }
        }
    };

    return Framebuffer;
});
/*global define*/
define('Renderer/MipmapHint',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports MipmapHint
     */
    var MipmapHint = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        DONT_CARE : new Enumeration(0x1100, 'DONT_CARE'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        FASTEST : new Enumeration(0x1101, 'FASTEST'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        NICEST : new Enumeration(0x1102, 'NICEST'),

        /**
         * DOC_TBA
         *
         * @param mipmapHint
         *
         * @returns {Boolean}
         */
        validate : function(mipmapHint) {
            return ((mipmapHint === MipmapHint.DONT_CARE) ||
                    (mipmapHint === MipmapHint.FASTEST) ||
                    (mipmapHint === MipmapHint.NICEST));
        }
    };

    return MipmapHint;
});
/*global define*/
define('Renderer/PixelDatatype',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports PixelDatatype
     */
    var PixelDatatype = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        UNSIGNED_BYTE : new Enumeration(0x1401, 'UNSIGNED_BYTE'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        UNSIGNED_SHORT_4_4_4_4 : new Enumeration(0x8033, 'UNSIGNED_SHORT_4_4_4_4'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        UNSIGNED_SHORT_5_5_5_1 : new Enumeration(0x8034, 'UNSIGNED_SHORT_5_5_5_1'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        UNSIGNED_SHORT_5_6_5 : new Enumeration(0x8363, 'UNSIGNED_SHORT_5_6_5'),

        /**
         * DOC_TBA
         *
         * @param pixelDatatype
         *
         * @returns {Boolean}
         */
        validate : function(pixelDatatype) {
            return ((pixelDatatype === PixelDatatype.UNSIGNED_BYTE) ||
                    (pixelDatatype === PixelDatatype.UNSIGNED_SHORT_4_4_4_4) ||
                    (pixelDatatype === PixelDatatype.UNSIGNED_SHORT_5_5_5_1) ||
                    (pixelDatatype === PixelDatatype.UNSIGNED_SHORT_5_6_5));
        }
    };

    return PixelDatatype;
});
/*global define*/
define('Renderer/PixelFormat',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports PixelFormat
     */
    var PixelFormat = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        DEPTH_COMPONENT : new Enumeration(0x1902, 'DEPTH_COMPONENT'),
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        ALPHA : new Enumeration(0x1906, 'ALPHA'),
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        RGB : new Enumeration(0x1907, 'RGB'),
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        RGBA : new Enumeration(0x1908, 'RGBA'),
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        LUMINANCE : new Enumeration(0x1909, 'LUMINANCE'),
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        LUMINANCE_ALPHA : new Enumeration(0x190A, 'LUMINANCE_ALPHA'),

        /**
         * DOC_TBA
         *
         * @param pixelFormat
         *
         * @returns {Boolean}
         */
        validate : function(pixelFormat) {
            return ((pixelFormat === PixelFormat.DEPTH_COMPONENT) ||
                    (pixelFormat === PixelFormat.ALPHA) ||
                    (pixelFormat === PixelFormat.RGB) ||
                    (pixelFormat === PixelFormat.RGBA) ||
                    (pixelFormat === PixelFormat.LUMINANCE) ||
                    (pixelFormat === PixelFormat.LUMINANCE_ALPHA));
        }
    };

    return PixelFormat;
});
/*global define*/
define('Renderer/Renderbuffer',[
        '../Core/DeveloperError',
        '../Core/destroyObject'
    ], function(
        DeveloperError,
        destroyObject) {
    

    /**
     * DOC_TBA
     *
     * @alias Renderbuffer
     * @internalConstructor
     *
     * @see Context#createRenderbuffer
     */
    function Renderbuffer(_gl, _format, _width, _height) {
        var _renderbuffer = _gl.createRenderbuffer();

        _gl.bindRenderbuffer(_gl.RENDERBUFFER, _renderbuffer);
        _gl.renderbufferStorage(_gl.RENDERBUFFER, _format, _width, _height);
        _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);

        /**
        * DOC_TBA
        * @memberof Renderbuffer
        * @return {Boolean} DOC_TBA
        * @exception {DeveloperError} This renderbuffer was destroyed, i.e., destroy() was called.
        */
        this.getFormat = function() {
            return _format;
        };

        /**
        * DOC_TBA
        * @memberof Renderbuffer
        * @return {Boolean} DOC_TBA
        * @exception {DeveloperError} This renderbuffer was destroyed, i.e., destroy() was called.
        */
        this.getWidth = function() {
            return _width;
        };

        /**
        * DOC_TBA
        * @memberof Renderbuffer
        * @return {Boolean} DOC_TBA
        * @exception {DeveloperError} This renderbuffer was destroyed, i.e., destroy() was called.
        */
        this.getHeight = function() {
            return _height;
        };

        this._getRenderbuffer = function() {
            return _renderbuffer;
        };

        /**
         * Returns true if this object was destroyed; otherwise, false.
         * <br /><br />
         * If this object was destroyed, it should not be used; calling any function other than
         * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
         *
         * @memberof Renderbuffer
         *
         * @return {Boolean} True if this object was destroyed; otherwise, false.
         *
         * @see Renderbuffer.destroy
         */
        this.isDestroyed = function() {
            return false;
        };

        /**
         * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
         * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
         * <br /><br />
         * Once an object is destroyed, it should not be used; calling any function other than
         * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
         * assign the return value (<code>undefined</code>) to the object as done in the example.
         *
         * @memberof Renderbuffer
         *
         * @return {undefined}
         *
         * @exception {DeveloperError} This shader renderbuffer destroyed, i.e., destroy() was called.
         *
         * @see Renderbuffer.isDestroyed
         * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glDeleteRenderbuffers.xml'>glDeleteRenderbuffers</a>
         *
         * @example
         * renderbuffer = renderbuffer && renderbuffer.destroy();
         */
        this.destroy = function() {
            _gl.deleteRenderbuffer(_renderbuffer);
            return destroyObject(this);
        };
    }

    return Renderbuffer;
});
/*global define*/
define('Renderer/RenderbufferFormat',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports RenderbufferFormat
     */
    var RenderbufferFormat = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        RGBA4 : new Enumeration(0x8056, 'RGBA4'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        RGB5_A1 : new Enumeration(0x8057, 'RGB5_A1'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        RGB565 : new Enumeration(0x8D62, 'RGB565'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        DEPTH_COMPONENT16 : new Enumeration(0x81A5, 'DEPTH_COMPONENT16'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        STENCIL_INDEX8 : new Enumeration(0x8D48, 'STENCIL_INDEX8'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        DEPTH_STENCIL : new Enumeration(0x84F9, 'DEPTH_STENCIL'),

        /**
         * DOC_TBA
         *
         * @param renderbufferFormat
         *
         * @returns {Boolean}
         */
        validate : function(renderbufferFormat) {
            return ((renderbufferFormat === RenderbufferFormat.RGBA4) ||
                    (renderbufferFormat === RenderbufferFormat.RGB5_A1) ||
                    (renderbufferFormat === RenderbufferFormat.RGB565) ||
                    (renderbufferFormat === RenderbufferFormat.DEPTH_COMPONENT16) ||
                    (renderbufferFormat === RenderbufferFormat.STENCIL_INDEX8) ||
                    (renderbufferFormat === RenderbufferFormat.DEPTH_STENCIL));
        }
    };

    return RenderbufferFormat;
});
/*global define*/
define('Renderer/PickFramebuffer',[
        '../Core/destroyObject',
        '../Core/Color',
        './RenderbufferFormat'
    ], function(
        destroyObject,
        Color,
        RenderbufferFormat) {
    

    /**
     * DOC_TBA
     *
     * @alias PickFramebuffer
     * @internalConstructor
     *
     * @see Context#createPickFramebuffer
     * @see Context#pick
     */
    var PickFramebuffer = function(context) {
        this._context = context;
        this._fb = null;
        this._width = 0;
        this._height = 0;
    };

    /**
     * DOC_TBA
     * @memberof PickFramebuffer
     */
    PickFramebuffer.prototype.begin = function() {
        var context = this._context;

        // Initially create or recreate renderbuffers and framebuffer used for picking
        if (!this._fb ||
            (this._width !== context.getCanvas().clientWidth) ||
            (this._height !== context.getCanvas().clientHeight)) {
            this._width = context.getCanvas().clientWidth;
            this._height = context.getCanvas().clientHeight;

            this._fb = this._fb && this._fb.destroy();
            this._fb = context.createFramebuffer({
                colorRenderbuffer : context.createRenderbuffer(),
                depthStencilRenderbuffer : context.createRenderbuffer({
                    format : RenderbufferFormat.DEPTH_STENCIL
                })
            });
        }

        // Clear to black.  Since this is the background color, no objects will be black
        context.clear(context.createClearState({
            framebuffer : this._fb,
            color : new Color(0.0, 0.0, 0.0, 1.0),
            depth : 1.0,
            stencil : 0
        }));

        return this._fb;
    };

    /**
     * DOC_TBA
     * @memberof PickFramebuffer
     */
    PickFramebuffer.prototype.end = function(screenSpacePosition) {
        if (screenSpacePosition) {
            // TODO:  function with custom width/height
            var pixels = this._context.readPixels({
                x : screenSpacePosition.x,
                y : screenSpacePosition.y,
                width : 1,
                height : 1,
                framebuffer : this._fb
            });

            return this._context.getObjectByPickId(new Color(pixels[0], pixels[1], pixels[2], pixels[3]));
        }

        return undefined;
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof PickFramebuffer
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see PickFramebuffer#destroy
     */
    PickFramebuffer.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof PickFramebuffer
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see PickFramebuffer#isDestroyed
     *
     * @example
     * PickFramebuffer = PickFramebuffer && PickFramebuffer.destroy();
     */
    PickFramebuffer.prototype.destroy = function() {
        this._fb = this._fb && this._fb.destroy();
        return destroyObject(this);
    };

    return PickFramebuffer;
});
/*global define*/
define('Renderer/ShaderCache',[
        '../Core/destroyObject'
    ], function(
        destroyObject) {
    

    /**
     * DOC_TBA
     *
     * @alias ShaderCache
     *
     * @internalConstructor
     *
     * @see Context#getShaderCache
     */
    var ShaderCache = function(context) {
        this._context = context;
        this._shaders = {};
        this._shadersToRelease = {};
    };

    /**
     * DOC_TBA
     *
     * @memberof ShaderCache
     *
     * @returns {ShaderProgram} DOC_TBA.
     */
    ShaderCache.prototype.getShaderProgram = function(vertexShaderSource, fragmentShaderSource, attributeLocations) {
        // TODO: compare attributeLocations!
        var keyword = vertexShaderSource + fragmentShaderSource;
        var cachedShader;

        if (this._shaders[keyword]) {
            cachedShader = this._shaders[keyword];
        } else {
            var sp = this._context.createShaderProgram(vertexShaderSource, fragmentShaderSource, attributeLocations);

            cachedShader = {
                cache : this,
                shaderProgram : sp,
                keyword : keyword,
                count : 0
            };

            // A shader can't be in more than one cache.
            sp._cachedShader = cachedShader;
            this._shaders[keyword] = cachedShader;
        }

        ++cachedShader.count;
        return cachedShader.shaderProgram;
    };

    /**
     * DOC_TBA
     * @memberof ShaderCache
     */
    ShaderCache.prototype.destroyReleasedShaderPrograms = function() {
        var shadersToRelease = this._shadersToRelease;

        for ( var keyword in shadersToRelease) {
            if (shadersToRelease.hasOwnProperty(keyword)) {
                // Check the count again here because the shader may have been requested
                // after it was released, in which case, we are avoiding thrashing the cache.
                var cachedShader = shadersToRelease[keyword];
                if (cachedShader.count === 0) {
                    delete this._shaders[cachedShader.keyword];
                    cachedShader.shaderProgram.destroy();
                }
            }
        }

        this._shadersToRelease = {};
    };

    /**
     * DOC_TBA
     *
     * @memberof ShaderCache
     *
     * @parameter {ShaderProgram} shaderProgram DOC_TBA.
     */
    ShaderCache.prototype.releaseShaderProgram = function(shaderProgram) {
        if (shaderProgram) {
            var cachedShader = shaderProgram._cachedShader;
            if (cachedShader && (--cachedShader.count === 0)) {
                this._shadersToRelease[cachedShader.keyword] = cachedShader;
            }
        }

        return null;
    };

    /**
     * DOC_TBA
     * @memberof ShaderCache
     */
    ShaderCache.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * DOC_TBA
     * @memberof ShaderCache
     */
    ShaderCache.prototype.destroy = function() {
        var shaders = this._shaders;

        for ( var keyword in shaders) {
            if (shaders.hasOwnProperty(keyword)) {
                shaders[keyword].shaderProgram.destroy();
            }
        }

        return destroyObject(this);
    };

    return ShaderCache;
});
/*global define*/
define('Renderer/StencilFunction',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports StencilFunction
     */
    var StencilFunction = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        NEVER : new Enumeration(0x0200, 'NEVER'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        LESS : new Enumeration(0x0201, 'LESS'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        EQUAL : new Enumeration(0x0202, 'EQUAL'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        LESS_OR_EQUAL : new Enumeration(0x0203, 'LESS_OR_EQUAL'), // WebGL: LEQUAL

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        GREATER : new Enumeration(0x0204, 'GREATER'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        NOT_EQUAL : new Enumeration(0x0205, 'NOT_EQUAL'), // WebGL: NOTEQUAL

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        GREATER_OR_EQUAL : new Enumeration(0x0206, 'GREATER_OR_EQUAL'), // WebGL: GEQUAL

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        ALWAYS : new Enumeration(0x0207, 'ALWAYS'),

        /**
         * DOC_TBA
         *
         * @param stencilFunction
         *
         * @returns {Boolean}
         */
        validate : function(stencilFunction) {
            return ((stencilFunction === StencilFunction.NEVER) ||
                    (stencilFunction === StencilFunction.LESS) ||
                    (stencilFunction === StencilFunction.EQUAL) ||
                    (stencilFunction === StencilFunction.LESS_OR_EQUAL) ||
                    (stencilFunction === StencilFunction.GREATER) ||
                    (stencilFunction === StencilFunction.NOT_EQUAL) ||
                    (stencilFunction === StencilFunction.GREATER_OR_EQUAL) ||
                    (stencilFunction === StencilFunction.ALWAYS));
        }
    };

    return StencilFunction;
});
/*global define*/
define('Renderer/StencilOperation',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports StencilOperation
     */
    var StencilOperation = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        ZERO : new Enumeration(0, 'ZERO'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        KEEP : new Enumeration(0x1E00, 'KEEP'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        REPLACE : new Enumeration(0x1E01, 'REPLACE'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        INCREMENT : new Enumeration(0x1E02, 'INCREMENT'), // WebGL: INCR

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        DECREMENT : new Enumeration(0x1E03, 'DECREMENT'), // WebGL: DECR

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        INVERT : new Enumeration(0x150A, 'INVERT'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        INCREMENT_WRAP : new Enumeration(0x8507, 'INCREMENT_WRAP'), // WebGL: INCR_WRAP

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        DECREMENT_WRAP : new Enumeration(0x8508, 'DECREMENT_WRAP'), // WebGL: DECR_WRAP

        /**
         * DOC_TBA
         *
         * @param stencilOperation
         *
         * @returns {Boolean}
         */
        validate : function(stencilOperation) {
            return ((stencilOperation === StencilOperation.ZERO) ||
                    (stencilOperation === StencilOperation.KEEP) ||
                    (stencilOperation === StencilOperation.REPLACE) ||
                    (stencilOperation === StencilOperation.INCREMENT) ||
                    (stencilOperation === StencilOperation.DECREMENT) ||
                    (stencilOperation === StencilOperation.INVERT) ||
                    (stencilOperation === StencilOperation.INCREMENT_WRAP) ||
                    (stencilOperation === StencilOperation.DECREMENT_WRAP));
        }
    };

    return StencilOperation;
});
/*global define*/
define('Renderer/TextureAtlas',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/Cartesian2',
        '../Core/Rectangle',
        '../Core/createGuid',
        './PixelFormat'
    ], function(
        DeveloperError,
        destroyObject,
        Cartesian2,
        Rectangle,
        createGuid,
        PixelFormat) {
    

    // The atlas is made up of regions of space called nodes that contain images or child nodes.
    function TextureAtlasNode(bottomLeft, topRight, childNode1, childNode2, imageIndex) {
        this.bottomLeft = (typeof bottomLeft !== 'undefined') ? bottomLeft : new Cartesian2();
        this.topRight = (typeof topRight !== 'undefined') ? topRight : new Cartesian2();
        this.childNode1 = childNode1;
        this.childNode2 = childNode2;
        this.imageIndex = imageIndex;
    }

    /**
     * A TextureAtlas stores multiple images in one square texture and keeps
     * track of the texture coordinates for each image. TextureAtlas is dynamic,
     * meaning new images can be added at any point in time.
     * Calling addImages is more space-efficient than calling addImage multiple times.
     * Texture coordinates are subject to change if the texture atlas resizes, so it is
     * important to check {@link TextureAtlas#getGUID} before using old values.
     *
     * @alias TextureAtlas
     *
     * @param {Context} description.context The context in which the texture gets created.
     * @param {PixelFormat} [description.pixelFormat = PixelFormat.RGBA] The pixel format of the texture.
     * @param {Number} [description.borderWidthInPixels = 1] The amount of spacing between adjacent images in pixels.
     * @param {Cartesian2} [description.initialSize = new Cartesian2(16.0, 16.0)] The initial side lengths of the texture.
     * @param {Array} description.images Optional array of {@link Image} to be added to the atlas. Same as calling addImages(images).
     * @param {Image} description.image Optional single image to be added to the atlas. Same as calling addImage(image).
     *
     * @internalConstructor
     *
     * @exception {DeveloperError} context is required.
     * @exception {DeveloperError} borderWidthInPixels must be greater than or equal to zero.
     * @exception {DeveloperError} initialSize must be greater than zero.
     *
     */
    var TextureAtlas = function(description) {
        description = (typeof description !== 'undefined') ? description : {};
        var context = description.context;
        var pixelFormat = description.pixelFormat;
        var borderWidthInPixels = description.borderWidthInPixels;
        var initialSize = description.initialSize;
        var images = description.images;
        var image = description.image;

        // Context
        if (typeof context === 'undefined') {
            throw new DeveloperError('context is required.');
        }

        // Pixel Format
        pixelFormat = (typeof pixelFormat !== 'undefined') ? pixelFormat : PixelFormat.RGBA;

        // Border
        borderWidthInPixels = (typeof borderWidthInPixels !== 'undefined') ? borderWidthInPixels : 1.0;
        if (borderWidthInPixels < 0) {
            throw new DeveloperError('borderWidthInPixels must be greater than or equal to zero.');
        }

        // Initial size
        initialSize = (typeof initialSize !== 'undefined') ? initialSize : new Cartesian2(16.0, 16.0);
        if (initialSize.x < 1 || initialSize.y < 1) {
            throw new DeveloperError('initialSize must be greater than zero.');
        }

        this._context = context;
        this._pixelFormat = pixelFormat;
        this._borderWidthInPixels = borderWidthInPixels;
        this._textureCoordinates = [];
        this._guid = createGuid();

        // Create initial texture and root.
        this._texture = this._context.createTexture2D({
            width : initialSize.x,
            height : initialSize.y,
            pixelFormat : this._pixelFormat
        });
        this._root = new TextureAtlasNode(new Cartesian2(0.0, 0.0), new Cartesian2(initialSize.x, initialSize.y));

        // Add initial images if there are any.
        if (typeof images !== 'undefined' && (images.length > 0)) {
            this.addImages(images);
        }
        if (typeof image !== 'undefined') {
            this.addImage(image);
        }
    };

    // Builds a larger texture and copies the old texture into the new one.
    TextureAtlas.prototype._resizeAtlas = function (image) {
        var numImages = this.getNumberOfImages();
        var scalingFactor = 2.0;
        if(numImages > 0) {
            var oldAtlasWidth = this._texture.getWidth();
            var oldAtlasHeight = this._texture.getHeight();
            var atlasWidth = scalingFactor * (oldAtlasWidth + image.width + this._borderWidthInPixels);
            var atlasHeight = scalingFactor * (oldAtlasHeight + image.height + this._borderWidthInPixels);
            var widthRatio = oldAtlasWidth / atlasWidth;
            var heightRatio = oldAtlasHeight / atlasHeight;

            // Create new node structure, putting the old root node in the bottom left.
            var nodeBottomRight = new TextureAtlasNode(new Cartesian2(oldAtlasWidth + this._borderWidthInPixels, 0.0), new Cartesian2(atlasWidth, oldAtlasHeight));
            var nodeBottomHalf = new TextureAtlasNode(new Cartesian2(0.0, 0.0), new Cartesian2(atlasWidth, oldAtlasHeight), this._root, nodeBottomRight);
            var nodeTopHalf = new TextureAtlasNode(new Cartesian2(0.0, oldAtlasHeight + this._borderWidthInPixels), new Cartesian2(atlasWidth, atlasHeight));
            var nodeMain = new TextureAtlasNode(new Cartesian2(0.0, 0.0), new Cartesian2(atlasWidth, atlasHeight), nodeBottomHalf, nodeTopHalf);
            this._root = nodeMain;

            // Resize texture coordinates.
            for (var i = 0; i < this._textureCoordinates.length; i++) {
                var texCoord = this._textureCoordinates[i];
                if (typeof texCoord !== 'undefined') {
                    texCoord.x *= widthRatio;
                    texCoord.y *= heightRatio;
                    texCoord.width *= widthRatio;
                    texCoord.height *= heightRatio;
                }
        }

            // Copy larger texture.
            var newTexture = this._context.createTexture2D({
                width : atlasWidth,
                height : atlasHeight,
                pixelFormat : this._pixelFormat
        });

            // Copy old texture into new using an fbo.
            var framebuffer = this._context.createFramebuffer({colorTexture:this._texture});
            framebuffer._bind();
            newTexture.copyFromFramebuffer(0, 0, 0, 0, oldAtlasWidth, oldAtlasHeight);
            framebuffer._unBind();
            framebuffer.destroy();
            this._texture = newTexture;
            }
        // First image exceeds initialSize
        else {
            var initialWidth = scalingFactor * (image.width + this._borderWidthInPixels);
            var initialHeight = scalingFactor * (image.height + this._borderWidthInPixels);
            this._texture = this._texture && this._texture.destroy();
            this._texture = this._context.createTexture2D({width : initialWidth, height : initialHeight, pixelFormat : this._pixelFormat});
            this._root = new TextureAtlasNode(new Cartesian2(0.0, 0.0), new Cartesian2(initialWidth, initialHeight));
        }
    };

    // A recursive function that finds the best place to insert
    // a new image based on existing image 'nodes'.
    // Inspired by: http://blackpawn.com/texts/lightmaps/default.html
    TextureAtlas.prototype._findNode = function (node, image) {
        if (typeof node === 'undefined') {
            return undefined;
        }

        // If a leaf node
        if (typeof node.childNode1 === 'undefined' &&
            typeof node.childNode2 === 'undefined') {

            // Node already contains an image, don't add to it.
            if (typeof node.imageIndex !== 'undefined') {
                return undefined;
            }

            var nodeWidth = node.topRight.x - node.bottomLeft.x;
            var nodeHeight = node.topRight.y - node.bottomLeft.y;
            var widthDifference = nodeWidth - image.width;
            var heightDifference = nodeHeight - image.height;

            // Node is smaller than the image.
            if (widthDifference < 0 || heightDifference < 0) {
                return undefined;
            }

            // If the node is the same size as the image, return the node
            if (widthDifference === 0 && heightDifference === 0) {
                return node;
            }

            // Vertical split (childNode1 = left half, childNode2 = right half).
            if (widthDifference > heightDifference) {
                node.childNode1 = new TextureAtlasNode(new Cartesian2(node.bottomLeft.x, node.bottomLeft.y), new Cartesian2(node.bottomLeft.x + image.width, node.topRight.y));
                // Only make a second child if the border gives enough space.
                var childNode2BottomLeftX = node.bottomLeft.x + image.width + this._borderWidthInPixels;
                if (childNode2BottomLeftX < node.topRight.x) {
                    node.childNode2 = new TextureAtlasNode(new Cartesian2(childNode2BottomLeftX, node.bottomLeft.y), new Cartesian2(node.topRight.x, node.topRight.y));
                }
            }
            // Horizontal split (childNode1 = bottom half, childNode2 = top half).
            else {
                node.childNode1 = new TextureAtlasNode(new Cartesian2(node.bottomLeft.x, node.bottomLeft.y), new Cartesian2(node.topRight.x, node.bottomLeft.y + image.height));
                // Only make a second child if the border gives enough space.
                var childNode2BottomLeftY = node.bottomLeft.y + image.height + this._borderWidthInPixels;
                if (childNode2BottomLeftY < node.topRight.y) {
                    node.childNode2 = new TextureAtlasNode(new Cartesian2(node.bottomLeft.x, childNode2BottomLeftY), new Cartesian2(node.topRight.x, node.topRight.y));
                }
            }
            return this._findNode(node.childNode1, image);
        }

        // If not a leaf node
        return this._findNode(node.childNode1, image) ||
               this._findNode(node.childNode2, image);
    };

    // Adds image of given index to the texture atlas. Called from addImage and addImages.
    TextureAtlas.prototype._addImage = function(image, index) {
        if (typeof image === 'undefined') {
            throw new DeveloperError('image is required.');
        }

        var node = this._findNode(this._root, image);

        // Found a node that can hold the image.
        if (typeof node !== 'undefined'){
            node.imageIndex = index;

            // Add texture coordinate and write to texture
            var atlasWidth = this._texture.getWidth();
            var atlasHeight = this._texture.getHeight();
            var nodeWidth = node.topRight.x - node.bottomLeft.x;
            var nodeHeight = node.topRight.y - node.bottomLeft.y;
            this._textureCoordinates[index] = new Rectangle(
                node.bottomLeft.x / atlasWidth, node.bottomLeft.y / atlasHeight,
                nodeWidth / atlasWidth, nodeHeight / atlasHeight
            );
            this._texture.copyFrom(image, node.bottomLeft.x, node.bottomLeft.y);
        }
        // No node found, must resize the texture atlas.
        else {
            this._resizeAtlas(image);
            this._addImage(image, index);
        }
    };

    /**
     * Adds an image to the texture atlas.
     * Calling addImages is more space-efficient than calling addImage multiple times.
     * Texture coordinates are subject to change if the texture atlas resizes, so it is
     * important to check {@link TextureAtlas#getGUID} before using old values.
     *
     * @memberof TextureAtlas
     *
     * @param {Image} image An image to be added to the texture atlas.
     *
     * @returns {Number} The index of the newly added image.
     *
     * @exception {DeveloperError} image is required.
     *
     * @see TextureAtlas#addImages
     *
     */
    TextureAtlas.prototype.addImage = function(image) {
        var index = this.getNumberOfImages();
        this._addImage(image, index);

        this._guid = createGuid();

        return index;
            };

    /**
     * Adds an array of images to the texture atlas.
     * Calling addImages is more space-efficient than calling addImage multiple times.
     * Texture coordinates are subject to change if the texture atlas resizes, so it is
     * important to check {@link TextureAtlas#getGUID} before using old values.
     *
     * @memberof TextureAtlas
     *
     * @param {Array} images An array of {@link Image} to be added to the texture atlas.
     *
     * @returns {Number} The first index of the newly added images.
     *
     * @exception {DeveloperError} images is required and must have length greater than zero.
     *
     * @see TextureAtlas#addImage
     *
     */
    TextureAtlas.prototype.addImages = function(images) {
        // Check if image array is valid.
        if (typeof images === 'undefined' || (images.length < 1)) {
            throw new DeveloperError('images is required and must have length greater than zero.');
        }

        // Store images in containers that have an index.
        var i;
        var annotatedImages = [];
        var numberOfImages = images.length;
        var oldNumberOfImages = this.getNumberOfImages();
        for (i = 0; i < numberOfImages; ++i) {
            annotatedImages.push({
                image : images[i],
                index : i + oldNumberOfImages
            });
        }

        // Sort images by maximum to minimum side length.
        annotatedImages.sort(function(left, right) {
            return Math.max(right.image.height, right.image.width) -
                   Math.max(left.image.height, left.image.width);
        });

        // Add images to the texture atlas.
        for (i = 0; i < numberOfImages; ++i) {
            var annotatedImage = annotatedImages[i];
            this._addImage(annotatedImage.image, annotatedImage.index);
    }

        this._guid = createGuid();

        // Return index of the first added image.
        return oldNumberOfImages;
    };


    /**
     * Add a set of sub-regions to one atlas image as additional image indices.
     *
     * @memberof TextureAtlas
     *
     * @param {Image} image An image to be added to the texture atlas.
     * @param {Array} subRegions An array of {@link Rectangle} sub-regions measured in pixels from the bottom-left.
     *
     * @returns {Number} The index of the first newly-added region.
     *
     * @exception {DeveloperError} image is required.
     */
    TextureAtlas.prototype.addSubRegions = function(image, subRegions) {
        var index = this.addImage(image);

        var atlasWidth = this._texture.getWidth();
        var atlasHeight = this._texture.getHeight();
        var numImages = this.getNumberOfImages();
        var numSubRegions = subRegions.length;

        var baseRegion = this._textureCoordinates[index];
        for (var i = 0; i < numSubRegions; ++i) {
            var thisRegion = subRegions[i];
            this._textureCoordinates.push(new Rectangle(
                baseRegion.x + (thisRegion.x / atlasWidth),
                baseRegion.y + (thisRegion.y / atlasHeight),
                thisRegion.width / atlasWidth,
                thisRegion.height / atlasHeight
            ));
        }

        this._guid = createGuid();

        return numImages;
    };

    /**
     * Returns the amount of spacing between adjacent images in pixels.
     *
     * @memberof TextureAtlas
     *
     * @returns {Number} The border width in pixels.
     */
    TextureAtlas.prototype.getBorderWidthInPixels = function() {
        return this._borderWidthInPixels;
    };

    /**
     * Returns an array of {@link Rectangle} texture coordinate regions for all the images in the texture atlas.
     * The x and y values of the rectangle correspond to the bottom-left corner of the texture coordinate.
     * The coordinates are in the order that the corresponding images were added to the atlas.
     *
     * @memberof TextureAtlas
     *
     * @returns {Array} The texture coordinates.
     *
     * @see Rectangle
     */
    TextureAtlas.prototype.getTextureCoordinates = function() {
        return this._textureCoordinates;
    };

    /**
     * Returns the texture that all of the images are being written to.
     *
     * @memberof TextureAtlas
     *
     * @returns {@link Texture} The texture used by the texture atlas.
     */
    TextureAtlas.prototype.getTexture = function() {
        return this._texture;
    };

    /**
     * Returns the number of images in the texture atlas. This value increases
     * every time addImage or addImages is called.
     * Texture coordinates are subject to change if the texture atlas resizes, so it is
     * important to check {@link TextureAtlas#getGUID} before using old values.
     *
     * @memberof TextureAtlas
     *
     * @returns {Number} The number of images in the texture atlas.
     */
    TextureAtlas.prototype.getNumberOfImages = function() {
        return this._textureCoordinates.length;
    };

    /**
     * Returns the atlas' globally unique identifier (GUID).
     * The GUID changes whenever the texture atlas is modified.
     * Classes that use a texture atlas should check if the GUID
     * has changed before processing the atlas data.
     *
     * @memberof TextureAtlas
     *
     * @returns {String} The globally unique identifier (GUID).
     */
    TextureAtlas.prototype.getGUID = function() {
        return this._guid;
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof TextureAtlas
     *
     * @returns {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see TextureAtlas#destroy
     */
    TextureAtlas.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof TextureAtlas
     *
     * @returns {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see TextureAtlas#isDestroyed
     *
     * @example
     * atlas = atlas && atlas.destroy();
     */
    TextureAtlas.prototype.destroy = function() {
        this._texture = this._texture && this._texture.destroy();
        return destroyObject(this);
    };

    return TextureAtlas;
});
/*global define*/
define('Renderer/TextureMagnificationFilter',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports TextureMagnificationFilter
     */
    var TextureMagnificationFilter = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        NEAREST : new Enumeration(0x2600, 'NEAREST'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        LINEAR : new Enumeration(0x2601, 'LINEAR'),

        /**
         * DOC_TBA
         *
         * @param textureMagnificationFilter
         *
         * @returns {Boolean}
         */
        validate : function(textureMagnificationFilter) {
            return ((textureMagnificationFilter === TextureMagnificationFilter.NEAREST) ||
                    (textureMagnificationFilter === TextureMagnificationFilter.LINEAR));
        }
    };

    return TextureMagnificationFilter;
});
/*global define*/
define('Renderer/TextureMinificationFilter',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports TextureMinificationFilter
     */
    var TextureMinificationFilter = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        NEAREST : new Enumeration(0x2600, 'NEAREST'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        LINEAR : new Enumeration(0x2601, 'LINEAR'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        NEAREST_MIPMAP_NEAREST : new Enumeration(0x2700, 'NEAREST_MIPMAP_NEAREST'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        LINEAR_MIPMAP_NEAREST : new Enumeration(0x2701, 'LINEAR_MIPMAP_NEAREST'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        NEAREST_MIPMAP_LINEAR : new Enumeration(0x2702, 'NEAREST_MIPMAP_LINEAR'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        LINEAR_MIPMAP_LINEAR : new Enumeration(0x2703, 'LINEAR_MIPMAP_LINEAR'),

        /**
         * DOC_TBA
         *
         * @param textureMinificationFilter
         *
         * @returns {Boolean}
         */
        validate : function(textureMinificationFilter) {
            return ((textureMinificationFilter === TextureMinificationFilter.NEAREST) ||
                    (textureMinificationFilter === TextureMinificationFilter.LINEAR) ||
                    (textureMinificationFilter === TextureMinificationFilter.NEAREST_MIPMAP_NEAREST) ||
                    (textureMinificationFilter === TextureMinificationFilter.LINEAR_MIPMAP_NEAREST) ||
                    (textureMinificationFilter === TextureMinificationFilter.NEAREST_MIPMAP_LINEAR) ||
                    (textureMinificationFilter === TextureMinificationFilter.LINEAR_MIPMAP_LINEAR));
        }
    };

    return TextureMinificationFilter;
});
/*global define*/
define('Renderer/TextureWrap',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports TextureWrap
     */
    var TextureWrap = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        CLAMP : new Enumeration(0x812F, 'CLAMP'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        REPEAT : new Enumeration(0x2901, 'REPEAT'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        MIRRORED_REPEAT : new Enumeration(0x8370, 'MIRRORED_REPEAT'),

        /**
         * DOC_TBA
         *
         * @param textureWrap
         *
         * @returns {Boolean}
         */
        validate : function(textureWrap) {
            return ((textureWrap === TextureWrap.CLAMP) ||
                    (textureWrap === TextureWrap.REPEAT) ||
                    (textureWrap === TextureWrap.MIRRORED_REPEAT));
        }
    };

    return TextureWrap;
});
/*global define*/
define('Renderer/CubeMap',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        './MipmapHint',
        './TextureMagnificationFilter',
        './TextureMinificationFilter',
        './TextureWrap'
    ], function(
        DeveloperError,
        destroyObject,
        MipmapHint,
        TextureMagnificationFilter,
        TextureMinificationFilter,
        TextureWrap) {
    

    /**
     * DOC_TBA
     *
     * @alias CubeMap
     * @internalConstructor
     *
     * @see Context#createCubeMap
     */
    var CubeMap = function(gl, textureFilterAnisotropic, textureTarget, texture, pixelFormat, pixelDatatype, size, preMultiplyAlpha) {
        this._gl = gl;
        this._textureFilterAnisotropic = textureFilterAnisotropic;
        this._textureTarget = textureTarget;
        this._texture = texture;
        this._pixelFormat = pixelFormat;
        this._pixelDatatype = pixelDatatype;
        this._size = size;
        this._preMultiplyAlpha = preMultiplyAlpha;
        this._sampler = undefined;

        this.setSampler();
    };

    /**
     * DOC_TBA
     *
     * @param {Object} source The source {ImageData}, {HTMLImageElement}, {HTMLCanvasElement}, or {HTMLVideoElement}.
     * @param {Number} xOffset optional
     * @param {Number} yOffset optional
     *
     * @exception {DeveloperError} source is required.
     * @exception {DeveloperError} xOffset must be greater than or equal to zero.
     * @exception {DeveloperError} yOffset must be greater than or equal to zero.
     * @exception {DeveloperError} xOffset + source.width must be less than or equal to getWidth().
     * @exception {DeveloperError} yOffset + source.height must be less than or equal to getHeight().
     * @exception {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.
     */
    CubeMap.prototype._copyFrom = function(targetFace, source, xOffset, yOffset) {
        if (!source) {
            throw new DeveloperError('source is required.');
        }

        xOffset = xOffset || 0;
        yOffset = yOffset || 0;

        var width = source.width;
        var height = source.height;

        if (xOffset < 0) {
            throw new DeveloperError('xOffset must be greater than or equal to zero.');
        }

        if (yOffset < 0) {
            throw new DeveloperError('yOffset must be greater than or equal to zero.');
        }

        if (xOffset + width > this._size) {
            throw new DeveloperError('xOffset + source.width must be less than or equal to getWidth().');
        }

        if (yOffset + height > this._size) {
            throw new DeveloperError('yOffset + source.height must be less than or equal to getHeight().');
        }

        var gl = this._gl;
        var target = this._textureTarget;

        // TODO: gl.pixelStorei(gl._UNPACK_ALIGNMENT, 4);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this._preMultiplyAlpha);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(target, this._texture);

        //Firefox bug: texSubImage2D has overloads and can't resolve our enums, so we use + to explicitly convert to a number.
        if (source.arrayBufferView) {
            gl.texSubImage2D(targetFace, 0, xOffset, yOffset, width, height, +this._pixelFormat, +this._pixelDatatype, source.arrayBufferView);
        } else {
            gl.texSubImage2D(targetFace, 0, xOffset, yOffset, +this._pixelFormat, +this._pixelDatatype, source);
        }

        gl.bindTexture(target, null);
    };

    /**
     * DOC_TBA
     *
     * @param {Number} xOffset optional
     * @param {Number} yOffset optional
     * @param {Number} framebufferXOffset optional
     * @param {Number} framebufferYOffset optional
     * @param {Number} width optional
     * @param {Number} height optional
     *
     * @exception {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.
     * @exception {DeveloperError} xOffset must be greater than or equal to zero.
     * @exception {DeveloperError} yOffset must be greater than or equal to zero.
     * @exception {DeveloperError} framebufferXOffset must be greater than or equal to zero.
     * @exception {DeveloperError} framebufferYOffset must be greater than or equal to zero.
     * @exception {DeveloperError} xOffset + source.width must be less than or equal to getWidth().
     * @exception {DeveloperError} yOffset + source.height must be less than or equal to getHeight().
     */
    CubeMap.prototype._copyFromFramebuffer = function(targetFace, xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height) {
        xOffset = xOffset || 0;
        yOffset = yOffset || 0;
        framebufferXOffset = framebufferXOffset || 0;
        framebufferYOffset = framebufferYOffset || 0;
        width = width || this._size;
        height = height || this._size;

        if (xOffset < 0) {
            throw new DeveloperError('xOffset must be greater than or equal to zero.');
        }

        if (yOffset < 0) {
            throw new DeveloperError('yOffset must be greater than or equal to zero.');
        }

        if (framebufferXOffset < 0) {
            throw new DeveloperError('framebufferXOffset must be greater than or equal to zero.');
        }

        if (framebufferYOffset < 0) {
            throw new DeveloperError('framebufferYOffset must be greater than or equal to zero.');
        }

        if (xOffset + width > this._size) {
            throw new DeveloperError('xOffset + source.width must be less than or equal to getWidth().');
        }

        if (yOffset + height > this._size) {
            throw new DeveloperError('yOffset + source.height must be less than or equal to getHeight().');
        }

        var gl = this._gl;
        var target = this._textureTarget;

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(target, this._texture);
        gl.copyTexSubImage2D(targetFace, 0, xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height);
        gl.bindTexture(target, null);
    };

    /**
     * DOC_TBA
     * @memberof CubeMap
     */
    CubeMap.prototype.getPositiveX = function() {
        var that = this;
        return {
            copyFrom : function(source, xOffset, yOffset) {
                that._copyFrom(that._gl.TEXTURE_CUBE_MAP_POSITIVE_X, source, xOffset, yOffset);
            },

            copyFromFramebuffer : function(xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height) {
                that._copyFromFramebuffer(that._gl.TEXTURE_CUBE_MAP_POSITIVE_X, xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height);
            },

            _getTexture : function() {
                return that._texture;
            },

            _getTarget : function() {
                return that._gl.TEXTURE_CUBE_MAP_POSITIVE_X;
            }
        };
    };

    /**
     * DOC_TBA
     * @memberof CubeMap
     */
    CubeMap.prototype.getNegativeX = function() {
        var that = this;
        return {
            copyFrom : function(source, xOffset, yOffset) {
                that._copyFrom(that._gl.TEXTURE_CUBE_MAP_NEGATIVE_X, source, xOffset, yOffset);
            },

            copyFromFramebuffer : function(xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height) {
                that._copyFromFramebuffer(that._gl.TEXTURE_CUBE_MAP_NEGATIVE_X, xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height);
            },

            _getTexture : function() {
                return that._texture;
            },

            _getTarget : function() {
                return that._gl.TEXTURE_CUBE_MAP_NEGATIVE_X;
            }
        };
    };

    /**
     * DOC_TBA
     * @memberof CubeMap
     */
    CubeMap.prototype.getPositiveY = function() {
        var that = this;
        return {
            copyFrom : function(source, xOffset, yOffset) {
                that._copyFrom(that._gl.TEXTURE_CUBE_MAP_POSITIVE_Y, source, xOffset, yOffset);
            },

            copyFromFramebuffer : function(xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height) {
                that._copyFromFramebuffer(that._gl.TEXTURE_CUBE_MAP_POSITIVE_Y, xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height);
            },

            _getTexture : function() {
                return that._texture;
            },

            _getTarget : function() {
                return that._gl.TEXTURE_CUBE_MAP_POSITIVE_Y;
            }
        };
    };

    /**
     * DOC_TBA
     * @memberof CubeMap
     */
    CubeMap.prototype.getNegativeY = function() {
        var that = this;
        return {
            copyFrom : function(source, xOffset, yOffset) {
                that._copyFrom(that._gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, source, xOffset, yOffset);
            },

            copyFromFramebuffer : function(xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height) {
                that._copyFromFramebuffer(that._gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height);
            },

            _getTexture : function() {
                return that._texture;
            },

            _getTarget : function() {
                return that._gl.TEXTURE_CUBE_MAP_NEGATIVE_Y;
            }
        };
    };

    /**
     * DOC_TBA
     * @memberof CubeMap
     */
    CubeMap.prototype.getPositiveZ = function() {
        var that = this;
        return {
            copyFrom : function(source, xOffset, yOffset) {
                that._copyFrom(that._gl.TEXTURE_CUBE_MAP_POSITIVE_Z, source, xOffset, yOffset);
            },

            copyFromFramebuffer : function(xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height) {
                that._copyFromFramebuffer(that._gl.TEXTURE_CUBE_MAP_POSITIVE_Z, xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height);
            },

            _getTexture : function() {
                return that._texture;
            },

            _getTarget : function() {
                return that._gl.TEXTURE_CUBE_MAP_POSITIVE_Z;
            }
        };
    };

    /**
     * DOC_TBA
     * @memberof CubeMap
     */
    CubeMap.prototype.getNegativeZ = function() {
        var that = this;
        return {
            copyFrom : function(source, xOffset, yOffset) {
                that._copyFrom(that._gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, source, xOffset, yOffset);
            },

            copyFromFramebuffer : function(xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height) {
                that._copyFromFramebuffer(that._gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height);
            },

            _getTexture : function() {
                return that._texture;
            },

            _getTarget : function() {
                return that._gl.TEXTURE_CUBE_MAP_NEGATIVE_Z;
            }
        };
    };

    /**
     * DOC_TBA
     *
     * @memberof CubeMap
     *
     * @param {MipmapHint} hint optional.
     *
     * @exception {DeveloperError} hint is invalid.
     * @exception {DeveloperError} This CubeMap's width must be a power of two to call generateMipmap().
     * @exception {DeveloperError} This CubeMap's height must be a power of two to call generateMipmap().
     * @exception {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.
     */
    CubeMap.prototype.generateMipmap = function(hint) {
        if ((this._size > 1) && (this._size % 2 !== 0)) {
            throw new DeveloperError('width and height must be a power of two to call generateMipmap().');
        }

        hint = hint || MipmapHint.DONT_CARE;
        if (!MipmapHint.validate(hint)) {
            throw new DeveloperError('hint is invalid.');
        }

        var gl = this._gl;
        var target = this._textureTarget;

        gl.hint(gl.GENERATE_MIPMAP_HINT, hint);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(target, this._texture);
        gl.generateMipmap(target);
        gl.bindTexture(target, null);
    };

    /**
     * DOC_TBA
     *
     * @memberof CubeMap
     *
     * @param sampler optional.
     *
     * @exception {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.
     */
    CubeMap.prototype.setSampler = function(sampler) {
        var s = sampler || {
            wrapS : TextureWrap.CLAMP,
            wrapT : TextureWrap.CLAMP,
            minificationFilter : TextureMinificationFilter.LINEAR,
            magnificationFilter : TextureMagnificationFilter.LINEAR,
            maximumAnisotropy : 1.0
        };

        var gl = this._gl;
        var target = this._textureTarget;

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(target, this._texture);
        gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, s.minificationFilter);
        gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, s.magnificationFilter);
        gl.texParameteri(target, gl.TEXTURE_WRAP_S, s.wrapS);
        gl.texParameteri(target, gl.TEXTURE_WRAP_T, s.wrapT);
        if (this._textureFilterAnisotropic) {
            gl.texParameteri(target, this._textureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, s.maximumAnisotropy);
        }
        gl.bindTexture(target, null);

        this._sampler = {
            wrapS : s.wrapS,
            wrapT : s.wrapT,
            minificationFilter : s.minificationFilter,
            magnificationFilter : s.magnificationFilter,
            maximumAnisotropy : s.maximumAnisotropy
        };
    };

    /**
     * DOC_TBA
     *
     * @memberof CubeMap
     *
     * @exception {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.
     */
    CubeMap.prototype.getSampler = function() {
        return this._sampler;
    };

    /**
     * DOC_TBA
     *
     * @memberof CubeMap
     *
     * @exception {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.
     */
    CubeMap.prototype.getPixelFormat = function() {
        return this._pixelFormat;
    };

    /**
     * DOC_TBA
     *
     * @memberof CubeMap
     *
     * @exception {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.
     */
    CubeMap.prototype.getPixelDatatype = function() {
        return this._pixelDatatype;
    };

    /**
     * DOC_TBA
     *
     * @memberof CubeMap
     *
     * @exception {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.
     */
    CubeMap.prototype.getWidth = function() {
        return this._size;
    };

    /**
     * DOC_TBA
     *
     * @memberof CubeMap
     *
     * @exception {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.
     */
    CubeMap.prototype.getHeight = function() {
        return this._size;
    };

    /**
     * DOC_TBA
     *
     * @memberof CubeMap
     *
     * @exception {DeveloperError} This texture was destroyed, i.e., destroy() was called.
     */
    CubeMap.prototype.getPreMultiplyAlpha = function() {
        return this._preMultiplyAlpha;
    };

    CubeMap.prototype._getTexture = function() {
        return this._texture;
    };

    CubeMap.prototype._getTarget = function() {
        return this._textureTarget;
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof CubeMap
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see CubeMap.destroy
     */
    CubeMap.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof CubeMap
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This cube map was destroyed, i.e., destroy() was called.
     *
     * @see CubeMap.isDestroyed
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glDeleteTextures.xml'>glDeleteTextures</a>
     *
     * @example
     * cubeMap = cubeMap && cubeMap.destroy();
     */
    CubeMap.prototype.destroy = function() {
        this._gl.deleteTexture(this._texture);
        return destroyObject(this);
    };

    return CubeMap;
});
/*global define*/
define('Renderer/Texture',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/Cartesian2',
        './MipmapHint',
        './TextureMagnificationFilter',
        './TextureMinificationFilter',
        './TextureWrap'
    ], function(
        DeveloperError,
        destroyObject,
        Cartesian2,
        MipmapHint,
        TextureMagnificationFilter,
        TextureMinificationFilter,
        TextureWrap) {
    

    /**
     * DOC_TBA
     *
     * @alias Texture
     * @internalConstructor
     *
     * @see Context#createTexture2D
     * @see Context#createTexture2DFromFramebuffer
     */
    var Texture = function(gl, textureFilterAnisotropic, textureTarget, texture, pixelFormat, pixelDatatype, width, height, preMultiplyAlpha) {
        this._gl = gl;
        this._textureFilterAnisotropic = textureFilterAnisotropic;
        this._textureTarget = textureTarget;
        this._texture = texture;
        this._pixelFormat = pixelFormat;
        this._pixelDatatype = pixelDatatype;
        this._width = width;
        this._height = height;
        this._dimensions = new Cartesian2(width, height);
        this._preMultiplyAlpha = preMultiplyAlpha;
        this._sampler = undefined;

        this.setSampler();
    };

    /**
     * DOC_TBA
     *
     * @memberof Texture
     *
     * @param {Object} source The source {ImageData}, {HTMLImageElement}, {HTMLCanvasElement}, or {HTMLVideoElement}.
     * @param {Number} xOffset optional
     * @param {Number} yOffset optional
     *
     * @exception {DeveloperError} source is required.
     * @exception {DeveloperError} xOffset must be greater than or equal to zero.
     * @exception {DeveloperError} yOffset must be greater than or equal to zero.
     * @exception {DeveloperError} xOffset + source.width must be less than or equal to getWidth().
     * @exception {DeveloperError} yOffset + source.height must be less than or equal to getHeight().
     * @exception {DeveloperError} This texture was destroyed, i.e., destroy() was called.
     */
    Texture.prototype.copyFrom = function(source, xOffset, yOffset) {
        if (!source) {
            throw new DeveloperError('source is required.');
        }

        xOffset = xOffset || 0;
        yOffset = yOffset || 0;

        var width = source.width;
        var height = source.height;

        if (xOffset < 0) {
            throw new DeveloperError('xOffset must be greater than or equal to zero.');
        }

        if (yOffset < 0) {
            throw new DeveloperError('yOffset must be greater than or equal to zero.');
        }

        if (xOffset + width > this._width) {
            throw new DeveloperError('xOffset + source.width must be less than or equal to getWidth().');
        }

        if (yOffset + height > this._height) {
            throw new DeveloperError('yOffset + source.height must be less than or equal to getHeight().');
        }

        var gl = this._gl;
        var target = this._textureTarget;

        // TODO: gl.pixelStorei(gl._UNPACK_ALIGNMENT, 4);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this._preMultiplyAlpha);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(target, this._texture);

        //Firefox bug: texSubImage2D has overloads and can't resolve our enums, so we use + to explicitly convert to a number.
        if (source.arrayBufferView) {
            gl.texSubImage2D(target, 0, xOffset, yOffset, width, height, +this._pixelFormat, +this._pixelDatatype, source.arrayBufferView);
        } else {
            gl.texSubImage2D(target, 0, xOffset, yOffset, this._pixelFormat, this._pixelDatatype, source);
        }

        gl.bindTexture(target, null);
    };

    /**
     * DOC_TBA
     *
     * @memberof Texture
     *
     * @param {Number} xOffset optional
     * @param {Number} yOffset optional
     * @param {Number} framebufferXOffset optional
     * @param {Number} framebufferYOffset optional
     * @param {Number} width optional
     * @param {Number} height optional
     *
     * @exception {DeveloperError} This texture was destroyed, i.e., destroy() was called.
     * @exception {DeveloperError} xOffset must be greater than or equal to zero.
     * @exception {DeveloperError} yOffset must be greater than or equal to zero.
     * @exception {DeveloperError} framebufferXOffset must be greater than or equal to zero.
     * @exception {DeveloperError} framebufferYOffset must be greater than or equal to zero.
     * @exception {DeveloperError} xOffset + source.width must be less than or equal to getWidth().
     * @exception {DeveloperError} yOffset + source.height must be less than or equal to getHeight().
     */
    Texture.prototype.copyFromFramebuffer = function(xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height) {
        xOffset = xOffset || 0;
        yOffset = yOffset || 0;
        framebufferXOffset = framebufferXOffset || 0;
        framebufferYOffset = framebufferYOffset || 0;
        width = width || this._width;
        height = height || this._height;

        if (xOffset < 0) {
            throw new DeveloperError('xOffset must be greater than or equal to zero.');
        }

        if (yOffset < 0) {
            throw new DeveloperError('yOffset must be greater than or equal to zero.');
        }

        if (framebufferXOffset < 0) {
            throw new DeveloperError('framebufferXOffset must be greater than or equal to zero.');
        }

        if (framebufferYOffset < 0) {
            throw new DeveloperError('framebufferYOffset must be greater than or equal to zero.');
        }

        if (xOffset + width > this._width) {
            throw new DeveloperError('xOffset + source.width must be less than or equal to getWidth().');
        }

        if (yOffset + height > this._height) {
            throw new DeveloperError('yOffset + source.height must be less than or equal to getHeight().');
        }

        var gl = this._gl;
        var target = this._textureTarget;

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(target, this._texture);
        gl.copyTexSubImage2D(target, 0, xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height);
        gl.bindTexture(target, null);
    };

    /**
     * DOC_TBA
     *
     * @memberof Texture
     *
     * @param {MipmapHint} hint optional.
     *
     * @exception {DeveloperError} hint is invalid.
     * @exception {DeveloperError} This texture's width must be a power of two to call generateMipmap().
     * @exception {DeveloperError} This texture's height must be a power of two to call generateMipmap().
     * @exception {DeveloperError} This texture was destroyed, i.e., destroy() was called.
     */
    Texture.prototype.generateMipmap = function(hint) {
        if ((this._width > 1) && (this._width % 2 !== 0)) {
            throw new DeveloperError('width must be a power of two to call generateMipmap().');
        } else if ((this._height > 1) && (this._height % 2 !== 0)) {
            throw new DeveloperError('height must be a power of two to call generateMipmap().');
        }

        hint = hint || MipmapHint.DONT_CARE;
        if (!MipmapHint.validate(hint)) {
            throw new DeveloperError('hint is invalid.');
        }

        var gl = this._gl;
        var target = this._textureTarget;

        gl.hint(gl.GENERATE_MIPMAP_HINT, hint);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(target, this._texture);
        gl.generateMipmap(target);
        gl.bindTexture(target, null);
    };

    /**
    * DOC_TBA
    *
    * @memberof Texture
    *
    * @param sampler optional.
    *
    * @exception {DeveloperError} This texture was destroyed, i.e., destroy() was called.
    */
    Texture.prototype.setSampler = function(sampler) {
        var s = sampler || {
            wrapS : TextureWrap.CLAMP,
            wrapT : TextureWrap.CLAMP,
            minificationFilter : TextureMinificationFilter.LINEAR,
            magnificationFilter : TextureMagnificationFilter.LINEAR,
            maximumAnisotropy : 1.0
        };

        var gl = this._gl;
        var target = this._textureTarget;

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(target, this._texture);
        gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, s.minificationFilter);
        gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, s.magnificationFilter);
        gl.texParameteri(target, gl.TEXTURE_WRAP_S, s.wrapS);
        gl.texParameteri(target, gl.TEXTURE_WRAP_T, s.wrapT);
        if (this._textureFilterAnisotropic) {
            gl.texParameteri(target, this._textureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, s.maximumAnisotropy);
        }
        gl.bindTexture(target, null);

        this._sampler = {
            wrapS : s.wrapS,
            wrapT : s.wrapT,
            minificationFilter : s.minificationFilter,
            magnificationFilter : s.magnificationFilter,
            maximumAnisotropy : s.maximumAnisotropy
        };
    };

    /**
     * DOC_TBA
     * @memberof Texture
     * @exception {DeveloperError} This texture was destroyed, i.e., destroy() was called.
     */
    Texture.prototype.getSampler = function() {
        return this._sampler;
    };

    /**
     * DOC_TBA
     * @memberof Texture
     * @exception {DeveloperError} This texture was destroyed, i.e., destroy() was called.
     */
    Texture.prototype.getPixelFormat = function() {
        return this._pixelFormat;
    };

    /**
     * DOC_TBA
     * @memberof Texture
     * @exception {DeveloperError} This texture was destroyed, i.e., destroy() was called.
     */
    Texture.prototype.getPixelDatatype = function() {
        return this._pixelDatatype;
    };

    /**
     * DOC_TBA
     * @memberof Texture
     * @exception {DeveloperError} This texture was destroyed, i.e., destroy() was called.
     */
    Texture.prototype.getWidth = function() {
        return this._width;
    };

    /**
     * DOC_TBA
     * @memberof Texture
     * @exception {DeveloperError} This texture was destroyed, i.e., destroy() was called.
     */
    Texture.prototype.getDimensions = function() {
        return this._dimensions;
    };

    /**
     * DOC_TBA
     * @memberof Texture
     * @exception {DeveloperError} This texture was destroyed, i.e., destroy() was called.
     */
    Texture.prototype.getPreMultiplyAlpha = function() {
        return this._preMultiplyAlpha;
    };

    /**
     * DOC_TBA
     * @memberof Texture
     * @exception {DeveloperError} This texture was destroyed, i.e., destroy() was called.
     */
    Texture.prototype.getHeight = function() {
        return this._height;
    };

    Texture.prototype._getTexture = function() {
        return this._texture;
    };

    Texture.prototype._getTarget = function() {
        return this._textureTarget;
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof Texture
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see Texture.destroy
     */
    Texture.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof Texture
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This texture was destroyed, i.e., destroy() was called.
     *
     * @see Texture.isDestroyed
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glDeleteTextures.xml'>glDeleteTextures</a>
     *
     * @example
     * texture = texture && texture.destroy();
     */
    Texture.prototype.destroy = function() {
        this._gl.deleteTexture(this._texture);
        return destroyObject(this);
    };

    return Texture;
});
/*global define*/
define('Renderer/UniformDatatype',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * Indicates a GLSL uniform's datatype.
     *
     * @exports UniformDatatype
     * @see Uniform.getDatatype
     */
    var UniformDatatype = {
        /**
         * A <code>float</code> uniform.
         *
         * @constant
         * @type {Enumeration}
         */
        FLOAT : new Enumeration(0x1406, 'FLOAT', {
            getGLSL : function() {
                return 'float';
            }
        }), // FLOAT

        /**
         * A <code>vec2</code> uniform: a two-component floating-point vector.
         *
         * @constant
         * @type {Enumeration}
         */
        FLOAT_VECTOR2 : new Enumeration(0x8B50, 'FLOAT_VECTOR2', {
            getGLSL : function() {
                return 'vec2';
            }
        }), // FLOAT_VEC2

        /**
         * A <code>vec3</code> uniform: a three-component floating-point vector.
         *
         * @constant
         * @type {Enumeration}
         */
        FLOAT_VECTOR3 : new Enumeration(0x8B51, 'FLOAT_VECTOR3', {
            getGLSL : function() {
                return 'vec3';
            }
        }), // FLOAT_VEC3

        /**
         * A <code>vec4</code> uniform: a four-component floating-point vector.
         *
         * @constant
         * @type {Enumeration}
         */
        FLOAT_VECTOR4 : new Enumeration(0x8B52, 'FLOAT_VECTOR4', {
            getGLSL : function() {
                return 'vec4';
            }
        }), // FLOAT_VEC4

        /**
         * An <code>int</code> uniform.
         *
         * @constant
         * @type {Enumeration}
         */
        INT : new Enumeration(0x1404, 'INT', {
            getGLSL : function() {
                return 'int';
            }
        }), // INT

        /**
         * An <code>ivec2</code> uniform: a two-component integer vector.
         *
         * @constant
         * @type {Enumeration}
         */
        INT_VECTOR2 : new Enumeration(0x8B53, 'INT_VECTOR2', {
            getGLSL : function() {
                return 'ivec2';
            }
        }), // INT_VEC2

        /**
         * An <code>ivec3</code> uniform: a three-component integer vector.
         *
         * @constant
         * @type {Enumeration}
         */
        INT_VECTOR3 : new Enumeration(0x8B54, 'INT_VECTOR3', {
            getGLSL : function() {
                return 'ivec3';
            }
        }), // INT_VEC3

        /**
         * An <code>ivec4</code> uniform: a four-component integer vector.
         *
         * @constant
         * @type {Enumeration}
         */
        INT_VECTOR4 : new Enumeration(0x8B55, 'INT_VECTOR4', {
            getGLSL : function() {
                return 'ivec4';
            }
        }), // INT_VEC4

        /**
         * A <code>bool</code> uniform.
         *
         * @constant
         * @type {Enumeration}
         */
        BOOL : new Enumeration(0x8B56, 'BOOL', {
            getGLSL : function() {
                return 'bool';
            }
        }), // BOOL

        /**
         * A <code>bvec2</code> uniform: a two-component boolean vector.
         *
         * @constant
         * @type {Enumeration}
         */
        BOOL_VECTOR2 : new Enumeration(0x8B57, 'BOOL_VECTOR2', {
            getGLSL : function() {
                return 'bvec2';
            }
        }), // BOOL_VEC2

        /**
         * A <code>bvec3</code> uniform: a three-component boolean vector.
         *
         * @constant
         * @type {Enumeration}
         */
        BOOL_VECTOR3 : new Enumeration(0x8B58, 'BOOL_VECTOR3', {
            getGLSL : function() {
                return 'bvec3';
            }
        }), // BOOL_VEC3

        /**
         * A <code>bvec4</code> uniform: a four-component boolean vector.
         *
         * @constant
         * @type {Enumeration}
         */
        BOOL_VECTOR4 : new Enumeration(0x8B59, 'BOOL_VECTOR4', {
            getGLSL : function() {
                return 'bvec4';
            }
        }), // BOOL_VEC4

        /**
         * An <code>mat2</code> uniform: a 2x2 floating-point matrix.
         *
         * @constant
         * @type {Enumeration}
         */
        FLOAT_MATRIX2 : new Enumeration(0x8B5A, 'FLOAT_MATRIX2', {
            getGLSL : function() {
                return 'mat2';
            }
        }), // FLOAT_MAT2

        /**
         * An <code>mat3</code> uniform: a 3x3 floating-point matrix.
         *
         * @constant
         * @type {Enumeration}
         */
        FLOAT_MATRIX3 : new Enumeration(0x8B5B, 'FLOAT_MATRIX3', {
            getGLSL : function() {
                return 'mat3';
            }
        }), // FLOAT_MAT3

        /**
         * An <code>mat4</code> uniform: a 4x4 floating-point matrix.
         *
         * @constant
         * @type {Enumeration}
         */
        FLOAT_MATRIX4 : new Enumeration(0x8B5C, 'FLOAT_MATRIX4', {
            getGLSL : function() {
                return 'mat4';
            }
        }), // FLOAT_MAT4

        /**
         * A <code>sampler2D</code> uniform: an opaque type to access 2D textures.
         *
         * @constant
         * @type {Enumeration}
         */
        SAMPLER_2D : new Enumeration(0x8B5E, 'SAMPLER_2D', {
            getGLSL : function() {
                return 'sampler2D';
            }
        }), // SAMPLER_2D

        /**
         * A <code>samplerCube</code> uniform: an opaque type to access cube-map textures.
         *
         * @constant
         * @type {Enumeration}
         */
        SAMPLER_CUBE : new Enumeration(0x8B60, 'SAMPLER_CUBE', {
            getGLSL : function() {
                return 'samplerCube';
            }
        }) // SAMPLER_CUBE
    };

    return UniformDatatype;
});
/*global define*/
define('Renderer/ShaderProgram',[
        '../Core/DeveloperError',
        '../Core/RuntimeError',
        '../Core/destroyObject',
        '../Core/Math',
        '../Core/Matrix2',
        '../Core/Matrix3',
        '../Core/Matrix4',
        './UniformDatatype'
    ], function(
        DeveloperError,
        RuntimeError,
        destroyObject,
        CesiumMath,
        Matrix2,
        Matrix3,
        Matrix4,
        UniformDatatype) {
    
    /*global console*/

    function getUniformDatatype(gl, activeUniformType) {
        switch (activeUniformType) {
        case gl.FLOAT:
            return function() {
                return UniformDatatype.FLOAT;
            };
        case gl.FLOAT_VEC2:
            return function() {
                return UniformDatatype.FLOAT_VECTOR2;
            };
        case gl.FLOAT_VEC3:
            return function() {
                return UniformDatatype.FLOAT_VECTOR3;
            };
        case gl.FLOAT_VEC4:
            return function() {
                return UniformDatatype.FLOAT_VECTOR4;
            };
        case gl.INT:
            return function() {
                return UniformDatatype.INT;
            };
        case gl.INT_VEC2:
            return function() {
                return UniformDatatype.INT_VECTOR2;
            };
        case gl.INT_VEC3:
            return function() {
                return UniformDatatype.INT_VECTOR3;
            };
        case gl.INT_VEC4:
            return function() {
                return UniformDatatype.INT_VECTOR4;
            };
        case gl.BOOL:
            return function() {
                return UniformDatatype.BOOL;
            };
        case gl.BOOL_VEC2:
            return function() {
                return UniformDatatype.BOOL_VECTOR2;
            };
        case gl.BOOL_VEC3:
            return function() {
                return UniformDatatype.BOOL_VECTOR3;
            };
        case gl.BOOL_VEC4:
            return function() {
                return UniformDatatype.BOOL_VECTOR4;
            };
        case gl.FLOAT_MAT2:
            return function() {
                return UniformDatatype.FLOAT_MATRIX2;
            };
        case gl.FLOAT_MAT3:
            return function() {
                return UniformDatatype.FLOAT_MATRIX3;
            };
        case gl.FLOAT_MAT4:
            return function() {
                return UniformDatatype.FLOAT_MATRIX4;
            };
        case gl.SAMPLER_2D:
            return function() {
                return UniformDatatype.SAMPLER_2D;
            };
        case gl.SAMPLER_CUBE:
            return function() {
                return UniformDatatype.SAMPLER_CUBE;
            };
        default:
            throw new RuntimeError('Unrecognized uniform type: ' + activeUniformType);
        }
    }

    /**
     * A shader program's uniform, including the uniform's value.  This is most commonly used to change
     * the value of a uniform, but can also be used retrieve a uniform's name and datatype,
     * which is useful for creating user interfaces for tweaking shaders.
     * <br /><br />
     * Do not create a uniform object with the <code>new</code> keyword; a shader program's uniforms
     * are available via {@link ShaderProgram#getAllUniforms}.
     * <br /><br />
     * Changing a uniform's value will affect future calls to {@link Context#draw}
     * that use the corresponding shader program.
     * <br /><br />
     * The datatype of the <code>value</code> property depends on the datatype
     * used in the GLSL declaration as shown in the examples in the table below.
     * <br /><br />
     * <table border='1'>
     * <tr>
     * <td>GLSL</td>
     * <td>JavaScript</td>
     * </tr>
     * <tr>
     * <td><code>uniform float u_float; </code></td>
     * <td><code> sp.getAllUniforms().u_float.value = 1.0;</code></td>
     * </tr>
     * <tr>
     * <td><code>uniform vec2 u_vec2; </code></td>
     * <td><code> sp.getAllUniforms().u_vec2.value = new Cartesian2(1.0, 2.0);</code></td>
     * </tr>
     * <tr>
     * <td><code>uniform vec3 u_vec3; </code></td>
     * <td><code> sp.getAllUniforms().u_vec3.value = new Cartesian3(1.0, 2.0, 3.0);</code></td>
     * </tr>
     * <tr>
     * <td><code>uniform vec4 u_vec4; </code></td>
     * <td><code> sp.getAllUniforms().u_vec4.value = new Cartesian4(1.0, 2.0, 3.0, 4.0);</code></td>
     * </tr>
     * <tr>
     * <td><code>uniform int u_int; </code></td>
     * <td><code> sp.getAllUniforms().u_int.value = 1;</code></td>
     * </tr>
     * <tr>
     * <td><code>uniform ivec2 u_ivec2; </code></td>
     * <td><code> sp.getAllUniforms().u_ivec2.value = new Cartesian2(1, 2);</code></td>
     * </tr>
     * <tr>
     * <td><code>uniform ivec3 u_ivec3; </code></td>
     * <td><code> sp.getAllUniforms().u_ivec3.value = new Cartesian3(1, 2, 3);</code></td>
     * </tr>
     * <tr>
     * <td><code>uniform ivec4 u_ivec4; </code></td>
     * <td><code> sp.getAllUniforms().u_ivec4.value = new Cartesian4(1, 2, 3, 4);</code></td>
     * </tr>
     * <tr>
     * <td><code>uniform bool u_bool; </code></td>
     * <td><code> sp.getAllUniforms().u_bool.value = true;</code></td>
     * </tr>
     * <tr>
     * <td><code>uniform bvec2 u_bvec2; </code></td>
     * <td><code> sp.getAllUniforms().u_bvec2.value = new Cartesian2(true, true);</code></td>
     * </tr>
     * <tr>
     * <td><code>uniform bvec3 u_bvec3; </code></td>
     * <td><code> sp.getAllUniforms().u_bvec3.value = new Cartesian3(true, true, true);</code></td>
     * </tr>
     * <tr>
     * <td><code>uniform bvec4 u_bvec4; </code></td>
     * <td><code> sp.getAllUniforms().u_bvec4.value = new Cartesian4(true, true, true, true);</code></td>
     * </tr>
     * <tr>
     * <td><code>uniform mat2 u_mat2; </code></td>
     * <td><code> sp.getAllUniforms().u_mat2.value = new Matrix2(1.0, 2.0, 3.0, 4.0);</code></td>
     * </tr>
     * <tr>
     * <td><code>uniform mat3 u_mat3; </code></td>
     * <td><code> sp.getAllUniforms().u_mat3.value = new Matrix3(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0);</code></td>
     * </tr>
     * <tr>
     * <td><code>uniform mat4 u_mat4; </code></td>
     * <td><code> sp.getAllUniforms().u_mat4.value = new Matrix4(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 8.0, 7.0, 6.0, 5.0, 4.0, 3.0, 2.0);</code></td>
     * </tr>
     * <tr>
     * <td><code>uniform sampler2D u_texture; </code></td>
     * <td><code> sp.getAllUniforms().u_texture.value = context.createTexture2D(...);</code></td>
     * </tr>
     * <tr>
     * <td><code>uniform samplerCube u_cubeMap; </code></td>
     * <td><code> sp.getAllUniforms().u_cubeMap.value = context.createCubeMap(...);</code></td>
     * </tr>
     * </table>
     * <br />
     * When the GLSL uniform is declared as an array, <code>value</code> is also an array as shown in Example 2.
     * Individual members of a <code>struct uniform</code> can be accessed as done in Example 3.
     * <br /><br />
     * Uniforms whose names starting with <code>agi_</code>, such as {@link agi_viewProjection}, are called
     * automatic uniforms; they are implicitly declared and automatically assigned to in
     * <code>Context.draw</code> based on the {@link UniformState}.
     *
     * @alias Uniform
     * @internalConstructor
     *
     * @see Uniform#value
     * @see UniformDatatype
     * @see ShaderProgram#getAllUniforms
     * @see UniformState
     * @see Context#draw
     * @see Context#createTexture2D
     * @see Context#createCubeMap
     *
     * @example
     * // Example 1. Create a shader program and set its
     * // one uniform, a 4x4 matrix, to the identity matrix
     * var vs =
     *   'attribute vec4 position; ' +
     *   'uniform mat4 u_mvp; ' +
     *   'void main() { gl_Position = u_mvp * position; }';
     * var fs = // ...
     * var sp = context.createShaderProgram(vs, fs);
     *
     * var mvp = sp.getAllUniforms().u_mvp;
     * console.log(mvp.getName());           // 'u_mvp'
     * console.log(mvp.getDatatype().name);  // 'FLOAT_MATRIX4'
     * mvp.value = Matrix4.IDENTITY;
     *
     * //////////////////////////////////////////////////////////////////////
     *
     * // Example 2. Setting values for a GLSL array uniform
     * // GLSL:  uniform float u_float[2];
     * sp.getAllUniforms().u_float.value = new Cartesian2(1.0, 2.0);
     *
     * // GLSL:  uniform vec4 u_vec4[2];
     * sp.getAllUniforms().u_vec4.value = [
     *   Cartesian4.UNIT_X,
     *   Cartesian4.UNIT_Y
     * ];
     *
     * //////////////////////////////////////////////////////////////////////
     *
     * // Example 3. Setting values for members of a GLSL struct
     * // GLSL:  uniform struct { float f; vec4 v; } u_struct;
     * sp.getAllUniforms()['u_struct.f'].value = 1.0;
     * sp.getAllUniforms()['u_struct.v'].value = new Cartesian4(1.0, 2.0, 3.0, 4.0);
     */
    var Uniform = function(_gl, activeUniform, _uniformName, _location, uniformValue) {
        /**
         * The value of the uniform.  The datatype depends on the datatype used in the
         * GLSL declaration as explained in the {@link Uniform} help and shown
         * in the examples below.
         *
         * @field
         * @alias Uniform#value
         *
         * @see Context#createTexture2D
         *
         * @example
         * // GLSL:  uniform float u_float;
         * sp.getAllUniforms().u_float.value = 1.0;
         *
         * // GLSL:  uniform vec4 u_vec4;
         * sp.getAllUniforms().u_vec4.value = Cartesian4.ZERO;
         *
         * // GLSL:  uniform bvec4 u_bvec4;
         * sp.getAllUniforms().u_bvec4.value = new Cartesian4(true, true, true, true);
         *
         * // GLSL:  uniform mat4 u_mat4;
         * sp.getAllUniforms().u_mat4.value = Matrix4.IDENTITY;
         *
         * // GLSL:  uniform sampler2D u_texture;
         * sp.getAllUniforms().u_texture.value = context.createTexture2D(...);
         *
         * // GLSL:  uniform vec2 u_vec2[2];
         * sp.getAllUniforms().u_vec2.value = [
         *   new Cartesian2(1.0, 2.0),
         *   new Cartesian2(3.0, 4.0)
         * ];
         *
         * // GLSL:  uniform struct { float f; vec4 v; } u_struct;
         * sp.getAllUniforms()['u_struct.f'].value = 1.0;
         * sp.getAllUniforms()['u_struct.v'].value = new Cartesian4(1.0, 2.0, 3.0, 4.0);
         */
        this.value = uniformValue;

        /**
         * Returns the case-sensitive name of the GLSL uniform.
         *
         * @returns {String} The name of the uniform.
         * @function
         * @alias Uniform#getName
         *
         * @example
         * // GLSL: uniform mat4 u_mvp;
         * console.log(sp.getAllUniforms().u_mvp.getName());  // 'u_mvp'
         */
        this.getName = function() {
            return _uniformName;
        };

        /**
         * Returns the datatype of the uniform.  This is useful when dynamically
         * creating a user interface to tweak shader uniform values.
         *
         * @returns {UniformDatatype} The datatype of the uniform.
         * @function
         * @alias Uniform#getDatatype
         *
         * @see UniformDatatype
         *
         * @example
         * // GLSL: uniform mat4 u_mvp;
         * console.log(sp.getAllUniforms().u_mvp.getDatatype().name);  // 'FLOAT_MATRIX4'
         */
        this.getDatatype = getUniformDatatype(_gl, activeUniform.type);

        this._getLocation = function() {
            return _location;
        };

        this._set = function() {
            switch (activeUniform.type) {
            case _gl.FLOAT:
                return function() {
                    _gl.uniform1f(_location, this.value);
                };
            case _gl.FLOAT_VEC2:
                return function() {
                    var v = this.value;
                    _gl.uniform2f(_location, v.x, v.y);
                };
            case _gl.FLOAT_VEC3:
                return function() {
                    var v = this.value;
                    _gl.uniform3f(_location, v.x, v.y, v.z);
                };
            case _gl.FLOAT_VEC4:
                return function() {
                    var v = this.value;

                    if (typeof v.red !== 'undefined') {
                        _gl.uniform4f(_location, v.red, v.green, v.blue, v.alpha);
                    } else if (typeof v.x !== 'undefined') {
                        _gl.uniform4f(_location, v.x, v.y, v.z, v.w);
                    } else {
                        throw new DeveloperError('Invalid vec4 value.');
                    }
                };
            case _gl.SAMPLER_2D:
            case _gl.SAMPLER_CUBE:
                // See _setSampler()
                return undefined;
            case _gl.INT:
            case _gl.BOOL:
                return function() {
                    _gl.uniform1i(_location, this.value);
                };
            case _gl.INT_VEC2:
            case _gl.BOOL_VEC2:
                return function() {
                    var v = this.value;
                    _gl.uniform2i(_location, v.x, v.y);
                };
            case _gl.INT_VEC3:
            case _gl.BOOL_VEC3:
                return function() {
                    var v = this.value;
                    _gl.uniform3i(_location, v.x, v.y, v.z);
                };
            case _gl.INT_VEC4:
            case _gl.BOOL_VEC4:
                return function() {
                    var v = this.value;
                    _gl.uniform4i(_location, v.x, v.y, v.z, v.w);
                };
            case _gl.FLOAT_MAT2:
                return function() {
                    _gl.uniformMatrix2fv(_location, false, Matrix2.toArray(this.value));
                };
            case _gl.FLOAT_MAT3:
                return function() {
                    _gl.uniformMatrix3fv(_location, false, Matrix3.toArray(this.value));
                };
            case _gl.FLOAT_MAT4:
                return function() {
                    _gl.uniformMatrix4fv(_location, false, Matrix4.toArray(this.value));
                };
            default:
                throw new RuntimeError('Unrecognized uniform type: ' + activeUniform.type);
            }
        }();

        if ((activeUniform.type === _gl.SAMPLER_2D) || (activeUniform.type === _gl.SAMPLER_CUBE)) {
            this._setSampler = function(textureUnitIndex) {
                _gl.activeTexture(_gl.TEXTURE0 + textureUnitIndex);
                _gl.bindTexture(this.value._getTarget(), this.value._getTexture());
                _gl.uniform1i(_location, textureUnitIndex);

                return textureUnitIndex + 1;
            };

            this._clearSampler = function(textureUnitIndex) {
                _gl.activeTexture(_gl.TEXTURE0 + textureUnitIndex);
                _gl.bindTexture(this.value._getTarget(), null);

                return textureUnitIndex + 1;
            };
        }
    };

    /**
     * Uniform and UniformArray have the same documentation.  It is just an implementation
     * detail that they are two different types.
     *
     * @alias UniformArray
     * @constructor
     *
     * @see Uniform
     */
    var UniformArray = function(_gl, activeUniform, _uniformName, locations, value) {
        this.value = value;

        var _locations = locations;

        /**
         * @private
         */
        this.getName = function() {
            return _uniformName;
        };

        this.getDatatype = getUniformDatatype(_gl, activeUniform.type);

        this._getLocations = function() {
            return _locations;
        };

        this._set = function() {
            switch (activeUniform.type) {
            case _gl.FLOAT:
                return function() {
                    for ( var i = 0; i < _locations.length; ++i) {
                        _gl.uniform1f(_locations[i], this.value[i]);
                    }
                };
            case _gl.FLOAT_VEC2:
                return function() {
                    for ( var i = 0; i < _locations.length; ++i) {
                        var v = this.value[i];
                        _gl.uniform2f(_locations[i], v.x, v.y);
                    }
                };
            case _gl.FLOAT_VEC3:
                return function() {
                    for ( var i = 0; i < _locations.length; ++i) {
                        var v = this.value[i];
                        _gl.uniform3f(_locations[i], v.x, v.y, v.z);
                    }
                };
            case _gl.FLOAT_VEC4:
                return function() {
                    for ( var i = 0; i < _locations.length; ++i) {
                        var v = this.value[i];

                        if (typeof v.red !== 'undefined') {
                            _gl.uniform4f(_locations[i], v.red, v.green, v.blue, v.alpha);
                        } else if (typeof v.x !== 'undefined') {
                            _gl.uniform4f(_locations[i], v.x, v.y, v.z, v.w);
                        } else {
                            throw new DeveloperError('Invalid vec4 value.');
                        }
                    }
                };
            case _gl.SAMPLER_2D:
            case _gl.SAMPLER_CUBE:
                // See _setSampler()
                return undefined;
            case _gl.INT:
            case _gl.BOOL:
                return function() {
                    for ( var i = 0; i < _locations.length; ++i) {
                        _gl.uniform1i(_locations[i], this.value[i]);
                    }
                };
            case _gl.INT_VEC2:
            case _gl.BOOL_VEC2:
                return function() {
                    for ( var i = 0; i < _locations.length; ++i) {
                        var v = this.value[i];
                        _gl.uniform2i(_locations[i], v.x, v.y);
                    }
                };
            case _gl.INT_VEC3:
            case _gl.BOOL_VEC3:
                return function() {
                    for ( var i = 0; i < _locations.length; ++i) {
                        var v = this.value[i];
                        _gl.uniform3i(_locations[i], v.x, v.y, v.z);
                    }
                };
            case _gl.INT_VEC4:
            case _gl.BOOL_VEC4:
                return function() {
                    for ( var i = 0; i < _locations.length; ++i) {
                        var v = this.value[i];
                        _gl.uniform4i(_locations[i], v.x, v.y, v.z, v.w);
                    }
                };
            case _gl.FLOAT_MAT2:
                return function() {
                    for ( var i = 0; i < _locations.length; ++i) {
                        _gl.uniformMatrix2fv(_locations[i], false, Matrix2.toArray(this.value[i]));
                    }
                };
            case _gl.FLOAT_MAT3:
                return function() {
                    for ( var i = 0; i < _locations.length; ++i) {
                        _gl.uniformMatrix3fv(_locations[i], false, Matrix3.toArray(this.value[i]));
                    }
                };
            case _gl.FLOAT_MAT4:
                return function() {
                    for ( var i = 0; i < _locations.length; ++i) {
                        _gl.uniformMatrix4fv(_locations[i], false, Matrix4.toArray(this.value[i]));
                    }
                };
            default:
                throw new RuntimeError('Unrecognized uniform type: ' + activeUniform.type);
            }
        }();

        if ((activeUniform.type === _gl.SAMPLER_2D) || (activeUniform.type === _gl.SAMPLER_CUBE)) {
            this._setSampler = function(textureUnitIndex) {
                for ( var i = 0; i < _locations.length; ++i) {
                    var index = textureUnitIndex + i;
                    _gl.activeTexture(_gl.TEXTURE0 + index);
                    _gl.bindTexture(this.value[i]._getTarget(), this.value[i]._getTexture());
                    _gl.uniform1i(_locations[i], index);
                }

                return textureUnitIndex + _locations.length;
            };

            this._clearSampler = function(textureUnitIndex) {
                for ( var i = 0; i < _locations.length; ++i) {
                    _gl.activeTexture(_gl.TEXTURE0 + textureUnitIndex + i);
                    _gl.bindTexture(this.value[i]._getTarget(), null);
                }

                return textureUnitIndex + _locations.length;
            };
        }
    };

    /**
     * DOC_TBA
     *
     * @alias ShaderProgram
     * @internalConstructor
     *
     * @see Context#createShaderProgram
     * @see Context#getShaderCache
     */
    var ShaderProgram = function(gl, logShaderCompilation, builtInGlslFunctions, vertexShaderSource, fragmentShaderSource, attributeLocations) {
        var getAllAutomaticUniforms = function() {
            var uniforms = {
                /**
                 * An automatic GLSL uniform containing the viewport's <code>x</code>, <code>y</code>, <code>width</code>,
                 * and <code>height</code> properties in an <code>ivec4</code>'s <code>x</code>, <code>y</code>, <code>z</code>,
                 * and <code>w</code> components, respectively.
                 * <br /><br />
                 * Like all automatic uniforms, <code>agi_viewport</code> does not need to be explicitly declared.
                 * However, it can be explicitly declared when a shader is also used by other applications such
                 * as a third-party authoring tool.
                 *
                 * @alias agi_viewport
                 * @glslUniform
                 *
                 * @see Context#getViewport
                 *
                 * @example
                 * // GLSL declaration
                 * uniform ivec4 agi_viewport;
                 *
                 * // Scale the window coordinate components to [0, 1] by dividing
                 * // by the viewport's width and height.
                 * vec2 v = gl_FragCoord.xy / agi_viewport.zw;
                 */
                agi_viewport : {
                    /**
                     * @private
                     */
                    getSize : function() {
                        return 1;
                    },

                    /**
                     * @private
                     */
                    getDatatype : function() {
                        return UniformDatatype.INT_VECTOR4;
                    },

                    /**
                     * @private
                     */
                    create : function(uniform) {
                        return {
                            _set : function(uniformState) {
                                var v = uniformState.getContext().getViewport();
                                uniform.value = {
                                    x : v.x,
                                    y : v.y,
                                    z : v.width,
                                    w : v.height
                                };
                            }
                        };
                    }
                },

                /**
                 * An automatic GLSL uniform representing a 4x4 orthographic projection matrix that
                 * transforms window coordinates to clip coordinates.  Clip coordinates is the
                 * coordinate system for a vertex shader's <code>gl_Position</code> output.
                 * <br /><br />
                 * This transform is useful when a vertex shader inputs or manipulates window coordinates
                 * as done by {@link BillboardCollection}.
                 * <br /><br />
                 * Do not confuse {@link agi_viewportTransformation} with <code>agi_viewportOrthographic</code>.
                 * The former transforms from normalized device coordinates to window coordinates; the later transforms
                 * from window coordinates to clip coordinates, and is often used to assign to <code>gl_Position</code>.
                 * <br /><br />
                 * Like all automatic uniforms, <code>agi_viewportOrthographic</code> does not need to be explicitly declared.
                 * However, it can be explicitly declared when a shader is also used by other applications such
                 * as a third-party authoring tool.
                 *
                 * @alias agi_viewportOrthographic
                 * @glslUniform
                 *
                 * @see UniformState#getViewportOrthographic
                 * @see agi_viewport
                 * @see agi_viewportTransformation
                 * @see BillboardCollection
                 *
                 * @example
                 * // GLSL declaration
                 * uniform mat4 agi_viewportOrthographic;
                 *
                 * // Example
                 * gl_Position = agi_viewportOrthographic * vec4(windowPosition, 0.0, 1.0);
                 */
                agi_viewportOrthographic : {
                    /**
                     * @private
                     */
                    getSize : function() {
                        return 1;
                    },

                    /**
                     * @private
                     */
                    getDatatype : function() {
                        return UniformDatatype.FLOAT_MATRIX4;
                    },

                    /**
                     * @private
                     */
                    create : function(uniform) {
                        return {
                            _set : function(uniformState) {
                                uniform.value = uniformState.getViewportOrthographic();
                            }
                        };
                    }
                },

                /**
                 * An automatic GLSL uniform representing a 4x4 transformation matrix that
                 * transforms normalized device coordinates to window coordinates.  The context's
                 * full viewport is used, and the depth range is assumed to be <code>near = 0</code>
                 * and <code>far = 1</code>.
                 * <br /><br />
                 * This transform is useful when there is a need to manipulate window coordinates
                 * in a vertex shader as done by {@link BillboardCollection}.  In many cases,
                 * this matrix will not be used directly; instead, {@link agi_modelToWindowCoordinates}
                 * will be used to transform directly from model to window coordinates.
                 * <br /><br />
                 * Do not confuse <code>agi_viewportTransformation</code> with {@link agi_viewportOrthographic}.
                 * The former transforms from normalized device coordinates to window coordinates; the later transforms
                 * from window coordinates to clip coordinates, and is often used to assign to <code>gl_Position</code>.
                 * <br /><br />
                 * Like all automatic uniforms, <code>agi_viewportTransformation</code> does not need to be explicitly declared.
                 * However, it can be explicitly declared when a shader is also used by other applications such
                 * as a third-party authoring tool.
                 *
                 * @alias agi_viewportTransformation
                 * @glslUniform
                 *
                 * @see UniformState#getViewportTransformation
                 * @see agi_viewport
                 * @see agi_viewportOrthographic
                 * @see agi_modelToWindowCoordinates
                 * @see BillboardCollection
                 *
                 * @example
                 * // GLSL declaration
                 * uniform mat4 agi_viewportTransformation;
                 *
                 * // Use agi_viewportTransformation as part of the
                 * // transform from model to window coordinates.
                 * vec4 q = agi_modelViewProjection * positionMC;              // model to clip coordinates
                 * q.xyz /= q.w;                                                // clip to normalized device coordinates (ndc)
                 * q.xyz = (agi_viewportTransformation * vec4(q.xyz, 1.0)).xyz; // ndc to window coordinates
                 */
                agi_viewportTransformation : {
                    /**
                     * @private
                     */
                    getSize : function() {
                        return 1;
                    },

                    /**
                     * @private
                     */
                    getDatatype : function() {
                        return UniformDatatype.FLOAT_MATRIX4;
                    },

                    /**
                     * @private
                     */
                    create : function(uniform) {
                        return {
                            _set : function(uniformState) {
                                uniform.value = uniformState.getViewportTransformation();
                            }
                        };
                    }
                },

                /**
                 * An automatic GLSL uniform representing a 4x4 model transformation matrix that
                 * transforms model coordinates to world coordinates.
                 * <br /><br />
                 * Like all automatic uniforms, <code>agi_model</code> does not need to be explicitly declared.
                 * However, it can be explicitly declared when a shader is also used by other applications such
                 * as a third-party authoring tool.
                 *
                 * @alias agi_model
                 * @glslUniform
                 *
                 * @see UniformState#getModel
                 * @see agi_modelView
                 * @see agi_modelViewProjection
                 *
                 * @example
                 * // GLSL declaration
                 * uniform mat4 agi_model;
                 *
                 * // Example
                 * vec4 worldPosition = agi_model * modelPosition;
                 */
                agi_model : {
                    /**
                     * @private
                     */
                    getSize : function() {
                        return 1;
                    },

                    /**
                     * @private
                     */
                    getDatatype : function() {
                        return UniformDatatype.FLOAT_MATRIX4;
                    },

                    /**
                     * @private
                     */
                    create : function(uniform) {
                        return {
                            _set : function(uniformState) {
                                uniform.value = uniformState.getModel();
                            }
                        };
                    }
                },

                /**
                 * An automatic GLSL uniform representing a 4x4 transformation matrix that
                 * transforms from eye coordinates to world coordinates.
                 * <br /><br />
                 * Like all automatic uniforms, <code>agi_inverseView</code> does not need to be explicitly declared.
                 * However, it can be explicitly declared when a shader is also used by other applications such
                 * as a third-party authoring tool.
                 *
                 * @alias agi_inverseView
                 * @glslUniform
                 *
                 * @see UniformState#getInverseView
                 * @see agi_view
                 * @see agi_inverseNormal
                 *
                 * @example
                 * // GLSL declaration
                 * uniform mat4 agi_inverseView;
                 *
                 * // Example
                 * vec4 worldPosition = agi_inverseView * eyePosition;
                 */
                agi_inverseView : {
                    getSize : function() {
                        return 1;
                    },

                    getDatatype : function() {
                        return UniformDatatype.FLOAT_MATRIX4;
                    },

                    create : function(uniform) {
                        return {
                            _set : function(uniformState) {
                                uniform.value = uniformState.getInverseView();
                            }
                        };
                    }
                },

                /**
                 * An automatic GLSL uniform representing a 4x4 view transformation matrix that
                 * transforms world coordinates to eye coordinates.
                 * <br /><br />
                 * Like all automatic uniforms, <code>agi_view</code> does not need to be explicitly declared.
                 * However, it can be explicitly declared when a shader is also used by other applications such
                 * as a third-party authoring tool.
                 *
                 * @alias agi_view
                 * @glslUniform
                 *
                 * @see UniformState#getView
                 * @see agi_modelView
                 * @see agi_viewProjection
                 * @see agi_modelViewProjection
                 * @see agi_inverseView
                 *
                 * @example
                 * // GLSL declaration
                 * uniform mat4 agi_view;
                 *
                 * // Example
                 * vec4 eyePosition = agi_view * worldPosition;
                 */
                agi_view : {
                    getSize : function() {
                        return 1;
                    },

                    getDatatype : function() {
                        return UniformDatatype.FLOAT_MATRIX4;
                    },

                    create : function(uniform) {
                        return {
                            _set : function(uniformState) {
                                uniform.value = uniformState.getView();
                            }
                        };
                    }
                },

                /**
                 * An automatic GLSL uniform representing a 4x4 projection transformation matrix that
                 * transforms eye coordinates to clip coordinates.  Clip coordinates is the
                 * coordinate system for a vertex shader's <code>gl_Position</code> output.
                 * <br /><br />
                 * Like all automatic uniforms, <code>agi_projection</code> does not need to be explicitly declared.
                 * However, it can be explicitly declared when a shader is also used by other applications such
                 * as a third-party authoring tool.
                 *
                 * @alias agi_projection
                 * @glslUniform
                 *
                 * @see UniformState#getProjection
                 * @see agi_viewProjection
                 * @see agi_modelViewProjection
                 * @see agi_infiniteProjection
                 *
                 * @example
                 * // GLSL declaration
                 * uniform mat4 agi_projection;
                 *
                 * // Example
                 * gl_Position = agi_projection * eyePosition;
                 */
                agi_projection : {
                    getSize : function() {
                        return 1;
                    },

                    getDatatype : function() {
                        return UniformDatatype.FLOAT_MATRIX4;
                    },

                    create : function(uniform) {
                        return {
                            _set : function(uniformState) {
                                uniform.value = uniformState.getProjection();
                            }
                        };
                    }
                },

                /**
                 * An automatic GLSL uniform representing a 4x4 inverse projection transformation matrix that
                 * transforms from clip coordinates to eye coordinates. Clip coordinates is the
                 * coordinate system for a vertex shader's <code>gl_Position</code> output.
                 * <br /><br />
                 * Like all automatic uniforms, <code>agi_inverseProjection</code> does not need to be explicitly declared.
                 * However, it can be explicitly declared when a shader is also used by other applications such
                 * as a third-party authoring tool.
                 *
                 * @alias agi_inverseProjection
                 * @glslUniform
                 *
                 * @see UniformState#getInverseProjection
                 * @see agi_projection
                 *
                 * @example
                 * // GLSL declaration
                 * uniform mat4 agi_inverseProjection;
                 *
                 * // Example
                 * vec4 eyePosition = agi_inverseProjection * clipPosition;
                 */
                agi_inverseProjection : {
                    getSize : function() {
                        return 1;
                    },

                    getDatatype : function() {
                        return UniformDatatype.FLOAT_MATRIX4;
                    },

                    create : function(uniform) {
                        return {
                            _set : function(uniformState) {
                                uniform.value = uniformState.getInverseProjection();
                            }
                        };
                    }
                },

                /**
                 * An automatic GLSL uniform representing a 4x4 projection transformation matrix with the far plane at infinity,
                 * that transforms eye coordinates to clip coordinates.  Clip coordinates is the
                 * coordinate system for a vertex shader's <code>gl_Position</code> output.  An infinite far plane is used
                 * in algorithms like shadow volumes and GPU ray casting with proxy geometry to ensure that triangles
                 * are not clipped by the far plane.
                 * <br /><br />
                 * Like all automatic uniforms, <code>agi_infiniteProjection</code> does not need to be explicitly declared.
                 * However, it can be explicitly declared when a shader is also used by other applications such
                 * as a third-party authoring tool.
                 *
                 * @alias agi_infiniteProjection
                 * @glslUniform
                 *
                 * @see UniformState#getInfiniteProjection
                 * @see agi_projection
                 * @see agi_modelViewInfiniteProjection
                 *
                 * @example
                 * // GLSL declaration
                 * uniform mat4 agi_infiniteProjection;
                 *
                 * // Example
                 * gl_Position = agi_infiniteProjection * eyePosition;
                 */
                agi_infiniteProjection : {
                    getSize : function() {
                        return 1;
                    },

                    getDatatype : function() {
                        return UniformDatatype.FLOAT_MATRIX4;
                    },

                    create : function(uniform) {
                        return {
                            _set : function(uniformState) {
                                uniform.value = uniformState.getInfiniteProjection();
                            }
                        };
                    }
                },

                /**
                 * An automatic GLSL uniform representing a 4x4 model-view transformation matrix that
                 * transforms model coordinates to eye coordinates.
                 * <br /><br />
                 * Positions should be transformed to eye coordinates using <code>agi_modelView</code> and
                 * normals should be transformed using {@link agi_normal}.
                 * <br /><br />
                 * Like all automatic uniforms, <code>agi_modelView</code> does not need to be explicitly declared.
                 * However, it can be explicitly declared when a shader is also used by other applications such
                 * as a third-party authoring tool.
                 *
                 * @alias agi_modelView
                 * @glslUniform
                 *
                 * @see UniformState#getModelView
                 * @see agi_model
                 * @see agi_view
                 * @see agi_modelViewProjection
                 * @see agi_normal
                 *
                 * @example
                 * // GLSL declaration
                 * uniform mat4 agi_modelView;
                 *
                 * // Example
                 * vec4 eyePosition = agi_modelView * modelPosition;
                 *
                 * // The above is equivalent to, but more efficient than:
                 * vec4 eyePosition = agi_view * agi_model * modelPosition;
                 */
                agi_modelView : {
                    getSize : function() {
                        return 1;
                    },

                    getDatatype : function() {
                        return UniformDatatype.FLOAT_MATRIX4;
                    },

                    create : function(uniform) {
                        return {
                            _set : function(uniformState) {
                                uniform.value = uniformState.getModelView();
                            }
                        };
                    }
                },

                /**
                 * An automatic GLSL uniform representing a 4x4 transformation matrix that
                 * transforms from eye coordinates to model coordinates.
                 * <br /><br />
                 * Like all automatic uniforms, <code>agi_inverseModelView</code> does not need to be explicitly declared.
                 * However, it can be explicitly declared when a shader is also used by other applications such
                 * as a third-party authoring tool.
                 *
                 * @alias agi_inverseModelView
                 * @glslUniform
                 *
                 * @see UniformState#getInverseModelView
                 * @see agi_modelView
                 *
                 * @example
                 * // GLSL declaration
                 * uniform mat4 agi_inverseModelView;
                 *
                 * // Example
                 * vec4 modelPosition = agi_inverseModelView * eyePosition;
                 */
                agi_inverseModelView : {
                    getSize : function() {
                        return 1;
                    },

                    getDatatype : function() {
                        return UniformDatatype.FLOAT_MATRIX4;
                    },

                    create : function(uniform) {
                        return {
                            _set : function(uniformState) {
                                uniform.value = uniformState.getInverseModelView();
                            }
                        };
                    }
                },

                /**
                 * An automatic GLSL uniform representing a 4x4 view-projection transformation matrix that
                 * transforms world coordinates to clip coordinates.  Clip coordinates is the
                 * coordinate system for a vertex shader's <code>gl_Position</code> output.
                 * <br /><br />
                 * Like all automatic uniforms, <code>agi_viewProjection</code> does not need to be explicitly declared.
                 * However, it can be explicitly declared when a shader is also used by other applications such
                 * as a third-party authoring tool.
                 *
                 * @alias agi_viewProjection
                 * @glslUniform
                 *
                 * @see UniformState#getViewProjection
                 * @see agi_view
                 * @see agi_projection
                 * @see agi_modelViewProjection
                 *
                 * @example
                 * // GLSL declaration
                 * uniform mat4 agi_viewProjection;
                 *
                 * // Example
                 * vec4 gl_Position = agi_viewProjection * agi_model * modelPosition;
                 *
                 * // The above is equivalent to, but more efficient than:
                 * gl_Position = agi_projection * agi_view * agi_model * modelPosition;
                 */
                agi_viewProjection : {
                    getSize : function() {
                        return 1;
                    },

                    getDatatype : function() {
                        return UniformDatatype.FLOAT_MATRIX4;
                    },

                    create : function(uniform) {
                        return {
                            _set : function(uniformState) {
                                uniform.value = uniformState.getViewProjection();
                            }
                        };
                    }
                },

                /**
                 * An automatic GLSL uniform representing a 4x4 model-view-projection transformation matrix that
                 * transforms model coordinates to clip coordinates.  Clip coordinates is the
                 * coordinate system for a vertex shader's <code>gl_Position</code> output.
                 * <br /><br />
                 * Like all automatic uniforms, <code>agi_modelViewProjection</code> does not need to be explicitly declared.
                 * However, it can be explicitly declared when a shader is also used by other applications such
                 * as a third-party authoring tool.
                 *
                 * @alias agi_modelViewProjection
                 * @glslUniform
                 *
                 * @see UniformState#getModelViewProjection
                 * @see agi_model
                 * @see agi_view
                 * @see agi_projection
                 * @see agi_modelView
                 * @see agi_viewProjection
                 * @see agi_modelViewInfiniteProjection
                 *
                 * @example
                 * // GLSL declaration
                 * uniform mat4 agi_modelViewProjection;
                 *
                 * // Example
                 * vec4 gl_Position = agi_modelViewProjection * modelPosition;
                 *
                 * // The above is equivalent to, but more efficient than:
                 * gl_Position = agi_projection * agi_view * agi_model * modelPosition;
                 */
                agi_modelViewProjection : {
                    getSize : function() {
                        return 1;
                    },

                    getDatatype : function() {
                        return UniformDatatype.FLOAT_MATRIX4;
                    },

                    create : function(uniform) {
                        return {
                            _set : function(uniformState) {
                                uniform.value = uniformState.getModelViewProjection();
                            }
                        };
                    }
                },

                /**
                 * An automatic GLSL uniform representing a 4x4 model-view-projection transformation matrix that
                 * transforms model coordinates to clip coordinates.  Clip coordinates is the
                 * coordinate system for a vertex shader's <code>gl_Position</code> output.  The projection matrix places
                 * the far plane at infinity.  This is useful in algorithms like shadow volumes and GPU ray casting with
                 * proxy geometry to ensure that triangles are not clipped by the far plane.
                 * <br /><br />
                 * Like all automatic uniforms, <code>agi_modelViewInfiniteProjection</code> does not need to be explicitly declared.
                 * However, it can be explicitly declared when a shader is also used by other applications such
                 * as a third-party authoring tool.
                 *
                 * @alias agi_modelViewInfiniteProjection
                 * @glslUniform
                 *
                 * @see UniformState#getModelViewInfiniteProjection
                 * @see agi_model
                 * @see agi_view
                 * @see agi_infiniteProjection
                 * @see agi_modelViewProjection
                 *
                 * @example
                 * // GLSL declaration
                 * uniform mat4 agi_modelViewInfiniteProjection;
                 *
                 * // Example
                 * vec4 gl_Position = agi_modelViewInfiniteProjection * modelPosition;
                 *
                 * // The above is equivalent to, but more efficient than:
                 * gl_Position = agi_infiniteProjection * agi_view * agi_model * modelPosition;
                 */
                agi_modelViewInfiniteProjection : {
                    getSize : function() {
                        return 1;
                    },

                    getDatatype : function() {
                        return UniformDatatype.FLOAT_MATRIX4;
                    },

                    create : function(uniform) {
                        return {
                            _set : function(uniformState) {
                                uniform.value = uniformState.getModelViewInfiniteProjection();
                            }
                        };
                    }
                },

                /**
                 * An automatic GLSL uniform representing a 3x3 normal transformation matrix that
                 * transforms normal vectors in model coordinates to eye coordinates.
                 * <br /><br />
                 * Positions should be transformed to eye coordinates using {@link agi_modelView} and
                 * normals should be transformed using <code>agi_normal</code>.
                 * <br /><br />
                 * Like all automatic uniforms, <code>agi_normal</code> does not need to be explicitly declared.
                 * However, it can be explicitly declared when a shader is also used by other applications such
                 * as a third-party authoring tool.
                 *
                 * @alias agi_normal
                 * @glslUniform
                 *
                 * @see UniformState#getNormal
                 * @see agi_inverseNormal
                 * @see agi_modelView
                 *
                 * @example
                 * // GLSL declaration
                 * uniform mat3 agi_normal;
                 *
                 * // Example
                 * vec3 eyeNormal = agi_normal * normal;
                 */
                agi_normal : {
                    getSize : function() {
                        return 1;
                    },

                    getDatatype : function() {
                        return UniformDatatype.FLOAT_MATRIX3;
                    },

                    create : function(uniform) {
                        return {
                            _set : function(uniformState) {
                                uniform.value = uniformState.getNormal();
                            }
                        };
                    }
                },

                /**
                 * An automatic GLSL uniform representing a 3x3 normal transformation matrix that
                 * transforms normal vectors in eye coordinates to model coordinates.  This is
                 * in the opposite transform provided by {@link agi_normal}.
                 * <br /><br />
                 * Like all automatic uniforms, <code>agi_inverseNormal</code> does not need to be explicitly declared.
                 * However, it can be explicitly declared when a shader is also used by other applications such
                 * as a third-party authoring tool.
                 *
                 * @alias agi_inverseNormal
                 * @glslUniform
                 *
                 * @see UniformState#getInverseNormal
                 * @see agi_normal
                 * @see agi_modelView
                 * @see agi_inverseView
                 *
                 * @example
                 * // GLSL declaration
                 * uniform mat3 agi_inverseNormal;
                 *
                 * // Example
                 * vec3 normalMC = agi_inverseNormal * normalEC;
                 */
                agi_inverseNormal : {
                    getSize : function() {
                        return 1;
                    },

                    getDatatype : function() {
                        return UniformDatatype.FLOAT_MATRIX3;
                    },

                    create : function(uniform) {
                        return {
                            _set : function(uniformState) {
                                uniform.value = uniformState.getInverseNormal();
                            }
                        };
                    }
                },

                /**
                 * An automatic GLSL uniform representing the direction of the sun in eye coordinates.
                 * This is commonly used for directional lighting computations.
                 * <br /><br />
                 * Like all automatic uniforms, <code>agi_sunDirectionEC</code> does not need to be explicitly declared.
                 * However, it can be explicitly declared when a shader is also used by other applications such
                 * as a third-party authoring tool.
                 *
                 * @alias agi_sunDirectionEC
                 * @glslUniform
                 *
                 * @see UniformState#getSunDirectionEC
                 * @see agi_sunDirectionWC
                 *
                 * @example
                 * // GLSL declaration
                 * uniform vec3 agi_sunDirectionEC;
                 *
                 * // Example
                 * float diffuse = max(dot(agi_sunDirectionEC, normalEC), 0.0);
                 */
                agi_sunDirectionEC : {
                    getSize : function() {
                        return 1;
                    },

                    getDatatype : function() {
                        return UniformDatatype.FLOAT_VECTOR3;
                    },

                    create : function(uniform) {
                        return {
                            _set : function(uniformState) {
                                uniform.value = uniformState.getSunDirectionEC();
                            }
                        };
                    }
                },

                /**
                 * An automatic GLSL uniform representing a normalized vector from the origin
                 * in world coordinates to the sun.  This is commonly used for lighting computations.
                 * <br /><br />
                 * Like all automatic uniforms, <code>agi_sunDirectionWC</code> does not need to be explicitly declared.
                 * However, it can be explicitly declared when a shader is also used by other applications such
                 * as a third-party authoring tool.
                 *
                 * @alias agi_sunDirectionWC
                 * @glslUniform
                 *
                 * @see UniformState#getSunDirectionWC
                 * @see agi_sunDirectionEC
                 *
                 * @example
                 * // GLSL declaration
                 * uniform vec3 agi_sunDirectionWC;
                 */
                agi_sunDirectionWC : {
                    getSize : function() {
                        return 1;
                    },

                    getDatatype : function() {
                        return UniformDatatype.FLOAT_VECTOR3;
                    },

                    create : function(uniform) {
                        return {
                            _set : function(uniformState) {
                                uniform.value = uniformState.getSunDirectionWC();
                            }
                        };
                    }
                },

                /**
                 * An automatic GLSL uniform representing the position of the viewer (camera) in world coordinates.
                 * <br /><br />
                 * Like all automatic uniforms, <code>agi_sunDirectionWC</code> does not need to be explicitly declared.
                 * However, it can be explicitly declared when a shader is also used by other applications such
                 * as a third-party authoring tool.
                 *
                 * @alias agi_viewerPositionWC
                 * @glslUniform
                 *
                 * @example
                 * // GLSL declaration
                 * uniform vec3 agi_viewerPositionWC;
                 */
                agi_viewerPositionWC : {
                    getSize : function() {
                        return 1;
                    },

                    getDatatype : function() {
                        return UniformDatatype.FLOAT_VECTOR3;
                    },

                    create : function(uniform) {
                        return {
                            _set : function(uniformState) {
                                uniform.value = uniformState.getInverseView().getTranslation();
                            }
                        };
                    }
                }

            };

            getAllAutomaticUniforms = function() {
                return uniforms;
            };

            return uniforms;
        };

        function extractShaderVersion(source) {
            // This will fail if the first #version is actually in a comment.
            var index = source.indexOf('#version');
            if (index !== -1) {
                var newLineIndex = source.indexOf('\n', index);

                // We could throw an exception if there is not a new line after
                // #version, but the GLSL compiler will catch it.
                if (index !== -1) {
                    // Extract #version directive, including the new line.
                    var version = source.substring(index, newLineIndex + 1);

                    // Comment out original #version directive so the line numbers
                    // are not off by one.  There can be only one #version directive
                    // and it must appear at the top of the source, only preceded by
                    // whitespace and comments.
                    var modified = source.substring(0, index) + '//' + source.substring(index);

                    return {
                        versionDirective : version,
                        modifiedSource : modified
                    };
                }
            }

            return {
                versionDirective : '', // defaults to #version 100
                modifiedSource : source // no modifications required
            };
        }

        function getAutomaticUniformDeclaration(uniforms, uniform) {
            var factory = uniforms[uniform];
            var declaration = 'uniform ' + factory.getDatatype().getGLSL() + ' ' + uniform;

            var size = factory.getSize();
            if (size === 1) {
                declaration += ';';
            } else {
                declaration += '[' + size.toString() + '];';
            }

            return declaration;
        }

        function commentOutAutomaticUniforms(source) {
            // Comment out automatic uniforms that the user may have declared, perhaps
            // because the shader was authored in a third-party tool like RenderMonkey.
            // At runtime, all automatic uniforms are declared by the engine itself.

            // This function has problems if the automatic uniform was declared with the
            // wrong datatype or with extra whitespace or comments in the declaration.

            var modifiedSource = source;
            var uniforms = getAllAutomaticUniforms();
            for ( var uniform in uniforms) {
                if (uniforms.hasOwnProperty(uniform)) {
                    var declaration = getAutomaticUniformDeclaration(uniforms, uniform);
                    var index = modifiedSource.indexOf(declaration);
                    if (index !== -1) {
                        modifiedSource =
                            modifiedSource.substring(0, index) +
                            '/*' +
                            modifiedSource.substring(index, declaration.length) +
                            '*/' +
                            modifiedSource.substring(index + declaration.length);
                    }
                }
            }

            return modifiedSource;
        }

        function getFragmentShaderPrecision() {
            // TODO: Performance?
            return '#ifdef GL_FRAGMENT_PRECISION_HIGH \n' +
                   '  precision highp float; \n' +
                   '#else \n' +
                   '  precision mediump float; \n' +
                   '#endif \n\n';
        }

        function getBuiltinConstants() {
            var constants = {
                /**
                 * A built-in GLSL floating-point constant for <code>Math.PI</code>.
                 *
                 * @alias agi_pi
                 * @glslConstant
                 *
                 * @see CesiumMath.PI
                 *
                 * @example
                 * // GLSL declaration
                 * const float agi_pi = ...;
                 *
                 * // Example
                 * float twoPi = 2.0 * agi_pi;
                 */
                agi_pi : Math.PI.toString(),

                /**
                 * A built-in GLSL floating-point constant for <code>1/pi</code>.
                 *
                 * @alias agi_oneOverPi
                 * @glslConstant
                 *
                 * @see CesiumMath.ONE_OVER_PI
                 *
                 * @example
                 * // GLSL declaration
                 * const float agi_oneOverPi = ...;
                 *
                 * // Example
                 * float pi = 1.0 / agi_oneOverPi;
                 */
                agi_oneOverPi : CesiumMath.ONE_OVER_PI.toString(),

                /**
                 * A built-in GLSL floating-point constant for <code>pi/2</code>.
                 *
                 * @alias agi_piOverTwo
                 * @glslConstant
                 *
                 * @see CesiumMath.PI_OVER_TWO
                 *
                 * @example
                 * // GLSL declaration
                 * const float agi_piOverTwo = ...;
                 *
                 * // Example
                 * float pi = 2.0 * agi_piOverTwo;
                 */
                agi_piOverTwo : CesiumMath.PI_OVER_TWO.toString(),

                /**
                 * A built-in GLSL floating-point constant for <code>pi/3</code>.
                 *
                 * @alias agi_piOverThree
                 * @glslConstant
                 *
                 * @see CesiumMath.PI_OVER_THREE
                 *
                 * @example
                 * // GLSL declaration
                 * const float agi_piOverThree = ...;
                 *
                 * // Example
                 * float pi = 3.0 * agi_piOverThree;
                 */
                agi_piOverThree : CesiumMath.PI_OVER_THREE.toString(),

                /**
                 * A built-in GLSL floating-point constant for <code>pi/4</code>.
                 *
                 * @alias agi_piOverFour
                 * @glslConstant
                 *
                 * @see CesiumMath.PI_OVER_FOUR
                 *
                 * @example
                 * // GLSL declaration
                 * const float agi_piOverFour = ...;
                 *
                 * // Example
                 * float pi = 4.0 * agi_piOverFour;
                 */
                agi_piOverFour : CesiumMath.PI_OVER_FOUR.toString(),

                /**
                 * A built-in GLSL floating-point constant for <code>pi/6</code>.
                 *
                 * @alias agi_piOverSix
                 * @glslConstant
                 *
                 * @see CesiumMath.PI_OVER_SIX
                 *
                 * @example
                 * // GLSL declaration
                 * const float agi_piOverSix = ...;
                 *
                 * // Example
                 * float pi = 6.0 * agi_piOverSix;
                 */
                agi_piOverSix : CesiumMath.PI_OVER_SIX.toString(),

                /**
                 * A built-in GLSL floating-point constant for <code>3pi/2</code>.
                 *
                 * @alias agi_threePiOver2
                 * @glslConstant
                 *
                 * @see CesiumMath.THREE_PI_OVER_TWO
                 *
                 * @example
                 * // GLSL declaration
                 * const float agi_threePiOver2 = ...;
                 *
                 * // Example
                 * float pi = (2.0 / 3.0) * agi_threePiOver2;
                 */
                agi_threePiOver2 : CesiumMath.THREE_PI_OVER_TWO.toString(),

                /**
                 * A built-in GLSL floating-point constant for <code>2pi</code>.
                 *
                 * @alias agi_twoPi
                 * @glslConstant
                 *
                 * @see CesiumMath.TWO_PI
                 *
                 * @example
                 * // GLSL declaration
                 * const float agi_twoPi = ...;
                 *
                 * // Example
                 * float pi = agi_twoPi / 2.0;
                 */
                agi_twoPi : CesiumMath.TWO_PI.toString(),

                /**
                 * A built-in GLSL floating-point constant for <code>1/2pi</code>.
                 *
                 * @alias agi_oneOverTwoPi
                 * @glslConstant
                 *
                 * @see CesiumMath.ONE_OVER_TWO_PI
                 *
                 * @example
                 * // GLSL declaration
                 * const float agi_oneOverTwoPi = ...;
                 *
                 * // Example
                 * float pi = 2.0 * agi_oneOverTwoPi;
                 */
                agi_oneOverTwoPi : CesiumMath.ONE_OVER_TWO_PI.toString(),

                /**
                 * A built-in GLSL floating-point constant for converting degrees to radians.
                 *
                 * @alias agi_radiansPerDegree
                 * @glslConstant
                 *
                 * @see CesiumMath.RADIANS_PER_DEGREE
                 *
                 * @example
                 * // GLSL declaration
                 * const float agi_radiansPerDegree = ...;
                 *
                 * // Example
                 * float rad = agi_radiansPerDegree * deg;
                 */
                agi_radiansPerDegree : CesiumMath.RADIANS_PER_DEGREE.toString(),

                /**
                 * A built-in GLSL floating-point constant for converting radians to degrees.
                 *
                 * @alias agi_degreesPerRadian
                 * @glslConstant
                 *
                 * @see CesiumMath.DEGREES_PER_RADIAN
                 *
                 * @example
                 * // GLSL declaration
                 * const float agi_degreesPerRadian = ...;
                 *
                 * // Example
                 * float deg = agi_degreesPerRadian * rad;
                 */
                agi_degreesPerRadian : CesiumMath.DEGREES_PER_RADIAN.toString()
            };

            var glslConstants = '';
            for ( var name in constants) {
                if (constants.hasOwnProperty(name)) {
                    glslConstants += 'const float ' + name + ' = ' + constants[name] + '; \n';
                }
            }
            glslConstants += ' \n';

            return glslConstants;
        }

        function getAutomaticUniforms() {
            var automatics = '';

            var uniforms = getAllAutomaticUniforms();
            for ( var uniform in uniforms) {
                if (uniforms.hasOwnProperty(uniform)) {
                    automatics += getAutomaticUniformDeclaration(uniforms, uniform) + ' \n';
                }
            }
            automatics += '\n';

            return automatics;
        }

        var getShaderDefinitions = function() {
            // I think this should be #line 1 given what the GL ES spec says:
            //
            //   After processing this directive (including its new-line), the implementation will
            //   behave as if the following line has line number line...
            //
            // But this works, at least on NVIDIA hardware.

            // Functions after constants and uniforms because functions depend on them.
            var definitions = getBuiltinConstants() +
                              getAutomaticUniforms() +
                              builtInGlslFunctions + '\n\n' +
                              '#line 0 \n';

            getShaderDefinitions = function() {
                return definitions;
            };

            return definitions;
        };

        function createAndLinkProgram() {
            var vsSourceVersioned = extractShaderVersion(vertexShaderSource);
            var fsSourceVersioned = extractShaderVersion(fragmentShaderSource);

            var vsSource = vsSourceVersioned.versionDirective +
                           getShaderDefinitions() +
                           commentOutAutomaticUniforms(vsSourceVersioned.modifiedSource);
            var fsSource = fsSourceVersioned.versionDirective +
                           getFragmentShaderPrecision() +
                           getShaderDefinitions() +
                           commentOutAutomaticUniforms(fsSourceVersioned.modifiedSource);

            var vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertexShader, vsSource);
            gl.compileShader(vertexShader);
            var vsLog = gl.getShaderInfoLog(vertexShader);

            if (logShaderCompilation && vsLog && vsLog.length) {
                console.log('[GL] Vertex shader compile log: ' + vsLog);
            }

            if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                gl.deleteShader(vertexShader);
                console.error('[GL] Vertex shader compile log: ' + vsLog);
                throw new RuntimeError('Vertex shader failed to compile.  Compile log: ' + vsLog);
            }

            var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, fsSource);
            gl.compileShader(fragmentShader);
            var fsLog = gl.getShaderInfoLog(fragmentShader);

            if (logShaderCompilation && fsLog && fsLog.length) {
                console.log('[GL] Fragment shader compile log: ' + fsLog);
            }

            if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                gl.deleteShader(vertexShader);
                gl.deleteShader(fragmentShader);
                console.error('[GL] Fragment shader compile log: ' + fsLog);
                throw new RuntimeError('Fragment shader failed to compile.  Compile log: ' + fsLog);
            }

            var program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);

            gl.deleteShader(vertexShader);
            gl.deleteShader(fragmentShader);

            if (attributeLocations) {
                for ( var attribute in attributeLocations) {
                    if (attributeLocations.hasOwnProperty(attribute)) {
                        gl.bindAttribLocation(program, attributeLocations[attribute], attribute);
                    }
                }
            }

            gl.linkProgram(program);
            var linkLog = gl.getProgramInfoLog(program);

            if (logShaderCompilation && linkLog && linkLog.length) {
                console.log('[GL] Shader program link log: ' + linkLog);
            }

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                gl.deleteProgram(program);
                console.error('[GL] Shader program link log: ' + linkLog);
                throw new RuntimeError('Program failed to link.  Link log: ' + linkLog);
            }

            return program;
        }

        function findVertexAttributes(program, numberOfAttributes) {
            var attributes = {};
            for ( var i = 0; i < numberOfAttributes; ++i) {
                var attr = gl.getActiveAttrib(program, i);
                var location = gl.getAttribLocation(program, attr.name);

                attributes[attr.name] = {
                    name : attr.name,
                    type : attr.type,
                    index : location
                };
            }

            return attributes;
        }

        function findUniforms(program) {
            var allUniforms = {};
            var uniforms = [];
            var samplerUniforms = [];

            var numberOfUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);

            for ( var i = 0; i < numberOfUniforms; ++i) {
                var activeUniform = gl.getActiveUniform(program, i);
                var suffix = '[0]';
                var uniformName =
                    activeUniform.name.indexOf(suffix, activeUniform.name.length - suffix.length) !== -1 ? activeUniform.name.slice(0, activeUniform.name.length - 3) : activeUniform.name;

                // Ignore GLSL built-in uniforms returned in Firefox.
                if (uniformName.indexOf('gl_') !== 0) {
                    if (activeUniform.size === 1) {
                        // Single uniform
                        var location = gl.getUniformLocation(program, uniformName);
                        var uniformValue = gl.getUniform(program, location);
                        var uniform = new Uniform(gl, activeUniform, uniformName, location, uniformValue);

                        allUniforms[uniformName] = uniform;

                        if (uniform._setSampler) {
                            samplerUniforms.push(uniform);
                        } else {
                            uniforms.push(uniform);
                        }
                    } else {
                        // Uniform array
                        var locations = [];
                        var value = [];
                        for ( var j = 0; j < activeUniform.size; ++j) {
                            var loc = gl.getUniformLocation(program, uniformName + '[' + j + ']');
                            locations.push(loc);
                            value.push(gl.getUniform(program, loc));
                        }
                        var uniformArray = new UniformArray(gl, activeUniform, uniformName, locations, value);

                        allUniforms[uniformName] = uniformArray;

                        if (uniformArray._setSampler) {
                            samplerUniforms.push(uniformArray);
                        } else {
                            uniforms.push(uniformArray);
                        }
                    }
                }
            }

            return {
                allUniforms : allUniforms,
                uniforms : uniforms,
                samplerUniforms : samplerUniforms
            };
        }

        function findAutomaticUniforms(uniforms) {
            var automaticUniforms = [];
            var manualUniforms = {};

            var allAutomaticUniforms = getAllAutomaticUniforms();

            for ( var uniform in uniforms) {
                if (uniforms.hasOwnProperty(uniform)) {
                    var factory = allAutomaticUniforms[uniform];
                    if (factory) {
                        automaticUniforms.push(factory.create(uniforms[uniform]));
                    } else {
                        manualUniforms[uniform] = uniforms[uniform];
                    }
                }
            }

            return {
                automaticUniforms : automaticUniforms,
                manualUniforms : manualUniforms
            };
        }

        var _program = createAndLinkProgram();
        var _numberOfVertexAttributes = gl.getProgramParameter(_program, gl.ACTIVE_ATTRIBUTES);
        var _vertexAttributes = findVertexAttributes(_program, _numberOfVertexAttributes);
        var uniforms = findUniforms(_program);
        var _allUniforms = uniforms.allUniforms;
        var _uniforms = uniforms.uniforms;
        var _samplerUniforms = uniforms.samplerUniforms;
        var automaticUniforms = findAutomaticUniforms(_allUniforms);
        var _automaticUniforms = automaticUniforms.automaticUniforms;
        var _manualUniforms = automaticUniforms.manualUniforms;

        this._getProgram = function() {
            return _program;
        };

        /**
        * DOC_TBA
        *
        * @return {Object} DOC_TBA
        * @exception {DeveloperError} This shader program was destroyed, i.e., destroy() was called.
        */
        this.getVertexAttributes = function() {
            return _vertexAttributes;
        };

        /**
        * DOC_TBA
        *
        * @return {Number} DOC_TBA
        * @exception {DeveloperError} This shader program was destroyed, i.e., destroy() was called.
        */
        this.getNumberOfVertexAttributes = function() {
            return _numberOfVertexAttributes;
        };

        /**
        * DOC_TBA
        *
        * @return {Object} DOC_TBA
        *
        * @exception {DeveloperError} This shader program was destroyed, i.e., destroy() was called.
        *
        * @see ShaderProgram#getManualUniforms
        */
        this.getAllUniforms = function() {
            return _allUniforms;
        };

        /**
         * DOC_TBA
         *
         * @exception {DeveloperError} This shader program was destroyed, i.e., destroy() was called.
         *
         * @see ShaderProgram#getAllUniforms
         */
        this.getManualUniforms = function() {
            return _manualUniforms;
        };

        this._bind = function() {
            gl.useProgram(_program);
        };

        this._setUniforms = function(uniformMap, uniformState) {
            // TODO: Performance

            var len;
            var i;

            if (uniformMap) {
                uniformState.setModel(uniformMap.u_model ? uniformMap.u_model() : Matrix4.IDENTITY);

                for ( var uniform in _manualUniforms) {
                    if (_manualUniforms.hasOwnProperty(uniform)) {
                        _manualUniforms[uniform].value = uniformMap[uniform]();
                    }
                }
            }

            len = _automaticUniforms.length;
            for (i = 0; i < len; ++i) {
                _automaticUniforms[i]._set(uniformState);
            }

            ///////////////////////////////////////////////////////////////////

            len = _uniforms.length;
            for (i = 0; i < len; ++i) {
                _uniforms[i]._set();
            }

            var textureUnitIndex = 0;
            len = _samplerUniforms.length;
            for (i = 0; i < len; ++i) {
                textureUnitIndex = _samplerUniforms[i]._setSampler(textureUnitIndex);
            }
        };

        this._unBind = function() {
            gl.useProgram(null);

            var textureUnitIndex = 0;
            var len = _samplerUniforms.length;
            for ( var i = 0; i < len; ++i) {
                textureUnitIndex = _samplerUniforms[i]._clearSampler(textureUnitIndex);
            }
        };

        /**
         * Returns true if this object was destroyed; otherwise, false.
         * <br /><br />
         * If this object was destroyed, it should not be used; calling any function other than
         * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
         *
         * @return {Boolean} True if this object was destroyed; otherwise, false.
         *
         * @see ShaderProgram.destroy
         */
        this.isDestroyed = function() {
            return false;
        };

        /**
         * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
         * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
         * <br /><br />
         * Once an object is destroyed, it should not be used; calling any function other than
         * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
         * assign the return value (<code>undefined</code>) to the object as done in the example.
         *
         * @return {undefined}
         *
         * @exception {DeveloperError} This shader program was destroyed, i.e., destroy() was called.
         *
         * @see ShaderProgram.isDestroyed
         * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glDeleteShader.xml'>glDeleteShader</a>
         * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glDeleteProgram.xml'>glDeleteProgram</a>
         *
         * @example
         * shaderProgram = shaderProgram && shaderProgram.destroy();
         */
        this.destroy = function() {
            gl.deleteProgram(_program);
            return destroyObject(this);
        };

        /**
         * DOC_TBA
         */
        this.release = function() {
            if (this._cachedShader) {
                return this._cachedShader.cache.releaseShaderProgram(this);
            }

            return this.destroy();
        };

        return null;
    };

    return ShaderProgram;
});

/*global define*/
define('Renderer/UniformState',[
        '../Core/DeveloperError',
        '../Core/Ellipsoid',
        '../Core/Matrix4',
        '../Core/Cartesian3',
        '../Core/Cartesian4'
    ], function(
        DeveloperError,
        Ellipsoid,
        Matrix4,
        Cartesian3,
        Cartesian4) {
    

    /**
     * DOC_TBA
     *
     * @alias UniformState
     *
     * @internalConstructor
     */
    var UniformState = function(context) {
        this._context = context;
        this._viewport = {
            x : 0,
            y : 0,
            width : 0,
            height : 0
        };
        this._viewportOrthographicMatrix = Matrix4.IDENTITY;
        this._viewportTransformation = Matrix4.IDENTITY;

        this._model = Matrix4.IDENTITY;
        this._view = Matrix4.IDENTITY;
        this._projection = Matrix4.IDENTITY;

        this._infiniteProjection = Matrix4.IDENTITY;

        // Arbitrary.  The user will explicitly set this later.
        this._sunPosition = new Cartesian3(2.0 * Ellipsoid.WGS84.getRadii().x, 0.0, 0.0);

        // Derived members
        this._inverseViewDirty = true;
        this._inverseProjectionDirty = true;
        this._modelViewDirty = true;
        this._inverseModelViewDirty = true;
        this._viewProjectionDirty = true;
        this._modelViewProjectionDirty = true;
        this._modelViewInfiniteProjectionDirty = true;
        this._normalDirty = true;
        this._inverseNormalDirty = true;
        this._sunDirectionECDirty = true;
        this._sunDirectionWCDirty = true;
    };

    /**
     * DOC_TBA
     * @memberof UniformState
     */
    UniformState.prototype.getContext = function() {
        return this._context;
    };

    UniformState.prototype._cleanViewport = function() {
        var current = this._viewport;
        var v = this._context.getViewport();

        if ((current.x !== v.x) ||
            (current.y !== v.y) ||
            (current.width !== v.width) ||
            (current.height !== v.height)) {
            current.x = v.x;
            current.y = v.y;
            current.width = v.width;
            current.height = v.height;

            this._viewportOrthographicMatrix = Matrix4.computeOrthographicOffCenter(v.x, v.x + v.width, v.y, v.y + v.height, 0.0, 1.0);
            this._viewportTransformation = Matrix4.computeViewportTransformation(v);
        }
    };

    /**
     * DOC_TBA
     * @memberof UniformState
     *
     *
     * @see agi_viewportOrthographic
     */
    UniformState.prototype.getViewportOrthographic = function() {
        this._cleanViewport();
        return this._viewportOrthographicMatrix;
    };

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @see agi_viewportTransformation
     */
    UniformState.prototype.getViewportTransformation = function() {
        this._cleanViewport();
        return this._viewportTransformation;
    };

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @param {Matrix4} [matrix] DOC_TBA.
     *
     * @see UniformState#getModel
     * @see agi_model
     */
    UniformState.prototype.setModel = function(matrix) {
        matrix = matrix || Matrix4.IDENTITY;

        this._model = matrix;
        this._modelViewDirty = true;
        this._inverseModelViewDirty = true;
        this._modelViewProjectionDirty = true;
        this._modelViewInfiniteProjectionDirty = true;
        this._normalDirty = true;
        this._inverseNormalDirty = true;
        this._sunDirectionWCDirty = true;
    };

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @return {Matrix4} DOC_TBA.
     *
     * @see UniformState#setModel
     * @see agi_model
     */
    UniformState.prototype.getModel = function() {
        return this._model;
    };

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @param {Matrix4} [matrix] DOC_TBA.
     *
     * @see UniformState#getView
     * @see agi_view
     */
    UniformState.prototype.setView = function(matrix) {
        matrix = matrix || Matrix4.IDENTITY;

        this._view = matrix;
        this._inverseViewDirty = true;
        this._modelViewDirty = true;
        this._inverseModelViewDirty = true;
        this._viewProjectionDirty = true;
        this._modelViewProjectionDirty = true;
        this._modelViewInfiniteProjectionDirty = true;
        this._normalDirty = true;
        this._inverseNormalDirty = true;
        this._sunDirectionECDirty = true;
    };

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @return {Matrix4} DOC_TBA.
     *
     * @see UniformState#setView
     * @see agi_view
     */
    UniformState.prototype.getView = function() {
        return this._view;
    };

    UniformState.prototype._cleanInverseView = function() {
        if (this._inverseViewDirty) {
            this._inverseViewDirty = false;

            var n = this.getView().inverse();
            this._inverseView = n;
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @return {Matrix4} DOC_TBA.
     *
     * @see agi_inverseView
     */
    UniformState.prototype.getInverseView = function() {
        this._cleanInverseView();
        return this._inverseView;
    };

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @param {Matrix4} [matrix] DOC_TBA.
     *
     * @see UniformState#getProjection
     * @see agi_projection
     */
    UniformState.prototype.setProjection = function(matrix) {
        matrix = matrix || Matrix4.IDENTITY;

        this._projection = matrix;
        this._inverseProjectionDirty = true;
        this._viewProjectionDirty = true;
        this._modelViewProjectionDirty = true;
    };

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @return {Matrix4} DOC_TBA.
     *
     * @see UniformState#setProjection
     * @see agi_projection
     */
    UniformState.prototype.getProjection = function() {
        return this._projection;
    };

    UniformState.prototype._cleanInverseProjection = function() {
        if (this._inverseProjectionDirty) {
            this._inverseProjectionDirty = false;

            var n = this.getProjection().inverse();
            this._inverseProjection = n;
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @return {Matrix4} DOC_TBA.
     *
     * @see agi_inverseProjection
     */
    UniformState.prototype.getInverseProjection = function() {
        this._cleanInverseProjection();
        return this._inverseProjection;
    };

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @param {Matrix4} [matrix] DOC_TBA.
     *
     * @see UniformState#getInfiniteProjection
     * @see agi_infiniteProjection
     */
    UniformState.prototype.setInfiniteProjection = function(matrix) {
        matrix = matrix || Matrix4.IDENTITY;

        this._infiniteProjection = matrix;
        this._modelViewInfiniteProjectionDirty = true;
    };

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @return {Matrix4} DOC_TBA.
     *
     * @see UniformState#setInfiniteProjection
     * @see agi_infiniteProjection
     */
    UniformState.prototype.getInfiniteProjection = function() {
        return this._infiniteProjection;
    };

    // Derived
    UniformState.prototype._cleanModelView = function() {
        if (this._modelViewDirty) {
            this._modelViewDirty = false;

            var mv = this._view.multiply(this._model);
            this._modelView = mv;
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @return {Matrix4} DOC_TBA.
     *
     * @see agi_modelView
     */
    UniformState.prototype.getModelView = function() {
        this._cleanModelView();
        return this._modelView;
    };

    UniformState.prototype._cleanInverseModelView = function() {
        if (this._inverseModelViewDirty) {
            this._inverseModelViewDirty = false;

            var m = this.getModelView().inverse();
            this._inverseModelView = m;
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @return {Matrix4} DOC_TBA.
     *
     * @see agi_inverseModelView
     */
    UniformState.prototype.getInverseModelView = function() {
        this._cleanInverseModelView();
        return this._inverseModelView;
    };

    UniformState.prototype._cleanViewProjection = function() {
        if (this._viewProjectionDirty) {
            this._viewProjectionDirty = false;

            var vp = this.getProjection().multiply(this.getView());
            this._viewProjection = vp;
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @return {Matrix4} DOC_TBA.
     *
     * @see agi_viewProjection
     */
    UniformState.prototype.getViewProjection = function() {
        this._cleanViewProjection();
        return this._viewProjection;
    };

    UniformState.prototype._cleanModelViewProjection = function() {
        if (this._modelViewProjectionDirty) {
            this._modelViewProjectionDirty = false;

            var mvp = this._projection.multiply(this.getModelView());
            this._modelViewProjection = mvp;
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @return {Matrix4} DOC_TBA.
     *
     * @see agi_modelViewProjection
     */
    UniformState.prototype.getModelViewProjection = function() {
        this._cleanModelViewProjection();
        return this._modelViewProjection;
    };

    UniformState.prototype._cleanModelViewInfiniteProjection = function() {
        if (this._modelViewInfiniteProjectionDirty) {
            this._modelViewInfiniteProjectionDirty = false;

            var mvp = this._infiniteProjection.multiply(this.getModelView());
            this._modelViewInfiniteProjection = mvp;
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @return {Matrix4} DOC_TBA.
     *
     * @see agi_modelViewProjection
     */
    UniformState.prototype.getModelViewInfiniteProjection = function() {
        this._cleanModelViewInfiniteProjection();
        return this._modelViewInfiniteProjection;
    };

    UniformState.prototype._cleanNormal = function() {
        if (this._normalDirty) {
            this._normalDirty = false;

            // TODO:  Inverse, transpose of the whole 4x4?  Or we can just do the 3x3?
            var n = this.getModelView().inverse().transpose().getRotation();
            this._normal = n;
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @return {Matrix3} DOC_TBA.
     *
     * @see agi_normal
     */
    UniformState.prototype.getNormal = function() {
        this._cleanNormal();
        return this._normal;
    };

    UniformState.prototype._cleanInverseNormal = function() {
        if (this._inverseNormalDirty) {
            this._inverseNormalDirty = false;

            // TODO:  Inverse of the whole 4x4?  Or we can just do the 3x3?
            var n = this.getModelView().inverse().getRotation();
            this._inverseNormal = n;
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @return {Matrix3} DOC_TBA.
     *
     * @see agi_inverseNormal
     */
    UniformState.prototype.getInverseNormal = function() {
        this._cleanInverseNormal();
        return this._inverseNormal;
    };

    UniformState.prototype._cleanSunDirectionEC = function() {
        if (this._sunDirectionECDirty) {
            this._sunDirectionECDirty = false;

            var sunPosition = new Cartesian4(this._sunPosition.x, this._sunPosition.y, this._sunPosition.z, 0.0);
            var sunEC = this.getView().multiplyByVector(sunPosition);
            var p = new Cartesian3(sunEC.x, sunEC.y, sunEC.z).normalize();

            this._sunDirectionEC = p;
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @param {Matrix4} sunPosition The position of the sun in the sun's reference frame.
     *
     * @exception {DeveloperError} sunPosition is required.
     *
     * @see UniformState#getSunPosition
     */
    UniformState.prototype.setSunPosition = function(sunPosition) {
        if (!sunPosition) {
            throw new DeveloperError('sunPosition is required.');
        }

        this._sunPosition = sunPosition;
        this._sunDirectionECDirty = true;
        this._sunDirectionWCDirty = true;
    };

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @see UniformState#setSunPosition
     */
    UniformState.prototype.getSunPosition = function() {
        return this._sunPosition;
    };

    /**
     * DOC_TBA
     *
     * @memberof UniformState
     *
     * @return {Cartesian3} The sun's direction in eye coordinates.
     *
     * @see agi_sunDirectionEC
     * @see UniformState#getSunDirectionEC
     */
    UniformState.prototype.getSunDirectionEC = function() {
        this._cleanSunDirectionEC();
        return this._sunDirectionEC;
    };

    UniformState.prototype._cleanSunDirectionWC = function() {
        if (this._sunDirectionWCDirty) {
            this._sunDirectionWCDirty = false;
            this._sunDirectionWC = this._sunPosition.normalize();
        }
    };

    /**
    * DOC_TBA
    *
    * @memberof UniformState
    *
    * @return {Cartesian3} A normalized vector from the model's origin to the sun in model coordinates.
    *
    * @see agi_sunDirectionWC
    */
    UniformState.prototype.getSunDirectionWC = function() {
        this._cleanSunDirectionWC();
        return this._sunDirectionWC;
    };

    UniformState.prototype.getHighResolutionSnapScale = function() {
        return 1.0;
    };

    return UniformState;
});
/*global define*/
define('Renderer/VertexArray',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/ComponentDatatype'
    ], function(
        DeveloperError,
        destroyObject,
        ComponentDatatype) {
    

    /**
     * DOC_TBA
     *
     * @alias VertexArray
     *
     * @internalConstructor
     *
     * @see {@link Context#createVertexArray}
     * @see {@link Context#createVertexArrayFromMesh}
     */
    var VertexArray = function(gl, attributes, indexBuffer) {
        this._gl = gl;
        this._attributes = [];
        this._indexBuffer = indexBuffer;

        if (attributes) {
            for ( var i = 0; i < attributes.length; ++i) {
                try {
                    this._addAttribute(attributes[i], i);
                } catch (e) {
                    throw new DeveloperError(e.message);
                }
            }
        }

        // Verify all attribute names are unique
        var uniqueIndices = {};
        for ( var j = 0; j < this._attributes.length; ++j) {
            var index = this._attributes[j].index;
            if (uniqueIndices[index]) {
                throw new DeveloperError('Index ' + index + ' is used by more than one attribute.');
            }

            uniqueIndices[index] = true;
        }
    };

    VertexArray.prototype._addAttribute = function(attribute, index) {
        if (!attribute.vertexBuffer && !attribute.value) {
            throw new DeveloperError('attribute must have a vertexBuffer or a value.');
        }

        if (attribute.vertexBuffer && attribute.value) {
            throw new DeveloperError('attribute cannot have both a vertexBuffer and a value.  It must have either a vertexBuffer property defining per-vertex data or a value property defining data for all vertices.');
        }

        var componentsPerAttribute = attribute.value ? attribute.value.length : attribute.componentsPerAttribute;

        if ((componentsPerAttribute !== 1) &&
            (componentsPerAttribute !== 2) &&
            (componentsPerAttribute !== 3) &&
            (componentsPerAttribute !== 4)) {
            if (attribute.value) {
                throw new DeveloperError('attribute.value.length must be in the range [1, 4].');
            }

            throw new DeveloperError('attribute.componentsPerAttribute must be in the range [1, 4].');
        }

        if (attribute.componentDatatype) {
            var datatype = attribute.componentDatatype;
            if (!ComponentDatatype.validate(datatype)) {
                throw new DeveloperError('attribute must have a valid componentDatatype or not specify it.');
            }
        }

        if (attribute.strideInBytes && (attribute.strideInBytes > 255)) {
            // WebGL limit.  Not in GL ES.
            throw new DeveloperError('attribute must have a strideInBytes less than or equal to 255 or not specify it.');
        }

        // Shallow copy the attribute; we do not want to copy the vertex buffer.
        var attr = {
            index : (typeof attribute.index === 'undefined') ? index : attribute.index,
            enabled : (typeof attribute.enabled === 'undefined') ? true : attribute.enabled,
            vertexBuffer : attribute.vertexBuffer,
            value : attribute.value ? attribute.value.slice(0) : undefined,
            componentsPerAttribute : componentsPerAttribute,
            componentDatatype : attribute.componentDatatype || ComponentDatatype.FLOAT,
            normalize : attribute.normalize || false,
            offsetInBytes : attribute.offsetInBytes || 0,
            strideInBytes : attribute.strideInBytes || 0
        };

        if (attr.vertexBuffer) {
            // Common case: vertex buffer for per-vertex data
            attr.vertexAttrib = function(gl) {
                gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer._getBuffer());
                gl.vertexAttribPointer(this.index, this.componentsPerAttribute, this.componentDatatype, this.normalize, this.strideInBytes, this.offsetInBytes);
                gl.enableVertexAttribArray(this.index);
            };

            attr.disableVertexAttribArray = function(gl) {
                gl.disableVertexAttribArray(this.index);
            };
        } else {
            // Less common case: value array for the same data for each vertex
            switch (attr.componentsPerAttribute) {
            case 1:
                attr.vertexAttrib = function(gl) {
                    gl.vertexAttrib1fv(this.index, this.value);
                };
                break;
            case 2:
                attr.vertexAttrib = function(gl) {
                    gl.vertexAttrib2fv(this.index, this.value);
                };
                break;
            case 3:
                attr.vertexAttrib = function(gl) {
                    gl.vertexAttrib3fv(this.index, this.value);
                };
                break;
            case 4:
                attr.vertexAttrib = function(gl) {
                    gl.vertexAttrib4fv(this.index, this.value);
                };
                break;
            }

            attr.disableVertexAttribArray = function(gl) {
            };
        }

        this._attributes.push(attr);
    };

    /**
     * DOC_TBA
     *
     * index is the location in the array of attributes, not the index property of an attribute.
     *
     * @memberof VertexArray
     *
     * @exception {DeveloperError} index is required.
     * @exception {DeveloperError} This vertex array was destroyed, i.e., destroy() was called.
     */
    VertexArray.prototype.getAttribute = function(index) {
        if (typeof index === 'undefined') {
            throw new DeveloperError('index is required.');
        }

        return this._attributes[index];
    };

    /**
    * DOC_TBA
    *
    * @memberof VertexArray
    *
    * @exception {DeveloperError} This vertex array was destroyed, i.e., destroy() was called.
    */
    VertexArray.prototype.getNumberOfAttributes = function() {
        return this._attributes.length;
    };

    /**
     * DOC_TBA
     *
     * @memberof VertexArray
     *
     * @exception {DeveloperError} Attribute must have a vertexBuffer.
     * @exception {DeveloperError} Attribute must have a componentsPerAttribute.
     * @exception {DeveloperError} Attribute must have a valid componentDatatype or not specify it.
     * @exception {DeveloperError} Attribute must have a strideInBytes less than or equal to 255 or not specify it.
     * @exception {DeveloperError} Index is already in use.
     * @exception {DeveloperError} This vertex array was destroyed, i.e., destroy() was called.
     */
    VertexArray.prototype.addAttribute = function(attribute) {
        if (attribute) {
            var attributes = this._attributes;
            var index = (typeof attribute.index === 'undefined') ? attributes.length : attribute.index;
            for ( var i = 0; i < attributes.length; ++i) {
                if (index === attributes[i].index) {
                    throw new DeveloperError('Index ' + index + ' is already in use.');
                }
            }

            try {
                this._addAttribute(attribute, index);
            } catch (e) {
                throw new DeveloperError(e.message);
            }
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof VertexArray
     *
     * @return {Boolean} True if the attribute was removed; false if the attribute was not found in the vertex array.
     *
     * @exception {DeveloperError} Attribute must have an index.
     * @exception {DeveloperError} This vertex array was destroyed, i.e., destroy() was called.
     */
    VertexArray.prototype.removeAttribute = function(attribute) {
        if (attribute) {
            if (typeof attribute.index === 'undefined') {
                throw new DeveloperError('Attribute must have an index.');
            }

            var attributes = this._attributes;
            for ( var i = 0; i < attributes.length; ++i) {
                if (attributes[i].index === attribute.index) {
                    attributes.splice(i, 1);
                    return true;
                }
            }
        }

        return false;
    };

    /**
     * DOC_TBA
     *
     * @memberof VertexArray
     *
     * @return {Buffer} DOC_TBA.
     * @exception {DeveloperError} This vertex array was destroyed, i.e., destroy() was called.
     */
    VertexArray.prototype.getIndexBuffer = function() {
        return this._indexBuffer;
    };

    /**
     * DOC_TBA
     *
     * @memberof VertexArray
     *
     * @exception {DeveloperError} This vertex array was destroyed, i.e., destroy() was called.
     */
    VertexArray.prototype.setIndexBuffer = function(indexBuffer) {
        this._indexBuffer = indexBuffer;
    };

    VertexArray.prototype._bind = function() {
        var attributes = this._attributes;
        var gl = this._gl;

        // TODO:  Performance: sort by vertex buffer?
        for ( var i = 0; i < attributes.length; ++i) {
            var attribute = attributes[i];
            if (attribute.enabled) {
                attribute.vertexAttrib(gl);
            }
        }

        if (this._indexBuffer) {
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer._getBuffer());
        }
    };

    VertexArray.prototype._unBind = function() {
        var attributes = this._attributes;
        var gl = this._gl;

        for ( var i = 0; i < attributes.length; ++i) {
            var attribute = attributes[i];
            if (attribute.enabled) {
                attribute.disableVertexAttribArray(gl);
            }
        }
        if (this._indexBuffer) {
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        }
    };

    /**
     * This assumes that each vertex buffer in the vertex array has the same number of vertices.
     * @private
     */
    VertexArray.prototype._getNumberOfVertices = function() {
        if (this._attributes.length > 0) {
            var attribute = this._attributes[0];
            var bytes = attribute.strideInBytes || (attribute.componentsPerAttribute * attribute.componentDatatype.sizeInBytes);

            return attribute.vertexBuffer.getSizeInBytes() / bytes;
        }

        return 0;
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof VertexArray
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see VertexArray#destroy
     */
    VertexArray.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Only call this if the vertex array owns the vertex buffers referenced by the attributes and owns its
     * index buffer; otherwise, the owner of the buffers is responsible for destroying them.  A vertex or
     * index buffer is only destroyed if it's <code>getVertexArrayDestroyable</code> function returns
     * <code>true</code> (the default).  This allows combining destroyable and non-destroyable buffers
     * in the same vertex array.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof VertexArray
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This vertex array was destroyed, i.e., destroy() was called.
     *
     * @see VertexArray#isDestroyed
     * @see Buffer#getVertexArrayDestroyable
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glDeleteBuffers.xml'>glDeleteBuffers</a>
     *
     * @example
     * // Destroying the vertex array implicitly calls destroy for each of its vertex
     * // buffers and its index buffer.
     * var vertexBuffer = context.createVertexBuffer(new Float32Array([0, 0, 0]),
     *     BufferUsage.STATIC_DRAW);
     * var vertexArray = context.createVertexArray();
     * vertexArray.addAttribute({ vertexBuffer : vertexBuffer, componentsPerAttribute : 3 });
     * // ...
     * vertexArray = vertexArray.destroy();
     * // Calling vertexBuffer.destroy() would throw DeveloperError at this point.
     */
    VertexArray.prototype.destroy = function() {
        var attributes = this._attributes;
        for ( var i = 0; i < attributes.length; ++i) {
            var vertexBuffer = attributes[i].vertexBuffer;
            if (vertexBuffer && !vertexBuffer.isDestroyed() && vertexBuffer.getVertexArrayDestroyable()) {
                vertexBuffer.destroy();
            }
        }

        var indexBuffer = this._indexBuffer;
        if (indexBuffer && indexBuffer.getVertexArrayDestroyable()) {
            this._indexBuffer = indexBuffer.destroy();
        }

        return destroyObject(this);
    };

    return VertexArray;
});
/*global define*/
define('Renderer/VertexArrayFacade',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/ComponentDatatype',
        './BufferUsage'
    ], function(
        DeveloperError,
        destroyObject,
        ComponentDatatype,
        BufferUsage) {
    

    /**
     * DOC_TBA
     *
     * @alias VertexArrayFacade
     *
     * @constructor
     *
     * @exception {DeveloperError} context is required.
     * @exception {DeveloperError} At least one attribute is required.
     * @exception {DeveloperError} Attribute must have a componentsPerAttribute.
     * @exception {DeveloperError} Attribute must have a valid componentDatatype or not specify it.
     * @exception {DeveloperError} Attribute must have a valid usage or not specify it.
     * @exception {DeveloperError} Index n is used by more than one attribute.
     */
    var VertexArrayFacade = function(context, attributes, sizeInVertices) {
        if (!context) {
            throw new DeveloperError('context is required.');
        }

        if (!attributes || (attributes.length === 0)) {
            throw new DeveloperError('At least one attribute is required.');
        }

        var attrs = VertexArrayFacade._verifyAttributes(attributes);

        sizeInVertices = sizeInVertices || 0;

        var staticAttributes = [];
        var streamAttributes = [];
        var dynamicAttributes = [];
        var precreatedAttributes = [];

        var length = attrs.length;
        for ( var i = 0; i < length; ++i) {
            var attribute = attrs[i];

            // If the attribute already has a vertex buffer, we do not need
            // to manage a vertex buffer or typed array for it.
            if (attribute.vertexBuffer) {
                precreatedAttributes.push(attribute);
            } else {
                switch (attribute.usage) {
                case BufferUsage.STATIC_DRAW:
                    staticAttributes.push(attribute);
                    break;
                case BufferUsage.STREAM_DRAW:
                    streamAttributes.push(attribute);
                    break;
                case BufferUsage.DYNAMIC_DRAW:
                    dynamicAttributes.push(attribute);
                    break;
                }
            }
        }

        // Sort attributes by the size of their components.  From left to right, a vertex stores floats, shorts, and then bytes.
        function compare(left, right) {
            return right.componentDatatype.sizeInBytes - left.componentDatatype.sizeInBytes;
        }

        staticAttributes.sort(compare);
        streamAttributes.sort(compare);
        dynamicAttributes.sort(compare);

        var staticVertexSizeInBytes = VertexArrayFacade._vertexSizeInBytes(staticAttributes);
        var streamVertexSizeInBytes = VertexArrayFacade._vertexSizeInBytes(streamAttributes);
        var dynamicVertexSizeInBytes = VertexArrayFacade._vertexSizeInBytes(dynamicAttributes);

        this._size = 0;

        this._static = {
            vertexSizeInBytes : staticVertexSizeInBytes,

            vertexBuffer : undefined,
            usage : BufferUsage.STATIC_DRAW,
            needsCommit : false,

            arrayBuffer : undefined,
            arrayViews : VertexArrayFacade._createArrayViews(staticAttributes, staticVertexSizeInBytes)
        };

        this._stream = {
            vertexSizeInBytes : streamVertexSizeInBytes,

            vertexBuffer : undefined,
            usage : BufferUsage.STREAM_DRAW,
            needsCommit : false,

            arrayBuffer : undefined,
            arrayViews : VertexArrayFacade._createArrayViews(streamAttributes, streamVertexSizeInBytes)
        };

        this._dynamic = {
            vertexSizeInBytes : dynamicVertexSizeInBytes,

            vertexBuffer : undefined,
            usage : BufferUsage.DYNAMIC_DRAW,
            needsCommit : false,

            arrayBuffer : undefined,
            arrayViews : VertexArrayFacade._createArrayViews(dynamicAttributes, dynamicVertexSizeInBytes)
        };

        this._precreated = precreatedAttributes;
        this._context = context;

        /**
         * DOC_TBA
         */
        this.writers = undefined;

        /**
         * DOC_TBA
         */
        this.va = undefined;

        this.resize(sizeInVertices);
    };

    VertexArrayFacade._verifyAttributes = function(attributes) {
        var attrs = [];

        for ( var i = 0; i < attributes.length; ++i) {
            var attribute = attributes[i];

            var attr = {
                index : (typeof attribute.index === 'undefined') ? i : attribute.index,
                enabled : (typeof attribute.enabled === 'undefined') ? true : attribute.enabled,
                componentsPerAttribute : attribute.componentsPerAttribute,
                componentDatatype : attribute.componentDatatype || ComponentDatatype.FLOAT,
                normalize : attribute.normalize || false,

                // There will be either a vertexBuffer or an [optional] usage.
                vertexBuffer : attribute.vertexBuffer,
                usage : attribute.usage || BufferUsage.STATIC_DRAW
            };
            attrs.push(attr);

            if ((attr.componentsPerAttribute !== 1) && (attr.componentsPerAttribute !== 2) && (attr.componentsPerAttribute !== 3) && (attr.componentsPerAttribute !== 4)) {
                throw new DeveloperError('attribute.componentsPerAttribute must be in the range [1, 4].');
            }

            var datatype = attr.componentDatatype;
            if (!ComponentDatatype.validate(datatype)) {
                throw new DeveloperError('Attribute must have a valid componentDatatype or not specify it.');
            }

            if (!BufferUsage.validate(attr.usage)) {
                throw new DeveloperError('Attribute must have a valid usage or not specify it.');
            }
        }

        // Verify all attribute names are unique
        var uniqueIndices = new Array(attrs.length);
        for ( var j = 0; j < attrs.length; ++j) {
            var index = attrs[j].index;
            if (uniqueIndices[index]) {
                throw new DeveloperError('Index ' + index + ' is used by more than one attribute.');
            }
            uniqueIndices[index] = true;
        }

        return attrs;
    };

    VertexArrayFacade._vertexSizeInBytes = function(attributes) {
        var sizeInBytes = 0;

        var length = attributes.length;
        for ( var i = 0; i < length; ++i) {
            var attribute = attributes[i];
            sizeInBytes += (attribute.componentsPerAttribute * attribute.componentDatatype.sizeInBytes);
        }

        var maxComponentSizeInBytes = (length > 0) ? attributes[0].componentDatatype.sizeInBytes : 0; // Sorted by size
        var remainder = (maxComponentSizeInBytes > 0) ? (sizeInBytes % maxComponentSizeInBytes) : 0;
        var padding = (remainder === 0) ? 0 : (maxComponentSizeInBytes - remainder);
        sizeInBytes += padding;

        return sizeInBytes;
    };

    VertexArrayFacade._createArrayViews = function(attributes, vertexSizeInBytes) {
        var views = [];
        var offsetInBytes = 0;

        var length = attributes.length;
        for ( var i = 0; i < length; ++i) {
            var attribute = attributes[i];
            var componentDatatype = attribute.componentDatatype;

            views.push({
                index : attribute.index,
                enabled : attribute.enabled,
                componentsPerAttribute : attribute.componentsPerAttribute,
                componentDatatype : componentDatatype,
                normalize : attribute.normalize,

                offsetInBytes : offsetInBytes,
                vertexSizeInComponentType : vertexSizeInBytes / componentDatatype.sizeInBytes,

                view : undefined
            });

            offsetInBytes += (attribute.componentsPerAttribute * componentDatatype.sizeInBytes);
        }

        return views;
    };

    /**
     * DOC_TBA
     *
     * Invalidates writers.  Can't render again until commit is called.
     *
     * @memberof VertexArrayFacade
     */
    VertexArrayFacade.prototype.resize = function(sizeInVertices) {
        this._size = sizeInVertices;

        VertexArrayFacade._resize(this._static, this._size);
        VertexArrayFacade._resize(this._stream, this._size);
        VertexArrayFacade._resize(this._dynamic, this._size);

        // Reserving invalidates the writers, so if client's cache them, they need to invalidate their cache.
        this.writers = [];
        VertexArrayFacade._appendWriters(this.writers, this._static);
        VertexArrayFacade._appendWriters(this.writers, this._stream);
        VertexArrayFacade._appendWriters(this.writers, this._dynamic);

        // VAs are recreated next time commit is called.
        this._destroyVA();
    };

    VertexArrayFacade._resize = function(buffer, size) {
        if (buffer.vertexSizeInBytes > 0) {
            // Create larger array buffer
            var arrayBuffer = new ArrayBuffer(size * buffer.vertexSizeInBytes);

            // Copy contents from previous array buffer
            if (buffer.arrayBuffer) {
                var destView = new Uint8Array(arrayBuffer);
                var sourceView = new Uint8Array(buffer.arrayBuffer);
                var sourceLength = sourceView.length;
                for ( var j = 0; j < sourceLength; ++j) {
                    destView[j] = sourceView[j];
                }
            }

            // Create typed views into the new array buffer
            var views = buffer.arrayViews;
            var length = views.length;
            for ( var i = 0; i < length; ++i) {
                var view = views[i];
                view.view = view.componentDatatype.createArrayBufferView(arrayBuffer, view.offsetInBytes);
            }

            buffer.arrayBuffer = arrayBuffer;
        }
    };

    var createWriters = [
    // 1 component per attribute
    function(buffer, view, vertexSizeInComponentType) {
        return function(index, attribute) {
            view[index * vertexSizeInComponentType] = attribute;
            buffer.needsCommit = true;
        };
    },

    // 2 component per attribute
    function(buffer, view, vertexSizeInComponentType) {
        return function(index, component0, component1) {
            var i = index * vertexSizeInComponentType;
            view[i] = component0;
            view[i + 1] = component1;
            buffer.needsCommit = true;
        };
    },

    // 3 component per attribute
    function(buffer, view, vertexSizeInComponentType) {
        return function(index, component0, component1, component2) {
            var i = index * vertexSizeInComponentType;
            view[i] = component0;
            view[i + 1] = component1;
            view[i + 2] = component2;
            buffer.needsCommit = true;
        };
    },

    // 4 component per attribute
    function(buffer, view, vertexSizeInComponentType) {
        return function(index, component0, component1, component2, component3) {
            var i = index * vertexSizeInComponentType;
            view[i] = component0;
            view[i + 1] = component1;
            view[i + 2] = component2;
            view[i + 3] = component3;
            buffer.needsCommit = true;
        };
    }];

    VertexArrayFacade._appendWriters = function(writers, buffer) {
        var arrayViews = buffer.arrayViews;
        var length = arrayViews.length;
        for ( var i = 0; i < length; ++i) {
            var arrayView = arrayViews[i];
            writers[arrayView.index] = createWriters[arrayView.componentsPerAttribute - 1](buffer, arrayView.view, arrayView.vertexSizeInComponentType);
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof VertexArrayFacade
     */
    VertexArrayFacade.prototype.commit = function(indexBuffer) {
        var recreateVA = false;
        recreateVA = this._commit(this._static) || recreateVA;
        recreateVA = this._commit(this._stream) || recreateVA;
        recreateVA = this._commit(this._dynamic) || recreateVA;

        ///////////////////////////////////////////////////////////////////////

        if (recreateVA || !this.va) {
            // Using unsigned short indices, 64K vertices can be indexed by one index buffer
            var sixtyFourK = 64 * 1024;

            var va = [];
            var numberOfVertexArrays = Math.ceil(this._size / sixtyFourK);
            for ( var k = 0; k < numberOfVertexArrays; ++k) {
                var attributes = [];
                VertexArrayFacade._appendAttributes(attributes, this._static, k * (this._static.vertexSizeInBytes * sixtyFourK));
                VertexArrayFacade._appendAttributes(attributes, this._stream, k * (this._stream.vertexSizeInBytes * sixtyFourK));
                VertexArrayFacade._appendAttributes(attributes, this._dynamic, k * (this._dynamic.vertexSizeInBytes * sixtyFourK));

                attributes = attributes.concat(this._precreated);

                va.push({
                    va : this._context.createVertexArray(attributes, indexBuffer),
                    indicesCount : 1.5 * ((k !== (numberOfVertexArrays - 1)) ? sixtyFourK : (this._size % sixtyFourK))
                // TODO: not hardcode 1.5
                });
            }

            this._destroyVA();
            this.va = va;
        }
    };

    VertexArrayFacade.prototype._commit = function(buffer) {
        if (buffer.needsCommit && (buffer.vertexSizeInBytes > 0)) {
            buffer.needsCommit = false;

            var vertexBuffer = buffer.vertexBuffer;
            var vertexBufferSizeInBytes = this._size * buffer.vertexSizeInBytes;
            if (!vertexBuffer || (vertexBuffer.getSizeInBytes() < vertexBufferSizeInBytes)) {
                if (vertexBuffer) {
                    vertexBuffer.destroy();
                }
                buffer.vertexBuffer = this._context.createVertexBuffer(buffer.arrayBuffer, buffer.usage);
                buffer.vertexBuffer.setVertexArrayDestroyable(false);

                return true; // Created new vertex buffer
            }

            buffer.vertexBuffer.copyFromArrayView(buffer.arrayBuffer);
        }

        return false; // Did not create new vertex buffer
    };

    VertexArrayFacade._appendAttributes = function(attributes, buffer, vertexBufferOffset) {
        var arrayViews = buffer.arrayViews;
        var length = arrayViews.length;
        for ( var i = 0; i < length; ++i) {
            var view = arrayViews[i];

            attributes.push({
                index : view.index,
                enabled : view.enabled,
                componentsPerAttribute : view.componentsPerAttribute,
                componentDatatype : view.componentDatatype,
                normalize : view.normalize,
                vertexBuffer : buffer.vertexBuffer,
                offsetInBytes : vertexBufferOffset + view.offsetInBytes,
                strideInBytes : buffer.vertexSizeInBytes
            });
        }
    };

    /**
     * DOC_TBA
     * @memberof VertexArrayFacade
     */
    VertexArrayFacade.prototype.subCommit = function(offsetInVertices, lengthInVertices) {
        if (offsetInVertices < 0 || offsetInVertices >= this._size) {
            throw new DeveloperError('offsetInVertices must be greater than or equal to zero and less than the vertex array size.');
        }

        if (offsetInVertices + lengthInVertices > this._size) {
            throw new DeveloperError('offsetInVertices + lengthInVertices cannot exceed the vertex array size.');
        }

        this._subCommit(this._static, offsetInVertices, lengthInVertices);
        this._subCommit(this._stream, offsetInVertices, lengthInVertices);
        this._subCommit(this._dynamic, offsetInVertices, lengthInVertices);
    };

    VertexArrayFacade.prototype._subCommit = function(buffer, offsetInVertices, lengthInVertices) {
        if (buffer.needsCommit && (buffer.vertexSizeInBytes > 0)) {
            var byteOffset = buffer.vertexSizeInBytes * offsetInVertices;
            var byteLength = buffer.vertexSizeInBytes * lengthInVertices;

            // PERFORMANCE_IDEA: If we want to get really crazy, we could consider updating
            // individual attributes instead of the entire (sub-)vertex.
            //
            // PERFORMANCE_IDEA: Does creating the typed view add too much GC overhead?
            buffer.vertexBuffer.copyFromArrayView(new Uint8Array(buffer.arrayBuffer, byteOffset, byteLength), byteOffset);
        }
    };

    /**
     * DOC_TBA
     * @memberof VertexArrayFacade
     */
    VertexArrayFacade.prototype.endSubCommits = function() {
        this._static.needsCommit = false;
        this._stream.needsCommit = false;
        this._dynamic.needsCommit = false;
    };

    VertexArrayFacade.prototype._destroyVA = function() {
        var va = this.va;
        if (va) {
            this.va = undefined;

            var length = va.length;
            for ( var i = 0; i < length; ++i) {
                va[i].va.destroy();
            }
        }
    };

    /**
     * DOC_TBA
     * @memberof VertexArrayFacade
     */
    VertexArrayFacade.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * DOC_TBA
     * @memberof VertexArrayFacade
     */
    VertexArrayFacade.prototype.destroy = function() {
        this._static.vertexBuffer = this._static.vertexBuffer && this._static.vertexBuffer.destroy();
        this._stream.vertexBuffer = this._stream.vertexBuffer && this._stream.vertexBuffer.destroy();
        this._dynamic.vertexBuffer = this._dynamic.vertexBuffer && this._dynamic.vertexBuffer.destroy();
        this._destroyVA();

        return destroyObject(this);
    };

    return VertexArrayFacade;
});
/*global define*/
define('Renderer/VertexLayout',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * Determines if vertex attributes are interleaved in a single vertex buffer or if each attribute is stored in a separate vertex buffer.
     *
     * @exports VertexLayout
     *
     * @see Context#createVertexArrayFromMesh
     */
    var VertexLayout = {
        /**
         * Each attribute will be stored in a separate vertex buffer.  This can be slightly slower
         * than using a single interleaved vertex buffer, but it is more flexible; more easily allowing
         * the sharing of vertex buffers among vertex arrays.  It also requires much less initial CPU
         * processing than interleaving.
         *
         * @constant
         * @type {Enumeration}
         */
        SEPARATE : new Enumeration(0, 'SEPARATE'),
        /**
         * Each attribute will be interleaved in a single vertex buffer.  This can have a slight
         * performance advantage over using a separate vertex buffer per attribute, but it requires
         * extra CPU processing to initially interleave the vertex data.  This is recommended for
         * static data that will be rendered over several frames.
         *
         * @constant
         * @type {Enumeration}
         */
        INTERLEAVED : new Enumeration(1, 'INTERLEAVED'),

        /**
         * DOC_TBA
         *
         * @param vertexLayout
         *
         * @returns {Boolean}
         */
        validate : function(vertexLayout) {
            return ((vertexLayout === VertexLayout.SEPARATE) ||
                    (vertexLayout === VertexLayout.INTERLEAVED));
        }

    };

    return VertexLayout;
});
/*global define*/
define('Scene/BingMapsStyle',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * An enumeration of the types of imagery provided by Bing Maps.
     *
     * @exports BingMapsStyle
     *
     * @see BingMapsTileProvider
     */
    var BingMapsStyle = {
        /**
         * Aerial imagery.
         *
         * @constant
         * @type {Enumeration}
         */
        AERIAL : new Enumeration(0, 'AERIAL', { imagerySetName : 'Aerial' }),

        /**
         * Aerial imagery with a road overlay.
         *
         * @constant
         * @type {Enumeration}
         */
        AERIAL_WITH_LABELS : new Enumeration(1, 'AERIAL_WITH_LABELS', { imagerySetName : 'AerialWithLabels' }),

        /**
         * Roads without additional imagery.
         *
         * @constant
         * @type {Enumeration}
         */
        ROAD : new Enumeration(2, 'ROAD', { imagerySetName : 'Road' }),

        /**
         * Ordnance Survey imagery
         *
         * @constant
         * @type {Enumeration}
         */
        ORDNANCE_SURVEY : new Enumeration(3, 'ORDNANCE_SURVEY', { imagerySetName : 'OrdnanceSurvey' }),

        /**
         * Collins Bart imagery.
         *
         * @constant
         * @type {Enumeration}
         */
        COLLINS_BART : new Enumeration(4, 'COLLINS_BART', { imagerySetName : 'CollinsBart' })
    };

    return BingMapsStyle;
});
/*global define*/
define('Scene/CameraEventType',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports CameraEventType
     */
    var CameraEventType = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        LEFT_DRAG : new Enumeration(0, 'LEFT_DRAG'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        RIGHT_DRAG : new Enumeration(1, 'RIGHT_DRAG'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        MIDDLE_DRAG : new Enumeration(2, 'MIDDLE_DRAG'),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        WHEEL : new Enumeration(3, 'WHEEL')
    };

    return CameraEventType;
});
/*global define*/
define('Scene/CameraEventHandler',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/Math',
        '../Core/EventHandler',
        '../Core/MouseEventType',
        '../Core/Cartesian2',
        './CameraEventType'
    ], function(
        DeveloperError,
        destroyObject,
        CesiumMath,
        EventHandler,
        MouseEventType,
        Cartesian2,
        CameraEventType) {
    

    /**
     * DOC_TBA
     *
     * @alias CameraEventHandler
     *
     * @param {HTMLCanvasElement} canvas DOC_TBA
     * @param {CameraEventType} moveType DOC_TBA
     * @param {EventModifier} moveModifier DOC_TBA
     *
     * @exception {DeveloperError} canvas is required.
     * @exception {DeveloperError} moveType is required.
     *
     * @constructor
     *
     * @see EventHandler
     */
    var CameraEventHandler = function(canvas, moveType, moveModifier) {
        if (typeof canvas === 'undefined') {
            throw new DeveloperError('description.canvas is required.');
        }

        if (typeof moveType === 'undefined') {
            throw new DeveloperError('moveType is required.');
        }

        this._eventHandler = new EventHandler(canvas);

        this._update = true;
        this._movement = undefined;
        this._lastMovement = undefined;
        this._isDown = false;
        this._pressTime = undefined;
        this._releaseTime = undefined;

        var that = this;

        if (moveType !== CameraEventType.WHEEL) {
            var down;
            var up;
            if (moveType === CameraEventType.LEFT_DRAG) {
                down = MouseEventType.LEFT_DOWN;
                up = MouseEventType.LEFT_UP;
            } else if (moveType === CameraEventType.RIGHT_DRAG) {
                down = MouseEventType.RIGHT_DOWN;
                up = MouseEventType.RIGHT_UP;
            } else if (moveType === CameraEventType.MIDDLE_DRAG) {
                down = MouseEventType.MIDDLE_DOWN;
                up = MouseEventType.MIDDLE_UP;
            } else {
                this._eventHandler = this._eventHandler && this._eventHandler.destroy();
                throw new DeveloperError('moveType must be of type CameraEventType.');
            }

            this._eventHandler.setMouseAction(function(movement) {
                that._lastMovement = null;
                that._isDown = true;
                that._pressTime = new Date();
            }, down, moveModifier);

            this._eventHandler.setMouseAction(function(movement) {
                that._isDown = false;
                that._releaseTime = new Date();
            }, up, moveModifier);

            this._eventHandler.setMouseAction(function(movement) {
                if (that._isDown) {
                    if (!that._update) {
                        that._movement.endPosition = movement.endPosition.clone();
                    } else {
                        that._lastMovement = that._movement;
                        that._movement = movement;
                        that._update = false;
                    }
                }
            }, MouseEventType.MOVE, moveModifier);
        } else {
            this._eventHandler.setMouseAction(function(delta) {
                // TODO: magic numbers
                var arcLength = 2 * CesiumMath.toRadians(delta);
                if (!that._update) {
                    that._movement.endPosition.y = that._movement.endPosition.y + arcLength;
                } else {
                    that._movement = {
                        startPosition : new Cartesian2(0.0, 0.0),
                        endPosition : new Cartesian2(0.0, arcLength),
                        motion : new Cartesian2(0.0, 0.0)
                    };
                    that._lastMovement = that._movement; // This looks unusual, but its needed for wheel inertia.
                    that._update = false;
                }
                that._pressTime = new Date();
                that._releaseTime = new Date(that._pressTime.getTime() + Math.abs(arcLength) * 5.0);
            }, MouseEventType.WHEEL, moveModifier);
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraEventHandler
     *
     * @return {Boolean} DOC_TBA
     */
    CameraEventHandler.prototype.isMoving = function() {
        return !this._update;
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraEventHandler
     *
     * @return {Object} DOC_TBA
     */
    CameraEventHandler.prototype.getMovement = function() {
        var movement = this._movement;
        this._update = true;
        return movement;
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraEventHandler
     *
     * @return {Object} DOC_TBA
     */
    CameraEventHandler.prototype.getLastMovement = function() {
        return this._lastMovement;
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraEventHandler
     *
     * @return {Boolean} DOC_TBA
     *
     */
    CameraEventHandler.prototype.isButtonDown = function() {
        return this._isDown;
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraEventHandler
     *
     * @return {Date} DOC_TBA
     *
     */
    CameraEventHandler.prototype.getButtonPressTime = function() {
        return this._pressTime;
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraEventHandler
     *
     * @return {Date} DOC_TBA
     *
     */
    CameraEventHandler.prototype.getButtonReleaseTime = function() {
        return this._releaseTime;
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof CameraEventHandler
     *
     * @return {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     *
     * @see CameraEventHandler#destroy
     */
    CameraEventHandler.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Removes mouse listeners held by this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof CameraEventHandler
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CameraEventHandler#isDestroyed
     *
     * @example
     * handler = handler && handler.destroy();
     */
    CameraEventHandler.prototype.destroy = function() {
        this._eventHandler = this._eventHandler && this._eventHandler.destroy();
        return destroyObject(this);
    };

    return CameraEventHandler;
});
/*global define*/
define('Scene/CameraFlightController',[
        '../Core/destroyObject',
        '../Core/EventHandler',
        '../Core/MouseEventType',
        '../Core/Quaternion',
        '../Core/Matrix3',
        '../Core/Cartesian3',
        '../Core/HermiteSpline'
    ], function(
        destroyObject,
        EventHandler,
        MouseEventType,
        Quaternion,
        Matrix3,
        Cartesian3,
        HermiteSpline) {
    

    /**
     * A type that defines camera behavior: the camera will follow a path from the
     * current position of the camera to an end point around an ellipsoid.
     *
     * @alias CameraFlightController
     * @internalConstructor
     *
     * @param {HTMLCanvasElement} canvas An HTML canvas element used to listen for user events.
     * @param {Camera} camera The camera to use.
     * @param {Ellipsoid} ellipsoid The ellipsoid to move the camera around.
     * @param {Cartesian} destination The Cartesian point that is the end of the path.
     * @param {Number} duration The time, in seconds, to travel along the path.
     *
     * @see CameraControllerCollection#addFlight
     */
    var CameraFlightController = function(canvas, camera, ellipsoid, destination, duration, complete) {
        // get minimum altitude from which the whole ellipsoid is visible
        var radius = ellipsoid.getRadii().getMaximumComponent();

        var frustum = camera.frustum;
        var near = frustum.near;
        var top = frustum.near * Math.tan(0.5 * frustum.fovy);
        var right = frustum.aspectRatio * top;

        var dx = radius * near / right;
        var dy = radius * near / top;
        var dm = Math.max(dx, dy);
        var altitude = dm - radius;

        this._camera = camera;
        this._start = new Date();
        this._end = new Date(this._start.getTime() + duration * 1000);
        this._path = this._createPath(ellipsoid, altitude, destination, duration);
        this._canceled = false;
        this._complete = complete;

        var that = this;
        var cancelFlight = function() {
            that._canceled = true;
        };

        this._handler = new EventHandler(canvas);
        this._handler.setMouseAction(cancelFlight, MouseEventType.LEFT_DOWN);
        this._handler.setMouseAction(cancelFlight, MouseEventType.RIGHT_DOWN);
        this._handler.setMouseAction(cancelFlight, MouseEventType.MIDDLE_DOWN);
    };

    CameraFlightController.prototype._createPath = function(ellipsoid, altitude, endPoint, duration) {
        var start = this._camera.position;

        var maxStartAlt = ellipsoid.getMaximumRadius() + altitude;
        var dot = start.normalize().dot(endPoint.normalize());

        var abovePercentage, incrementPercentage;
        var startAboveMaxAlt = (start.magnitude() > maxStartAlt);
        if (startAboveMaxAlt) {
            abovePercentage = 0.6;
            incrementPercentage = 0.35;
        } else {
            // TODO: revisit when hi-res imagery is implemented.
            abovePercentage = Math.max(0.1, 1.0 - Math.abs(dot));
            incrementPercentage = 0.5;
        }

        maxStartAlt = ellipsoid.getMaximumRadius() + abovePercentage * altitude;

        var aboveEnd = endPoint.normalize().multiplyByScalar(maxStartAlt);
        var afterStart = start.normalize().multiplyByScalar(maxStartAlt);

        var points, axis, angle, rotation;
        if (start.magnitude() > maxStartAlt && dot > 0) {
            var middle = start.subtract(aboveEnd).multiplyByScalar(0.5).add(aboveEnd);

            points = [{
                point : start
            }, {
                point : middle
            }, {
                point : aboveEnd
            }, {
                point : endPoint
            }];
        } else {
            points = [{
                point : start
            }];

            angle = Math.acos(afterStart.normalize().dot(aboveEnd.normalize()));
            axis = aboveEnd.cross(afterStart);

            var increment = incrementPercentage * angle;
            var startCondition = (startAboveMaxAlt) ? angle - increment : angle;
            for ( var i = startCondition; i > 0.0; i = i - increment) {
                rotation = Matrix3.fromQuaternion(Quaternion.fromAxisAngle(axis, i));
                points.push({
                    point : rotation.multiplyByVector(aboveEnd)
                });
            }

            points.push({
                point : aboveEnd
            }, {
                point : endPoint
            });
        }

        var scalar = duration / (points.length - 1);
        for ( var k = 0; k < points.length; ++k) {
            points[k].time = k * scalar;
        }

        return new HermiteSpline(points);
    };

    /**
     * @private
     */
    CameraFlightController.prototype.update = function() {
        var time = new Date(),
            diff,
            position,
            normal,
            tangent,
            target;

        var now = (time.getTime() > this._end.getTime()) ? this._end : time;

        diff = ( now.getTime() - this._start.getTime()) / 1000.0;
        position = this._path.evaluate(diff);
        normal = Cartesian3.UNIT_Z.cross(position).normalize();
        tangent = position.cross(normal).normalize();
        target = Cartesian3.ZERO;
        this._camera.lookAt(position, target, tangent);

        var isComplete = (now === this._end) || this._canceled;
        if(isComplete && !this._canceled && (typeof this._complete !== 'undefined')){
            this._complete();
        }
        return !isComplete;
    };

    /**
      * Returns true if this object was destroyed; otherwise, false.
      * <br /><br />
      * If this object was destroyed, it should not be used; calling any function other than
      * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
      *
      * @memberof CameraFlightController
      *
      * @return {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
      *
      * @see CameraFlightController#destroy
      */
    CameraFlightController.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Removes mouse listeners held by this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof CameraFlightController
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CameraFlightControllerController#isDestroyed
     *
     * @example
     * controller = controller && controller.destroy();
     */
    CameraFlightController.prototype.destroy = function() {
        this._handler.destroy();
        return destroyObject(this);
    };

    return CameraFlightController;
});
/*global define*/
define('Scene/CameraHelpers',[
        '../Core/Math',
        '../Core/Cartesian2'
    ], function(
        CesiumMath,
        Cartesian2) {
    

    function move(camera, direction, rate) {
        var position = camera.position;
        var newPosition = position.add(direction.multiplyByScalar(rate));
        camera.position = newPosition;
    }

    function decay(time, coefficient) {
        if (time < 0) {
            return 0.0;
        }

        var tau = (1.0 - coefficient) * 25.0;
        return Math.exp(-tau * time);
    }

    function sameMousePosition(movement) {
        return movement.startPosition.equalsEpsilon(movement.endPosition, CesiumMath.EPSILON14);
    }

    // If the time between mouse down and mouse up is not between
    // these thresholds, the camera will not move with inertia.
    // This value is probably dependent on the browser and/or the
    // hardware. Should be investigated further.
    var inertiaMaxClickTimeThreshold = 0.4;
    var inertiaMaxTimeThreshold = 2.0;

    function maintainInertia(handler, decayCoef, action, object, lastMovementName) {
        var ts = handler.getButtonPressTime();
        var tr = handler.getButtonReleaseTime();
        var threshold = ts && tr && ((tr.getTime() - ts.getTime()) / 1000.0);
        var now = new Date();
        var fromNow = tr && ((now.getTime() - tr.getTime()) / 1000.0);
        if (ts && tr && threshold < inertiaMaxClickTimeThreshold && fromNow <= inertiaMaxTimeThreshold) {
            var d = decay(fromNow, decayCoef);

            if (!object[lastMovementName]) {
                var lastMovement = handler.getLastMovement();
                if (!lastMovement || sameMousePosition(lastMovement)) {
                    return;
                }

                var motionX = (lastMovement.endPosition.x - lastMovement.startPosition.x) * 0.5;
                var motionY = (lastMovement.endPosition.y - lastMovement.startPosition.y) * 0.5;
                object[lastMovementName] = {
                    startPosition : new Cartesian2(lastMovement.startPosition.x, lastMovement.startPosition.y),
                    endPosition : new Cartesian2(lastMovement.startPosition.x + motionX * d, lastMovement.startPosition.y + motionY * d),
                    motion : new Cartesian2(motionX, motionY)
                };
            } else {
                object[lastMovementName] = {
                    startPosition : object[lastMovementName].endPosition.clone(),
                    endPosition : new Cartesian2(
                            object[lastMovementName].endPosition.x + object[lastMovementName].motion.x * d,
                            object[lastMovementName].endPosition.y + object[lastMovementName].motion.y * d),
                    motion : new Cartesian2(0.0, 0.0)
                };
            }

            // If value from the decreasing exponential function is close to zero,
            // the end coordinates may be NaN.
            if (isNaN(object[lastMovementName].endPosition.x) || isNaN(object[lastMovementName].endPosition.y) || sameMousePosition(object[lastMovementName])) {
                object[lastMovementName] = undefined;
                return;
            }

            if (!handler.isButtonDown()) {
                action.apply(object, [object[lastMovementName]]);
            }
        } else {
            object[lastMovementName] = undefined;
        }
    }

    /**
     * This function is similar to maintainInertia except that it does not require a handler.
     * Instead, the touch start time, touch release time, and last movement are passed as arguments.
     *
     * @param {Number} touchStartTime The starting time of the movement to create inertia for in milliseconds since 1970/01/01.
     * @param {Number} touchReleaseTime The ending time of the movement to create inertia for in milliseconds since 1970/01/01.
     * @param {Object} lastMovement The movement to create inertia for.
     * @param {Number} decayCoefficient
     * @param {Function} action
     * @param {Object} object
     * @param {String} lastMovementName
     */
    function createInertia(touchStartTime, touchReleaseTime, lastMovement, decayCoefficient, action, object, lastMovementName) {
        var ts = touchStartTime;
        var tr = touchReleaseTime;
        var threshold = ts && tr && ((tr - ts) / 1000.0);
        var now = new Date();
        var fromNow = tr && ((now.getTime() - tr) / 1000.0);
        if (ts && tr && threshold < inertiaMaxClickTimeThreshold && fromNow <= inertiaMaxTimeThreshold) {
            var d = decay(fromNow, decayCoefficient);

            if (!object[lastMovementName]) {
                if (!lastMovement) {
                    return;
                }

                var motionX = (lastMovement.endPosition.x - lastMovement.startPosition.x) * 0.5;
                var motionY = (lastMovement.endPosition.y - lastMovement.startPosition.y) * 0.5;
                object[lastMovementName] = {
                    startPosition : new Cartesian2(lastMovement.startPosition.x, lastMovement.startPosition.y),
                    endPosition : new Cartesian2(lastMovement.startPosition.x + motionX * d, lastMovement.startPosition.y + motionY * d),
                    motion : new Cartesian2(motionX, motionY)
                };
            } else {
                object[lastMovementName] = {
                    startPosition : object[lastMovementName].endPosition.clone(),
                    endPosition : new Cartesian2(
                            object[lastMovementName].endPosition.x + object[lastMovementName].motion.x * d,
                            object[lastMovementName].endPosition.y + object[lastMovementName].motion.y * d),
                    motion : new Cartesian2(0.0, 0.0)
                };
            }

            // If value from the decreasing exponential function is close to zero,
            // the end coordinates may be NaN.
            if (isNaN(object[lastMovementName].endPosition.x) || isNaN(object[lastMovementName].endPosition.y) || sameMousePosition(object[lastMovementName])) {
                object[lastMovementName] = undefined;
                return;
            }

            action.apply(object, [object[lastMovementName]]);
        }
    }

    var maxHeight = 20.0;

    function handleZoom(object, movement, distanceMeasure) {
        // distanceMeasure should be the height above the ellipsoid.
        // The zoomRate slows as it approaches the surface and stops maxHeight above it.
        var zoomRate = object._zoomFactor * (distanceMeasure - maxHeight);

        if (zoomRate > object._maximumZoomRate) {
            zoomRate = object._maximumZoomRate;
        }

        var diff = movement.endPosition.y - movement.startPosition.y;
        if (diff === 0) {
            return;
        }

        var rangeWindowRatio = diff / object._canvas.clientHeight;
        var dist = zoomRate * rangeWindowRatio;

        if (dist > 0.0 && Math.abs(distanceMeasure - maxHeight) < 1.0) {
            return;
        }

        if (distanceMeasure - dist < maxHeight) {
            dist = distanceMeasure - maxHeight - 1.0;
        }

        if (dist > 0.0) {
            object.zoomIn(dist);
        } else {
            object.zoomOut(-dist);
        }
    }

    function zoom(camera, rate) {
        move(camera, camera.direction, rate);
    }

    return {
        move : move,
        maxHeight : maxHeight,
        handleZoom : handleZoom,
        maintainInertia : maintainInertia,
        createInertia : createInertia,
        zoom : zoom
    };
});
/*global define*/
define('Scene/CameraFreeLookController',[
        '../Core/destroyObject',
        '../Core/Math',
        '../Core/EventModifier',
        '../Core/Quaternion',
        '../Core/Cartesian2',
        '../Core/Cartesian3',
        '../Core/Matrix3',
        './CameraEventHandler',
        './CameraEventType',
        './CameraHelpers'
    ], function(
        destroyObject,
        CesiumMath,
        EventModifier,
        Quaternion,
        Cartesian2,
        Cartesian3,
        Matrix3,
        CameraEventHandler,
        CameraEventType,
        CameraHelpers) {
    

    var move = CameraHelpers.move;

    /**
     * A type that defines camera behavior: movement of the position in the direction
     * of the camera's axes and rotation of the axes keeping the position stationary.
     *
     * @alias CameraFreeLookController
     *
     * @param {HTMLCanvasElement} canvas An HTML canvas element used for its dimensions
     * and for listening on user events.
     * @param {Camera} camera The camera to use.
     *
     * @internalConstructor
     */
    var CameraFreeLookController = function(canvas, camera) {
        this._canvas = canvas;
        this._camera = camera;
        this._handler = new CameraEventHandler(canvas, CameraEventType.LEFT_DRAG, EventModifier.SHIFT);

        this._maximumMoveRate = 2000000.0;
        this._minimumMoveRate = 1.0 / 5000.0;
        this._maximumTurnRate = Math.PI / 8.0;
        this._minimumTurnRate = Math.PI / 120.0;

        this._moveRate = 100000.0;
        this._turnRate = Math.PI / 60.0;

        /**
         * DOC_TBD
         */
        this.horizontalRotationAxis = undefined;
    };

    /**
     * Translates the camera's position by <code>rate</code> along the camera's view vector.
     *
     * @memberof CameraFreeLookController
     *
     * @param {Number} rate The rate to move.
     *
     * @see CameraFreeLookController#moveBackward
     */
    CameraFreeLookController.prototype.moveForward = function(rate) {
        move(this._camera, this._camera.direction, rate || this._moveRate);
    };

    /**
     * Translates the camera's position by <code>rate</code> along the opposite direction
     * of the camera's view vector.
     *
     * @memberof CameraFreeLookController
     *
     * @param {Number} rate The rate to move.
     *
     * @see CameraFreeLookController#moveForward
     */
    CameraFreeLookController.prototype.moveBackward = function(rate) {
        move(this._camera, this._camera.direction, -rate || -this._moveRate);
    };

    /**
     * Translates the camera's position by <code>rate</code> along the camera's up vector.
     *
     * @memberof CameraFreeLookController
     *
     * @param {Number} rate The rate to move.
     *
     * @see CameraFreeLookController#moveDown
     */
    CameraFreeLookController.prototype.moveUp = function(rate) {
        move(this._camera, this._camera.up, rate || this._moveRate);
    };

    /**
     * Translates the camera's position by <code>rate</code> along the opposite direction
     * of the camera's up vector.
     *
     * @memberof CameraFreeLookController
     *
     * @param {Number} rate The rate to move.
     *
     * @see CameraFreeLookController#moveUp
     */
    CameraFreeLookController.prototype.moveDown = function(rate) {
        move(this._camera, this._camera.up, -rate || -this._moveRate);
    };

    /**
     * Translates the camera's position by <code>rate</code> along the camera's right vector.
     *
     * @memberof CameraFreeLookController
     *
     * @param {Number} rate The rate to move.
     *
     * @see CameraFreeLookController#moveLeft
     */
    CameraFreeLookController.prototype.moveRight = function(rate) {
        move(this._camera, this._camera.right, rate || this._moveRate);
    };

    /**
     * Translates the camera's position by <code>rate</code> along the opposite direction
     * of the camera's right vector.
     *
     * @memberof CameraFreeLookController
     *
     * @param {Number} rate The rate to move.
     *
     * @see CameraFreeLookController#moveRight
     */
    CameraFreeLookController.prototype.moveLeft = function(rate) {
        move(this._camera, this._camera.right, -rate || -this._moveRate);
    };

    /**
     * Rotates the camera around its up vector by rate, in radians, in the opposite direction
     * of its right vector.
     *
     * @memberof CameraFreeLookController
     *
     * @param {Number} rate The rate, in radians, to rotate by.
     *
     * @see CameraFreeLookController#lookRight
     */
    CameraFreeLookController.prototype.lookLeft = function(rate) {
        var turnRate = rate || this._turnRate;
        var rotated = this._rotateTwoAxes(this._camera.direction, this._camera.right, this._camera.up, turnRate);
        this._camera.direction = rotated[0];
        this._camera.right = rotated[1];
    };

    /**
     * Rotates the camera around its up vector by rate, in radians, in the direction
     * of its right vector.
     *
     * @memberof CameraFreeLookController
     *
     * @param {Number} rate The rate, in radians, to rotate by.
     *
     * @see CameraFreeLookController#lookLeft
     */
    CameraFreeLookController.prototype.lookRight = function(rate) {
        this.lookLeft(-rate || -this._turnRate);
    };

    /**
     * Rotates the camera around its right vector by rate, in radians, in the direction
     * of its up vector.
     *
     * @memberof CameraFreeLookController
     *
     * @param {Number} rate The rate, in radians, to rotate by.
     *
     * @see CameraFreeLookController#lookDown
     */
    CameraFreeLookController.prototype.lookUp = function(rate) {
        var turnRate = rate || this._turnRate;
        var rotated = this._rotateTwoAxes(this._camera.direction, this._camera.up, this._camera.right, turnRate);
        this._camera.direction = rotated[0];
        this._camera.up = rotated[1];
    };

    /**
     * Rotates the camera around its right vector by rate, in radians, in the opposite direction
     * of its up vector.
     *
     * @memberof CameraFreeLookController
     *
     * @param {Number} rate The rate, in radians, to rotate by.
     *
     * @see CameraFreeLookController#lookUp
     */
    CameraFreeLookController.prototype.lookDown = function(rate) {
        this.lookUp(-rate || -this._turnRate);
    };

    CameraFreeLookController.prototype._rotateTwoAxes = function(v0, v1, axis, angle) {
        var rotation = Matrix3.fromQuaternion(Quaternion.fromAxisAngle(axis, angle));
        var u0 = rotation.multiplyByVector(v0);
        var u1 = rotation.multiplyByVector(v1);
        return [u0, u1];
    };

    /**
     * Rotate each of the camera's orientation vectors around <code>axis</code> by <code>angle</code>
     *
     * @memberof CameraFreeLookController
     *
     * @param {Cartesian3} axis The axis to rotate around.
     * @param {Number} angle The angle, in radians, to rotate by.
     *
     * @see CameraFreeLookController#lookUp
     * @see CameraFreeLookController#lookDown
     * @see CameraFreeLookController#lookLeft
     * @see CameraFreeLookController#lookRight
     */
    CameraFreeLookController.prototype.rotate = function(axis, angle) {
        var a = Cartesian3.clone(axis);
        var turnAngle = angle || this._moveRate;
        var rotation = Matrix3.fromQuaternion(Quaternion.fromAxisAngle(a, turnAngle));
        var direction = rotation.multiplyByVector(this._camera.direction);
        var up = rotation.multiplyByVector(this._camera.up);
        var right = rotation.multiplyByVector(this._camera.right);
        this._camera.direction = direction;
        this._camera.up = up;
        this._camera.right = right;
    };

    /**
     * @private
     */
    CameraFreeLookController.prototype.update = function(time) {
        if (this._handler.isMoving()) {
            this._look(this._handler.getMovement());
        }

        return true;
    };

    CameraFreeLookController.prototype._look = function(movement) {
        var camera = this._camera;

        var width = this._canvas.clientWidth;
        var height = this._canvas.clientHeight;

        var tanPhi = Math.tan(camera.frustum.fovy * 0.5);
        var tanTheta = camera.frustum.aspectRatio * tanPhi;
        var near = camera.frustum.near;

        var startNDC = new Cartesian2((2.0 / width) * movement.startPosition.x - 1.0, (2.0 / height) * (height - movement.startPosition.y) - 1.0);
        var endNDC = new Cartesian2((2.0 / width) * movement.endPosition.x - 1.0, (2.0 / height) * (height - movement.endPosition.y) - 1.0);

        var nearCenter = camera.position.add(camera.direction.multiplyByScalar(near));

        var startX = camera.right.multiplyByScalar(startNDC.x * near * tanTheta);
        startX = nearCenter.add(startX).subtract(camera.position).normalize();
        var endX = camera.right.multiplyByScalar(endNDC.x * near * tanTheta);
        endX = nearCenter.add(endX).subtract(camera.position).normalize();

        var dot = startX.dot(endX);
        var angle = 0.0;
        var axis = (typeof this.horizontalRotationAxis !== 'undefined') ? this.horizontalRotationAxis : camera.up;
        axis = (movement.startPosition.x > movement.endPosition.x) ? axis : axis.negate();
        axis = axis.normalize();
        if (dot < 1.0) { // dot is in [0, 1]
            angle = -Math.acos(dot);
        }
        var rotation = Matrix3.fromQuaternion(Quaternion.fromAxisAngle(axis, angle));

        if (1.0 - Math.abs(camera.direction.dot(axis)) > CesiumMath.EPSILON6) {
            camera.direction = rotation.multiplyByVector(camera.direction);
        }

        if (1.0 - Math.abs(camera.up.dot(axis)) > CesiumMath.EPSILON6) {
            camera.up = rotation.multiplyByVector(camera.up);
        }

        var startY = camera.up.multiplyByScalar(startNDC.y * near * tanPhi);
        startY = nearCenter.add(startY).subtract(camera.position).normalize();
        var endY = camera.up.multiplyByScalar(endNDC.y * near * tanPhi);
        endY = nearCenter.add(endY).subtract(camera.position).normalize();

        dot = startY.dot(endY);
        angle = 0.0;
        axis = startY.cross(endY);
        if (dot < 1.0 && !axis.equalsEpsilon(Cartesian3.ZERO, CesiumMath.EPSILON14)) { // dot is in [0, 1]
            angle = -Math.acos(dot);
        } else { // no rotation
            axis = Cartesian3.UNIT_X;
        }
        rotation = Matrix3.fromQuaternion(Quaternion.fromAxisAngle(axis, angle));

        if (1.0 - Math.abs(camera.direction.dot(axis)) > CesiumMath.EPSILON6) {
            camera.direction = rotation.multiplyByVector(camera.direction);
        }

        if (1.0 - Math.abs(camera.up.dot(axis)) > CesiumMath.EPSILON6) {
            camera.up = rotation.multiplyByVector(camera.up);
        }

        camera.right = camera.direction.cross(camera.up);
    };

    /**
      * Returns true if this object was destroyed; otherwise, false.
      * <br /><br />
      * If this object was destroyed, it should not be used; calling any function other than
      * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
      *
      * @memberof CameraFreeLookController
      *
      * @return {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
      *
      * @see CameraFreeLookController#destroy
      */
    CameraFreeLookController.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Removes mouse listeners held by this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof CameraFreeLookController
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CameraFreeLookController#isDestroyed
     *
     * @example
     * controller = controller && controller.destroy();
     */
    CameraFreeLookController.prototype.destroy = function() {
        this._handler = this._handler && this._handler.destroy();
        return destroyObject(this);
    };

    return CameraFreeLookController;
});
/*global define*/
define('Scene/CameraSpindleControllerMode',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * This enumerated type is for describing how the <code>CameraSpindleController</code>
     * will handle mouse events.
     *
     * @exports CameraSpindleControllerMode
     *
     * @see {CameraSpindleController#mode}
     */
    var CameraSpindleControllerMode = {
        /**
         * This mode is useful for rotating around arbitrary ellipsoids.
         *
         * @constant
         * @type {Enumeration}
         */
        ROTATE : new Enumeration(0, 'ROTATE'),

        /**
         * This mode will cause the controller to rotate around an ellipsoid such that
         * the point under the mouse cursor will remain there when dragged. This mode can only
         * be used for larger ellipsoids like the WGS84 ellipsoid.
         *
         * @constant
         * @type {Enumeration}
         */
        PAN : new Enumeration(1, 'PAN'),

        /**
         * This mode will choose the best mode for the mouse input.
         *
         * @constant
         * @type {Enumeration}
         */
        AUTO : new Enumeration(2, 'AUTO')
    };

    return CameraSpindleControllerMode;
});
/*global define*/
define('Scene/CameraSpindleController',[
        '../Core/destroyObject',
        '../Core/FAR',
        '../Core/Math',
        '../Core/Quaternion',
        '../Core/Matrix3',
        '../Core/Ellipsoid',
        '../Core/Cartesian3',
        '../Core/Cartesian4',
        './CameraEventHandler',
        './CameraEventType',
        './CameraSpindleControllerMode',
        './CameraHelpers'
    ], function(
        destroyObject,
        FAR,
        CesiumMath,
        Quaternion,
        Matrix3,
        Ellipsoid,
        Cartesian3,
        Cartesian4,
        CameraEventHandler,
        CameraEventType,
        CameraSpindleControllerMode,
        CameraHelpers) {
    

    var handleZoom = CameraHelpers.handleZoom;
    var maintainInertia = CameraHelpers.maintainInertia;
    var zoom = CameraHelpers.zoom;

    /**
     * A type that defines camera behavior: the camera's position and axes will be rotated around the center
     * of the camera's reference frame.
     *
     * @alias CameraSpindleController
     *
     * @param {HTMLCanvasElement} canvas An HTML canvas element used for its dimensions
     * and for listening on user events.
     * @param {Camera} camera The camera to use.
     * @param {Ellipsoid} [ellipsoid=WGS84 Ellipsoid] The ellipsoid to move around.
     *
     * @internalConstructor
     */
    var CameraSpindleController = function(canvas, camera, ellipsoid) {
        ellipsoid = ellipsoid || Ellipsoid.WGS84;

        this._canvas = canvas;
        this._camera = camera;
        this._ellipsoid = ellipsoid;
        this._zoomRate = 100000.0;
        this._moveRate = Math.PI / 3600.0;

        /**
         * A parameter in the range <code>[0, 1]</code> used to determine how long
         * the camera will continue to spin because of inertia.
         * With a value of one, the camera will spin forever and
         * with value of zero, the camera will have no inertia.
         *
         * @type Number
         */
        this.inertiaSpin = 0.9;

        /**
         * A parameter in the range <code>[0, 1)</code> used to determine how long
         * the camera will continue to zoom because of inertia.
         * With value of zero, the camera will have no inertia.
         *
         * @type Number
         */
        this.inertiaZoom = 0.8;

        /**
         * If set, the camera will not be able to rotate past this axis in either direction.
         * If this is set while in pan mode, the position clicked on the ellipsoid
         * will not always map directly to the cursor.
         *
         * @type Cartesian3
         *
         * @see CameraSpindleController#mode
         */
        this.constrainedAxis = undefined;

        /**
         * Determines the rotation behavior on mouse events.
         *
         * @type CameraSpindleControllerMode
         */
        this.mode = CameraSpindleControllerMode.AUTO;

        var radius = this._ellipsoid.getRadii().getMaximumComponent();
        this._zoomFactor = 5.0;
        this._minimumZoomRate = 20.0;
        this._maximumZoomRate = FAR;
        this._rotateFactor = 1.0 / radius;
        this._rotateRateRangeAdjustment = radius;
        this._maximumRotateRate = 1.77;
        this._minimumRotateRate = 1.0 / 5000.0;

        this._spinHandler = new CameraEventHandler(canvas, CameraEventType.LEFT_DRAG);
        this._zoomHandler = new CameraEventHandler(canvas, CameraEventType.RIGHT_DRAG);
        this._zoomWheel = new CameraEventHandler(canvas, CameraEventType.WHEEL);

        this._lastInertiaSpinMovement = undefined;
        this._lastInertiaZoomMovement = undefined;
        this._lastInertiaWheelZoomMovement = undefined;
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraSpindleController
     *
     * @param {Matrix4} transform DOC_TBA
     * @param {Ellipsoid} [ellipsoid=WGS84 Ellipsoid] DOC_TBA
     *
     * @example
     * // Example 1.
     * // Change the reference frame to one centered at a point on the ellipsoid's surface.
     * // Set the spindle controller's ellipsoid to a unit sphere for easy rotation around that point.
     * var center = ellipsoid.cartographicToCartesian(Cartographic.fromDegrees(-75.59777, 40.03883));
     * var transform = Transforms.eastNorthUpToFixedFrame(center);
     * scene.getCamera().getControllers().get(0).setReferenceFrame(transform, Ellipsoid.UNIT_SPHERE);
     *
     * // Example 2.
     * // Reset to the defaults.
     * scene.getCamera().getControllers().get(0).setReferenceFrame(Matrix4.IDENTITY);
     *
     */
    CameraSpindleController.prototype.setReferenceFrame = function (transform, ellipsoid) {
        this._camera.transform = transform;
        this.setEllipsoid(ellipsoid);
    };

    /**
     * Returns the ellipsoid that the camera is moving around.
     *
     * @memberof CameraSpindleController
     *
     * @returns {Ellipsoid} The ellipsoid that the camera is moving around.
     *
     * @see CameraSpindleController#setEllipsoid
     */
    CameraSpindleController.prototype.getEllipsoid = function() {
        return this._ellipsoid;
    };

    /**
     * Sets the ellipsoid that the camera is moving around.
     *
     * @memberof CameraSpindleController
     *
     * @param {Ellipsoid} [ellipsoid=WGS84 Ellipsoid] The ellipsoid that the camera is moving around.
     *
     * @see CameraSpindleController#getEllipsoid
     */
    CameraSpindleController.prototype.setEllipsoid = function(ellipsoid) {
        ellipsoid = ellipsoid || Ellipsoid.WGS84;

        var radius = ellipsoid.getRadii().getMaximumComponent();
        this._ellipsoid = ellipsoid;
        this._rotateFactor = 1.0 / radius;
        this._rotateRateRangeAdjustment = radius;
    };

    /**
     * Rotates the camera around <code>axis</code> by <code>angle</code>. The distance
     * of the camera's position to the center of the camera's reference frame remains the same.
     *
     * @memberof CameraSpindleController
     *
     * @param {Cartesian3} axis The axis to rotate around given in world coordinates.
     * @param {Number} angle The angle, in radians, to rotate by. The direction of rotation is
     * determined by the sign of the angle.
     *
     * @see CameraSpindleController#moveUp
     * @see CameraSpindleController#moveDown
     * @see CameraSpindleController#moveLeft
     * @see CameraSpindleController#moveRight
    */
    CameraSpindleController.prototype.rotate = function(axis, angle) {
        var a = Cartesian3.clone(axis);
        var turnAngle = (typeof angle !== 'undefined') ? angle : this._moveRate;
        var rotation = Matrix3.fromQuaternion(Quaternion.fromAxisAngle(a, turnAngle));

        var camera = this._camera;
        camera.position = rotation.multiplyByVector(camera.position);
        camera.direction = rotation.multiplyByVector(camera.direction);
        camera.up = rotation.multiplyByVector(camera.up);
        camera.right = camera.direction.cross(camera.up);
    };

    /**
     * Rotates the camera around the center of the camera's reference frame by angle downwards.
     *
     * @memberof CameraSpindleController
     *
     * @param {Number} angle The angle to rotate in radians.
     *
     * @see CameraSpindleController#moveUp
     * @see CameraSpindleController#rotate
     */
    CameraSpindleController.prototype.moveDown = function(angle) {
        angle = (typeof angle !== 'undefined') ? -angle : -this._moveRate;
        this._moveVertical(angle);
    };

    /**
     * Rotates the camera around the center of the camera's reference frame by angle upwards.
     *
     * @memberof CameraSpindleController
     *
     * @param {Number} angle The angle to rotate in radians.
     *
     * @see CameraSpindleController#moveDown
     * @see CameraSpindleController#rotate
     */
    CameraSpindleController.prototype.moveUp = function(angle) {
        angle = (typeof angle !== 'undefined') ? angle : this._moveRate;
        this._moveVertical(angle);
    };

    CameraSpindleController.prototype._moveVertical = function(angle) {
        if (typeof this.constrainedAxis !== 'undefined') {
            var p = this._camera.position.normalize();
            var dot = p.dot(this.constrainedAxis.normalize());
            if (CesiumMath.equalsEpsilon(1.0, Math.abs(dot), CesiumMath.EPSILON3) && dot * angle < 0.0) {
                return;
            }

            var angleToAxis = Math.acos(dot);
            if (Math.abs(angle) > Math.abs(angleToAxis)) {
                angle = angleToAxis;
            }

            var tangent = this.constrainedAxis.cross(p).normalize();
            var bitangent = this._camera.up.cross(tangent);
            tangent = bitangent.cross(this._camera.up);
            this.rotate(tangent, angle);
        } else {
            this.rotate(this._camera.right, angle);
        }
    };

    /**
     * Rotates the camera around the center of the camera's reference frame by angle to the right.
     *
     * @memberof CameraSpindleController
     *
     * @param {Number} angle The angle to rotate in radians.
     *
     * @see CameraSpindleController#moveLeft
     * @see CameraSpindleController#rotate
     */
    CameraSpindleController.prototype.moveRight = function(angle) {
        angle = (typeof angle !== 'undefined') ? angle : this._moveRate;
        this._moveHorizontal(angle);
    };

    /**
     * Rotates the camera around the center of the camera's reference frame by angle to the left.
     *
     * @memberof CameraSpindleController
     *
     * @param {Number} angle The angle to rotate in radians.
     *
     * @see CameraSpindleController#moveRight
     * @see CameraSpindleController#rotate
     */
    CameraSpindleController.prototype.moveLeft = function(angle) {
        angle = (typeof angle !== 'undefined') ? -angle : -this._moveRate;
        this._moveHorizontal(angle);
    };

    CameraSpindleController.prototype._moveHorizontal = function(angle) {
        if (typeof this.constrainedAxis !== 'undefined') {
            this.rotate(this.constrainedAxis.normalize(), angle);
        } else {
            this.rotate(this._camera.up, angle);
        }
    };

    /**
     * Translates the camera's position by <code>rate</code> along the camera's view vector.
     *
     * @memberof CameraSpindleController
     *
     * @param {Number} rate The rate to move.
     *
     * @see CameraSpindleController#zoomOut
     */
    CameraSpindleController.prototype.zoomIn = function(rate) {
        zoom(this._camera, (typeof rate !== 'undefined') ? rate : this._zoomRate);
    };

    /**
     * Translates the camera's position by <code>rate</code> along the opposite direction of
     * the camera's view vector.
     *
     * @memberof CameraSpindleController
     *
     * @param {Number} rate The rate to move.
     *
     * @see CameraSpindleController#zoomIn
     */
    CameraSpindleController.prototype.zoomOut = function(rate) {
        zoom(this._camera, (typeof rate !== 'undefined') ? -rate : -this._zoomRate);
    };

    /**
     * @private
     */
    CameraSpindleController.prototype.update = function() {
        var spin = this._spinHandler;
        var rightZoom = this._zoomHandler;
        var wheelZoom = this._zoomWheel;
        var rotating = spin && spin.isMoving() && spin.getMovement();
        var rightZooming = rightZoom && rightZoom.isMoving();
        var wheelZooming = wheelZoom && wheelZoom.isMoving();

        if (rotating) {
            this._spin(spin.getMovement());
        }

        if (spin && !rotating && this.inertiaSpin < 1.0) {
            maintainInertia(spin, this.inertiaSpin, this._spin, this, '_lastInertiaSpinMovement');
        }

        if (rightZooming) {
            this._zoom(rightZoom.getMovement());
        } else if (wheelZooming) {
            this._zoom(wheelZoom.getMovement());
        }

        if (rightZoom && !rightZooming && this.inertiaZoom < 1.0) {
            maintainInertia(rightZoom, this.inertiaZoom, this._zoom, this, '_lastInertiaZoomMovement');
        }

        if (wheelZoom && !wheelZooming && this.inertiaZoom < 1.0) {
            maintainInertia(wheelZoom, this.inertiaZoom, this._zoom, this, '_lastInertiaWheelZoomMovement');
        }

        return true;
    };

    CameraSpindleController.prototype._spin = function(movement) {
        if (this.mode === CameraSpindleControllerMode.AUTO) {
            if (typeof this._camera.pickEllipsoid(movement.startPosition, this._ellipsoid) !== 'undefined') {
                this._pan(movement);
            } else {
                this._rotate(movement);
            }
        } else if (this.mode === CameraSpindleControllerMode.ROTATE) {
            this._rotate(movement);
        } else {
            this._pan(movement);
        }
    };

    CameraSpindleController.prototype._rotate = function(movement) {
        var position = this._camera.position;
        var rho = position.magnitude();
        var rotateRate = this._rotateFactor * (rho - this._rotateRateRangeAdjustment);

        if (rotateRate > this._maximumRotateRate) {
            rotateRate = this._maximumRotateRate;
        }

        if (rotateRate < this._minimumRotateRate) {
            rotateRate = this._minimumRotateRate;
        }

        var phiWindowRatio = (movement.endPosition.x - movement.startPosition.x) / this._canvas.clientWidth;
        var thetaWindowRatio = (movement.endPosition.y - movement.startPosition.y) / this._canvas.clientHeight;

        var deltaPhi = -rotateRate * phiWindowRatio * Math.PI * 2.0;
        var deltaTheta = -rotateRate * thetaWindowRatio * Math.PI;

        this._moveHorizontal(deltaPhi);
        this._moveVertical(deltaTheta);
    };

    CameraSpindleController.prototype._pan = function(movement) {
        var camera = this._camera;
        var p0 = camera.pickEllipsoid(movement.startPosition, this._ellipsoid);
        var p1 = camera.pickEllipsoid(movement.endPosition, this._ellipsoid);

        if (typeof p0 === 'undefined' || typeof p1 === 'undefined') {
            return;
        }

        var transform = camera.getInverseTransform();
        p0 = Cartesian3.fromCartesian4(transform.multiplyByVector(new Cartesian4(p0.x, p0.y, p0.z, 1.0)));
        p1 = Cartesian3.fromCartesian4(transform.multiplyByVector(new Cartesian4(p1.x, p1.y, p1.z, 1.0)));

        if (typeof this.constrainedAxis === 'undefined') {
            p0 = p0.normalize();
            p1 = p1.normalize();
            var dot = p0.dot(p1);
            var axis = p0.cross(p1);

            if (dot < 1.0 && !axis.equalsEpsilon(Cartesian3.ZERO, CesiumMath.EPSILON14)) { // dot is in [0, 1]
                var angle = -Math.acos(dot);
                this.rotate(axis, angle);
            }
        } else {
            var startRho = p0.magnitude();
            var startPhi = Math.atan2(p0.y, p0.x);
            var startTheta = Math.acos(p0.z / startRho);

            var endRho = p1.magnitude();
            var endPhi = Math.atan2(p1.y, p1.x);
            var endTheta = Math.acos(p1.z / endRho);

            var deltaPhi = startPhi - endPhi;
            var deltaTheta = startTheta - endTheta;

            var theta = Math.acos(camera.position.z / camera.position.magnitude()) + deltaTheta;
            if (theta < 0 || theta > Math.PI) {
                deltaTheta = 0;
            }

            this._moveHorizontal(deltaPhi);
            this._moveVertical(deltaTheta);
        }
    };

    CameraSpindleController.prototype._zoom = function(movement) {
        handleZoom(this, movement, this._ellipsoid.cartesianToCartographic(this._camera.position).height);
    };

   /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof CameraSpindleController
     *
     * @return {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     *
     * @see CameraSpindleController#destroy
     */
    CameraSpindleController.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Removes mouse and keyboard listeners held by this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof CameraSpindleController
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CameraSpindleController#isDestroyed
     *
     * @example
     * controller = controller && controller.destroy();
     */
    CameraSpindleController.prototype.destroy = function() {
        this._spinHandler = this._spinHandler && this._spinHandler.destroy();
        this._zoomHandler = this._zoomHandler && this._zoomHandler.destroy();
        this._zoomWheel = this._zoomWheel && this._zoomWheel.destroy();
        return destroyObject(this);
    };

    return CameraSpindleController;
});
/*global define*/
define('Scene/CameraCentralBodyController',[
        '../Core/destroyObject',
        '../Core/Ellipsoid',
        '../Core/Cartesian3',
        '../Core/Cartesian4',
        '../Core/IntersectionTests',
        '../Core/Math',
        '../Core/Matrix4',
        '../Core/Ray',
        '../Core/Transforms',
        './CameraEventHandler',
        './CameraEventType',
        './CameraSpindleController',
        './CameraFreeLookController',
        './CameraHelpers'
    ], function(
        destroyObject,
        Ellipsoid,
        Cartesian3,
        Cartesian4,
        IntersectionTests,
        CesiumMath,
        Matrix4,
        Ray,
        Transforms,
        CameraEventHandler,
        CameraEventType,
        CameraSpindleController,
        CameraFreeLookController,
        CameraHelpers) {
    

    var maxHeight = CameraHelpers.maxHeight;

    /**
     * Defines camera movement and handles mouse events that move the camera. Moves the camera
     * position around the center of an ellipsoid or a point on the surface. Also, moves the camera viewing
     * direction.
     *
     * @alias CameraCentralBodyController
     *
     * @param {HTMLCanvasElement} canvas An HTML canvas element used for its dimensions
     * and for listening on user events.
     * @param {Camera} camera The camera to use.
     * @param {Ellipsoid} ellipsoid The ellipsoid to move around.
     *
     * @internalConstructor
     *
     * @see CameraSpindleController
     * @see CameraFreeLookController
     */
    var CameraCentralBodyController = function(canvas, camera, ellipsoid) {
        this._canvas = canvas;
        this._camera = camera;
        this._rotateHandler = new CameraEventHandler(canvas, CameraEventType.MIDDLE_DRAG);

        /**
         * Rotates the camera's position and axes around the center of the ellipsoid.
         *
         * @type {CameraSpindleController}
         */
        this.spindleController = new CameraSpindleController(canvas, camera, ellipsoid);

        /**
         * Rotates the view direction about the camera's other axes. The camera's position is stationary.
         *
         * @type {CameraFreeLookController}
         */
        this.freeLookController = new CameraFreeLookController(canvas, camera);
    };

    /**
     * @private
     */
    CameraCentralBodyController.prototype.update = function() {
        var rotate = this._rotateHandler;
        var rotating = rotate.isMoving() && rotate.getMovement();

        if (rotating) {
            this._rotate(rotate.getMovement());
        }

        this.spindleController.update();
        this.freeLookController.update();

        return true;
    };

    CameraCentralBodyController.prototype._rotate = function(movement) {
        var camera = this._camera;

        var ellipsoid = this.spindleController.getEllipsoid();
        var position = camera.position;
        if (ellipsoid.cartesianToCartographic(position).height - maxHeight - 1.0 < CesiumMath.EPSILON3 &&
                movement.endPosition.y - movement.startPosition.y < 0) {
            return;
        }

        var up = camera.up;
        var right = camera.right;
        var direction = camera.direction;

        var oldTransform = camera.transform;
        var oldEllipsoid = this.spindleController.getEllipsoid();
        var oldConstrainedZ = this.spindleController.constrainedAxis;

        var ray = new Ray(this._camera.getPositionWC(), this._camera.getDirectionWC());
        var intersection = IntersectionTests.rayEllipsoid(ray, this.spindleController.getEllipsoid());
        if (typeof intersection === 'undefined') {
            return;
        }

        var center = ray.getPoint(intersection.start);
        center = Cartesian3.fromCartesian4(camera.getInverseTransform().multiplyByVector(new Cartesian4(center.x, center.y, center.z, 1.0)));
        var localTransform = Transforms.eastNorthUpToFixedFrame(center);
        var transform = localTransform.multiply(oldTransform);

        this.spindleController.constrainedAxis = Cartesian3.UNIT_Z;
        this.spindleController.setReferenceFrame(transform, Ellipsoid.UNIT_SPHERE);

        var invTransform = camera.getInverseTransform();
        camera.position = Cartesian3.fromCartesian4(invTransform.multiplyByVector(new Cartesian4(position.x, position.y, position.z, 1.0)));
        camera.up = Cartesian3.fromCartesian4(invTransform.multiplyByVector(new Cartesian4(up.x, up.y, up.z, 0.0)));
        camera.right = Cartesian3.fromCartesian4(invTransform.multiplyByVector(new Cartesian4(right.x, right.y, right.z, 0.0)));
        camera.direction = Cartesian3.fromCartesian4(invTransform.multiplyByVector(new Cartesian4(direction.x, direction.y, direction.z, 0.0)));

        this.spindleController._rotate(movement);

        position = camera.position;
        up = camera.up;
        right = camera.right;
        direction = camera.direction;

        this.spindleController.constrainedAxis = oldConstrainedZ;
        this.spindleController.setReferenceFrame(oldTransform, oldEllipsoid);

        camera.position = Cartesian3.fromCartesian4(transform.multiplyByVector(new Cartesian4(position.x, position.y, position.z, 1.0)));
        camera.up = Cartesian3.fromCartesian4(transform.multiplyByVector(new Cartesian4(up.x, up.y, up.z, 0.0)));
        camera.right = Cartesian3.fromCartesian4(transform.multiplyByVector(new Cartesian4(right.x, right.y, right.z, 0.0)));
        camera.direction = Cartesian3.fromCartesian4(transform.multiplyByVector(new Cartesian4(direction.x, direction.y, direction.z, 0.0)));

        position = ellipsoid.cartesianToCartographic(camera.position);
        if (position.height < maxHeight + 1.0) {
            position.height = maxHeight + 1.0;
            camera.position = ellipsoid.cartographicToCartesian(position);
            camera.direction = Cartesian3.fromCartesian4(transform.getColumn(3).subtract(camera.position)).normalize();
            camera.right = camera.position.negate().cross(camera.direction).normalize();
            camera.up = camera.right.cross(camera.direction);
        }
    };

    /**
      * Returns true if this object was destroyed; otherwise, false.
      * <br /><br />
      * If this object was destroyed, it should not be used; calling any function other than
      * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
      *
      * @memberof CameraCentralBodyController
      *
      * @return {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
      *
      * @see CameraCentralBodyController#destroy
      */
    CameraCentralBodyController.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Removes mouse and keyboard listeners held by this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof CameraCentralBodyController
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CameraCentralBodyController#isDestroyed
     *
     * @example
     * controller = controller && controller.destroy();
     */
    CameraCentralBodyController.prototype.destroy = function() {
        this._rotateHandler = this._rotateHandler && this._rotateHandler.destroy();
        this.spindleController = this.spindleController && this.spindleController.destroy();
        this.freeLookController = this.freeLookController && this.freeLookController.destroy();
        return destroyObject(this);
    };

    return CameraCentralBodyController;
});
/*global define*/
define('Scene/CompositePrimitive',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/createGuid'
    ], function(
        DeveloperError,
        destroyObject,
        createGuid) {
    

    // PERFORMANCE_IDEA: Add hierarchical culling and state sorting.

    /**
     * DOC_TBA
     *
     * @alias CompositePrimitive
     * @constructor
     *
     * @example
     * // Example 1. Add primitives to a composite.
     * var primitives = new CompositePrimitive();
     * primitives.setCentralBody(new CentralBody());
     * primitives.add(billboards);
     * primitives.add(labels);
     *
     * //////////////////////////////////////////////////////////////////
     *
     * // Example 2. Create composites of composites.
     * var children = new CompositePrimitive();
     * children.add(billboards);
     *
     * var parent = new CompositePrimitive();
     * parent.add(children);    // Add composite
     * parent.add(labels);      // Add regular primitive
     */
    var CompositePrimitive = function() {
        this._centralBody = null;
        this._primitives = [];
        this._guid = createGuid();

        /**
         * DOC_TBA
         *
         * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
         *
         * @see CompositePrimitive#destroy
         * @see CompositePrimitive#setCentralBody
         * @see CompositePrimitive#remove
         * @see CompositePrimitive#removeAll
         *
         * @example
         * // Example 1. Primitives are destroyed by default.
         * var primitives = new CompositePrimitive();
         * primitives.add(labels);
         * primitives = primitives.destroy();
         * var b = labels.isDestroyed(); // true
         *
         * //////////////////////////////////////////////////////////////////
         *
         * // Example 2. Do not destroy primitives in a composite.
         * var primitives = new CompositePrimitive();
         * primitives.destroyPrimitives = false;
         * primitives.add(labels);
         * primitives = primitives.destroy();
         * var b = labels.isDestroyed(); // false
         * labels = labels.destroy();    // explicitly destroy
         */
        this.destroyPrimitives = true;

        /**
         * Determines if primitives in this composite will be shown.
         *
         * @type Boolean
         */
        this.show = true;
    };

    /**
     * DOC_TBA
     *
     * @memberof CompositePrimitive
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CompositePrimitive#setCentralBody
     */
    CompositePrimitive.prototype.getCentralBody = function() {
        return this._centralBody;
    };

    /**
     * DOC_TBA
     *
     * Implicitly sets the depth-test ellipsoid.
     *
     * @memberof CompositePrimitive
     *
     * @see CompositePrimitive#depthTestEllipsoid
     * @see CompositePrimitive#getCentralBody
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @example
     * var primitives = new CompositePrimitive();
     * primitives.setCentralBody(new CentralBody());
     */
    CompositePrimitive.prototype.setCentralBody = function(centralBody) {
        this._centralBody = this.destroyPrimitives && this._centralBody && this._centralBody.destroy();
        this._centralBody = centralBody;
    };

    /**
     * DOC_TBA
     *
     * @memberof CompositePrimitive
     *
     * @param {Object} primitive DOC_TBA
     *
     * @exception {DeveloperError} primitive is required.
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CompositePrimitive#add
     *
     * @example
     * primitives.add(billboards);
     * primitives.add(labels);
     */
    CompositePrimitive.prototype.add = function(primitive) {
        if (!primitive) {
            throw new DeveloperError('primitive is required.');
        }

        var external = (primitive._external = primitive._external || {});
        var composites = (external._composites = external._composites || {});
        composites[this._guid] = {
            composite : this
        };

        this._primitives.push(primitive);
    };

    /**
     * DOC_TBA
     *
     * @memberof CompositePrimitive
     *
     * @param {Object} primitive DOC_TBA
     *
     * @return {Boolean} <code>true</code> if the primitive was removed; <code>false</code> if the primitive was not found in the composite.
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CompositePrimitive#removeAll
     *
     * @example
     * primitives.add(p);
     * primitives.remove(p);  // Returns true
     */
    CompositePrimitive.prototype.remove = function(primitive) {
        // PERFORMANCE_IDEA:  We can obviously make this a lot faster.
        if (this.contains(primitive)) {
            var index = this._primitives.indexOf(primitive);
            if (index !== -1) {
                this._primitives.splice(index, 1);

                delete primitive._external._composites[this._guid];

                if (this.destroyPrimitives) {
                    primitive.destroy();
                }

                return true;
            }
            // else ... this is not possible, I swear.
        }

        return false;
    };

    /**
     * DOC_TBA
     *
     * @memberof CompositePrimitive
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CompositePrimitive#remove
     *
     * @example
     * primitives.add(...);
     * primitives.add(...);
     * primitives.removeAll();
     */
    CompositePrimitive.prototype.removeAll = function() {
        if (this.destroyPrimitives) {
            var primitives = this._primitives;
            var length = primitives.length;
            for ( var i = 0; i < length; ++i) {
                primitives[i].destroy();
            }
        }
        this._primitives = [];
    };

    /**
     * DOC_TBA
     *
     * @memberof CompositePrimitive
     *
     * Does not include central body.
     *
     * @param {Object} primitive DOC_TBA
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CompositePrimitive#get
     */
    CompositePrimitive.prototype.contains = function(primitive) {
        return !!(primitive &&
                  primitive._external &&
                  primitive._external._composites &&
                  primitive._external._composites[this._guid]);
    };

    CompositePrimitive.prototype._getPrimitiveIndex = function(primitive) {
        if (!this.contains(primitive)) {
            throw new DeveloperError('primitive is not in this composite.');
        }

        return this._primitives.indexOf(primitive);
    };

    /**
     * DOC_TBA
     *
     * @memberof CompositePrimitive
     *
     * @exception {DeveloperError} primitive is not in this composite.
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CompositePrimitive#bringToFront
     * @see CompositePrimitive#sendBackward
     * @see CompositePrimitive#sendToBack
     * @see CompositePrimitive#addGround
     */
    CompositePrimitive.prototype.bringForward = function(primitive) {
        if (primitive) {
            var index = this._getPrimitiveIndex(primitive);
            var primitives = this._primitives;

            if (index !== primitives.length - 1) {
                var p = primitives[index];
                primitives[index] = primitives[index + 1];
                primitives[index + 1] = p;
            }
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof CompositePrimitive
     *
     * @exception {DeveloperError} primitive is not in this composite.
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CompositePrimitive#bringForward
     * @see CompositePrimitive#sendBackward
     * @see CompositePrimitive#sendToBack
     * @see CompositePrimitive#addGround
     */
    CompositePrimitive.prototype.bringToFront = function(primitive) {
        if (primitive) {
            var index = this._getPrimitiveIndex(primitive);
            var primitives = this._primitives;

            if (index !== primitives.length - 1) {
                // PERFORMANCE_IDEA:  Could be faster
                primitives.splice(index, 1);
                primitives.push(primitive);
            }
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof CompositePrimitive
     *
     * @exception {DeveloperError} primitive is not in this composite.
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CompositePrimitive#sendToBack
     * @see CompositePrimitive#bringForward
     * @see CompositePrimitive#bringToFront
     * @see CompositePrimitive#addGround
     */
    CompositePrimitive.prototype.sendBackward = function(primitive) {
        if (primitive) {
            var index = this._getPrimitiveIndex(primitive);
            var primitives = this._primitives;

            if (index !== 0) {
                var p = primitives[index];
                primitives[index] = primitives[index - 1];
                primitives[index - 1] = p;
            }
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof CompositePrimitive
     *
     * @exception {DeveloperError} primitive is not in this composite.
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CompositePrimitive#sendBackward
     * @see CompositePrimitive#bringForward
     * @see CompositePrimitive#bringToFront
     * @see CompositePrimitive#addGround
     */
    CompositePrimitive.prototype.sendToBack = function(primitive) {
        if (primitive) {
            var index = this._getPrimitiveIndex(primitive);
            var primitives = this._primitives;

            if (index !== 0) {
                // PERFORMANCE_IDEA:  Could be faster
                primitives.splice(index, 1);
                primitives.unshift(primitive);
            }
        }
    };

    /**
     * DOC_TBA
     *
     * The index is based on the order the primitives were added to the composite.
     *
     * @memberof CompositePrimitive
     *
     * @exception {DeveloperError} index is required.
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CompositePrimitive#getLength
     *
     * @example
     * // Toggle the show property of every primitive in the composite -
     * // not recursive on child composites.
     * var len = primitives.getLength();
     * for (var i = 0; i < len; ++i) {
     *   var p = primitives.get(i);
     *   p.show = !p.show;
     * }
     */
    CompositePrimitive.prototype.get = function(index) {
        if (typeof index === 'undefined') {
            throw new DeveloperError('index is required.');
        }

        return this._primitives[index];
    };

    /**
     * DOC_TBA
     *
     * @memberof CompositePrimitive
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CompositePrimitive#get
     *
     * @example
     * // Toggle the show property of every primitive in the composite -
     * // not recursive on child composites.
     * var len = primitives.getLength();
     * for (var i = 0; i < len; ++i) {
     *   var p = primitives.get(i);
     *   p.show = !p.show;
     * }
     */
    CompositePrimitive.prototype.getLength = function() {
        return this._primitives.length;
    };

    /**
     * @private
     */
    CompositePrimitive.prototype.update = function(context, sceneState) {
        if (this.show) {
            if (this._centralBody) {
                this._centralBody.update(context, sceneState);
            }

            var primitives = this._primitives;
            var length = primitives.length;
            for ( var i = 0; i < length; ++i) {
                primitives[i].update(context, sceneState);
            }
        }
    };

    /**
     * DOC_TBA
     * @memberof CompositePrimitive
     */
    CompositePrimitive.prototype.render = function(context) {
        if (this.show) {
            var cb = this._centralBody;
            var primitives = this._primitives;
            var primitivesLen = primitives.length;

            if (cb) {
                cb.render(context);
            }
            for ( var i = 0; i < primitivesLen; ++i) {
                var primitive = primitives[i];
                primitive.render(context);
            }
        }
    };

    /**
     * @private
     */
    CompositePrimitive.prototype.updateForPick = function(context) {
        if (this.show) {
            if (this._centralBody && this._centralBody.updateForPick) {
                this._centralBody.updateForPick(context);
            }

            var primitives = this._primitives;
            var length = primitives.length;
            for ( var i = 0; i < length; ++i) {
                var primitive = primitives[i];
                if (primitive.updateForPick) {
                    primitives[i].updateForPick(context);
                }
            }
        }
    };

    /**
     * DOC_TBA
     * @memberof CompositePrimitive
     */
    CompositePrimitive.prototype.renderForPick = function(context, framebuffer) {
        if (this.show) {
            var cb = this._centralBody;
            var primitives = this._primitives;
            var primitivesLen = primitives.length;

            if (cb) {
                cb.renderForPick(context, framebuffer);
            }
            for ( var i = 0; i < primitivesLen; ++i) {
                var primitive = primitives[i];
                if (primitive.renderForPick) {
                    primitive.renderForPick(context, framebuffer);
                }
            }
        }
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof CompositePrimitive
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see CompositePrimitive#destroy
     */
    CompositePrimitive.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by each primitive in this composite.  Explicitly destroying this
     * composite allows for deterministic release of WebGL resources, instead of relying on the garbage
     * collector to destroy this composite.
     * <br /><br />
     * Since destroying a composite destroys all the contained primitives, only destroy a composite
     * when you are sure no other code is still using any of the contained primitives.
     * <br /><br />
     * Once this composite is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof CompositePrimitive
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CompositePrimitive#isDestroyed
     *
     * @example
     * primitives = primitives && primitives.destroy();
     */
    CompositePrimitive.prototype.destroy = function() {
        this.removeAll();

        this._centralBody = this.destroyPrimitives && this._centralBody && this._centralBody.destroy();

        return destroyObject(this);
    };

    return CompositePrimitive;
});
/*global define*/
define('Scene/CompositeTileProvider',[
        '../Core/DeveloperError',
        '../Core/Ellipsoid'
    ], function(
        DeveloperError,
        Ellipsoid) {
    

    /**
     * A container for tile providers that will change based of the altitude of the camera.
     *
     * @alias CompositeTileProvider
     * @constructor
     *
     * @param {Array} list An array of objects with provider and height attributes. The height attribute determines
     * the minimum height at which to use the accompanying provider.
     * @param {Camera} camera The camera.
     * @param {Ellipsoid} ellipsoid An ellipsoid to test the altitude against. Defaults to a WGS84 ellipsoid.
     *
     * @exception {DeveloperError} A non-empty list is required.
     * @exception {DeveloperError} camera is required.
     *
     * @see SingleTileProvider
     * @see ArcGISTileProvider
     * @see OpenStreetMapTileProvider
     * @see BingMapsTileProvider
     *
     * @example
     * // Create a CompositeTileProvider from a SingleTileProvider and BingMapsTileProvider
     *
     * // Single
     *  var single = new SingleTileProvider('Images/NE2_50M_SR_W_4096.jpg');
     *  // Bing Maps
     *  var bing = new BingMapsTileProvider({
     *      server : 'dev.virtualearth.net',
     *      mapStyle : BingMapsStyle.AERIAL
     *  });
     *  // Composite
     *  var composite = new CompositeTileProvider([
     *      { provider : single, height : 1000000 },
     *      { provider : bing, height : 0}
     *  ], scene.getCamera(), ellipsoid);
     *
     */
    var CompositeTileProvider = function(list, camera, ellipsoid) {
        if (!list) {
            throw new DeveloperError('A non-empty list is required.');
        }

        if (!camera) {
            throw new DeveloperError('camera is required.');
        }

        this._camera = camera;

        ellipsoid = ellipsoid || Ellipsoid.WGS84;
        this._radius = ellipsoid.getMaximumRadius();

        this._list = list;
        this._list.sort(CompositeTileProvider._compare);
        this._currentProviderIndex = 0;

        /**
         * The cartographic extent of the base tile, with north, south, east and
         * west properties in radians.
         *
         * @constant
         * @type {Extent}
         */
        this.maxExtent = this._list[0].provider.maxExtent;

        /**
         * The minimum zoom level that can be requested.
         *
         * @constant
         * @type {Number}
         */
        this.zoomMin = this._list[0].provider.zoomMin;

        /**
         * The maximum zoom level that can be requested.
         *
         * @constant
         * @type {Number}
         */
        this.zoomMax = this._list[this._list.length - 1].provider.zoomMax;

        /**
         * The smallest width of any image loaded.
         *
         * @type {Number}
         */
        this.tileWidth = Number.MAX_VALUE;

        /**
         * The smallest height of any image loaded.
         *
         * @type {Number}
         */
        this.tileHeight = Number.MAX_VALUE;

        // TODO: good idea?
        for ( var i = 0; i < this._list.length; ++i) {
            var provider = this._list[i].provider;
            if (provider.tileHeight < this.tileHeight || provider.tileWidth < this.tileWidth) {
                this.tileHeight = provider.tileHeight;
                this.tileWidth = provider.tileWidth;
            }
        }

        if (this.tileWidth === Number.MAX_VALUE) {
            this.tileWidth = null;
        }
        if (this.tileHeight === Number.MAX_VALUE) {
            this.tileHeight = null;
        }
    };

    CompositeTileProvider._compare = function(a, b) {
        // if height isn't provided, default to 0.0
        if (typeof a.height === 'undefined') {
            a.height = 0.0;
        }
        if (typeof b.height === 'undefined') {
            b.height = 0.0;
        }
        return b.height - a.height;
    };

    CompositeTileProvider.prototype._findIndex = function(currentIndex, height) {
        var i = currentIndex;
        if (this._list[i].height < height) {
            // search backwards
            for (i = i - 1; i >= 0; --i) {
                if (this._list[i].height > height) {
                    break;
                }
            }

            if (i === 0 && this._list[i].height < height) {
                return i;
            }

            return (i + 1 >= this._list.length) ? i : i + 1;
        }

        // search forwards
        for (i = i + 1; i < this._list.length; ++i) {
            if (this._list[i].height < height) {
                break;
            }
        }
        return (i >= this._list.length) ? this._list.length - 1 : i;
    };

    /**
     * Loads the top-level tile.
     *
     * @memberof CompositeTileProvider
     *
     * @param {Tile} tile The top-level tile.
     * @param {Function} onload A function that will be called when the image is finished loading.
     * @param {Function} onerror A function that will be called if there is an error loading the image.
     * @param {Function} oninvalid A function that will be called if the image loaded is not valid.
     *
     * @exception {DeveloperError} <code>tile.zoom</code> is less than <code>zoomMin</code>
     * or greater than <code>zoomMax</code>.
     */
    CompositeTileProvider.prototype.loadTileImage = function(tile, onload, onerror, oninvalid) {
        if (tile.zoom < this.zoomMin || tile.zoom > this.zoomMax) {
            throw new DeveloperError('tile.zoom must be between in [zoomMin, zoomMax].');
        }

        var height = this._camera.position.magnitude() - this._radius;
        this._currentProviderIndex = this._findIndex(this._currentProviderIndex, height);
        var provider = this._list[this._currentProviderIndex].provider;
        var image = null;

        if (tile.zoom >= provider.zoomMin && tile.zoom <= provider.zoomMax) {
            image = provider.loadTileImage(tile, onload, onerror, oninvalid);
            tile.projection = provider.projection;
        } else {
            if (oninvalid && typeof oninvalid === 'function') {
                oninvalid();
            }
        }

        return image;
    };

    /**
     * DOC_TBA
     * @memberof CompositeTileProvider
     */
    CompositeTileProvider.prototype.getLogo = function() {
        var height = this._camera.position.magnitude() - this._radius;
        this._currentProviderIndex = this._findIndex(this._currentProviderIndex, height);
        var provider = this._list[this._currentProviderIndex].provider;
        return (provider && provider.getLogo) ? provider.getLogo() : undefined;
    };

    return CompositeTileProvider;
});
/*global define*/
define('Scene/EllipsoidPrimitive',[
        '../Core/DeveloperError',
        '../Core/destroyObject'
    ], function(
        DeveloperError,
        destroyObject) {
    

    /**
     * DOC_TBA
     *
     * @alias EllipsoidPrimitive
     * @constructor
     *
     * @example TODO
     *
     */
    var EllipsoidPrimitive = function(position, radii) {
        /**
         * Determines if the ellipsoid primitive will be shown.
         *
         * @type Boolean
         */
        this.show = true;

        /**
         * DOC_TBA
         * TODO: Update for material system
         */
        this.material = new ColorMaterial({
            color : new Color(1.0, 0.0, 0.0, 0.5)
        });
        this._material = undefined;

        this._sp = undefined;
        this._rs = undefined;

        this._pickId = null;

    };

    /**
     * Commits changes to properties before rendering by updating the object's WebGL resources.
     * This must be called before calling {@link EllipsoidPrimitive#render} in order to realize
     * changes to EllipsoidPrimitive's positions and properties.
     *
     * @memberof EllipsoidPrimitive
     *
     * @param context
     * @param sceneState
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see Polygon#render
     */
    EllipsoidPrimitive.prototype.update = function(context, sceneState) {

    };

    /**
     * Renders the ellipsoid primitive. In order for changes to positions and properties to be realized,
     * {@link EllipsoidPrimitive#update} must be called before <code>render</code>.
     *
     * @memberof EllipsoidPrimitive
     *
     * @param context
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see EllipsoidPrimitive#update
     */
    EllipsoidPrimitive.prototype.render = function(context) {
        context.draw({
            primitiveType: PrimitiveType.TRIANGLES,
            shaderProgram: this._sp,
            uniformMap: this._drawUniforms,
            vertexArray: this._va,  // ??
            renderState: this._rs
        });
    };

    /**
     * DOC_TBA
     *
     * @memberof EllipsoidPrimitive
     *
     * @param context
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     */
    EllipsoidPrimitive.prototype.updateForPick = function(context) {
        this._pickId = this._pickId || context.createPickId(this);
        this.updateForPick = function(context) {};
    };

    /**
     * DOC_TBA
     *
     * @memberof EllipsoidPrimitive
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     */
    EllipsoidPrimitive.prototype.renderForPick = function(context, framebuffer) {
        if (this.show) {
            context.draw({
                primitiveType : PrimitiveType.TRIANGLES, // ?
                shaderProgram : this._sp,   // or this._spPick ?
                uniformMap : this._pickUniforms,
                vertexArray : this._va,     // HOW TO HANDLE VERTICES/ VERTEX ARRAY ?
                renderState : this._rs, // or this._rsPick ?
                framebuffer : framebuffer
            });
        }
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof EllipsoidPrimitive
     *
     * @return {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     *
     * @see EllipsoidPrimitive#destroy
     */
    EllipsoidPrimitive.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof EllipsoidPrimitive
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see EllipsoidPrimitive#isDestroyed
     *
     * @example
     * ellipsoidPrimitive = ellipsoidPrimitive && ellipsoidPrimitive();
     */
    EllipsoidPrimitive.prototype.destroy = function() {
        this._sp = this._sp && this._sp.release();
        // destroy whatever vertices
        this._pickId = this._pickId && this._pickId.destroy();
        return destroyObject(this);
    };

    return EllipsoidPrimitive;
});
/*global define*/
define('Scene/HorizontalOrigin',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * The horizontal location of an origin relative to an object, e.g., a {@link Billboard}.
     * For example, the horizontal origin is used to display a billboard to the left or right (in
     * screen space) of the actual position.
     *
     * @exports HorizontalOrigin
     *
     * @see Billboard#setHorizontalOrigin
     */
    var HorizontalOrigin = {
        /**
         * The origin is at the horizontal center of the object.
         *
         * @constant
         * @type {Enumeration}
         */
        CENTER : new Enumeration(0, 'CENTER'),
        /**
         * The origin is on the left side of the object.
         *
         * @constant
         * @type {Enumeration}
         */
        LEFT : new Enumeration(1, 'LEFT'),
        /**
         * The origin is on the right side of the object.
         *
         * @constant
         * @type {Enumeration}
         */
        RIGHT : new Enumeration(-1, 'RIGHT')
    };

    return HorizontalOrigin;
});
/*global define*/
define('DynamicScene/CzmlHorizontalOrigin',[
        '../Scene/HorizontalOrigin'
       ], function(
         HorizontalOrigin) {
    

    /**
     * Provides methods for working with a horizontal origin defined in CZML.
     *
     * @exports CzmlHorizontalOrigin
     *
     * @see HorizontalOrigin
     * @see DynamicProperty
     * @see CzmlBoolean
     * @see CzmlCartesian2
     * @see CzmlCartesian3
     * @see CzmlCartographic
     * @see CzmlColor
     * @see CzmlLabelStyle
     * @see CzmlNumber
     * @see CzmlString
     * @see CzmlUnitCartesian3
     * @see CzmlUnitQuaternion
     * @see CzmlUnitSpherical
     * @see CzmlVerticalOrigin
     */
    var CzmlHorizontalOrigin = {
        /**
         * Returns the packed enum representation contained within the provided CZML interval
         * or undefined if the interval does not contain enum data.
         *
         * @param {Object} czmlInterval The CZML interval to unwrap.
         */
        unwrapInterval : function(czmlInterval) {
            var result = czmlInterval.horizontalOrigin;
            return typeof result === 'undefined' ? czmlInterval : result;
        },

        /**
         * Since enums can not be sampled, this method always returns false.
         */
        isSampled : function() {
            return false;
        },

        /**
         * Returns the HorizontalOrigin contained within the unwrappedInterval.
         *
         * @param {Object} unwrappedInterval The result of CzmlHorizontalOrigin.unwrapInterval.
         * @returns The HorizontalOrigin value.
         */
        getValue : function(unwrappedInterval) {
            return HorizontalOrigin[unwrappedInterval];
        }
    };

    return CzmlHorizontalOrigin;
});
/*global define*/
define('Scene/LabelStyle',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports LabelStyle
     *
     * @see Label#setStyle
     */
    var LabelStyle = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        FILL : new Enumeration(0, 'FILL'),
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        OUTLINE : new Enumeration(1, 'OUTLINE'),
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        FILL_AND_OUTLINE : new Enumeration(2, 'FILL_AND_OUTLINE')
    };

    return LabelStyle;
});
/*global define*/
define('DynamicScene/CzmlLabelStyle',[
        '../Scene/LabelStyle'
       ], function(
         LabelStyle) {
    

    /**
     * Provides methods for working with a label style defined in CZML.
     *
     * @exports CzmlLabelStyle
     *
     * @see LabelStyle
     * @see DynamicProperty
     * @see CzmlBoolean
     * @see CzmlCartesian2
     * @see CzmlCartesian3
     * @see CzmlCartographic
     * @see CzmlColor
     * @see CzmlLabelStyle
     * @see CzmlNumber
     * @see CzmlString
     * @see CzmlUnitCartesian3
     * @see CzmlUnitQuaternion
     * @see CzmlUnitSpherical
     * @see CzmlVerticalOrigin
     */
    var CzmlLabelStyle = {
        /**
         * Returns the packed enum representation contained within the provided CZML interval
         * or undefined if the interval does not contain enum data.
         *
         * @param {Object} czmlInterval The CZML interval to unwrap.
         */
        unwrapInterval : function(czmlInterval) {
            var result = czmlInterval.labelStyle;
            return typeof result === 'undefined' ? czmlInterval : result;
        },

        /**
         * Since enums can not be sampled, this method always returns false.
         */
        isSampled : function() {
            return false;
        },

        /**
         * Returns the LabelStyle contained within the unwrappedInterval.
         *
         * @param {Object} unwrappedInterval The result of CzmlLabelStyle.unwrapInterval.
         * @returns The LabelStyle value.
         */
        getValue : function(unwrappedInterval) {
            return LabelStyle[unwrappedInterval];
        }
    };

    return CzmlLabelStyle;
});
/*global define*/
define('Scene/OrthographicFrustum',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/Cartesian3',
        '../Core/Cartesian4',
        '../Core/Matrix4'
    ], function(
        DeveloperError,
        destroyObject,
        Cartesian3,
        Cartesian4,
        Matrix4) {
    

    /**
     * The viewing frustum is defined by 6 planes.
     * Each plane is represented by a {Cartesian4} object, where the x, y, and z components
     * define the unit vector normal to the plane, and the w component is the distance of the
     * plane from the origin/camera position.
     *
     * @alias OrthographicFrustum
     * @constructor
     *
     * @example
     * var maxRadii = ellipsoid.getMaximumRadius();
     *
     * var frustum = new OrthographicFrustum();
     * frustum.right = maxRadii * CesiumMath.PI;
     * frustum.left = -c.frustum.right;
     * frustum.top = c.frustum.right * (canvas.clientHeight / canvas.clientWidth);
     * frustum.bottom = -c.frustum.top;
     * frustum.near = 0.01 * maxRadii;
     * frustum.far = 50.0 * maxRadii;
     */
    var OrthographicFrustum = function() {
        /**
         * DOC_TBA
         *
         * @type {Number}
         */
        this.left = null;
        this._left = null;

        /**
         * DOC_TBA
         *
         * @type {Number}
         */
        this.right = null;
        this._right = null;

        /**
         * DOC_TBA
         *
         * @type {Number}
         */
        this.top = null;
        this._top = null;

        /**
         * DOC_TBA
         *
         * @type {Number}
         */
        this.bottom = null;
        this._bottom = null;

        /**
         * The distance of the near plane from the camera's position.
         *
         * @type {Number}
         */
        this.near = null;
        this._near = null;

        /**
         * The The distance of the far plane from the camera's position.
         *
         * @type {Number}
         */
        this.far = null;
        this._far = null;

        this._orthographicMatrix = null;
    };

    /**
     * Returns the orthographic projection matrix computed from the view frustum.
     *
     * @memberof OrthographicFrustum
     *
     * @return {Matrix4} The orthographic projection matrix.
     *
     * @see OrthographicFrustum#getInfiniteProjectionMatrix
     */
    OrthographicFrustum.prototype.getProjectionMatrix = function() {
        this._update();
        return this._orthographicMatrix;
    };

    OrthographicFrustum.prototype._update = function() {
        if (this.left === null || this.right === null || this.top === null || this.bottom === null || this.near === null || this.far === null) {
            throw new DeveloperError('left, right, top, bottom, near, or far frustum parameters are not set.');
        }

        if (this.left !== this._left || this.right !== this._right || this.top !== this._top || this.bottom !== this._bottom || this.near !== this._near || this.far !== this._far) {
            if (this.left > this.right) {
                throw new DeveloperError('right must be greater than left.');
            }

            if (this.bottom > this.top) {
                throw new DeveloperError('top must be greater than bottom.');
            }

            if (this.near < 0 || this.near > this.far) {
                throw new DeveloperError('near must be greater than zero and less than far.');
            }

            this._left = this.left;
            this._right = this.right;
            this._top = this.top;
            this._bottom = this.bottom;
            this._near = this.near;
            this._far = this.far;

            this._updateProjectionMatrices();
        }
    };

    OrthographicFrustum.prototype._updateProjectionMatrices = function() {
        this._orthographicMatrix = Matrix4.computeOrthographicOffCenter(this.left, this.right, this.bottom, this.top, this.near, this.far);
    };

    /**
     * DOC_TBA
     *
     * @memberof OrthographicFrustum
     *
     * @param {Cartesian3} position The eye position.
     * @param {Cartesian3} direction The view direction.
     * @param {Cartesian3} up The up direction.
     *
     * @exception {DeveloperError} position is required.
     * @exception {DeveloperError} direction is required.
     * @exception {DeveloperError} up is required.
     */
    OrthographicFrustum.prototype.getPlanes = function(position, direction, up) {
        if (!position) {
            throw new DeveloperError('position is required.');
        }

        if (!direction) {
            throw new DeveloperError('direction is required.');
        }

        if (!up) {
            throw new DeveloperError('up is required.');
        }

        var pos = Cartesian3.clone(position);
        var dir = Cartesian3.clone(direction);
        var u = Cartesian3.clone(up);

        var right = dir.cross(u);

        var planes = [];
        planes.length = 6;

        var planePoint;
        var nearCenter = pos.add(dir.multiplyByScalar(this.near));

        // Left plane
        planePoint = nearCenter.add(right.multiplyByScalar(this.left));
        planes[0] = new Cartesian4(right.x, right.y, right.z, -right.dot(planePoint));

        // Right plane
        planePoint = nearCenter.add(right.multiplyByScalar(this.right));
        planes[1] = new Cartesian4(-right.x, -right.y, -right.z, -right.negate().dot(planePoint));

        // Bottom plane
        planePoint = nearCenter.add(u.multiplyByScalar(this.bottom));
        planes[2] = new Cartesian4(u.x, u.y, u.z, -u.dot(planePoint));

        // Top plane
        planePoint = nearCenter.add(u.multiplyByScalar(this.top));
        planes[3] = new Cartesian4(-u.x, -u.y, -u.z, -u.negate().dot(planePoint));

        // Near plane
        planes[4] = new Cartesian4(direction.x, direction.y, direction.z, -direction.dot(nearCenter));

        // Far plane
        planePoint = position.add(direction.multiplyByScalar(this.far));
        planes[5] = new Cartesian4(-direction.x, -direction.y, -direction.z, -direction.negate().dot(planePoint));

        return planes;
    };

    /**
     * Returns a duplicate of a OrthographicFrustum instance.
     *
     * @memberof OrthographicFrustum
     *
     * @return {OrthographicFrustum} A new copy of the OrthographicFrustum instance.
     */
    OrthographicFrustum.prototype.clone = function() {
        var frustum = new OrthographicFrustum();
        frustum.left = this.left;
        frustum.right = this.right;
        frustum.top = this.top;
        frustum.bottom = this.bottom;
        frustum.near = this.near;
        frustum.far = this.far;
        return frustum;
    };

    /**
     * DOC_TBA
     *
     * @memberof OrthographicFrustum
     */
    OrthographicFrustum.prototype.equals = function(other) {
        return (this.left === other.left &&
                this.right === other.right &&
                this.top === other.top &&
                this.bottom === other.bottom &&
                this.near === other.near &&
                this.far === other.far);
    };

    return OrthographicFrustum;
});
/*global define*/
define('Scene/PerspectiveFrustum',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/Cartesian3',
        '../Core/Cartesian4',
        '../Core/Matrix4'
    ], function(
        DeveloperError,
        destroyObject,
        Cartesian3,
        Cartesian4,
        Matrix4) {
    

    /**
     * The viewing frustum is defined by 6 planes.
     * Each plane is represented by a {Cartesian4} object, where the x, y, and z components
     * define the unit vector normal to the plane, and the w component is the distance of the
     * plane from the origin/camera position.
     *
     * @alias PerspectiveFrustum
     * @constructor
     *
     * @example
     * var frustum = new PerspectiveFrustum();
     * frustum.fovy = CesiumMath.PI_OVER_THREE;
     * frustum.aspectRatio = canvas.clientWidth / canvas.clientHeight;
     * frustum.near = 1.0;
     * frustum.far = 2.0;
     */
    var PerspectiveFrustum = function() {
        /**
         * The angle of the field of view, in radians.
         *
         * @type {Number}
         */
        this.fovy = null;
        this._fovy = null;

        /**
         * The aspect ratio of the frustum's width to it's height.
         *
         * @type {Number}
         */
        this.aspectRatio = null;
        this._aspectRatio = null;

        /**
         * The distance of the near plane from the camera's position.
         *
         * @type {Number}
         */
        this.near = null;
        this._near = null;

        /**
         * The The distance of the far plane from the camera's position.
         *
         * @type {Number}
         */
        this.far = null;
        this._far = null;

        this._perspectiveMatrix = null;
        this._infinitePerspective = null;
    };

    /**
     * Returns the perspective projection matrix computed from the view frustum.
     *
     * @memberof PerspectiveFrustum
     *
     * @return {Matrix4} The perspective projection matrix.
     *
     * @see PerspectiveFrustum#getInfiniteProjectionMatrix
     */
    PerspectiveFrustum.prototype.getProjectionMatrix = function() {
        this._update();
        return this._perspectiveMatrix;
    };

    /**
     * DOC_TBA
     *
     * @memberof PerspectiveFrustum
     *
     * @see PerspectiveFrustum#getProjectionMatrix
     */
    PerspectiveFrustum.prototype.getInfiniteProjectionMatrix = function() {
        this._update();
        return this._infinitePerspective;
    };

    PerspectiveFrustum.prototype._update = function() {
        if (this.fovy === null || this.aspectRatio === null || this.near === null || this.far === null) {
            throw new DeveloperError('fovy, aspectRatio, near, or far parameters are not set.');
        }

        if (this.fovy !== this._fovy || this.aspectRatio !== this._aspectRatio || this.near !== this._near || this.far !== this._far) {
            if (this.fovy < 0 || this.fovy >= Math.PI) {
                throw new DeveloperError('fovy must be in the range [0, PI).');
            }

            if (this.aspectRatio < 0) {
                throw new DeveloperError('aspectRatio must be positive.');
            }

            if (this.near < 0 || this.near > this.far) {
                throw new DeveloperError('near must be greater than zero and less than far.');
            }

            this._fovy = this.fovy;
            this._aspectRatio = this.aspectRatio;
            this._near = this.near;
            this._far = this.far;

            this._updateProjectionMatrices();
        }
    };

    PerspectiveFrustum.prototype._updateProjectionMatrices = function() {
        var t = this.near * Math.tan(0.5 * this.fovy);
        var b = -t;
        var r = this.aspectRatio * t;
        var l = -r;
        var n = this.near;
        var f = this.far;

        this._perspectiveMatrix = Matrix4.computePerspectiveOffCenter(l, r, b, t, n, f);
        this._infinitePerspective = Matrix4.computeInfinitePerspectiveOffCenter(l, r, b, t, n);
    };

    /**
     * DOC_TBA
     *
     * @memberof PerspectiveFrustum
     *
     * @param {Cartesian3} position The eye position.
     * @param {Cartesian3} direction The view direction.
     * @param {Cartesian3} up The up direction.
     *
     * @exception {DeveloperError} position is required.
     * @exception {DeveloperError} direction is required.
     * @exception {DeveloperError} up is required.
     */
    PerspectiveFrustum.prototype.getPlanes = function(position, direction, up) {
        if (!position) {
            throw new DeveloperError('position is required.');
        }

        if (!direction) {
            throw new DeveloperError('direction is required.');
        }

        if (!up) {
            throw new DeveloperError('up is required.');
        }

        var pos = Cartesian3.clone(position);
        var dir = Cartesian3.clone(direction);
        var u = Cartesian3.clone(up);

        var right = dir.cross(u);

        var t = this.near * Math.tan(0.5 * this.fovy);
        var r = this.aspectRatio * t;
        var n = this.near;
        var f = this.far;

        var planes = [];
        planes.length = 6;

        var normal, planeVec;
        var nearCenter = pos.add(dir.multiplyByScalar(n));
        var farCenter = pos.add(dir.multiplyByScalar(f));

        //Left plane computation
        planeVec = nearCenter.add(right.negate().multiplyByScalar(r)).subtract(pos);
        planeVec = planeVec.normalize();
        normal = planeVec.cross(u);
        planes[0] = new Cartesian4(normal.x, normal.y, normal.z, -normal.dot(pos));

        //Right plane computation
        planeVec = nearCenter.add(right.multiplyByScalar(r)).subtract(pos);
        planeVec = planeVec.normalize();
        normal = u.cross(planeVec);
        planes[1] = new Cartesian4(normal.x, normal.y, normal.z, -normal.dot(pos));

        //Bottom plane computation
        planeVec = nearCenter.add(u.negate().multiplyByScalar(t)).subtract(position);
        planeVec = planeVec.normalize();
        normal = right.cross(planeVec);
        planes[2] = new Cartesian4(normal.x, normal.y, normal.z, -normal.dot(pos));

        //Top plane computation
        planeVec = nearCenter.add(u.multiplyByScalar(t)).subtract(pos);
        planeVec = planeVec.normalize();
        normal = planeVec.cross(right);
        planes[3] = new Cartesian4(normal.x, normal.y, normal.z, -normal.dot(pos));

        //Near plane computation
        normal = direction;
        planes[4] = new Cartesian4(normal.x, normal.y, normal.z, -normal.dot(nearCenter));

        //Far plane computation
        normal = direction.negate();
        planes[5] = new Cartesian4(normal.x, normal.y, normal.z, -normal.dot(farCenter));

        return planes;
    };

    /**
     * Returns a duplicate of a PerspectiveFrustum instance.
     *
     * @memberof PerspectiveFrustum
     *
     * @return {PerspectiveFrustum} A new copy of the PerspectiveFrustum instance.
     */
    PerspectiveFrustum.prototype.clone = function() {
        var frustum = new PerspectiveFrustum();
        frustum.fovy = this.fovy;
        frustum.aspectRatio = this.aspectRatio;
        frustum.near = this.near;
        frustum.far = this.far;
        return frustum;
    };

    /**
     * DOC_TBA
     *
     * @memberof PerspectiveFrustum
     */
    PerspectiveFrustum.prototype.equals = function(other) {
        return (this.fovy === other.fovy && this.aspectRatio === other.aspectRatio && this.near === other.near && this.far === other.far);
    };

    return PerspectiveFrustum;
});
/*global define*/
define('Scene/Polyline',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/Cartesian3',
        '../Core/Color'
    ], function(
        DeveloperError,
        destroyObject,
        Cartesian3,
        Color) {
    

    /**
     *
     * @alias Polyline
     * @internalConstructor
     */
    var Polyline = function(polylineTemplate, polylineCollection) {
        var p = polylineTemplate || {};

        this._positions = [];
        if (typeof p.positions !== 'undefined') {
            var newPositions = p.positions;
            var length = newPositions.length;
            var positions = this._positions;
            for ( var i = 0; i < length; ++i) {
                var position = newPositions[i];
                positions.push(new Cartesian3(position.x, position.y, position.z));
    }
        }
        this._show = (typeof p.show === 'undefined') ? true : p.show;
        this._width = (typeof p.width === 'undefined') ? 1.0 : p.width;
        this._outlineWidth = (typeof p.outlineWidth === 'undefined') ? 0.0 : p.outlineWidth;
        this._color = (typeof p.color === 'undefined') ?
                new Color(1.0, 1.0, 1.0, 1.0) :
                Color.clone(p.color);

        this._outlineColor = (typeof p.outlineColor === 'undefined') ?
                new Color(1.0, 1.0, 1.0, 1.0) :
                Color.clone(p.outlineColor);

        this._propertiesChanged = new Uint32Array(NUMBER_OF_PROPERTIES);
        this._collection = polylineCollection;
        this._dirty = false;
        this._pickId = undefined;
        this._pickIdThis = p._pickIdThis;
    };

    var SHOW_INDEX = Polyline.SHOW_INDEX = 0;
    var POSITION_INDEX = Polyline.POSITION_INDEX = 1;
    var COLOR_INDEX = Polyline.COLOR_INDEX = 2;
    var OUTLINE_COLOR_INDEX = Polyline.OUTLINE_COLOR_INDEX = 3;
    var WIDTH_INDEX = Polyline.WIDTH_INDEX = 4;
    var OUTLINE_WIDTH_INDEX = Polyline.OUTLINE_WIDTH_INDEX = 5;
    var POSITION_SIZE_INDEX = Polyline.POSITION_SIZE_INDEX = 6;
    Polyline.NUMBER_OF_PROPERTIES = 7;
    var NUMBER_OF_PROPERTIES = Polyline.NUMBER_OF_PROPERTIES;

    /**
     * Returns true if this polyline will be shown.  Call {@link Polyline#setShow}
     * to hide or show a polyline, instead of removing it and re-adding it to the collection.
     *
     * @memberof Polyline
     *
     * @return {Boolean} <code>true</code> if this polyline will be shown; otherwise, <code>false</code>.
     *
     * @see Polyline#setShow
     */
    Polyline.prototype.getShow = function() {
        return this._show;
    };

    /**
     * Determines if this polyline will be shown.  Call this to hide or show a polyline, instead
     * of removing it and re-adding it to the collection.
     *
     * @memberof Polyline
     *
     * @param {Boolean} value Indicates if this polyline will be shown.
     *
     * @see Polyline#getShow
     */
    Polyline.prototype.setShow = function(value) {
        if ((typeof value !== 'undefined') && (this._show !== value)) {
            this._show = value;
            this._makeDirty(SHOW_INDEX);
                }
    };

    /**
     * Returns the polyline's positions.
     *
     * @memberof Polyline
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see Polyline#setPositions
     */
    Polyline.prototype.getPositions = function() {
        return this._positions;
    };

    /**
    * Defines the positions of the polyline.
    *
    * @memberof Polyline
    *
    * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
    * @see Polyline#getPositions
    *
    * @example
    * polyline.setPositions(
    *   ellipsoid.toCartesians(new Cartographic3(...),
    *                          new Cartographic3(...),
    *                          new Cartographic3(...))
    * );
     */
    Polyline.prototype.setPositions = function(value) {
        var length = 0;
        if(value && typeof value !== 'undefined')
            length = value.length;
        if (this._positions.length !== length) {
            this._makeDirty(POSITION_SIZE_INDEX);
        }
        var positions = [];
        for ( var i = 0; i < length; ++i) {
            var position = value[i];
            positions.push(new Cartesian3(position.x, position.y, position.z));
        }
        this._positions = positions;
        this._makeDirty(POSITION_INDEX);
    };

    /**
     * Returns the color of the polyline.
     *
     * @memberof Polyline
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @return {Color}
     *
     * @see Polyline#setColor
     */
    Polyline.prototype.getColor = function() {
        return this._color;
    };

        /**
     * Sets the color of the polyline.
     *
     * @memberof Polyline
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @param {Color} value. The color of the polyline.
         *
     * @see Polyline#getColor
         */
    Polyline.prototype.setColor = function(value) {
        var c = this._color;

        if ((typeof value !== 'undefined') && ((c.red !== value.red) || (c.green !== value.green) || (c.blue !== value.blue) || (c.alpha !== value.alpha))) {
            this._color = new Color(value.red, value.green, value.blue, value.alpha);
            this._makeDirty(COLOR_INDEX);
            }
        };

        /**
         * <br /><br />
         * The actual width used is clamped to the minimum and maximum width supported by the WebGL implementation.
         * These can be queried with {@link Context#getMinimumAliasedLineWidth} and
         * {@link Context#getMaximumAliasedLineWidth}.
         *
         * @type Number
         *
    * @see Polyline#width
         * @see Context#getMinimumAliasedLineWidth
         * @see Context#getMaximumAliasedLineWidth
         *
         * @example
         * // 3 pixel total width, 1 pixel interior width
         * polyline.width = 1.0;
         * polyline.outlineWidth = 3.0;
         */
    Polyline.prototype.getWidth = function() {
        return this._width;
    };

        /**
         * <br /><br />
         * The actual width used is clamped to the minimum and maximum width supported by the WebGL implementation.
         * These can be queried with {@link Context#getMinimumAliasedLineWidth} and
         * {@link Context#getMaximumAliasedLineWidth}.
         *
         * @type Number
         *
         * @see Polyline#width
         * @see Context#getMinimumAliasedLineWidth
         * @see Context#getMaximumAliasedLineWidth
         *
         * @example
         * // 3 pixel total width, 1 pixel interior width
         * polyline.width = 1.0;
         * polyline.outlineWidth = 3.0;
         */
    Polyline.prototype.setWidth = function(value) {
        var width = this._width;

        if ((typeof value !== 'undefined') && (value !== width)) {
            this._width = value;
            this._makeDirty(WIDTH_INDEX);
        }
        };

        /**
    * <br /><br />
    * The actual width used is clamped to the minimum and maximum width supported by the WebGL implementation.
    * These can be queried with {@link Context#getMinimumAliasedLineWidth} and
    * {@link Context#getMaximumAliasedLineWidth}.
         *
    * @type Number
    *
    * @see Polyline#outlineWidth
    * @see Context#getMinimumAliasedLineWidth
    * @see Context#getMaximumAliasedLineWidth
     *
    * @example
    * // 3 pixel total width, 1 pixel interior width
    * polyline.width = 1.0;
    * polyline.outlineWidth = 3.0;
         */
    Polyline.prototype.getOutlineWidth = function() {
        return this._outlineWidth;
        };

        /**
    * <br /><br />
    * The actual width used is clamped to the minimum and maximum width supported by the WebGL implementation.
    * These can be queried with {@link Context#getMinimumAliasedLineWidth} and
    * {@link Context#getMaximumAliasedLineWidth}.
         *
    * @type Number
         *
    * @see Polyline#outlineWidth
    * @see Context#getMinimumAliasedLineWidth
    * @see Context#getMaximumAliasedLineWidth
         *
         * @example
    * // 3 pixel total width, 1 pixel interior width
    * polyline.width = 1.0;
    * polyline.outlineWidth = 3.0;
         */
    Polyline.prototype.setOutlineWidth = function(value) {
        var width = this._outlineWidth;

        if ((typeof value !== 'undefined') && (value !== width)) {
            this._outlineWidth = value;
            this._makeDirty(OUTLINE_WIDTH_INDEX);
            }
        };

        /**
     * Returns the outline color of the polyline.
     *
     * @memberof Polyline
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @return {Color}
     *
     * @see Polyline#setOutlineColor
     */
    Polyline.prototype.getOutlineColor = function() {
        return this._outlineColor;
    };

    /**
     * Returns the outline color of the polyline.
     *
     * @memberof Polyline
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @return {Color}
     *
     * @see Polyline#setOutlineColor
     */
    Polyline.prototype.setOutlineColor = function(value) {
        var c = this._outlineColor;

        if ((typeof value !== 'undefined') && ((c.red !== value.red) || (c.green !== value.green) || (c.blue !== value.blue) || (c.alpha !== value.alpha))) {
            this._outlineColor = new Color(value.red, value.green, value.blue, value.alpha);
            this._makeDirty(OUTLINE_COLOR_INDEX);
        }
    };

    Polyline.prototype.getPickId = function(context) {
        this._pickId = this._pickId || context.createPickId(this._pickIdThis || this);
        return this._pickId;
    };

    Polyline.prototype._clean = function() {
        this._dirty = false;
        var properties = this._propertiesChanged;
        for ( var k = 0; k < NUMBER_OF_PROPERTIES - 1; ++k) {
            properties[k] = 0;
        }
    };

    Polyline.prototype._getCollection = function() {
        return this._collection;
    };

    Polyline.prototype._getChangedProperties = function() {
        return this._propertiesChanged;
    };

    Polyline.prototype._makeDirty = function(propertyChanged) {
        ++this._propertiesChanged[propertyChanged];
        var c = this._collection;
        if (c) {
            c._updatePolyline(propertyChanged, this);
            this._dirty = true;
        }
    };

    Polyline.prototype._destroy = function() {
        this._pickId = this._pickId && this._pickId.destroy();
        this._collection = undefined;
    };

    return Polyline;
});
/*global define*/
define('Scene/Projections',[
        '../Core/DeveloperError',
        '../Core/Enumeration'
    ], function(
        DeveloperError,
        Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports Projections
     */
    var Projections = {
        WGS84 : new Enumeration(0, 'WGS84', {
            toWgs84 : function(extent, image) {
                return image;
            }
        }),
        MERCATOR : new Enumeration(1, 'MERCATOR', {
            toWgs84 : function(extent, image) {
                if (!extent || typeof extent.north === 'undefined' || typeof extent.south === 'undefined') {
                    throw new DeveloperError('extent, extent.north and extent.south are required.');
                }

                if (!image) {
                    throw new DeveloperError('image is required.');
                }

                var width = parseInt(image.width, 10);
                var height = parseInt(image.height, 10);
                var wRowBytes = width * 4; // Always 4 bytes per pixel.

                // draw image to canvas and get the pixels
                var canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                var context = canvas.getContext('2d');
                context.drawImage(image, 0, 0);
                var fromPixels = context.getImageData(0, 0, width, height).data;

                // create array of pixels
                var newImageData = context.createImageData(width, height);
                var toPixels = newImageData.data;

                // WGS84 parameters
                var deltaWLat = (extent.north - extent.south) / height;
                var currentWLat = extent.north - (0.5 * deltaWLat);

                // mercator parameters
                var sinTheta = Math.sin(extent.south);
                var minMLat = 0.5 * Math.log((1 + sinTheta) / (1 - sinTheta));
                sinTheta = Math.sin(extent.north);
                var maxMLat = 0.5 * Math.log((1 + sinTheta) / (1 - sinTheta));
                var invMLatDim = 1.0 / (maxMLat - minMLat);

                // first row
                var heightMinusOne = height - 1;
                var i = 0;
                for (; i < wRowBytes; ++i) {
                    toPixels[i] = fromPixels[i];
                }

                // interior rows
                var end, mLat, mRow;
                var j = 1;
                for (; j < heightMinusOne; ++j, currentWLat -= deltaWLat) {
                    sinTheta = Math.sin(currentWLat);
                    mLat = 0.5 * Math.log((1.0 + sinTheta) / (1.0 - sinTheta));
                    mRow = Math.floor(heightMinusOne - ((heightMinusOne * (mLat - minMLat) * invMLatDim)));
                    end = i + wRowBytes;
                    for ( var k = 0; i < end; ++i, ++k) {
                        toPixels[i] = fromPixels[mRow * wRowBytes + k];
                    }
                }

                // last row
                end = i + wRowBytes;
                for (j = 0; i < end; ++i, ++j) {
                    toPixels[i] = fromPixels[i];
                }

                // paint new image to canvas
                context.putImageData(newImageData, 0, 0);

                return canvas;
            }
        })
    };

    return Projections;
});
/*global define*/
define('Scene/OpenStreetMapTileProvider',[
        '../Core/DeveloperError',
        '../Core/Extent',
        '../Core/Math',
        './Projections'
    ], function(
        DeveloperError,
        Extent,
        CesiumMath,
        Projections) {
    

    /**
     * Provides tile images hosted by OpenStreetMap.
     *
     * @alias OpenStreetMapTileProvider
     * @constructor
     *
     * @param {String} description.url The OpenStreetMap url.
     * @param {String} [description.fileExtension='png'] The file extension for images on the server.
     * @param {Object} [description.proxy=undefined] A proxy to use for requests. This object is expected to have a getURL function which returns the proxied URL.
     * @param {String} [description.credit='MapQuest, Open Street Map and contributors, CC-BY-SA'] A string crediting the data source, which is displayed on the canvas.
     *
     * @see SingleTileProvider
     * @see BingMapsTileProvider
     * @see ArcGISTileProvider
     * @see CompositeTileProvider
     *
     * @see <a href='http://wiki.openstreetmap.org/wiki/Main_Page'>OpenStreetMap Wiki</a>
     * @see <a href='http://www.w3.org/TR/cors/'>Cross-Origin Resource Sharing</a>
     *
     * @example
     * // OpenStreetMap tile provider
     * var osm = new OpenStreetMapTileProvider({
     *     url : 'http://tile.openstreetmap.org/'
     * });
     */
    var OpenStreetMapTileProvider = function(description) {
        var desc = description || {};

        this._url = desc.url || 'http://tile.openstreetmap.org/';
        this._fileExtension = desc.fileExtension || 'png';

        /**
         * A proxy to use for requests. This object is expected to have a getURL function which returns the proxied URL.
         * @type {Object}
         */
        this._proxy = desc.proxy;

        this._credit = desc.credit || 'MapQuest, Open Street Map and contributors, CC-BY-SA';

        // TODO: should not hard-code, get from server?

        /**
         * The cartographic extent of the base tile, with north, south, east and
         * west properties in radians.
         *
         * @type {Extent}
         */
        this.maxExtent = new Extent(
            -CesiumMath.PI,
            CesiumMath.toRadians(-85.05112878),
            CesiumMath.PI,
            CesiumMath.toRadians(85.05112878)
        );

        /**
         * The width of every image loaded.
         *
         * @type {Number}
         */
        this.tileWidth = 256;

        /**
         * The height of every image loaded.
         *
         * @type {Number}
         */
        this.tileHeight = 256;

        /**
         * The maximum zoom level that can be requested.
         *
         * @type {Number}
         */
        this.zoomMax = 18;

        /**
         * The minimum zoom level that can be requested.
         *
         * @type {Number}
         */
        this.zoomMin = 0;

        /**
         * The map projection of the image.
         *
         * @type {Enumeration}
         * @see Projections
         */
        this.projection = Projections.MERCATOR;

        this._logo = undefined;
    };

    /**
     * Loads the image for <code>tile</code>.
     *
     * @memberof OpenStreetMapTileProvider
     *
     * @param {Tile} tile The tile to load the image for.
     * @param {Function} onload A function that will be called when the image is finished loading.
     * @param {Function} onerror A function that will be called if there is an error loading the image.
     *
     * @exception {DeveloperError} <code>tile.zoom</code> is less than <code>zoomMin</code>
     * or greater than <code>zoomMax</code>.
     */
    OpenStreetMapTileProvider.prototype.loadTileImage = function(tile, onload, onerror) {
        if (tile.zoom < this.zoomMin || tile.zoom > this.zoomMax) {
            throw new DeveloperError('tile.zoom must be between in [zoomMin, zoomMax].');
        }

        var image = new Image();
        image.onload = onload;
        image.onerror = onerror;
        image.crossOrigin = '';

        var url = this._url + tile.zoom + '/' + tile.x + '/' + tile.y + '.' + this._fileExtension;
        if (typeof this._proxy !== 'undefined') {
            url = this._proxy.getURL(url);
        }

        image.src = url;

        return image;
    };

    /**
     * DOC_TBA
     * @memberof OpenStreetMapTileProvider
     */
    OpenStreetMapTileProvider.prototype.getLogo = function() {
        if (!this._logo) {
            var canvas = document.createElement('canvas');
            canvas.width = 800.0;
            canvas.height = 20.0;

            var context = canvas.getContext('2d');
            context.fillStyle = '#fff';
            context.font = '12px sans-serif';
            context.textBaseline = 'top';
            context.fillText(this._credit, 0, 0);

            this._logo = canvas;
        }

        return this._logo;
    };

    return OpenStreetMapTileProvider;
});
/*global define*/
define('Scene/SceneMode',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * DOC_TBA
     *
     * @exports SceneMode
     */
    var SceneMode = {
        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        SCENE2D : new Enumeration(0, 'SCENE2D', {
            morphTime : 0.0
        }),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        COLUMBUS_VIEW : new Enumeration(1, 'COLUMBUS_VIEW', {
            morphTime : 0.0
        }),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        SCENE3D : new Enumeration(2, 'SCENE3D', {
            morphTime : 1.0
        }),

        /**
         * DOC_TBA
         *
         * @constant
         * @type {Enumeration}
         */
        MORPHING : new Enumeration(3, 'MORPHING')
    };

    return SceneMode;
});
/*global define*/
define('Scene/SceneState',[], function() {
    

    /**
     * State information about the current scene.  An instance of this class
     * is provided to update functions.
     *
     * @alias SceneState
     * @constructor
     */
    var SceneState = function() {
        /**
         * The current mode of the scene.
         *
         * @type SceneMode
         */
        this.mode = undefined;

        this.scene2D = {
            /**
             * The projection to use in 2D mode.
             */
            projection : undefined
        };

        /**
         * The current camera.
         */
        this.camera = undefined;
    };

    return SceneState;
});
/*global define*/
define('Scene/SingleTileProvider',[
        '../Core/DeveloperError',
        '../Core/Extent',
        '../Core/Math',
        './Projections'
    ], function(
        DeveloperError,
        Extent,
        CesiumMath,
        Projections) {
    

    /**
     * Provides a single, top-level tile.
     *
     * @alias SingleTileProvider
     * @constructor
     *
     * @param {String} url The url for the tile.
     * @param {Object} [proxy=undefined] A proxy to use for requests. This object is expected to have a getURL function which returns the proxied URL, if needed.
     *
     * @exception {DeveloperError} url is required.
     *
     * @see ArcGISTileProvider
     * @see BingMapsTileProvider
     * @see OpenStreetMapTileProvider
     * @see CompositeTileProvider
     */
    var SingleTileProvider = function(url, proxy) {
        if (typeof url === 'undefined') {
            throw new DeveloperError('url is required.');
        }

        this._url = url;
        this._proxy = proxy;

        /**
         * The cartographic extent of the base tile, with north, south, east and
         * west properties in radians.
         *
         * @constant
         * @type {Extent}
         */
        this.maxExtent = new Extent(
            -CesiumMath.PI,
            -CesiumMath.PI_OVER_TWO,
            CesiumMath.PI,
            CesiumMath.PI_OVER_TWO
        );

        /**
         * The maximum zoom level that can be requested.
         *
         * @constant
         * @type {Number}
         */
        this.zoomMax = 0;

        /**
         * The minimum zoom level that can be requested.
         *
         * @constant
         * @type {Number}
         */
        this.zoomMin = 0;

        /**
         * The map projection of the image.
         *
         * @type {Enumeration}
         * @see Projections
         */
        this.projection = Projections.WGS84;
    };

    /**
     * Loads the top-level tile.
     *
     * @memberof SingleTileProvider
     *
     * @param {Tile} tile The top-level tile.
     * @param {Function} onload A function that will be called when the image is finished loading.
     * @param {Function} onerror A function that will be called if there is an error loading the image.
     *
     * @exception {DeveloperError} <code>tile.zoom</code> is less than <code>zoomMin</code>
     * or greater than <code>zoomMax</code>.
     */
    SingleTileProvider.prototype.loadTileImage = function(tile, onload, onerror) {
        if (tile.zoom < this.zoomMin || tile.zoom > this.zoomMax) {
            throw new DeveloperError('tile.zoom must be between in [zoomMin, zoomMax].');
        }

        var image = new Image();
        image.onload = onload;
        image.onerror = onerror;
        image.crossOrigin = '';

        var url = this._url;
        if (typeof this._proxy !== 'undefined') {
            url = this._proxy.getURL(url);
        }
        image.src = url;

        return image;
    };

    return SingleTileProvider;
});
/*global define*/
define('Scene/SolidColorTileProvider',[
        '../Core/DeveloperError',
        '../Core/Extent',
        '../Core/Math',
        './Projections'
    ], function(
        DeveloperError,
        Extent,
        CesiumMath,
        Projections) {
    

    /**
     * Provides tile images with a different solid color for each zoom level.
     * Useful for debugging or testing different {@link CentralBody} options.
     *
     * @alias SolidColorTileProvider
     * @constructor
     *
     * @param {Number} [maxZoom=23] The maximum zoom level to generate tiles.
     *
     * @see SingleTileProvider
     * @see BingMapsTileProvider
     * @see OpenStreetMapTileProvider
     * @see CompositeTileProvider
     */
    var SolidColorTileProvider = function(maxZoom) {
        var width = 256;
        var height = 256;
        maxZoom = maxZoom || 23;

        this._images = [];
        for (var i = 0; i <= maxZoom; ++i) {
            var color = { r : 0, g : 0, b : 0 };
            var x = i / maxZoom;
            if (x < 0.25) {
                // blue to cyan
                color.g = Math.floor(255.0 * 4.0 * x);
                color.b = 255;
            } else if (x < 0.5) {
                // cyan to green
                color.g = 255;
                color.b = Math.floor(256.0 - 4.0 * x);
            } else if (x < 0.75) {
                // green to yellow
                color.r = Math.floor(255.0 * 4.0 * x - 255.0 * 2.0);
                color.g = 255;
            } else {
                // yellow to red
                color.r = 255;
                color.g = Math.floor(255.0 * 4.0 * (1.0 - x));
            }
            this._images.push(this._createImage(color, width, height));
        }

        /**
         * The cartographic extent of the base tile, with north, south, east and
         * west properties in radians.
         *
         * @type {Extent}
         */
        this.maxExtent = new Extent(
            -CesiumMath.PI,
            -CesiumMath.PI_OVER_TWO,
            CesiumMath.PI,
            CesiumMath.PI_OVER_TWO
        );

        /**
         * The width of every image loaded.
         *
         * @type {Number}
         */
        this.tileWidth = width;

        /**
         * The height of every image loaded.
         *
         * @type {Number}
         */
        this.tileHeight = height;

        /**
         * The maximum zoom level that can be requested.
         *
         * @type {Number}
         */
        this.zoomMax = maxZoom;

        /**
         * The minimum zoom level that can be requested.
         *
         * @type {Number}
         */
        this.zoomMin = 0;

        /**
         * The map projection of the image.
         *
         * @type {Enumeration}
         * @see Projections
         */
        this.projection = Projections.WGS84;
    };

    SolidColorTileProvider.prototype._createImage = function(color, width, height) {
        var canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;

        var context = canvas.getContext('2d');
        context.fillStyle = 'rgba(' + color.r + ', ' + color.g + ', ' + color.b + ', 1.0)';
        context.fillRect(0, 0, width, height);

        return canvas;
    };

    /**
     * Loads the image for <code>tile</code>.
     *
     * @memberof SolidColorTileProvider
     *
     * @param {Tile} tile The tile to load the image for.
     * @param {Function} onload A function that will be called when the image is finished loading.
     * @param {Function} onerror A function that will be called if there is an error loading the image.
     *
     * @exception {DeveloperError} <code>tile.zoom</code> must be in [<code>zoomMin</code>, <code>zoomMax</code>].
     */
    SolidColorTileProvider.prototype.loadTileImage = function(tile, onload, onerror) {
        if (tile.zoom < this.zoomMin || tile.zoom > this.zoomMax) {
            throw new DeveloperError('tile.zoom must be in [zoomMin, zoomMax].');
        }

        if (typeof onload === 'function') {
            onload();
        }

        return this._images[tile.zoom];
    };

    return SolidColorTileProvider;
});
/*global define*/
define('Scene/Texture2DPool',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Renderer/PixelDatatype',
        '../Renderer/PixelFormat',
        '../Renderer/Texture'
    ], function(
        DeveloperError,
        destroyObject,
        PixelDatatype,
        PixelFormat,
        Texture) {
    

    function PooledTexture(texture, textureTypeKey, pool) {
        this._texture = texture;
        this._textureTypeKey = textureTypeKey;
        this._pool = pool;
    }

    //pass through all methods to the underlying texture
    Object.keys(Texture.prototype).forEach(function(methodName) {
        PooledTexture.prototype[methodName] = function() {
            var texture = this._texture;
            return texture[methodName].apply(texture, arguments);
        };
    });

    //except for destroy, which releases back into the pool
    PooledTexture.prototype.destroy = function() {
        var freeList = this._pool._free[this._textureTypeKey];
        if (typeof freeList === 'undefined') {
            freeList = this._pool._free[this._textureTypeKey] = [];
        }
        freeList.push(this);
    };

    /**
     * A pool of textures.  Textures created from the pool will be released back into the pool
     * when destroy() is called, so future calls to create may re-use a released texture.
     * <br/><br/>
     * Texture pools are useful when textures are being created and destroyed repeatedly.
     *
     * @alias Texture2DPool
     * @constructor
     *
     * @param {Context} context The context to use to create textures when needed.
     *
     * @see Texture
     */
    var Texture2DPool = function(context) {
        if (typeof context === 'undefined') {
            throw new DeveloperError('context is required.');
        }

        this._context = context;
        this._free = {};
    };

    /**
     * Create a texture.  This function takes the same arguments as {@link Context#createTexture2D},
     * but may return a pooled texture if there are any available.  If a pooled texture is re-used,
     * and no source is provided, the new texture will still retain its old contents.
     *
     * @memberof Texture2DPool
     *
     * @exception {DeveloperError} description is required.
     *
     * @see Context#createTexture2D
     */
    Texture2DPool.prototype.createTexture2D = function(description) {
        if (!description) {
            throw new DeveloperError('description is required.');
        }

        var source = description.source;
        var width = typeof source !== 'undefined' ? source.width : description.width;
        var height = typeof source !== 'undefined' ? source.height : description.height;
        //coerce values to primitive numbers to make textureTypeKey smaller.
        var pixelFormat = +(description.pixelFormat || PixelFormat.RGBA);
        var pixelDatatype = +(description.pixelDatatype || PixelDatatype.UNSIGNED_BYTE);
        var preMultiplyAlpha = +(description.preMultiplyAlpha || pixelFormat === PixelFormat.RGB || pixelFormat === PixelFormat.LUMINANCE);

        var textureTypeKey = JSON.stringify([width, height, pixelFormat, pixelDatatype, preMultiplyAlpha]);

        var freeList = this._free[textureTypeKey];
        if (typeof freeList !== 'undefined' && freeList.length > 0) {
            var texture = freeList.pop();
            if (typeof source !== 'undefined') {
                texture.copyFrom(source);
            }
            return texture;
        }

        return new PooledTexture(this._context.createTexture2D(description), textureTypeKey, this);
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof Texture2DPool
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see Texture2DPool#destroy
     */
    Texture2DPool.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof Texture2DPool
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see Texture2DPool#isDestroyed
     *
     * @example
     * pool = pool && pool.destroy();
     */
    Texture2DPool.prototype.destroy = function() {
        var free = this._free;
        Object.keys(free).forEach(function(textureTypeKey) {
            free[textureTypeKey].forEach(function(texture) {
                texture._texture.destroy();
            });
        });
        return destroyObject(this);
    };

    return Texture2DPool;
});
/*global define*/
define('Scene/Tile',[
        '../Core/DeveloperError',
        '../Core/Math',
        '../Core/Ellipsoid',
        '../Core/Extent'
    ], function(
        DeveloperError,
        CesiumMath,
        Ellipsoid,
        Extent) {
    

    /**
     * A single piece of a uniformly subdivided image mapped to the surface of an ellipsoid.
     *
     * @alias Tile
     * @constructor
     *
     * @param {Extent} description.extent The cartographic extent of the tile, with north, south, east and
     * west properties in radians.
     * @param {Number} description.x The tile x coordinate.
     * @param {Number} description.y The tile y coordinate.
     * @param {Number} description.zoom The tile zoom level.
     * @param {Ellipsoid} description.ellipsoid The ellipsoid whose surface the tile is on. Defaults to
     * a WGS84 ellipsoid.
     * @param {Tile} description.parent The parent of this tile in a tile tree system.
     *
     * @exception {DeveloperError} Either description.extent or both description.x and description.y is required.
     * @exception {DeveloperError} description.zoom is required.
     *
     * @see SingleTileProvider
     * @see ArcGISTileProvider
     * @see OpenStreetMapTileProvider
     * @see BingMapsTileProvider
     */
    var Tile = function(description) {
        if (!description) {
            throw new DeveloperError('description is required.');
        }

        if (typeof description.extent === 'undefined' &&
            (typeof description.x === 'undefined' || typeof description.y === 'undefined')) {
            throw new DeveloperError('Either description.extent is required or description.x and description.y are required.');
        }

        if (typeof description.zoom === 'undefined' || description.zoom < 0) {
            throw new DeveloperError('description.zoom is required an must be greater than zero.');
        }

        /**
         * The ellipsoid whose surface this tile is on.
         *
         * @type Ellipsoid
         */
        this.ellipsoid = description.ellipsoid || Ellipsoid.WGS84;

        /**
         * The cartographic extent of the tile, with north, south, east and
         * west properties in radians.
         *
         * @type Extent
         */
        this.extent = undefined;

        /**
         * The x coordinate.
         *
         * @type Number
         */
        this.x = undefined;

        /**
         * The y coordinate.
         *
         * @type Number
         */
        this.y = undefined;

        /**
         * The zoom level.
         *
         * @type Number
         */
        this.zoom = undefined;

        /**
         * The parent of this tile in a tile tree system.
         *
         * @type Tile
         */
        this.parent = description.parent;

        /**
         * The children of this tile in a tile tree system.
         *
         * @type Array
         */
        this.children = undefined;

        this.zoom = description.zoom;
        if (typeof description.extent !== 'undefined') {
            this.extent = description.extent;
            var coords = Tile.extentToTileXY(this.extent, this.zoom);
            this.x = coords.x;
            this.y = coords.y;
        } else {
            this.x = description.x;
            this.y = description.y;

            if (this.x < 0 || this.y < 0) {
                throw new DeveloperError('description.x and description.y must be greater than zero.');
            }

            this.extent = Tile.tileXYToExtent(this.x, this.y, this.zoom);
        }

        this._boundingSphere3D = undefined;
        this._occludeePoint = undefined;

        this._projection = undefined;
        this._boundingSphere2D = undefined;
        this._boundingRectangle = undefined;
    };

    /**
     * Converts an extent and zoom level into tile x, y coordinates.
     *
     * @memberof Tile
     *
     * @param {Extent} extent The cartographic extent of the tile, with north, south, east and
     * west properties in radians.
     * @param {Number} zoom The tile zoom level.
     *
     * @return {Object} An object with x and y properties.
     */
    Tile.extentToTileXY = function(extent, zoom) {
        var result = {};

        var sinN = Math.sin(extent.north);
        var k = CesiumMath.TWO_PI - Math.log((1.0 + sinN) / (1.0 - sinN));
        result.y = k * (1 << zoom) / (4.0 * Math.PI);
        result.y = Math.round(result.y);

        k = 1.0 << (zoom - 1.0);
        result.x = (extent.west + Math.PI) * k / Math.PI;
        result.x = Math.round(result.x);

        return result;
    };

    /**
     * Converts tile x, y coordinates and zoom to a cartographic extent.
     *
     * @memberof Tile
     *
     * @param {Number} x The x coordinate.
     * @param {Number} y The y coordinate.
     * @param {Number} zoom The tile zoom level.
     *
     * @return {Extent} The cartographic extent of the tile, with north, south, east and
     * west properties in radians.
     */
    Tile.tileXYToExtent = function(x, y, zoom) {
        if (x === 0 && y === 0 && zoom === 0) {
            return new Extent(
                -CesiumMath.PI,
                CesiumMath.toRadians(-85.05112878),
                CesiumMath.PI,
                CesiumMath.toRadians(85.05112878)
            );
        }

        // Lat
        var invZoom = 4.0 * Math.PI / (1 << zoom);
        var k = Math.exp(CesiumMath.TWO_PI - (y * invZoom));
        var north = Math.asin((k - 1.0) / (k + 1.0));
        k = Math.exp(CesiumMath.TWO_PI - ((y + 1) * invZoom));
        var south = Math.asin((k - 1.0) / (k + 1.0));

        // Lon
        invZoom = Math.PI / (1 << (zoom - 1.0));
        var west = x * invZoom - Math.PI;
        var east = (x + 1.0) * invZoom - Math.PI;

        return new Extent(west, south, east, north);
    };

    /**
     * Returns an array of tiles that would be at the next level of the tile tree.
     *
     * @memberof Tile
     *
     * @return {Array} The list of child tiles.
     */
    Tile.prototype.getChildren = function() {
        if (!this.children) {
            this.children = [];
            this.children.push(new Tile({
                x : this.x << 1,
                y : this.y << 1,
                zoom : this.zoom + 1,
                parent : this
            }));
            this.children.push(new Tile({
                x : this.x << 1 | 1,
                y : this.y << 1,
                zoom : this.zoom + 1,
                parent : this
            }));
            this.children.push(new Tile({
                x : this.x << 1,
                y : this.y << 1 | 1,
                zoom : this.zoom + 1,
                parent : this
            }));
            this.children.push(new Tile({
                x : this.x << 1 | 1,
                y : this.y << 1 | 1,
                zoom : this.zoom + 1,
                parent : this
            }));
        }
        return this.children;
    };

    Tile.prototype.computeMorphBounds = function(morphTime, projection) {
        return Extent.computeMorphBoundingSphere(this.extent, this.ellipsoid, morphTime, projection);
    };

    /**
     * The bounding sphere for the geometry.
     *
     * @memberof Tile
     *
     * @return {BoundingSphere} The bounding sphere.
     */
    Tile.prototype.get3DBoundingSphere = function() {
        if (!this._boundingSphere3D) {
            this._boundingSphere3D = Extent.compute3DBoundingSphere(this.extent, this.ellipsoid);
        }
        return this._boundingSphere3D;
    };

    /**
     * A point that when visible means the geometry for this tile is visible.
     *
     * @memberof Tile
     *
     * @return {Cartesian3} The occludee point or undefined.
     */
    Tile.prototype.getOccludeePoint = function() {
        if (!this._occludeePoint) {
            this._occludeePoint = Extent.computeOccludeePoint(this.extent, this.ellipsoid);
        }
        return ((this._occludeePoint.valid) ? this._occludeePoint.occludeePoint : undefined);
    };

    Tile.prototype._compute2DBounds = function(projection) {
        if (typeof projection !== 'undefined' && this._projection !== projection) {
            this._boundingRectangle = Extent.computeBoundingRectangle(this.extent, projection);
            this._boundingSphere2D = Extent.compute2DBoundingSphere(this.extent, projection);

            this._projection = projection;
        }
    };

    /**
     * The bounding sphere for the geometry when the extent is projected onto a surface that is displayed in 3D.
     *
     * @memberof Tile
     *
     * @return {BoundingSphere} The bounding sphere.
     */
    Tile.prototype.get2DBoundingSphere = function(projection) {
        this._compute2DBounds(projection);
        return this._boundingSphere2D;
    };

    /**
     * The bounding rectangle for when the tile is projected onto a surface that is displayed in 2D.
     *
     * @memberof Tile
     *
     * @return {Rectangle} The bounding rectangle.
     */
    Tile.prototype.get2DBoundingRectangle = function(projection) {
        this._compute2DBounds(projection);
        return this._boundingRectangle;
    };

    /**
     * Returns a unique id from the x, y coordinates and zoom level.
     *
     * @memberof Tile
     *
     * @return {String} The unique id.
     */
    Tile.prototype.getKey = function() {
        return 'x_' + this.x + '_y_' + this.y + '_z_' + this.zoom;
    };

    return Tile;
});
/*global define*/
define('Scene/TileState',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * @private
     */
    var TileState = {
        READY : new Enumeration(0, 'READY'),
        IMAGE_LOADING : new Enumeration(1, 'IMAGE_LOADING'),
        IMAGE_LOADED : new Enumeration(2, 'IMAGE_LOADED'),
        IMAGE_FAILED : new Enumeration(3, 'IMAGE_FAILED'),
        IMAGE_INVALID : new Enumeration(4, 'IMAGE_INVALID'),
        REPROJECTING : new Enumeration(5, 'REPROJECTING'),
        REPROJECTED : new Enumeration(6, 'REPROJECTED'),
        TEXTURE_LOADING : new Enumeration(7, 'TEXTURE_LOADING'),
        TEXTURE_LOADED : new Enumeration(8, 'TEXTURE_LOADED')
    };

    return TileState;
});
/*global define*/
define('Scene/VerticalOrigin',['../Core/Enumeration'], function(Enumeration) {
    

    /**
     * The vertical location of an origin relative to an object, e.g., a {@link Billboard}.
     * For example, the vertical origin is used to display a billboard above or below (in
     * screen space) of the actual position.
     *
     * @exports VerticalOrigin
     *
     * @see Billboard#setVerticalOrigin
     */
    var VerticalOrigin = {
        /**
         * The origin is at the vertical center of the object.
         *
         * @constant
         * @type {Enumeration}
         */
        CENTER : new Enumeration(0, 'CENTER'),
        /**
         * The origin is at the bottom of the object.
         *
         * @constant
         * @type {Enumeration}
         */
        BOTTOM : new Enumeration(1, 'BOTTOM'),
        /**
         * The origin is at the top of the object.
         *
         * @constant
         * @type {Enumeration}
         */
        TOP : new Enumeration(-1, 'TOP')
    };

    return VerticalOrigin;
});
/*global define*/
define('DynamicScene/CzmlVerticalOrigin',[
        '../Scene/VerticalOrigin'
       ], function(
         VerticalOrigin) {
    

    /**
     * Provides methods for working with a vertical origin defined in CZML.
     *
     * @exports CzmlVerticalOrigin
     *
     * @see VerticalOrigin
     * @see DynamicProperty
     * @see CzmlBoolean
     * @see CzmlCartesian2
     * @see CzmlCartesian3
     * @see CzmlCartographic
     * @see CzmlColor
     * @see CzmlHorizontalOrigin
     * @see CzmlLabelStyle
     * @see CzmlNumber
     * @see CzmlString
     * @see CzmlUnitCartesian3
     * @see CzmlUnitQuaternion
     * @see CzmlUnitSpherical
     */
    var CzmlVerticalOrigin = {
        /**
         * Returns the packed enum representation contained within the provided CZML interval
         * or undefined if the interval does not contain enum data.
         *
         * @param {Object} czmlInterval The CZML interval to unwrap.
         */
        unwrapInterval : function(czmlInterval) {
            var result = czmlInterval.verticalOrigin;
            return typeof result === 'undefined' ? czmlInterval : result;
        },

        /**
         * Since enums can not be sampled, this method always returns false.
         */
        isSampled : function() {
            return false;
        },

        /**
         * Returns the VerticalOrigin contained within the unwrappedInterval.
         *
         * @param {Object} unwrappedInterval The result of CzmlVerticalOrigin.unwrapInterval.
         * @returns The VerticalOrigin value.
         */
        getValue : function(unwrappedInterval) {
            return VerticalOrigin[unwrappedInterval];
        }
    };

    return CzmlVerticalOrigin;
});
/*global define*/
define('DynamicScene/DynamicLabel',[
        '../Core/TimeInterval',
        './CzmlBoolean',
        './CzmlCartesian2',
        './CzmlCartesian3',
        './CzmlNumber',
        './CzmlString',
        './CzmlHorizontalOrigin',
        './CzmlVerticalOrigin',
        './CzmlLabelStyle',
        './CzmlColor',
        './DynamicProperty'
       ], function(
        TimeInterval,
        CzmlBoolean,
        CzmlCartesian2,
        CzmlCartesian3,
        CzmlNumber,
        CzmlString,
        CzmlHorizontalOrigin,
        CzmlVerticalOrigin,
        CzmlLabelStyle,
        CzmlColor,
        DynamicProperty) {
    

    /**
     * Represents a time-dynamic label, typically used in conjunction with DynamicLabelVisualizer and
     * DynamicObjectCollection to visualize CZML.
     *
     * @alias DynamicLabel
     * @constructor
     *
     * @see DynamicObject
     * @see DynamicProperty
     * @see DynamicObjectCollection
     * @see DynamicLabelVisualizer
     * @see VisualizerCollection
     * @see Label
     * @see LabelCollection
     * @see CzmlDefaults
     */
    var DynamicLabel = function() {
        /**
         * A DynamicProperty of type CzmlString which determines the label's text.
         */
        this.text = undefined;
        /**
         * A DynamicProperty of type CzmlString which determines the label's font.
         */
        this.font = undefined;
        /**
         * A DynamicProperty of type CzmlLabelStyle which determines the label's style.
         */
        this.style = undefined;
        /**
         * A DynamicProperty of type CzmlColor which determines the label's fill color.
         */
        this.fillColor = undefined;
        /**
         * A DynamicProperty of type CzmlColor which determines the label's outline color.
         */
        this.outlineColor = undefined;
        /**
         * A DynamicProperty of type CzmlHorizontalOrigin which determines the label's horizontal origin.
         */
        this.horizontalOrigin = undefined;
        /**
         * A DynamicProperty of type CzmlVerticalOrigin which determines the label's vertical origin.
         */
        this.verticalOrigin = undefined;
        /**
         * A DynamicProperty of type CzmlCartesian3 which determines the label's eye offset.
         */
        this.eyeOffset = undefined;
        /**
         * A DynamicProperty of type CzmlCartesian2 which determines the label's pixel offset.
         */
        this.pixelOffset = undefined;
        /**
         * A DynamicProperty of type CzmlNumber which determines the label's scale.
         */
        this.scale = undefined;
        /**
         * A DynamicProperty of type CzmlBoolean which determines the label's visibility.
         */
        this.show = undefined;
    };

    /**
     * Processes a single CZML packet and merges its data into the provided DynamicObject's label.
     * If the DynamicObject does not have a label, one is created.  This method is not
     * normally called directly, but is part of the array of CZML processing functions that is
     * passed into the DynamicObjectCollection constructor.
     *
     * @param {DynamicObject} dynamicObject The DynamicObject which will contain the label data.
     * @param {Object} packet The CZML packet to process.
     * @returns {Boolean} true if any new properties were created while processing the packet, false otherwise.
     *
     * @see DynamicObject
     * @see DynamicProperty
     * @see DynamicObjectCollection
     * @see CzmlDefaults#updaters
     */
    DynamicLabel.processCzmlPacket = function(dynamicObject, packet) {
        var labelData = packet.label;
        if (typeof labelData === 'undefined') {
            return false;
        }

        var labelUpdated = false;
        var label = dynamicObject.label;
        labelUpdated = typeof label === 'undefined';
        if (labelUpdated) {
            dynamicObject.label = label = new DynamicLabel();
        }

        var interval = labelData.interval;
        if (typeof interval !== 'undefined') {
            interval = TimeInterval.fromIso8601(interval);
        }

        if (typeof labelData.fillColor !== 'undefined') {
            var fillColor = label.fillColor;
            if (typeof fillColor === 'undefined') {
                label.fillColor = fillColor = new DynamicProperty(CzmlColor);
                labelUpdated = true;
            }
            fillColor.processCzmlIntervals(labelData.fillColor, interval);
        }

        if (typeof labelData.outlineColor !== 'undefined') {
            var outlineColor = label.outlineColor;
            if (typeof outlineColor === 'undefined') {
                label.outlineColor = outlineColor = new DynamicProperty(CzmlColor);
                labelUpdated = true;
            }
            outlineColor.processCzmlIntervals(labelData.outlineColor, interval);
        }

        if (typeof labelData.eyeOffset !== 'undefined') {
            var eyeOffset = label.eyeOffset;
            if (typeof eyeOffset === 'undefined') {
                label.eyeOffset = eyeOffset = new DynamicProperty(CzmlCartesian3);
                labelUpdated = true;
            }
            eyeOffset.processCzmlIntervals(labelData.eyeOffset, interval);
        }

        if (typeof labelData.horizontalOrigin !== 'undefined') {
            var horizontalOrigin = label.horizontalOrigin;
            if (typeof horizontalOrigin === 'undefined') {
                label.horizontalOrigin = horizontalOrigin = new DynamicProperty(CzmlHorizontalOrigin);
                labelUpdated = true;
            }
            horizontalOrigin.processCzmlIntervals(labelData.horizontalOrigin, interval);
        }

        if (typeof labelData.text !== 'undefined') {
            var text = label.text;
            if (typeof text === 'undefined') {
                label.text = text = new DynamicProperty(CzmlString);
                labelUpdated = true;
            }
            text.processCzmlIntervals(labelData.text, interval);
        }

        if (typeof labelData.pixelOffset !== 'undefined') {
            var pixelOffset = label.pixelOffset;
            if (typeof pixelOffset === 'undefined') {
                label.pixelOffset = pixelOffset = new DynamicProperty(CzmlCartesian2);
                labelUpdated = true;
            }
            pixelOffset.processCzmlIntervals(labelData.pixelOffset, interval);
        }

        if (typeof labelData.scale !== 'undefined') {
            var scale = label.scale;
            if (typeof scale === 'undefined') {
                label.scale = scale = new DynamicProperty(CzmlNumber);
                labelUpdated = true;
            }
            scale.processCzmlIntervals(labelData.scale, interval);
        }

        if (typeof labelData.show !== 'undefined') {
            var show = label.show;
            if (typeof show === 'undefined') {
                label.show = show = new DynamicProperty(CzmlBoolean);
                labelUpdated = true;
            }
            show.processCzmlIntervals(labelData.show, interval);
        }

        if (typeof labelData.verticalOrigin !== 'undefined') {
            var verticalOrigin = label.verticalOrigin;
            if (typeof verticalOrigin === 'undefined') {
                label.verticalOrigin = verticalOrigin = new DynamicProperty(CzmlVerticalOrigin);
                labelUpdated = true;
            }
            verticalOrigin.processCzmlIntervals(labelData.verticalOrigin, interval);
        }

        if (typeof labelData.font !== 'undefined') {
            var font = label.font;
            if (typeof font === 'undefined') {
                label.font = font = new DynamicProperty(CzmlString);
                labelUpdated = true;
            }
            font.processCzmlIntervals(labelData.font, interval);
        }

        if (typeof labelData.style !== 'undefined') {
            var style = label.style;
            if (typeof style === 'undefined') {
                label.style = style = new DynamicProperty(CzmlLabelStyle);
                labelUpdated = true;
            }
            style.processCzmlIntervals(labelData.style, interval);
        }
        return labelUpdated;
    };

    /**
     * Given two DynamicObjects, takes the label properties from the second
     * and assigns them to the first, assuming such a property did not already exist.
     * This method is not normally called directly, but is part of the array of CZML processing
     * functions that is passed into the CompositeDynamicObjectCollection constructor.
     *
     * @param {DynamicObject} targetObject The DynamicObject which will have properties merged onto it.
     * @param {DynamicObject} objectToMerge The DynamicObject containing properties to be merged.
     *
     * @see CzmlDefaults
     */
    DynamicLabel.mergeProperties = function(targetObject, objectToMerge) {
        var labelToMerge = objectToMerge.label;
        if (typeof labelToMerge !== 'undefined') {

            var targetLabel = targetObject.label;
            if (typeof targetLabel === 'undefined') {
                targetObject.label = targetLabel = new DynamicLabel();
            }

            targetLabel.text = targetLabel.text || labelToMerge.text;
            targetLabel.font = targetLabel.font || labelToMerge.font;
            targetLabel.show = targetLabel.show || labelToMerge.show;
            targetLabel.style = targetLabel.style || labelToMerge.style;
            targetLabel.fillColor = targetLabel.fillColor || labelToMerge.fillColor;
            targetLabel.outlineColor = targetLabel.outlineColor || labelToMerge.outlineColor;
            targetLabel.scale = targetLabel.scale || labelToMerge.scale;
            targetLabel.horizontalOrigin = targetLabel.horizontalOrigin || labelToMerge.horizontalOrigin;
            targetLabel.verticalOrigin = targetLabel.verticalOrigin || labelToMerge.verticalOrigin;
            targetLabel.eyeOffset = targetLabel.eyeOffset || labelToMerge.eyeOffset;
            targetLabel.pixelOffset = targetLabel.pixelOffset || labelToMerge.pixelOffset;
        }
    };

    /**
     * Given a DynamicObject, undefines the label associated with it.
     * This method is not normally called directly, but is part of the array of CZML processing
     * functions that is passed into the CompositeDynamicObjectCollection constructor.
     *
     * @param {DynamicObject} dynamicObject The DynamicObject to remove the label from.
     *
     * @see CzmlDefaults
     */
    DynamicLabel.undefineProperties = function(dynamicObject) {
        dynamicObject.label = undefined;
    };

    return DynamicLabel;
});
/*global define*/
define('Scene/Billboard',[
        '../Core/DeveloperError',
        '../Core/shallowEquals',
        '../Core/Color',
        '../Core/Cartesian2',
        '../Core/Cartesian3',
        '../Core/Cartesian4',
        './HorizontalOrigin',
        './VerticalOrigin'
    ], function(
        DeveloperError,
        shallowEquals,
        Color,
        Cartesian2,
        Cartesian3,
        Cartesian4,
        HorizontalOrigin,
        VerticalOrigin) {
    

    /**
     * A viewport-aligned image positioned in the 3D scene, that is created
     * and rendered using a {@link BillboardCollection}.  A billboard is created and its initial
     * properties are set by calling {@link BillboardCollection#add}.  Any of the billboard's
     * properties can be changed at any time by calling the billboard's corresponding
     * <code>set</code> function, e.g., {@link Billboard#setShow}.
     * <br /><br />
     * <div align='center'>
     * <img src='images/Billboard.png' width='400' height='300' /><br />
     * Example billboards
     * </div>
     *
     * @alias Billboard
     *
     * @performance Calling any <code>get</code> function, e.g., {@link Billboard#getShow}, is constant time.
     * Calling a <code>set</code> function, e.g., {@link Billboard#setShow}, is constant time but results in
     * CPU to GPU traffic when {@link BillboardCollection#update} is called.  The per-billboard traffic is
     * the same regardless of how many properties were updated.  If most billboards in a collection need to be
     * updated, it may be more efficient to clear the collection with {@link BillboardCollection#removeAll}
     * and add new billboards instead of modifying each one.
     *
     * @see BillboardCollection
     * @see BillboardCollection#add
     * @see Label
     *
     * @internalConstructor
     */
    var Billboard = function(billboardTemplate, collection) {
        var b = billboardTemplate || {};
        var position = b.position ? new Cartesian3(b.position.x, b.position.y, b.position.z) : Cartesian3.ZERO.clone();

        this._show = (typeof b.show === 'undefined') ? true : b.show;
        this._position = position;
        this._actualPosition = position.clone(); // For columbus view and 2D
        this._pixelOffset = b.pixelOffset ? new Cartesian2(b.pixelOffset.x, b.pixelOffset.y) : Cartesian2.ZERO.clone();
        this._eyeOffset = b.eyeOffset ? new Cartesian3(b.eyeOffset.x, b.eyeOffset.y, b.eyeOffset.z) : Cartesian3.ZERO.clone();
        this._horizontalOrigin = b.horizontalOrigin || HorizontalOrigin.CENTER;
        this._verticalOrigin = b.verticalOrigin || VerticalOrigin.CENTER;
        this._scale = (typeof b.scale === 'undefined') ? 1.0 : b.scale;
        this._imageIndex = b.imageIndex || 0;
        this._color = (typeof b.color !== 'undefined') ? Color.clone(b.color) : new Color(1.0, 1.0, 1.0, 1.0);
        this._pickId = undefined;
        this._pickIdThis = b._pickIdThis;
        this._collection = collection;
        this._dirty = false;
    };

    var SHOW_INDEX = Billboard.SHOW_INDEX = 0;
    var POSITION_INDEX = Billboard.POSITION_INDEX = 1;
    var PIXEL_OFFSET_INDEX = Billboard.PIXEL_OFFSET_INDEX = 2;
    var EYE_OFFSET_INDEX = Billboard.EYE_OFFSET_INDEX = 3;
    var HORIZONTAL_ORIGIN_INDEX = Billboard.HORIZONTAL_ORIGIN_INDEX = 4;
    var VERTICAL_ORIGIN_INDEX = Billboard.VERTICAL_ORIGIN_INDEX = 5;
    var SCALE_INDEX = Billboard.SCALE_INDEX = 6;
    var IMAGE_INDEX_INDEX = Billboard.IMAGE_INDEX_INDEX = 7;
    var COLOR_INDEX = Billboard.COLOR_INDEX = 8;
    Billboard.NUMBER_OF_PROPERTIES = 9;

    Billboard.prototype._isDirty = function() {
        return this._dirty;
    };

    Billboard.prototype._clean = function() {
        this._dirty = false;
    };

    Billboard.prototype._makeDirty = function(propertyChanged) {
        var c = this._collection;
        if (c) {
            c._updateBillboard(this, propertyChanged);
            this._dirty = true;
        }
    };

    Billboard.prototype.getPickId = function(context) {
        this._pickId = this._pickId || context.createPickId(this._pickIdThis || this);
        return this._pickId;
    };

    Billboard.prototype._getCollection = function() {
        return this._collection;
    };

    /**
     * Returns true if this billboard will be shown.  Call {@link Billboard#setShow}
     * to hide or show a billboard, instead of removing it and re-adding it to the collection.
     *
     * @memberof Billboard
     *
     * @return {Boolean} <code>true</code> if this billboard will be shown; otherwise, <code>false</code>.
     *
     * @see Billboard#setShow
     */
    Billboard.prototype.getShow = function() {
        return this._show;
    };

    /**
     * Determines if this billboard will be shown.  Call this to hide or show a billboard, instead
     * of removing it and re-adding it to the collection.
     *
     * @memberof Billboard
     *
     * @param {Boolean} value Indicates if this billboard will be shown.
     *
     * @see Billboard#getShow
     */
    Billboard.prototype.setShow = function(value) {
        if ((typeof value !== 'undefined') && (this._show !== value)) {
            this._show = value;
            this._makeDirty(SHOW_INDEX);
        }
    };

    /**
     * Returns the Cartesian position of this billboard.
     *
     * @memberof Billboard
     *
     * @return {Cartesian3} The Cartesian position of this billboard.
     *
     * @see Billboard#setPosition
     */
    Billboard.prototype.getPosition = function() {
        return this._position;
    };

    /**
     * Sets the Cartesian position of this billboard.
     * <br /><br />
     * As shown in the examples, <code>value</code> can be either a {@link Cartesian3}
     * or an object literal with <code>x</code>, <code>y</code>, and <code>z</code> properties.
     * A copy of <code>value</code> is made, so changing it after calling <code>setPosition</code>
     * does not affect the billboard's position; an explicit call to <code>setPosition</code> is required.
     *
     * @memberof Billboard
     *
     * @param {Cartesian3} value The Cartesian position.
     *
     * @see Billboard#getPosition
     *
     * @example
     * // Example 1. Set a billboard's position using a Cartesian3.
     * b.setPosition(new Cartesian3(1.0, 2.0, 3.0));
     *
     * //////////////////////////////////////////////////////////////////
     *
     * // Example 2. Set a billboard's position using an object literal.
     * b.setPosition({
     *   x : 1.0,
     *   y : 2.0,
     *   z : 3.0});
     */
    Billboard.prototype.setPosition = function(value) {
        var p = this._position;

        if ((typeof value !== 'undefined') && ((p.x !== value.x) || (p.y !== value.y) || (p.z !== value.z))) {
            p.x = value.x;
            p.y = value.y;
            p.z = value.z;

            var actualP = this._actualPosition;
            actualP.x = value.x;
            actualP.y = value.y;
            actualP.z = value.z;

            this._makeDirty(POSITION_INDEX);
        }
    };

    Billboard.prototype._getActualPosition = function() {
        return this._actualPosition;
    };

    Billboard.prototype._setActualPosition = function(value) {
        var actualP = this._actualPosition;
        actualP.x = value.x;
        actualP.y = value.y;
        actualP.z = value.z;

        this._makeDirty(POSITION_INDEX);
    };

    /**
     * Returns the pixel offset from the origin of this billboard.
     *
     * @memberof Billboard
     *
     * @return {Cartesian2} The pixel offset of this billboard.
     *
     * @see Billboard#setPixelOffset
     */
    Billboard.prototype.getPixelOffset = function() {
        return this._pixelOffset;
    };

    /**
     * Sets the pixel offset in screen space from the origin of this billboard.  This is commonly used
     * to align multiple billboards and labels at the same position, e.g., an image and text.  The
     * screen space origin is the bottom, left corner of the canvas; <code>x</code> increases from
     * left to right, and <code>y</code> increases from bottom to top.
     * <br /><br />
     * <code>value</code> can be either a {@link Cartesian2}  or an object literal with
     * <code>x</code> and <code>y</code> properties.  A copy of <code>value</code> is made, so
     * changing it after calling <code>setPixelOffset</code> does not affect the billboard's pixel
     * offset; an explicit call to <code>setPixelOffset</code> is required.
     * <br /><br />
     * <div align='center'>
     * <table border='0' cellpadding='5'><tr>
     * <td align='center'><code>default</code><br/><img src='images/Billboard.setPixelOffset.default.png' width='250' height='188' /></td>
     * <td align='center'><code>b.setPixelOffset({ x : 50, y : -25 });</code><br/><img src='images/Billboard.setPixelOffset.x50y-25.png' width='250' height='188' /></td>
     * </tr></table>
     * The billboard's origin is indicated by the yellow point.
     * </div>
     *
     * @memberof Billboard
     *
     * @param {Cartesian2} value The 2D Cartesian pixel offset.
     *
     * @see Billboard#getPixelOffset
     * @see Label#setPixelOffset
     */
    Billboard.prototype.setPixelOffset = function(value) {
        var p = this._pixelOffset;

        if ((typeof value !== 'undefined') && ((p.x !== value.x) || (p.y !== value.y))) {
            p.x = value.x;
            p.y = value.y;
            this._makeDirty(PIXEL_OFFSET_INDEX);
        }
    };

    /**
     * Returns the 3D Cartesian offset applied to this billboard in eye coordinates.
     *
     * @memberof Billboard
     *
     * @return {Cartesian3} The 3D Cartesian offset applied to this billboard in eye coordinates.
     *
     * @see Billboard#setEyeOffset
     */
    Billboard.prototype.getEyeOffset = function() {
        return this._eyeOffset;
    };

    /**
     * Sets the 3D Cartesian offset applied to this billboard in eye coordinates.  Eye coordinates is a left-handed
     * coordinate system, where <code>x</code> points towards the viewer's right, <code>y</code> points up, and
     * <code>z</code> points into the screen.  Eye coordinates use the same scale as world and model coordinates,
     * which is typically meters.
     * <br /><br />
     * An eye offset is commonly used to arrange multiple billboards or objects at the same position, e.g., to
     * arrange a billboard above its corresponding 3D model.
     * <br /><br />
     * <code>value</code> can be either a {@link Cartesian3} or an object literal with <code>x</code>,
     * <code>y</code>, and <code>z</code> properties.  A copy of <code>value</code> is made, so changing it after
     * calling <code>setEyeOffset</code> does not affect the billboard's eye offset; an explicit call to
     * <code>setEyeOffset</code> is required.
     * <br /><br />
     * Below, the billboard is positioned at the center of the Earth but an eye offset makes it always
     * appear on top of the Earth regardless of the viewer's or Earth's orientation.
     * <br /><br />
     * <div align='center'>
     * <table border='0' cellpadding='5'><tr>
     * <td align='center'><img src='images/Billboard.setEyeOffset.one.png' width='250' height='188' /></td>
     * <td align='center'><img src='images/Billboard.setEyeOffset.two.png' width='250' height='188' /></td>
     * </tr></table>
     * <code>b.setEyeOffset({ x : 0.0, y : 8000000.0, z : 0.0 });</code><br /><br />
     * </div>
     *
     * @memberof Billboard
     *
     * @param {Cartesian3} value The 3D Cartesian offset in eye coordinates.
     *
     * @see Billboard#getEyeOffset
     */
    Billboard.prototype.setEyeOffset = function(value) {
        var e = this._eyeOffset;

        if ((typeof value !== 'undefined') && ((e.x !== value.x) || (e.y !== value.y) || (e.z !== value.z))) {
            e.x = value.x;
            e.y = value.y;
            e.z = value.z;
            this._makeDirty(EYE_OFFSET_INDEX);
        }
    };

    /**
     * Returns the horizontal origin of this billboard.
     *
     * @memberof Billboard
     *
     * @return {HorizontalOrigin} The horizontal origin of this billboard.
     *
     * @see Billboard#setHorizontalOrigin
     */
    Billboard.prototype.getHorizontalOrigin = function() {
        return this._horizontalOrigin;
    };

    /**
     * Sets the horizontal origin of this billboard, which determines if the billboard is
     * to the left, center, or right of its position.
     * <br /><br />
     * <div align='center'>
     * <img src='images/Billboard.setHorizontalOrigin.png' width='400' height='300' /><br />
     * </div>
     *
     * @memberof Billboard
     *
     * @param {HorizontalOrigin} value The horizontal origin.
     *
     * @see Billboard#getHorizontalOrigin
     * @see Billboard#setVerticalOrigin
     *
     * @example
     * // Use a bottom, left origin
     * b.setHorizontalOrigin(HorizontalOrigin.LEFT);
     * b.setVerticalOrigin(VerticalOrigin.BOTTOM);
     */
    Billboard.prototype.setHorizontalOrigin = function(value) {
        if ((typeof value !== 'undefined') && (this._horizontalOrigin !== value)) {
            this._horizontalOrigin = value;
            this._makeDirty(HORIZONTAL_ORIGIN_INDEX);
        }
    };

    /**
     * Returns the vertical origin of this billboard.
     *
     * @memberof Billboard
     *
     * @return {VerticalOrigin} The vertical origin of this billboard.
     *
     * @see Billboard#setVerticalOrigin
     */
    Billboard.prototype.getVerticalOrigin = function() {
        return this._verticalOrigin;
    };

    /**
     * Sets the vertical origin of this billboard, which determines if the billboard is
     * to the above, below, or at the center of its position.
     * <br /><br />
     * <div align='center'>
     * <img src='images/Billboard.setVerticalOrigin.png' width='400' height='300' /><br />
     * </div>
     *
     * @memberof Billboard
     *
     * @param {VerticalOrigin} value The vertical origin.
     *
     * @see Billboard#getVerticalOrigin
     * @see Billboard#setHorizontalOrigin
     *
     * @example
     * // Use a bottom, left origin
     * b.setHorizontalOrigin(HorizontalOrigin.LEFT);
     * b.setVerticalOrigin(VerticalOrigin.BOTTOM);
     */
    Billboard.prototype.setVerticalOrigin = function(value) {
        if ((typeof value !== 'undefined') && (this._verticalOrigin !== value)) {
            this._verticalOrigin = value;
            this._makeDirty(VERTICAL_ORIGIN_INDEX);
        }
    };

    /**
     * Returns the uniform scale that is multiplied with the billboard's image size in pixels.
     *
     * @memberof Billboard
     *
     * @return {Number} The scale used to size the billboard.
     *
     * @see Billboard#setScale
     */
    Billboard.prototype.getScale = function() {
        return this._scale;
    };

    /**
     * Sets the uniform scale that is multiplied with the billboard's image size in pixels.
     * A scale of <code>1.0</code> does not change the size of the billboard; a scale greater than
     * <code>1.0</code> enlarges the billboard; a positive scale less than <code>1.0</code> shrinks
     * the billboard.
     * <br /><br />
     * <div align='center'>
     * <img src='images/Billboard.setScale.png' width='400' height='300' /><br/>
     * From left to right in the above image, the scales are <code>0.5</code>, <code>1.0</code>,
     * and <code>2.0</code>.
     * </div>
     *
     * @memberof Billboard
     *
     * @param {Number} value The scale used to size the billboard.
     *
     * @see Billboard#getScale
     * @see Billboard#setImageIndex
     */
    Billboard.prototype.setScale = function(value) {
        if ((typeof value !== 'undefined') && (this._scale !== value)) {
            this._scale = value;
            this._makeDirty(SCALE_INDEX);
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof Billboard
     *
     * @see Billboard#setImageIndex
     * @see BillboardCollection#setTextureAtlas
     */
    Billboard.prototype.getImageIndex = function() {
        return this._imageIndex;
    };

    /**
     * DOC_TBA
     *
     * @memberof Billboard
     *
     * @see Billboard#getImageIndex
     * @see BillboardCollection#setTextureAtlas
     */
    Billboard.prototype.setImageIndex = function(value) {
        if ((typeof value !== 'undefined') && (this._imageIndex !== value)) {
            this._imageIndex = value;
            this._makeDirty(IMAGE_INDEX_INDEX);
        }
    };

    /**
     * Returns the color that is multiplied with the billboard's texture.  The red, green, blue, and alpha values
     * are indicated by the returned object's <code>red</code>, <code>green</code>, <code>blue</code>, and <code>alpha</code>
     * properties, which range from <code>0</code> (no intensity) to <code>1.0</code> (full intensity).
     *
     * @memberof Billboard
     *
     * @return {Number} The color that is multiplied with the billboard's texture.
     *
     * @see Billboard#setColor
     */
    Billboard.prototype.getColor = function() {
        return this._color;
    };

    /**
     * Sets the color that is multiplied with the billboard's texture.  This has two common use cases.  First,
     * the same white texture may be used by many different billboards, each with a different color, to create
     * colored billboards.  Second, the color's alpha component can be used to make the billboard translucent as shown below.
     * An alpha of <code>0.0</code> makes the billboard transparent, and <code>1.0</code> makes the billboard opaque.
     * <br /><br />
     * <div align='center'>
     * <table border='0' cellpadding='5'><tr>
     * <td align='center'><code>default</code><br/><img src='images/Billboard.setColor.Alpha255.png' width='250' height='188' /></td>
     * <td align='center'><code>alpha : 0.5</code><br/><img src='images/Billboard.setColor.Alpha127.png' width='250' height='188' /></td>
     * </tr></table>
     * </div>
     * <br />
     * The red, green, blue, and alpha values are indicated by <code>value</code>'s <code>red</code>, <code>green</code>,
     * <code>blue</code>, and <code>alpha</code> properties as shown in Example 1.  These components range from <code>0.0</code>
     * (no intensity) to <code>1.0</code> (full intensity).
     *
     * @memberof Billboard
     *
     * @param {Object} value The color's red, green, blue, and alpha components.
     *
     * @see Billboard#getColor
     *
     * @example
     *
     * // Example 1. Assign yellow.
     * b.setColor({
     *   red   : 1.0,
     *   green : 1.0,
     *   blue  : 0.0,
     *   alpha : 1.0 });
     *
     * //////////////////////////////////////////////////////////////////
     *
     * // Example 2. Make a billboard 50% translucent.
     * b.setColor({
     *   red   : 1.0,
     *   green : 1.0,
     *   blue  : 1.0,
     *   alpha : 0.5 });
     */
    Billboard.prototype.setColor = function(value) {
        var c = this._color;

        if ((typeof value !== 'undefined') && !Color.equals(c, value)) {
            Color.clone(value, c);
            this._makeDirty(COLOR_INDEX);
        }
    };

    Billboard._computeScreenSpacePosition = function(modelMatrix, position, eyeOffset, pixelOffset, uniformState) {
        // This function is basically a stripped-down JavaScript version of BillboardCollectionVS.glsl

        // Model to eye coordinates
        var mv = uniformState.getView().multiply(modelMatrix);
        var positionEC = mv.multiplyByVector(new Cartesian4(position.x, position.y, position.z, 1.0));

        // Apply eye offset, e.g., agi_eyeOffset
        var zEyeOffset = eyeOffset.multiplyComponents(positionEC.normalize());
        positionEC.x += eyeOffset.x + zEyeOffset.x;
        positionEC.y += eyeOffset.y + zEyeOffset.y;
        positionEC.z += zEyeOffset.z;

        // Eye to window coordinates, e.g., agi_eyeToWindowCoordinates
        var q = uniformState.getProjection().multiplyByVector(positionEC); // clip coordinates
        q.x /= q.w; // normalized device coordinates
        q.y /= q.w;
        q.z /= q.w;
        var positionWC = uniformState.getViewportTransformation().multiplyByVector(new Cartesian4(q.x, q.y, q.z, 1.0)); // window coordinates

        // Apply pixel offset
        var po = pixelOffset.multiplyByScalar(uniformState.getHighResolutionSnapScale());
        positionWC.x += po.x;
        positionWC.y += po.y;

        return new Cartesian2(positionWC.x, Math.floor(positionWC.y));
    };

    /**
     * Computes the screen-space position of the billboard's origin, taking into account eye and pixel offsets.
     * The screen space origin is the bottom, left corner of the canvas; <code>x</code> increases from
     * left to right, and <code>y</code> increases from bottom to top.
     *
     * @memberof Billboard
     *
     * @param {UniformState} uniformState The same state object passed to {@link BillboardCollection#render}.
     *
     * @return {Cartesian2} The screen-space position of the billboard.
     *
     * @exception {DeveloperError} Billboard must be in a collection.
     * @exception {DeveloperError} uniformState is required.
     *
     * @see Billboard#setEyeOffset
     * @see Billboard#setPixelOffset
     * @see BillboardCollection#render
     *
     * @example
     * console.log(b.computeScreenSpacePosition(scene.getUniformState()).toString());
     */
    Billboard.prototype.computeScreenSpacePosition = function(uniformState) {
        if (!this._collection) {
            throw new DeveloperError('Billboard must be in a collection.  Was it removed?');
        }

        if (!uniformState) {
            throw new DeveloperError('uniformState is required.');
        }

        return Billboard._computeScreenSpacePosition(this._collection.modelMatrix, this._actualPosition, this._eyeOffset, this._pixelOffset, uniformState);
    };

    /**
    * Determines if this billboard equals another billboard.  Billboards are equal if all their properties
    * are equal.  Billboards in different collections can be equal.
    *
    * @memberof Billboard
    *
    * @param {Billboard} other The billboard to compare for equality.
    *
    * @return {Boolean} <code>true</code> if the billboards are equal; otherwise, <code>false</code>.
     */
    Billboard.prototype.equals = function(other) {
        return other &&
               (this._show === other._show) &&
               (this._position.equals(other._position)) &&
               (this._pixelOffset.equals(other._pixelOffset)) &&
               (this._eyeOffset.equals(other._eyeOffset)) &&
               (this._horizontalOrigin === other._horizontalOrigin) &&
               (this._verticalOrigin === other._verticalOrigin) &&
               (this._scale === other._scale) &&
               (this._imageIndex === other._imageIndex) &&
               (shallowEquals(this._color, other._color));
    };

    Billboard.prototype._destroy = function() {
        this._pickId = this._pickId && this._pickId.destroy();
        this._collection = null;
    };

    return Billboard;
});
/*global define*/
define('Scene/combineMaterials',[],function() {
    

    /**
     * DOC_TBA
     * @exports combineMaterials
     */
    var combineMaterials = function() {
        var unforms = {};
        var concatenatedSource = '';
        var duplicateUniforms = {};

        var length = arguments.length;
        for ( var i = 0; i < length; ++i) {
            var material = arguments[i].material;
            var materialSource = material._getShaderSource();
            var materialUniforms = material._uniforms;

            for ( var name in materialUniforms) {
                if (materialUniforms.hasOwnProperty(name)) {
                    if (unforms[name]) {
                        // Rename uniform
                        var count = duplicateUniforms[name] || 1;
                        var uniqueName = '_agi_' + name + count.toString();

                        // PERFORMANCE_IDEA:  We could cache the RegExp for duplicate uniforms
                        // or see if a pure JavaScript search-and-replace is faster.

                        // This could rename other things like GLSL comments and other identifiers
                        // with the same name.
                        materialSource = materialSource.replace(new RegExp(name, 'g'), uniqueName);
                        unforms[uniqueName] = materialUniforms[name];

                        duplicateUniforms[name] = count + 1;
                    } else {
                        unforms[name] = materialUniforms[name];
                    }
                }
            }

            if (arguments[i].sourceTransform) {
                materialSource = arguments[i].sourceTransform(materialSource);
            }

            concatenatedSource += '#line 0\n' + materialSource;
        }

        return {
            _uniforms : unforms,
            _getShaderSource : function() {
                return concatenatedSource;
            }
        };
    };

    return combineMaterials;
});

/*global define*/
define('Shaders/BillboardCollectionFS',[],function() {
  
  return "uniform sampler2D u_atlas;\n" +
"varying vec2 v_textureCoordinates;\n" +
"varying vec4 v_color;\n" +
"varying vec4 v_pickColor;\n" +
"void main()\n" +
"{\n" +
"vec4 color = texture2D(u_atlas, v_textureCoordinates) * v_color;\n" +
"if (color.a == 0.0)\n" +
"{\n" +
"discard;\n" +
"}\n" +
"#ifdef RENDER_FOR_PICK\n" +
"gl_FragColor = v_pickColor;\n" +
"#else\n" +
"gl_FragColor = color;\n" +
"#endif\n" +
"}\n" +
"";
});

/*global define*/
define('Shaders/BillboardCollectionVS',[],function() {
  
  return "attribute vec3 position;\n" +
"attribute vec2 direction;\n" +
"attribute vec4 textureCoordinatesAndImageSize;\n" +
"attribute vec4 color;\n" +
"attribute vec3 originAndShow;\n" +
"attribute vec2 pixelOffset;\n" +
"attribute vec4 eyeOffsetAndScale;\n" +
"attribute vec4 pickColor;\n" +
"uniform vec2 u_atlasSize;\n" +
"const vec2 agi_highResolutionSnapScale = vec2(1.0, 1.0);\n" +
"varying vec2 v_textureCoordinates;\n" +
"varying vec4 v_color;\n" +
"varying vec4 v_pickColor;\n" +
"void main()\n" +
"{\n" +
"vec3 eyeOffset = eyeOffsetAndScale.xyz;\n" +
"float scale = eyeOffsetAndScale.w;\n" +
"vec2 textureCoordinates = textureCoordinatesAndImageSize.xy;\n" +
"vec2 imageSize = textureCoordinatesAndImageSize.zw;\n" +
"vec2 origin = originAndShow.xy;\n" +
"float show = originAndShow.z;\n" +
"vec4 positionEC = agi_modelView * vec4(position, 1.0);\n" +
"positionEC = agi_eyeOffset(positionEC, eyeOffset);\n" +
"positionEC.xyz *= show;\n" +
"vec4 positionWC = agi_eyeToWindowCoordinates(positionEC);\n" +
"vec2 halfSize = u_atlasSize * imageSize * 0.5 * scale * agi_highResolutionSnapScale;\n" +
"halfSize *= ((direction * 2.0) - 1.0);\n" +
"positionWC.xy += (origin * abs(halfSize)) + halfSize;\n" +
"positionWC.xy += (pixelOffset * agi_highResolutionSnapScale);\n" +
"gl_Position = agi_viewportOrthographic * vec4(positionWC.x, floor(positionWC.y), -positionWC.z, 1.0);\n" +
"v_textureCoordinates = textureCoordinates;\n" +
"v_color = color;\n" +
"v_pickColor = pickColor;\n" +
"}\n" +
"";
});
/*global define*/
define('Scene/BillboardCollection',[
        '../Core/DeveloperError',
        '../Core/combine',
        '../Core/destroyObject',
        '../Core/Math',
        '../Core/Cartesian3',
        '../Core/Cartesian4',
        '../Core/Matrix4',
        '../Core/ComponentDatatype',
        '../Core/IndexDatatype',
        '../Core/PrimitiveType',
        '../Renderer/BlendingState',
        '../Renderer/BufferUsage',
        '../Renderer/VertexArrayFacade',
        './SceneMode',
        './Billboard',
        '../Shaders/BillboardCollectionVS',
        '../Shaders/BillboardCollectionFS'
    ], function(
        DeveloperError,
        combine,
        destroyObject,
        CesiumMath,
        Cartesian3,
        Cartesian4,
        Matrix4,
        ComponentDatatype,
        IndexDatatype,
        PrimitiveType,
        BlendingState,
        BufferUsage,
        VertexArrayFacade,
        SceneMode,
        Billboard,
        BillboardCollectionVS,
        BillboardCollectionFS) {
    

    var SHOW_INDEX = Billboard.SHOW_INDEX;
    var POSITION_INDEX = Billboard.POSITION_INDEX;
    var PIXEL_OFFSET_INDEX = Billboard.PIXEL_OFFSET_INDEX;
    var EYE_OFFSET_INDEX = Billboard.EYE_OFFSET_INDEX;
    var HORIZONTAL_ORIGIN_INDEX = Billboard.HORIZONTAL_ORIGIN_INDEX;
    var VERTICAL_ORIGIN_INDEX = Billboard.VERTICAL_ORIGIN_INDEX;
    var SCALE_INDEX = Billboard.SCALE_INDEX;
    var IMAGE_INDEX_INDEX = Billboard.IMAGE_INDEX_INDEX;
    var COLOR_INDEX = Billboard.COLOR_INDEX;
    var NUMBER_OF_PROPERTIES = Billboard.NUMBER_OF_PROPERTIES;

    // PERFORMANCE_IDEA:  Use vertex compression so we don't run out of
    // vec4 attributes (WebGL minimum: 8)
    var attributeIndices = {
        position : 0,
        pixelOffset : 1,
        eyeOffsetAndScale : 2,
        textureCoordinatesAndImageSize : 3,
        pickColor : 4,
        color : 5,
        originAndShow : 6,
        direction : 7
    };

    /**
     * A renderable collection of billboards.  Billboards are viewport-aligned
     * images positioned in the 3D scene.
     * <br /><br />
     * <div align='center'>
     * <img src='images/Billboard.png' width='400' height='300' /><br />
     * Example billboards
     * </div>
     * <br /><br />
     * Billboards are added and removed from the collection using {@link BillboardCollection#add}
     * and {@link BillboardCollection#remove}.  All billboards in a collection reference images
     * from the same texture atlas, which is assigned using {@link BillboardCollection#setTextureAtlas}.
     *
     * @alias BillboardCollection
     * @constructor
     *
     * @performance For best performance, prefer a few collections, each with many billboards, to
     * many collections with only a few billboards each.  Organize collections so that billboards
     * with the same update frequency are in the same collection, i.e., billboards that do not
     * change should be in one collection; billboards that change every frame should be in another
     * collection; and so on.
     *
     * @see BillboardCollection#add
     * @see BillboardCollection#remove
     * @see BillboardCollection#setTextureAtlas
     * @see Billboard
     * @see TextureAtlas
     * @see LabelCollection
     *
     * @example
     * // Create a billboard collection with two billboards
     * var billboards = new BillboardCollection();
     * var atlas = context.createTextureAtlas({images : images});
     * billboards.setTextureAtlas(atlas);
     * billboards.add({
     *   position : { x : 1.0, y : 2.0, z : 3.0 }
     * });
     * billboards.add({
     *   position : { x : 4.0, y : 5.0, z : 6.0 }
     * });
     */
    var BillboardCollection = function() {
        this._textureAtlas = undefined;
        this._textureAtlasGUID = undefined;
        this._destroyTextureAtlas = true;
        this._sp = undefined;
        this._rs = undefined;
        this._vaf = undefined;
        this._rsPick = undefined;
        this._spPick = undefined;

        this._billboards = [];
        this._billboardsToUpdate = [];
        this._billboardsRemoved = false;
        this._createVertexArray = false;

        this._propertiesChanged = new Uint32Array(NUMBER_OF_PROPERTIES);

        /**
         * The 4x4 transformation matrix that transforms each billboard in this collection from model to world coordinates.
         * When this is the identity matrix, the billboards are drawn in world coordinates, i.e., Earth's WGS84 coordinates.
         * Local reference frames can be used by providing a different transformation matrix, like that returned
         * by {@link Transforms.eastNorthUpToFixedFrame}.  This matrix is available to GLSL vertex and fragment
         * shaders via {@link agi_model} and derived uniforms.
         *
         * @type Matrix4
         *
         * @see Transforms.eastNorthUpToFixedFrame
         * @see agi_model
         *
         * @example
         * var center = ellipsoid.cartographicToCartesian(Cartographic.fromDegrees(-75.59777, 40.03883));
         * billboards.modelMatrix = Transforms.eastNorthUpToFixedFrame(center);
         * billboards.add({ position : new Cartesian3(0.0, 0.0, 0.0) }); // center
         * billboards.add({ position : new Cartesian3(1000000.0, 0.0, 0.0) }); // east
         * billboards.add({ position : new Cartesian3(0.0, 1000000.0, 0.0) }); // north
         * billboards.add({ position : new Cartesian3(0.0, 0.0, 1000000.0) }); // up
         * ]);
         */
        this.modelMatrix = Matrix4.IDENTITY;
        this._modelMatrix = Matrix4.IDENTITY;

        this._mode = SceneMode.SCENE3D;
        this._projection = undefined;

        /**
         * The current morph transition time between 2D/Columbus View and 3D,
         * with 0.0 being 2D or Columbus View and 1.0 being 3D.
         *
         * @type Number
         */
        this.morphTime = this._mode.morphTime;

        // The buffer usage for each attribute is determined based on the usage of the attribute over time.
        this._buffersUsage = [
                              BufferUsage.STATIC_DRAW, // SHOW_INDEX
                              BufferUsage.STATIC_DRAW, // POSITION_INDEX
                              BufferUsage.STATIC_DRAW, // PIXEL_OFFSET_INDEX
                              BufferUsage.STATIC_DRAW, // EYE_OFFSET_INDEX
                              BufferUsage.STATIC_DRAW, // HORIZONTAL_ORIGIN_INDEX
                              BufferUsage.STATIC_DRAW, // VERTICAL_ORIGIN_INDEX
                              BufferUsage.STATIC_DRAW, // SCALE_INDEX
                              BufferUsage.STATIC_DRAW, // IMAGE_INDEX_INDEX
                              BufferUsage.STATIC_DRAW // COLOR_INDEX
                          ];

        var that = this;
        var uniforms = {
            u_atlas : function() {
                return that._textureAtlas.getTexture();
            },
            u_atlasSize : function() {
                return that._textureAtlas.getTexture().getDimensions();
            }
        };

        this._uniforms3D = combine(uniforms, {
            u_model : function() {
                return that.modelMatrix;
            }
        });
        this._uniforms2D = combine(uniforms, {
            u_model : function() {
                return Matrix4.IDENTITY;
            }
        });
        this._uniforms = undefined;
    };

    /**
     * Creates and adds a billboard with the specified initial properties to the collection.
     * The added billboard is returned so it can be modified or removed from the collection later.
     *
     * @memberof BillboardCollection
     *
     * @param {Object}[billboard=undefined] A template describing the billboard's properties as shown in Example 1.
     *
     * @return {Billboard} The billboard that was added to the collection.
     *
     * @performance Calling <code>add</code> is expected constant time.  However, when
     * {@link BillboardCollection#update} is called, the collection's vertex buffer
     * is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.  For
     * best performance, add as many billboards as possible before calling <code>update</code>.
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see BillboardCollection#remove
     * @see BillboardCollection#removeAll
     * @see BillboardCollection#update
     *
     * @example
     * // Example 1:  Add a billboard, specifying all the default values.
     * var b = billboards.add({
     *   show : true,
     *   position : new Cartesian3(0.0, 0.0, 0.0),
     *   pixelOffset : new Cartesian2(0.0, 0.0),
     *   eyeOffset : new Cartesian3(0.0, 0.0, 0.0),
     *   horizontalOrigin : HorizontalOrigin.CENTER,
     *   verticalOrigin : VerticalOrigin.CENTER,
     *   scale : 1.0,
     *   imageIndex : 0,
     *   color : new Color(1.0, 1.0, 1.0, 1.0)
     * });
     *
     * // Example 2:  Specify only the billboard's cartographic position.
     * var b = billboards.add({
     *   position : ellipsoid.cartographicToCartesian(new Cartographic(longitude, latitude, height))
     * });
     */
    BillboardCollection.prototype.add = function(billboard) {
        var b = new Billboard(billboard, this);
        b._index = this._billboards.length;

        this._billboards.push(b);
        this._createVertexArray = true;

        return b;
    };

    /**
     * Removes a billboard from the collection.
     *
     * @memberof BillboardCollection
     *
     * @param {Billboard} billboard The billboard to remove.
     *
     * @return {Boolean} <code>true</code> if the billboard was removed; <code>false</code> if the billboard was not found in the collection.
     *
     * @performance Calling <code>remove</code> is expected constant time.  However, when
     * {@link BillboardCollection#update} is called, the collection's vertex buffer
     * is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.  For
     * best performance, remove as many billboards as possible before calling <code>update</code>.
     * If you intend to temporarily hide a billboard, it is usually more efficient to call
     * {@link Billboard#setShow} instead of removing and re-adding the billboard.
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see BillboardCollection#add
     * @see BillboardCollection#removeAll
     * @see BillboardCollection#update
     * @see Billboard#setShow
     *
     * @example
     * var b = billboards.add(...);
     * billboards.remove(b);  // Returns true
     */
    BillboardCollection.prototype.remove = function(billboard) {
        if (this.contains(billboard)) {
            this._billboards[billboard._index] = null; // Removed later
            this._billboardsRemoved = true;
            this._createVertexArray = true;
            billboard._destroy();
            return true;
        }

        return false;
    };

    /**
     * Removes all billboards from the collection.
     *
     * @performance <code>O(n)</code>.  It is more efficient to remove all the billboards
     * from a collection and then add new ones than to create a new collection entirely.
     *
     * @memberof BillboardCollection
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see BillboardCollection#add
     * @see BillboardCollection#remove
     * @see BillboardCollection#update
     *
     * @example
     * billboards.add(...);
     * billboards.add(...);
     * billboards.removeAll();
     */
    BillboardCollection.prototype.removeAll = function() {
        this._destroyBillboards();
        this._billboards = [];
        this._billboardsToUpdate = [];
        this._billboardsRemoved = false;

        this._createVertexArray = true;
    };

    BillboardCollection.prototype._removeBillboards = function() {
        if (this._billboardsRemoved) {
            this._billboardsRemoved = false;

            var billboards = [];

            var length = this._billboards.length;
            for ( var i = 0, j = 0; i < length; ++i) {
                var billboard = this._billboards[i];
                if (billboard) {
                    billboard._index = j++;
                    billboards.push(billboard);
                }
            }

            this._billboards = billboards;
        }
    };

    BillboardCollection.prototype._updateBillboard = function(billboard, propertyChanged) {
        if (!billboard._isDirty()) {
            this._billboardsToUpdate.push(billboard);
        }

        ++this._propertiesChanged[propertyChanged];
    };

    /**
     * DOC_TBA
     *
     * @memberof BillboardCollection
     *
     * @param {Object} billboard DOC_TBA
     *
     * @see BillboardCollection#get
     */
    BillboardCollection.prototype.contains = function(billboard) {
        return (billboard && (billboard._getCollection() === this));
    };

    /**
     * Returns the billboard in the collection at the specified index.  Indices are zero-based
     * and increase as billboards are added.  Removing a billboard shifts all billboards after
     * it to the left, changing their indices.  This function is commonly used with
     * {@link BillboardCollection#getLength} to iterate over all the billboards
     * in the collection.
     *
     * @memberof BillboardCollection
     *
     * @param {Number} index The zero-based index of the billboard.
     *
     * @return {Billboard} The billboard at the specified index.
     *
     * @performance Expected constant time.  If billboards were removed from the collection and
     * {@link BillboardCollection#update} was not called, an implicit <code>O(n)</code>
     * operation is performed.
     *
     * @exception {DeveloperError} index is required.
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see BillboardCollection#getLength
     *
     * @example
     * // Toggle the show property of every billboard in the collection
     * var len = billboards.getLength();
     * for (var i = 0; i < len; ++i) {
     *   var b = billboards.get(i);
     *   b.setShow(!b.getShow());
     * }
     */
    BillboardCollection.prototype.get = function(index) {
        if (typeof index === 'undefined') {
            throw new DeveloperError('index is required.');
        }

        this._removeBillboards();
        return this._billboards[index];
    };

    /**
     * Returns the number of billboards in this collection.  This is commonly used with
     * {@link BillboardCollection#get} to iterate over all the billboards
     * in the collection.
     *
     * @memberof BillboardCollection
     *
     * @return {Number} The number of billboards in this collection.
     *
     * @performance Expected constant time.  If billboards were removed from the collection and
     * {@link BillboardCollection#update} was not called, an implicit <code>O(n)</code>
     * operation is performed.
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see BillboardCollection#get
     *
     * @example
     * // Toggle the show property of every billboard in the collection
     * var len = billboards.getLength();
     * for (var i = 0; i < len; ++i) {
     *   var b = billboards.get(i);
     *   b.setShow(!b.getShow());
     * }
     */
    BillboardCollection.prototype.getLength = function() {
        this._removeBillboards();
        return this._billboards.length;
    };

    /**
     * DOC_TBA
     *
     * @memberof BillboardCollection
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see BillboardCollection#setTextureAtlas
     * @see Billboard#setImageIndex
     */
    BillboardCollection.prototype.getTextureAtlas = function() {
        return this._textureAtlas;
    };

    /**
     * DOC_TBA
     *
     * @memberof BillboardCollection
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see BillboardCollection#getTextureAtlas
     * @see Billboard#setImageIndex
     *
     * @example
     * // Assigns a texture atlas with two images to a billboard collection.
     * // Two billboards, each referring to one of the images, are then
     * // added to the collection.
     * var billboards = new BillboardCollection();
     * var images = [image0, image1];
     * var atlas = context.createTextureAtlas({images : images});
     * billboards.setTextureAtlas(atlas);
     * billboards.add({
     *   // ...
     *   imageIndex : 0
     * });
     * billboards.add({
     *   // ...
     *   imageIndex : 1
     * });
     */
    BillboardCollection.prototype.setTextureAtlas = function(value) {
        if (this._textureAtlas !== value) {
            this._textureAtlas = this._destroyTextureAtlas && this._textureAtlas && this._textureAtlas.destroy();
            this._textureAtlas = value;
            this._createVertexArray = true; // New per-billboard texture coordinates
        }
    };

    /**
     * Returns <code>true</code> if the texture atlas is destroyed when the collection is
     * destroyed; otherwise, <code>false</code>.
     *
     * @memberof BillboardCollection
     *
     * @return <code>true</code> if the texture atlas is destroyed when the collection is
     * destroyed; otherwise, <code>false</code>.
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see BillboardCollection#setDestroyTextureAtlas
     */
    BillboardCollection.prototype.getDestroyTextureAtlas = function() {
        return this._destroyTextureAtlas;
    };

    /**
     * Determines if the texture atlas is destroyed when the collection is destroyed.  If the texture
     * atlas is used by more than one collection, set this to <code>false</code>, and explicitly
     * destroy the atlas to avoid attempting to destroy it multiple times.
     *
     * @memberof BillboardCollection
     *
     * @param {Boolean} value Indicates if the texture atlas is destroyed when the collection is destroyed.
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see BillboardCollection#getDestroyTextureAtlas
     * @see BillboardCollection#setTextureAtlas
     * @see BillboardCollection#destroy
     *
     * @example
     * // Destroy a billboard collection but not its texture atlas.
     *
     * var atlas = context.createTextureAtlas({images : images});
     * billboards.setTextureAtlas(atlas);
     * billboards.setDestroyTextureAtlas(false);
     * billboards = billboards.destroy();
     * console.log(atlas.isDestroyed()); // False
     */
    BillboardCollection.prototype.setDestroyTextureAtlas = function(value) {
        this._destroyTextureAtlas = value;
    };

    BillboardCollection._getDirectionsVertexBuffer = function(context) {
        var sixteenK = 16 * 1024;

        // Per-context cache for billboard collections
        context._primitivesCache = context._primitivesCache || {};
        var primitivesCache = context._primitivesCache;
        primitivesCache._billboardCollection = primitivesCache._billboardCollection || {};
        var c = primitivesCache._billboardCollection;

        if (c.directionsVertexBuffer) {
            return c.directionsVertexBuffer;
        }

        c.directionsVertexBuffer = c.directionsVertexBuffer && c.directionsVertexBuffer.destroy();

        var directions = new Uint8Array(sixteenK * 4 * 2);
        for ( var i = 0, j = 0; i < sixteenK; ++i) {
            directions[j++] = 0;
            directions[j++] = 0;

            directions[j++] = 255;
            directions[j++] = 0.0;

            directions[j++] = 255;
            directions[j++] = 255;

            directions[j++] = 0.0;
            directions[j++] = 255;
        }

        // PERFORMANCE_IDEA:  Should we reference count billboard collections, and eventually delete this?
        // Is this too much memory to allocate up front?  Should we dynamically grow it?
        c.directionsVertexBuffer = context.createVertexBuffer(directions, BufferUsage.STATIC_DRAW);
        c.directionsVertexBuffer.setVertexArrayDestroyable(false);
        return c.directionsVertexBuffer;
    };

    BillboardCollection._getIndexBuffer = function(context) {
        var sixteenK = 16 * 1024;

        // Per-context cache for billboard collections
        context._primitivesCache = context._primitivesCache || {};
        var primitivesCache = context._primitivesCache;
        primitivesCache._billboardCollection = primitivesCache._billboardCollection || {};
        var c = primitivesCache._billboardCollection;

        if (c.indexBuffer) {
            return c.indexBuffer;
        }

        var length = sixteenK * 6;
        var indices = new Uint16Array(length);
        for ( var i = 0, j = 0; i < length; i += 6, j += 4) {
            indices[i + 0] = j + 0;
            indices[i + 1] = j + 1;
            indices[i + 2] = j + 2;

            indices[i + 3] = j + 0;
            indices[i + 4] = j + 2;
            indices[i + 5] = j + 3;
        }

        // PERFORMANCE_IDEA:  Should we reference count billboard collections, and eventually delete this?
        // Is this too much memory to allocate up front?  Should we dynamically grow it?
        c.indexBuffer = context.createIndexBuffer(indices, BufferUsage.STATIC_DRAW, IndexDatatype.UNSIGNED_SHORT);
        c.indexBuffer.setVertexArrayDestroyable(false);
        return c.indexBuffer;
    };

    /**
     * Renders the billboards.  In order for changes to properties to be realized,
     * {@link BillboardCollection#update} must be called before <code>render</code>.
     * <br /><br />
     * A texture atlas must be assigned to the billboard collection using
     * {@link BillboardCollection#setTextureAtlas}, otherwise no billboards will be rendered.
     * <br /><br />
     * Billboards are rendered in a single pass using an uber-shader.
     *
     * @memberof BillboardCollection
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see BillboardCollection#update
     * @see BillboardCollection#setTextureAtlas
     */
    BillboardCollection.prototype.render = function(context) {
        if (this._vaf && this._vaf.va && this._textureAtlas) {
            var va = this._vaf.va;
            var length = va.length;
            for ( var i = 0; i < length; ++i) {
                context.draw({
                    primitiveType : PrimitiveType.TRIANGLES,
                    count : va[i].indicesCount,
                    shaderProgram : this._sp,
                    uniformMap : this._uniforms,
                    vertexArray : va[i].va,
                    renderState : this._rs
                });
            }
        }
    };

    /**
     * DOC_TBA
     * @memberof BillboardCollection
     */
    BillboardCollection.prototype.renderForPick = function(context, framebuffer) {
        if (this._vaf && this._vaf.va && this._textureAtlas) {
            var va = this._vaf.va;
            var length = va.length;
            for ( var i = 0; i < length; ++i) {
                context.draw({
                    primitiveType : PrimitiveType.TRIANGLES,
                    count : va[i].indicesCount,
                    shaderProgram : this._spPick,
                    uniformMap : this._uniforms,
                    vertexArray : va[i].va,
                    renderState : this._rsPick,
                    framebuffer : framebuffer
                });
            }
        }
    };

    /**
     * @private
     */
    BillboardCollection.prototype.update = function(context, sceneState) {
        // First update:  create render state and shader program
        this._rs = context.createRenderState({
            depthTest : {
                enabled : true
            },
            blending : BlendingState.ALPHA_BLEND
        });

        this._sp = context.getShaderCache().getShaderProgram(BillboardCollectionVS, BillboardCollectionFS, attributeIndices);

        this._update(context, sceneState);
        this.update = this._update;
    };

    BillboardCollection.prototype.computeNewBuffersUsage = function() {
        var buffersUsage = this._buffersUsage;
        var usageChanged = false;

        // PERFORMANCE_IDEA: Better heuristic to avoid ping-ponging.  What about DYNAMIC_STREAM?
        var properties = this._propertiesChanged;
        for ( var k = 0; k < NUMBER_OF_PROPERTIES; ++k) {
            var newUsage = (properties[k] === 0) ? BufferUsage.STATIC_DRAW : BufferUsage.STREAM_DRAW;
            usageChanged = usageChanged || (buffersUsage[k] !== newUsage);
            buffersUsage[k] = newUsage;
        }

        return usageChanged;
    };

    BillboardCollection._createVAF = function(context, numberOfBillboards, buffersUsage) {
        // Different billboard collections share the same vertex buffer for directions.
        var directionVertexBuffer = BillboardCollection._getDirectionsVertexBuffer(context);

        return new VertexArrayFacade(context, [{
            index : attributeIndices.position,
            componentsPerAttribute : 3,
            componentDatatype : ComponentDatatype.FLOAT,
            usage : buffersUsage[POSITION_INDEX]
        }, {
            index : attributeIndices.pixelOffset,
            componentsPerAttribute : 2,
            componentDatatype : ComponentDatatype.FLOAT,
            usage : buffersUsage[PIXEL_OFFSET_INDEX]
        }, {
            index : attributeIndices.eyeOffsetAndScale,
            componentsPerAttribute : 4,
            componentDatatype : ComponentDatatype.FLOAT,
            usage : buffersUsage[SCALE_INDEX] // buffersUsage[EYE_OFFSET_INDEX] ignored
        }, {
            index : attributeIndices.textureCoordinatesAndImageSize,
            componentsPerAttribute : 4,
            normalize : true,
            componentDatatype : ComponentDatatype.UNSIGNED_SHORT,
            usage : buffersUsage[IMAGE_INDEX_INDEX]
        }, {
            index : attributeIndices.pickColor,
            componentsPerAttribute : 4,
            normalize : true,
            componentDatatype : ComponentDatatype.UNSIGNED_BYTE,
            usage : BufferUsage.STATIC_DRAW
        }, {
            index : attributeIndices.color,
            componentsPerAttribute : 4,
            normalize : true,
            componentDatatype : ComponentDatatype.UNSIGNED_BYTE,
            usage : buffersUsage[COLOR_INDEX]
        }, {
            index : attributeIndices.originAndShow,
            componentsPerAttribute : 3,
            componentDatatype : ComponentDatatype.BYTE,
            usage : buffersUsage[SHOW_INDEX] // buffersUsage[HORIZONTAL_ORIGIN_INDEX] and buffersUsage[VERTICAL_ORIGIN_INDEX] ignored
        }, {
            index : attributeIndices.direction,
            vertexBuffer : directionVertexBuffer,
            componentsPerAttribute : 2,
            normalize : true,
            componentDatatype : ComponentDatatype.UNSIGNED_BYTE
        }], 4 * numberOfBillboards); // 4 vertices per billboard
    };

    ///////////////////////////////////////////////////////////////////////////

    // Four vertices per billboard.  Each has the same position, etc., but a different screen-space direction vector.

    // PERFORMANCE_IDEA:  Save memory if a property is the same for all billboards, use a latched attribute state,
    // instead of storing it in a vertex buffer.

    BillboardCollection.prototype._writePosition = function(context, textureAtlasCoordinates, vafWriters, billboard) {
        var i = (billboard._index * 4);
        var position = billboard._getActualPosition();

        vafWriters[attributeIndices.position](i + 0, position.x, position.y, position.z);
        vafWriters[attributeIndices.position](i + 1, position.x, position.y, position.z);
        vafWriters[attributeIndices.position](i + 2, position.x, position.y, position.z);
        vafWriters[attributeIndices.position](i + 3, position.x, position.y, position.z);
    };

    BillboardCollection.prototype._writePixelOffset = function(context, textureAtlasCoordinates, vafWriters, billboard) {
        var i = (billboard._index * 4);
        var pixelOffset = billboard.getPixelOffset();

        vafWriters[attributeIndices.pixelOffset](i + 0, pixelOffset.x, pixelOffset.y);
        vafWriters[attributeIndices.pixelOffset](i + 1, pixelOffset.x, pixelOffset.y);
        vafWriters[attributeIndices.pixelOffset](i + 2, pixelOffset.x, pixelOffset.y);
        vafWriters[attributeIndices.pixelOffset](i + 3, pixelOffset.x, pixelOffset.y);
    };

    BillboardCollection.prototype._writeEyeOffsetAndScale = function(context, textureAtlasCoordinates, vafWriters, billboard) {
        var i = (billboard._index * 4);
        var eyeOffset = billboard.getEyeOffset();
        var scale = billboard.getScale();

        vafWriters[attributeIndices.eyeOffsetAndScale](i + 0, eyeOffset.x, eyeOffset.y, eyeOffset.z, scale);
        vafWriters[attributeIndices.eyeOffsetAndScale](i + 1, eyeOffset.x, eyeOffset.y, eyeOffset.z, scale);
        vafWriters[attributeIndices.eyeOffsetAndScale](i + 2, eyeOffset.x, eyeOffset.y, eyeOffset.z, scale);
        vafWriters[attributeIndices.eyeOffsetAndScale](i + 3, eyeOffset.x, eyeOffset.y, eyeOffset.z, scale);
    };

    BillboardCollection.prototype._writePickColor = function(context, textureAtlasCoordinates, vafWriters, billboard) {
        var i = (billboard._index * 4);
        var pickColor = billboard.getPickId(context).unnormalizedRgb;

        vafWriters[attributeIndices.pickColor](i + 0, pickColor.red, pickColor.green, pickColor.blue, 255);
        vafWriters[attributeIndices.pickColor](i + 1, pickColor.red, pickColor.green, pickColor.blue, 255);
        vafWriters[attributeIndices.pickColor](i + 2, pickColor.red, pickColor.green, pickColor.blue, 255);
        vafWriters[attributeIndices.pickColor](i + 3, pickColor.red, pickColor.green, pickColor.blue, 255);
    };

    BillboardCollection.prototype._writeColor = function(context, textureAtlasCoordinates, vafWriters, billboard) {
        var i = (billboard._index * 4);
        var color = billboard.getColor();

        vafWriters[attributeIndices.color](i + 0, color.red * 255, color.green * 255, color.blue * 255, color.alpha * 255);
        vafWriters[attributeIndices.color](i + 1, color.red * 255, color.green * 255, color.blue * 255, color.alpha * 255);
        vafWriters[attributeIndices.color](i + 2, color.red * 255, color.green * 255, color.blue * 255, color.alpha * 255);
        vafWriters[attributeIndices.color](i + 3, color.red * 255, color.green * 255, color.blue * 255, color.alpha * 255);
    };

    BillboardCollection.prototype._writeOriginAndShow = function(context, textureAtlasCoordinates, vafWriters, billboard) {
        var i = (billboard._index * 4);
        var horizontalOrigin = billboard.getHorizontalOrigin().value;
        var verticalOrigin = billboard.getVerticalOrigin().value;
        var show = billboard.getShow();

        vafWriters[attributeIndices.originAndShow](i + 0, horizontalOrigin, verticalOrigin, show);
        vafWriters[attributeIndices.originAndShow](i + 1, horizontalOrigin, verticalOrigin, show);
        vafWriters[attributeIndices.originAndShow](i + 2, horizontalOrigin, verticalOrigin, show);
        vafWriters[attributeIndices.originAndShow](i + 3, horizontalOrigin, verticalOrigin, show);
    };

    BillboardCollection.prototype._writeTextureCoordinatesAndImageSize = function(context, textureAtlasCoordinates, vafWriters, billboard) {
        var i = (billboard._index * 4);
        var imageRectangle = textureAtlasCoordinates[billboard.getImageIndex()];
        var bottomLeftX = imageRectangle.x;
        var bottomLeftY = imageRectangle.y;
        var topRightX = imageRectangle.x + imageRectangle.width;
        var topRightY = imageRectangle.y + imageRectangle.height;
        vafWriters[attributeIndices.textureCoordinatesAndImageSize](i + 0, bottomLeftX * 65535, bottomLeftY * 65535, imageRectangle.width * 65535, imageRectangle.height * 65535); // Lower Left
        vafWriters[attributeIndices.textureCoordinatesAndImageSize](i + 1, topRightX * 65535, bottomLeftY * 65535, imageRectangle.width * 65535, imageRectangle.height * 65535); // Lower Right
        vafWriters[attributeIndices.textureCoordinatesAndImageSize](i + 2, topRightX * 65535, topRightY * 65535, imageRectangle.width * 65535, imageRectangle.height * 65535); // Upper Right
        vafWriters[attributeIndices.textureCoordinatesAndImageSize](i + 3, bottomLeftX * 65535, topRightY * 65535, imageRectangle.width * 65535, imageRectangle.height * 65535); // Upper Left
    };

    BillboardCollection.prototype._writeBillboard = function(context, textureAtlasCoordinates, vafWriters, billboard) {
        this._writePosition(context, textureAtlasCoordinates, vafWriters, billboard);
        this._writePixelOffset(context, textureAtlasCoordinates, vafWriters, billboard);
        this._writeEyeOffsetAndScale(context, textureAtlasCoordinates, vafWriters, billboard);
        this._writePickColor(context, textureAtlasCoordinates, vafWriters, billboard);
        this._writeColor(context, textureAtlasCoordinates, vafWriters, billboard);
        this._writeOriginAndShow(context, textureAtlasCoordinates, vafWriters, billboard);
        this._writeTextureCoordinatesAndImageSize(context, textureAtlasCoordinates, vafWriters, billboard);
    };

    BillboardCollection.prototype._updateScene2D = function(projection, billboards) {
        var length = billboards.length;

        for ( var i = 0; i < length; ++i) {
            var b = billboards[i];
            var p = this.modelMatrix.multiplyByVector(new Cartesian4(b.getPosition().x, b.getPosition().y, b.getPosition().z, 1.0));
            var projectedPoint = projection.project(projection.getEllipsoid().cartesianToCartographic(new Cartesian3(p.x, p.y, p.z)));
            b._setActualPosition({
                x : 0.0,
                y : projectedPoint.x,
                z : projectedPoint.y
            });
        }
    };

    BillboardCollection.prototype._updateColumbusView = function(projection, billboards) {
        var length = billboards.length;

        for ( var i = 0; i < length; ++i) {
            var b = billboards[i];
            var p = this.modelMatrix.multiplyByVector(new Cartesian4(b.getPosition().x, b.getPosition().y, b.getPosition().z, 1.0));
            var projectedPoint = projection.project(projection.getEllipsoid().cartesianToCartographic(new Cartesian3(p.x, p.y, p.z)));
            b._setActualPosition({
                x : projectedPoint.z,
                y : projectedPoint.x,
                z : projectedPoint.y
            });
        }
    };

    BillboardCollection.prototype._updateMode = function(sceneState) {
        var mode = sceneState.mode;
        var projection = sceneState.scene2D.projection;

        var billboards;
        var length;
        var i;
        var b;

        if ((this._mode !== mode) ||
            (this._projection !== projection) ||
            (mode !== SceneMode.SCENE3D) &&
            (!this._modelMatrix.equals(this.modelMatrix))) {

            this._mode = mode;
            this._projection = projection;
            this._modelMatrix = this.modelMatrix.clone();

            billboards = this._billboards;
            length = billboards.length;

            switch (mode) {
            case SceneMode.SCENE3D:
                for (i = 0; i < length; ++i) {
                    b = billboards[i];
                    b._setActualPosition(b.getPosition());
                }
                break;

            case SceneMode.SCENE2D:
                this._updateScene2D(projection, this._billboards);
                break;

            case SceneMode.COLUMBUS_VIEW:
                this._updateColumbusView(projection, this._billboards);
                break;
            }
        } else if (mode === SceneMode.MORPHING) {
            billboards = this._billboards;
            length = billboards.length;

            for (i = 0; i < length; ++i) {
                b = billboards[i];
                var p = b.getPosition();
                var projectedPoint = projection.project(projection.getEllipsoid().cartesianToCartographic(p));

                b._setActualPosition({
                    x : CesiumMath.lerp(projectedPoint.z, p.x, this.morphTime),
                    y : CesiumMath.lerp(projectedPoint.x, p.y, this.morphTime),
                    z : CesiumMath.lerp(projectedPoint.y, p.z, this.morphTime)
                });
            }
        } else if (mode === SceneMode.SCENE2D) {
            this._updateScene2D(projection, this._billboardsToUpdate);
        } else if (mode === SceneMode.COLUMBUS_VIEW) {
            this._updateColumbusView(projection, this._billboardsToUpdate);
        }
    };

    BillboardCollection.prototype._update = function(context, sceneState) {
        var textureAtlas = this._textureAtlas;
        if (typeof textureAtlas === 'undefined') {
            // Can't write billboard vertices until we have texture coordinates
            // provided by a texture atlas
            return;
        }

        var textureAtlasCoordinates = textureAtlas.getTextureCoordinates();
        if (textureAtlasCoordinates.length === 0) {
            // Can't write billboard vertices until we have texture coordinates
            // provided by a texture atlas
            return;
        }

        this._removeBillboards();

        this._updateMode(sceneState);

        var billboards = this._billboards;
        var length = billboards.length;
        var properties = this._propertiesChanged;

        var textureAtlasGUID = textureAtlas.getGUID();
        var createVertexArray = this._createVertexArray || this._textureAtlasGUID !== textureAtlasGUID;
        this._textureAtlasGUID = textureAtlasGUID;

        var vafWriters;

        // PERFORMANCE_IDEA: Round robin multiple buffers.
        if (createVertexArray || this.computeNewBuffersUsage()) {
            this._createVertexArray = false;

            this._vaf = this._vaf && this._vaf.destroy();

            if (length > 0) {
                // PERFORMANCE_IDEA:  Instead of creating a new one, resize like std::vector.
                this._vaf = BillboardCollection._createVAF(context, billboards.length, this._buffersUsage);
                vafWriters = this._vaf.writers;

                // Rewrite entire buffer if billboards were added or removed.
                for ( var i = 0; i < length; ++i) {
                    var billboard = this._billboards[i];
                    billboard._clean(); // In case it needed an update.
                    this._writeBillboard(context, textureAtlasCoordinates, vafWriters, billboard);
                }

                // Different billboard collections share the same index buffer.
                this._vaf.commit(BillboardCollection._getIndexBuffer(context));
            }

            this._billboardsToUpdate = [];
        } else {
            // Billboards were modified, but none were added or removed.

            var billboardsToUpdate = this._billboardsToUpdate;
            var updateLength = billboardsToUpdate.length;

            if (updateLength) {
                var writers = [];

                if (properties[POSITION_INDEX]) {
                    writers.push(this._writePosition);
                }

                if (properties[PIXEL_OFFSET_INDEX]) {
                    writers.push(this._writePixelOffset);
                }

                if (properties[EYE_OFFSET_INDEX] || properties[SCALE_INDEX]) {
                    writers.push(this._writeEyeOffsetAndScale);
                }

                if (properties[IMAGE_INDEX_INDEX]) {
                    writers.push(this._writeTextureCoordinatesAndImageSize);
                }

                if (properties[COLOR_INDEX]) {
                    writers.push(this._writeColor);
                }

                if (properties[HORIZONTAL_ORIGIN_INDEX] || properties[VERTICAL_ORIGIN_INDEX] || properties[SHOW_INDEX]) {
                    writers.push(this._writeOriginAndShow);
                }

                vafWriters = this._vaf.writers;

                if ((updateLength / length) > 0.1) {
                    // If more than 10% of billboard change, rewrite the entire buffer.

                    // PERFORMANCE_IDEA:  I totally made up 10% :).

                    for ( var m = 0; m < updateLength; ++m) {
                        var b = billboardsToUpdate[m];
                        b._clean();

                        for ( var n = 0; n < writers.length; ++n) {
                            writers[n](context, textureAtlasCoordinates, vafWriters, b);
                        }
                    }
                    this._vaf.commit(BillboardCollection._getIndexBuffer(context));
                } else {
                    for ( var h = 0; h < updateLength; ++h) {
                        var bb = billboardsToUpdate[h];
                        bb._clean();

                        for ( var o = 0; o < writers.length; ++o) {
                            writers[o](context, textureAtlasCoordinates, vafWriters, bb);
                        }
                        this._vaf.subCommit(bb._index * 4, 4);
                    }
                    this._vaf.endSubCommits();
                }

                this._billboardsToUpdate = [];
            }
        }

        for ( var k = 0; k < NUMBER_OF_PROPERTIES; ++k) {
            properties[k] = 0;
        }

        this._uniforms = (sceneState.mode === SceneMode.SCENE3D) ? this._uniforms3D : this._uniforms2D;
    };

    /**
     * @private
     */
    BillboardCollection.prototype.updateForPick = function(context) {
        // First update:  create render state and shader program
        this._rsPick = context.createRenderState({
            depthTest : {
                enabled : true
            }
        });

        this._spPick = context.getShaderCache().getShaderProgram(
                BillboardCollectionVS,
                '#define RENDER_FOR_PICK 1\n' + BillboardCollectionFS,
                attributeIndices);

        this.updateForPick = function(context) {
        };
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof BillboardCollection
     *
     * @return {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     *
     * @see BillboardCollection#destroy
     */
    BillboardCollection.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof BillboardCollection
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see BillboardCollection#isDestroyed
     *
     * @example
     * billboards = billboards && billboards.destroy();
     */
    BillboardCollection.prototype.destroy = function() {
        this._textureAtlas = this._destroyTextureAtlas && this._textureAtlas && this._textureAtlas.destroy();
        this._sp = this._sp && this._sp.release();
        this._spPick = this._spPick && this._spPick.release();
        this._vaf = this._vaf && this._vaf.destroy();
        this._destroyBillboards();

        return destroyObject(this);
    };

    BillboardCollection.prototype._destroyBillboards = function() {
        var billboards = this._billboards;
        var length = billboards.length;
        for ( var i = 0; i < length; ++i) {
            if (billboards[i]) {
                billboards[i]._destroy();
            }
        }
    };

    return BillboardCollection;
});

/*global define*/
define('Shaders/BlobMaterial',[],function() {
  
  return "uniform vec4 u_lightColor;\n" +
"uniform vec4 u_darkColor;\n" +
"uniform float u_repeat;\n" +
"vec4 agi_getMaterialColor(float zDistance, vec2 st, vec3 str)\n" +
"{\n" +
"vec2 F = agi_cellular(st * u_repeat);\n" +
"float t = 1.0 - F.x*F.x;\n" +
"return mix(u_lightColor, u_darkColor, t);\n" +
"}\n" +
"";
});

/*global define*/
define('Shaders/BuiltinFunctions',[],function() {
  
  return "const float agi_infinity = 5906376272000.0;\n" +
"const float agi_epsilon1 = 0.1;\n" +
"const float agi_epsilon2 = 0.01;\n" +
"const float agi_epsilon3 = 0.001;\n" +
"const float agi_epsilon4 = 0.0001;\n" +
"const float agi_epsilon5 = 0.00001;\n" +
"const float agi_epsilon6 = 0.000001;\n" +
"const float agi_epsilon7 = 0.0000001;\n" +
"bool agi_equalsEpsilon(float left, float right, float epsilon) {\n" +
"return (abs(left - right) <= epsilon);\n" +
"}\n" +
"bool agi_equalsEpsilon(float left, float right) {\n" +
"return (abs(left - right) <= agi_epsilon7);\n" +
"}\n" +
"mat2 agi_transpose(mat2 matrix)\n" +
"{\n" +
"return mat2(\n" +
"matrix[0][0], matrix[1][0],\n" +
"matrix[0][1], matrix[1][1]);\n" +
"}\n" +
"mat3 agi_transpose(mat3 matrix)\n" +
"{\n" +
"return mat3(\n" +
"matrix[0][0], matrix[1][0], matrix[2][0],\n" +
"matrix[0][1], matrix[1][1], matrix[2][1],\n" +
"matrix[0][2], matrix[1][2], matrix[2][2]);\n" +
"}\n" +
"mat4 agi_transpose(mat4 matrix)\n" +
"{\n" +
"return mat4(\n" +
"matrix[0][0], matrix[1][0], matrix[2][0], matrix[3][0],\n" +
"matrix[0][1], matrix[1][1], matrix[2][1], matrix[3][1],\n" +
"matrix[0][2], matrix[1][2], matrix[2][2], matrix[3][2],\n" +
"matrix[0][3], matrix[1][3], matrix[2][3], matrix[3][3]);\n" +
"}\n" +
"vec4 agi_modelToWindowCoordinates(vec4 position)\n" +
"{\n" +
"vec4 q = agi_modelViewProjection * position;\n" +
"q.xyz /= q.w;\n" +
"q.xyz = (agi_viewportTransformation * vec4(q.xyz, 1.0)).xyz;\n" +
"return q;\n" +
"}\n" +
"vec4 agi_eyeToWindowCoordinates(vec4 positionEC)\n" +
"{\n" +
"vec4 q = agi_projection * positionEC;\n" +
"q.xyz /= q.w;\n" +
"q.xyz = (agi_viewportTransformation * vec4(q.xyz, 1.0)).xyz;\n" +
"return q;\n" +
"}\n" +
"vec4 agi_windowToEyeCoordinates(vec4 fragmentCoordinate)\n" +
"{\n" +
"float x = 2.0 * (fragmentCoordinate.x - float(agi_viewport.x)) / float(agi_viewport.z) - 1.0;\n" +
"float y = 2.0 * (fragmentCoordinate.y - float(agi_viewport.y)) / float(agi_viewport.w) - 1.0;\n" +
"float z = (fragmentCoordinate.z - agi_viewportTransformation[3][2]) / agi_viewportTransformation[2][2];\n" +
"vec4 q = vec4(x, y, z, 1.0);\n" +
"q /= fragmentCoordinate.w;\n" +
"q = agi_inverseProjection * q;\n" +
"return q;\n" +
"}\n" +
"vec4 agi_eyeOffset(vec4 positionEC, vec3 eyeOffset)\n" +
"{\n" +
"vec4 p = positionEC;\n" +
"vec4 zEyeOffset = normalize(p) * eyeOffset.z;\n" +
"p.xy += eyeOffset.xy + zEyeOffset.xy;\n" +
"p.z += zEyeOffset.z;\n" +
"return p;\n" +
"}\n" +
"vec3 agi_geodeticSurfaceNormal(vec3 positionOnEllipsoid, vec3 ellipsoidCenter, vec3 oneOverEllipsoidRadiiSquared)\n" +
"{\n" +
"return normalize((positionOnEllipsoid - ellipsoidCenter) * oneOverEllipsoidRadiiSquared);\n" +
"}\n" +
"vec2 agi_ellipsoidWgs84TextureCoordinates(vec3 normal)\n" +
"{\n" +
"return vec2(atan(normal.y, normal.x) * agi_oneOverTwoPi + 0.5, asin(normal.z) * agi_oneOverPi + 0.5);\n" +
"}\n" +
"mat3 agi_eastNorthUpToEyeCoordinates(vec3 positionMC, vec3 normalEC)\n" +
"{\n" +
"vec3 tangentMC = normalize(vec3(-positionMC.y, positionMC.x, 0.0));\n" +
"vec3 tangentEC = normalize(agi_normal * tangentMC);\n" +
"vec3 bitangentEC = normalize(cross(normalEC, tangentEC));\n" +
"return mat3(\n" +
"tangentEC.x,   tangentEC.y,   tangentEC.z,\n" +
"bitangentEC.x, bitangentEC.y, bitangentEC.z,\n" +
"normalEC.x,    normalEC.y,    normalEC.z);\n" +
"}\n" +
"float agi_lightIntensity(vec3 normal, vec3 toLight, vec3 toEye)\n" +
"{\n" +
"vec4 diffuseSpecularAmbientShininess = vec4(0.8, 0.1, 0.1, 10.0);\n" +
"vec3 toReflectedLight = reflect(-toLight, normal);\n" +
"float diffuse = max(dot(toLight, normal), 0.0);\n" +
"float specular = max(dot(toReflectedLight, toEye), 0.0);\n" +
"specular = pow(specular, diffuseSpecularAmbientShininess.w);\n" +
"return (diffuseSpecularAmbientShininess.x * diffuse) +\n" +
"(diffuseSpecularAmbientShininess.y * specular) +\n" +
"diffuseSpecularAmbientShininess.z;\n" +
"}\n" +
"float agi_twoSidedLightIntensity(vec3 normal, vec3 toLight, vec3 toEye)\n" +
"{\n" +
"vec4 diffuseSpecularAmbientShininess = vec4(0.8, 0.1, 0.1, 10.0);\n" +
"vec3 toReflectedLight = reflect(-toLight, normal);\n" +
"float diffuse = abs(dot(toLight, normal));\n" +
"float specular = abs(dot(toReflectedLight, toEye));\n" +
"specular = pow(specular, diffuseSpecularAmbientShininess.w);\n" +
"return (diffuseSpecularAmbientShininess.x * diffuse) +\n" +
"(diffuseSpecularAmbientShininess.y * specular) +\n" +
"diffuseSpecularAmbientShininess.z;\n" +
"}\n" +
"vec3 agi_multiplyWithColorBalance(vec3 left, vec3 right)\n" +
"{\n" +
"const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n" +
"vec3 target = left * right;\n" +
"float leftLuminance = dot(left, W);\n" +
"float rightLumiance = dot(right, W);\n" +
"float targetLumiance = dot(target, W);\n" +
"return ((leftLuminance + rightLumiance) / (2.0 * targetLumiance)) * target;\n" +
"}\n" +
"vec4 agi_columbusViewMorph(vec3 position2D, vec3 position3D, float time)\n" +
"{\n" +
"vec3 p = mix(position2D, position3D, time);\n" +
"return vec4(p, 1.0);\n" +
"}\n" +
"struct agi_ray\n" +
"{\n" +
"vec3 origin;\n" +
"vec3 direction;\n" +
"};\n" +
"vec3 agi_pointAlongRay(agi_ray ray, float time)\n" +
"{\n" +
"return ray.origin + (time * ray.direction);\n" +
"}\n" +
"struct agi_raySegment\n" +
"{\n" +
"float start;\n" +
"float stop;\n" +
"};\n" +
"const agi_raySegment agi_emptyRaySegment = agi_raySegment(-agi_infinity, -agi_infinity);\n" +
"const agi_raySegment agi_fullRaySegment = agi_raySegment(0.0, agi_infinity);\n" +
"bool agi_isEmpty(agi_raySegment interval)\n" +
"{\n" +
"return (interval.stop < 0.0);\n" +
"}\n" +
"bool agi_isFull(agi_raySegment interval)\n" +
"{\n" +
"return (interval.start == 0.0 && interval.stop == agi_infinity);\n" +
"}\n" +
"struct agi_ellipsoid\n" +
"{\n" +
"vec3 center;\n" +
"vec3 radii;\n" +
"vec3 inverseRadii;\n" +
"vec3 inverseRadiiSquared;\n" +
"};\n" +
"agi_ellipsoid agi_ellipsoidNew(vec3 center, vec3 radii)\n" +
"{\n" +
"vec3 inverseRadii = vec3(1.0 / radii.x, 1.0 / radii.y, 1.0 / radii.z);\n" +
"vec3 inverseRadiiSquared = inverseRadii * inverseRadii;\n" +
"agi_ellipsoid temp = agi_ellipsoid(center, radii, inverseRadii, inverseRadiiSquared);\n" +
"return temp;\n" +
"}\n" +
"bool agi_ellipsoidContainsPoint(agi_ellipsoid ellipsoid, vec3 point)\n" +
"{\n" +
"vec3 scaled = ellipsoid.inverseRadii * (agi_inverseView * vec4(point, 1.0)).xyz;\n" +
"return (dot(scaled, scaled) <= 1.0);\n" +
"}\n" +
"vec3 agi_ellipsoidNormal(agi_ellipsoid ellipsoid, vec3 pointOnEllipsoid)\n" +
"{\n" +
"vec3 n = ellipsoid.inverseRadiiSquared * (agi_inverseView * vec4(pointOnEllipsoid, 1.0)).xyz;\n" +
"vec3 rotated = (agi_view * vec4(n, 0.0)).xyz;\n" +
"return normalize(rotated);\n" +
"}\n" +
"agi_raySegment agi_rayEllipsoidIntersectionInterval(agi_ray ray, agi_ellipsoid ellipsoid)\n" +
"{\n" +
"vec3 q = ellipsoid.inverseRadii * (agi_inverseView * vec4(ray.origin, 1.0)).xyz;\n" +
"vec3 w = ellipsoid.inverseRadii * (agi_inverseView * vec4(ray.direction, 0.0)).xyz;\n" +
"float q2 = dot(q, q);\n" +
"float qw = dot(q, w);\n" +
"if (q2 > 1.0)\n" +
"{\n" +
"if (qw >= 0.0)\n" +
"{\n" +
"return agi_emptyRaySegment;\n" +
"}\n" +
"else\n" +
"{\n" +
"float qw2 = qw * qw;\n" +
"float difference = q2 - 1.0;\n" +
"float w2 = dot(w, w);\n" +
"float product = w2 * difference;\n" +
"if (qw2 < product)\n" +
"{\n" +
"return agi_emptyRaySegment;\n" +
"}\n" +
"else if (qw2 > product)\n" +
"{\n" +
"float discriminant = qw * qw - product;\n" +
"float temp = -qw + sqrt(discriminant);\n" +
"float root0 = temp / w2;\n" +
"float root1 = difference / temp;\n" +
"if (root0 < root1)\n" +
"{\n" +
"agi_raySegment i = agi_raySegment(root0, root1);\n" +
"return i;\n" +
"}\n" +
"else\n" +
"{\n" +
"agi_raySegment i = agi_raySegment(root1, root0);\n" +
"return i;\n" +
"}\n" +
"}\n" +
"else\n" +
"{\n" +
"float root = sqrt(difference / w2);\n" +
"agi_raySegment i = agi_raySegment(root, root);\n" +
"return i;\n" +
"}\n" +
"}\n" +
"}\n" +
"else if (q2 < 1.0)\n" +
"{\n" +
"float difference = q2 - 1.0;\n" +
"float w2 = dot(w, w);\n" +
"float product = w2 * difference;\n" +
"if (qw < 0.0)\n" +
"{\n" +
"float discriminant = qw * qw - product;\n" +
"float temp = qw - sqrt(discriminant);\n" +
"agi_raySegment i = agi_raySegment(0.0, difference / temp);\n" +
"return i;\n" +
"}\n" +
"else if (qw > 0.0)\n" +
"{\n" +
"float discriminant = qw * qw - product;\n" +
"float temp = qw + sqrt(discriminant);\n" +
"agi_raySegment i = agi_raySegment(0.0, temp / w2);\n" +
"return i;\n" +
"}\n" +
"else\n" +
"{\n" +
"float temp = sqrt(-product);\n" +
"agi_raySegment i = agi_raySegment(0.0, temp / w2);\n" +
"return i;\n" +
"}\n" +
"}\n" +
"else\n" +
"{\n" +
"if (qw < 0.0)\n" +
"{\n" +
"float w2 = dot(w, w);\n" +
"agi_raySegment i = agi_raySegment(0.0, -qw / w2);\n" +
"return i;\n" +
"}\n" +
"else\n" +
"{\n" +
"return agi_emptyRaySegment;\n" +
"}\n" +
"}\n" +
"}\n" +
"agi_ellipsoid agi_getWgs84EllipsoidEC()\n" +
"{\n" +
"return agi_ellipsoidNew(\n" +
"vec3(agi_view[3].x, agi_view[3].y, agi_view[3].z),\n" +
"vec3(6378137.0, 6378137.0, 6356752.314245));\n" +
"}\n" +
"";
});
/*global define*/
define('Renderer/Context',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/Color',
        '../Core/IndexDatatype',
        '../Core/RuntimeError',
        '../Core/PrimitiveType',
        '../Core/WindingOrder',
        '../Shaders/BuiltinFunctions',
        './Buffer',
        './BufferUsage',
        './BlendEquation',
        './BlendFunction',
        './CubeMap',
        './CullFace',
        './DepthFunction',
        './Framebuffer',
        './MipmapHint',
        './PixelDatatype',
        './PixelFormat',
        './PickFramebuffer',
        './Renderbuffer',
        './RenderbufferFormat',
        './ShaderCache',
        './ShaderProgram',
        './StencilFunction',
        './StencilOperation',
        './Texture',
        './TextureAtlas',
        './TextureMagnificationFilter',
        './TextureMinificationFilter',
        './TextureWrap',
        './UniformState',
        './VertexArray',
        './VertexLayout'
    ], function(
        DeveloperError,
        destroyObject,
        Color,
        IndexDatatype,
        RuntimeError,
        PrimitiveType,
        WindingOrder,
        ShadersBuiltinFunctions,
        Buffer,
        BufferUsage,
        BlendEquation,
        BlendFunction,
        CubeMap,
        CullFace,
        DepthFunction,
        Framebuffer,
        MipmapHint,
        PixelDatatype,
        PixelFormat,
        PickFramebuffer,
        Renderbuffer,
        RenderbufferFormat,
        ShaderCache,
        ShaderProgram,
        StencilFunction,
        StencilOperation,
        Texture,
        TextureAtlas,
        TextureMagnificationFilter,
        TextureMinificationFilter,
        TextureWrap,
        UniformState,
        VertexArray,
        VertexLayout) {
    

    function _errorToString(gl, error) {
        var message = 'OpenGL Error:  ';
        switch (error) {
        case gl.INVALID_ENUM:
            message += 'Invalid enumeration';
            break;
        case gl.INVALID_VALUE:
            message += 'Invalid value';
            break;
        case gl.INVALID_OPERATION:
            message += 'Invalid operation';
            break;
        case gl.OUT_OF_MEMORY:
            message += 'Out of memory';
            break;
        case gl.CONTEXT_LOST_WEBGL:
            message += 'Context lost';
            break;
        default:
            message += 'Unknown';
        }

        return message;
    }

    function _createErrorMessage(gl, glFunc, glFuncArguments, error) {
        var message = _errorToString(gl, error) + ': ' + glFunc.name + '(';

        for ( var i = 0; i < glFuncArguments.length; ++i) {
            if (i !== 0) {
                message += ', ';
            }
            message += glFuncArguments[i];
        }
        message += ');';

        return message;
    }

    function throwOnError(gl, glFunc, glFuncArguments) {
        var error = gl.getError();
        if (error !== gl.NO_ERROR) {
            throw new RuntimeError(_createErrorMessage(gl, glFunc, glFuncArguments, error));
        }
    }

    function wrapGL(gl, logFunc) {
        if (!logFunc) {
            return gl;
        }

        function wrapFunction(property) {
            return function() {
                var result = property.apply(gl, arguments);
                logFunc(gl, property, arguments);
                return result;
            };
        }

        var glWrapper = {};

        /*jslint forin: true*/
        /*jshint forin: false*/
        // JSLint normally demands that a for..in loop must directly contain an if,
        // but in our loop below, we actually intend to iterate all properties, including
        // those in the prototype.
        for ( var propertyName in gl) {
            var property = gl[propertyName];

            // wrap any functions we encounter, otherwise just copy the property to the wrapper.
            if (typeof property === 'function') {
                glWrapper[propertyName] = wrapFunction(property);
            } else {
                glWrapper[propertyName] = property;
            }
        }

        return glWrapper;
    }

    /**
     * DOC_TBA
     *
     * @alias Context
     * @constructor
     *
     * @exception {RuntimeError} The browser does not support WebGL.  Visit http://get.webgl.org.
     * @exception {RuntimeError} The browser supports WebGL, but initialization failed.
     * @exception {DeveloperError} canvas is required.
     */
    var Context = function(canvas, options) {
        if (!window.WebGLRenderingContext) {
            throw new RuntimeError('The browser does not support WebGL.  Visit http://get.webgl.org.');
        }

        if (!canvas) {
            throw new DeveloperError('canvas is required.');
        }

        this._canvas = canvas;

        if (typeof options === 'undefined') {
            options = {};
        }
        if (typeof options.stencil === 'undefined') {
            options.stencil = true;
        }
        if (typeof options.alpha === 'undefined') {
            options.alpha = false;
        }

        this._originalGLContext = canvas.getContext('webgl', options) || canvas.getContext('experimental-webgl', options);

        if (!this._originalGLContext) {
            throw new RuntimeError('The browser supports WebGL, but initialization failed.');
        }

        // Validation and logging disabled by default for speed.
        this._validateFB = false;
        this._validateSP = false;
        this._logShaderCompilation = false;
        this._throwOnWebGLError = false;

        // TODO:  Also need point_size and point_size_enable for ColladaFX
        // TODO:  Also need sample_alpha_to_coverage_enable for ColladaFX
        this._shaderCache = new ShaderCache(this);

        var gl = this._gl = this._originalGLContext;

        this._version = gl.getParameter(gl.VERSION);
        this._shadingLanguageVersion = gl.getParameter(gl.SHADING_LANGUAGE_VERSION);
        this._vendor = gl.getParameter(gl.VENDOR);
        this._renderer = gl.getParameter(gl.RENDERER);
        this._redBits = gl.getParameter(gl.RED_BITS);
        this._greenBits = gl.getParameter(gl.GREEN_BITS);
        this._blueBits = gl.getParameter(gl.BLUE_BITS);
        this._alphaBits = gl.getParameter(gl.ALPHA_BITS);
        this._depthBits = gl.getParameter(gl.DEPTH_BITS);
        this._stencilBits = gl.getParameter(gl.STENCIL_BITS);
        this._maximumCombinedTextureImageUnits = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS); // min: 8
        this._maximumCubeMapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE); // min: 16
        this._maximumFragmentUniformVectors = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS); // min: 16
        this._maximumTextureImageUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS); // min: 8
        this._maximumRenderbufferSize = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE); // min: 1
        this._maximumTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE); // min: 64
        this._maximumVaryingVectors = gl.getParameter(gl.MAX_VARYING_VECTORS); // min: 8
        this._maximumVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS); // min: 8
        this._maximumVertexTextureImageUnits = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS); // min: 0
        this._maximumVertexUniformVectors = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS); // min: 128
        this._aliasedLineWidthRange = gl.getParameter(gl.ALIASED_LINE_WIDTH_RANGE); // must include 1
        this._aliasedPointSizeRange = gl.getParameter(gl.ALIASED_POINT_SIZE_RANGE); // must include 1
        this._maximumViewportDimensions = gl.getParameter(gl.MAX_VIEWPORT_DIMS);
        this._viewport = gl.getParameter(gl.VIEWPORT);

        // Query and initialize extensions
        var textureFilterAnisotropic = gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic');

        this._standardDerivatives = gl.getExtension('OES_standard_derivatives');
        this._textureFilterAnisotropic = textureFilterAnisotropic;
        this._maximumTextureFilterAnisotropy = textureFilterAnisotropic ? gl.getParameter(textureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1.0;

        var cc = gl.getParameter(gl.COLOR_CLEAR_VALUE);
        this._clearColor = new Color(cc[0], cc[1], cc[2], cc[3]);
        this._clearDepth = gl.getParameter(gl.DEPTH_CLEAR_VALUE);
        this._clearStencil = gl.getParameter(gl.STENCIL_CLEAR_VALUE);
        this._defaultClearColor = new Color(cc[0], cc[1], cc[2], cc[3]);
        this._defaultClearDepth = this._clearDepth;
        this._defaultClearStencil = this._clearStencil;

        this._us = new UniformState(this);
        this._currentFramebuffer = undefined;
        this._currentSp = undefined;
    };

    Context.prototype._enableOrDisable = function(glEnum, enable) {
        if (enable) {
            this._gl.enable(glEnum);
        } else {
            this._gl.disable(glEnum);
        }
    };

    Context.prototype._applyFrontFace = function(frontFace) {
        this._gl.frontFace(frontFace);
    };

    Context.prototype._applyCull = function(cull) {
        var gl = this._gl;
        var enabled = cull.enabled;

        this._enableOrDisable(gl.CULL_FACE, enabled);

        if (enabled) {
            gl.cullFace(cull.face);
        }
    };

    Context.prototype._applyLineWidth = function(lineWidth) {
        this._gl.lineWidth(lineWidth);
    };

    Context.prototype._applyPolygonOffset = function(polygonOffset) {
        var gl = this._gl;
        var enabled = polygonOffset.enabled;

        this._enableOrDisable(gl.POLYGON_OFFSET_FILL, enabled);

        if (enabled) {
            gl.polygonOffset(polygonOffset.factor, polygonOffset.units);
        }
    };

    Context.prototype._applyScissorTest = function(scissorTest) {
        var gl = this._gl;
        var enabled = scissorTest.enabled;

        this._enableOrDisable(gl.SCISSOR_TEST, enabled);

        if (enabled) {
            var newRectangle = scissorTest.rectangle;
            gl.scissor(newRectangle.x, newRectangle.y, newRectangle.width, newRectangle.height);
        }
    };

    Context.prototype._applyDepthRange = function(depthRange) {
        var near = depthRange.near;
        var far = depthRange.far;
        this._gl.depthRange(near, far);
    };

    Context.prototype._applyDepthTest = function(depthTest) {
        var gl = this._gl;
        var enabled = depthTest.enabled;

        this._enableOrDisable(gl.DEPTH_TEST, enabled);

        if (enabled) {
            gl.depthFunc(depthTest.func);
        }
    };

    Context.prototype._applyColorMask = function(colorMask) {
        this._gl.colorMask(colorMask.red, colorMask.green, colorMask.blue, colorMask.alpha);
    };

    Context.prototype._applyDepthMask = function(depthMask) {
        this._gl.depthMask(depthMask);
    };

    Context.prototype._applyStencilMask = function(stencilMask) {
        this._gl.stencilMask(stencilMask);
    };

    Context.prototype._applyBlending = function(blending) {
        var gl = this._gl;
        var enabled = blending.enabled;

        this._enableOrDisable(gl.BLEND, enabled);

        if (enabled) {
            var color = blending.color;
            var equationRgb = blending.equationRgb;
            var equationAlpha = blending.equationAlpha;
            var functionSourceRgb = blending.functionSourceRgb;
            var functionDestinationRgb = blending.functionDestinationRgb;
            var functionSourceAlpha = blending.functionSourceAlpha;
            var functionDestinationAlpha = blending.functionDestinationAlpha;

            gl.blendColor(color.red, color.green, color.blue, color.alpha);
            gl.blendEquationSeparate(equationRgb, equationAlpha);
            gl.blendFuncSeparate(functionSourceRgb, functionDestinationRgb, functionSourceAlpha, functionDestinationAlpha);
        }
    };

    Context.prototype._applyStencilTest = function(stencilTest) {
        var gl = this._gl;
        var enabled = stencilTest.enabled;

        this._enableOrDisable(gl.STENCIL_TEST, enabled);

        if (enabled) {
            var frontFunction = stencilTest.frontFunction;
            var backFunction = stencilTest.backFunction;
            var reference = stencilTest.reference;
            var mask = stencilTest.mask;

            // Section 6.8 of the WebGL spec requires the reference and masks to be the same for
            // front- and back-face tests.  This call prevents invalid operation errors when calling
            // stencilFuncSeparate on Firefox.  Perhaps they should delay validation to avoid requiring this.
            gl.stencilFunc(stencilTest.frontFunction, stencilTest.reference, stencilTest.mask);
            gl.stencilFuncSeparate(gl.BACK, backFunction, reference, mask);
            gl.stencilFuncSeparate(gl.FRONT, frontFunction, reference, mask);

            var frontOperation = stencilTest.frontOperation;
            var frontOperationFail = frontOperation.fail;
            var frontOperationZFail = frontOperation.zFail;
            var frontOperationZPass = frontOperation.zPass;

            gl.stencilOpSeparate(gl.FRONT, frontOperationFail, frontOperationZFail, frontOperationZPass);

            var backOperation = stencilTest.backOperation;
            var backOperationFail = backOperation.fail;
            var backOperationZFail = backOperation.zFail;
            var backOperationZPass = backOperation.zPass;

            gl.stencilOpSeparate(gl.BACK, backOperationFail, backOperationZFail, backOperationZPass);
        }
    };

    Context.prototype._applySampleCoverage = function(sampleCoverage) {
        var gl = this._gl;
        var enabled = sampleCoverage.enabled;

        this._enableOrDisable(gl.SAMPLE_COVERAGE, enabled);

        if (enabled) {
            gl.sampleCoverage(sampleCoverage.value, sampleCoverage.invert);
        }
    };

    Context.prototype._applyDither = function(dither) {
        this._enableOrDisable(this._gl.DITHER, dither);
    };

    Context.prototype._applyRenderState = function(state) {
        this._applyFrontFace(state.frontFace);
        this._applyCull(state.cull);
        this._applyLineWidth(state.lineWidth);
        this._applyPolygonOffset(state.polygonOffset);
        this._applyScissorTest(state.scissorTest);
        this._applyDepthRange(state.depthRange);
        this._applyDepthTest(state.depthTest);
        this._applyColorMask(state.colorMask);
        this._applyDepthMask(state.depthMask);
        this._applyStencilMask(state.stencilMask);
        this._applyBlending(state.blending);
        this._applyStencilTest(state.stencilTest);
        this._applySampleCoverage(state.sampleCoverage);
        this._applyDither(state.dither);
    };

    /**
     * Returns the canvas assoicated with this context.
     *
     * @memberof Context
     *
     * @returns {HTMLCanvasElement} The canvas assoicated with this context.
     */
    Context.prototype.getCanvas = function() {
        return this._canvas;
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     *
     * @see Context#createShaderProgram
     */
    Context.prototype.getShaderCache = function() {
        return this._shaderCache;
    };

    /**
     * DOC_TBA
     * @memberof Context
     */
    Context.prototype.getUniformState = function() {
        return this._us;
    };

    /**
     * Returns the viewport, which determines the rectangular region of the canvas that is rendered to.  The viewport contains four
     * properties: <code>x</code> and <code>y</code>, which define the lower left corner of the viewport in window coordinates
     * (relative to the canvas), and its <code>width</code> and <code>height</code> in pixels.
     *
     * @memberof Context
     *
     * @returns The viewport defined by its <code>x</code> and <code>y</code> window coordinates and its <code>width</code> and <code>height</code>.
     *
     * @see Context#setViewport
     * @see Context#getCanvas
     * @see agi_viewport
     *
     * @example
     * var viewport = context.getViewport();
     * console.log(viewport.x);
     * console.log(viewport.y);
     * console.log(viewport.width);
     * console.log(viewport.height);
     */
    Context.prototype.getViewport = function() {
        var v = this._viewport;
        return {
            x : v[0],
            y : v[1],
            width : v[2],
            height : v[3]
        };
    };

    /**
     * Sets the viewport, which determines the rectangular region of the canvas that is rendered to.  The viewport contains four
     * properties: <code>x</code> and <code>y</code>, which define the lower left corner of the viewport in window coordinates
     * (relative to the canvas), and its <code>width</code> and <code>height</code> in pixels.
     *
     * @memberof Context
     *
     * @param {Object} viewport The new viewport defined by its <code>x</code> and <code>y</code> window coordinates and its <code>width</code> and <code>height</code>.
     *
     * @exception {RuntimeError} viewport.width must be less than or equal to the maximum viewport width.
     * @exception {RuntimeError} viewport.height must be less than or equal to the maximum viewport height.
     *
     * @exception {DeveloperError} A viewport with x, y, width, and height properties is required.
     * @exception {DeveloperError} viewport.width must be greater than or equal to zero.
     * @exception {DeveloperError} viewport.height must be greater than or equal to zero.
     *
     * @see Context#getViewport
     * @see Context#getMaximumViewportWidth
     * @see Context#getMaximumViewportHeight
     * @see Context#getCanvas
     * @see agi_viewport
     *
     * @example
     * context.setViewport({
     *     x      : 0,
     *     y      : 0,
     *     width  : 640,
     *     height : 480
     * });
     */
    Context.prototype.setViewport = function(viewport) {
        if ((typeof viewport === 'undefined') ||
            (typeof viewport.x === 'undefined') ||
            (typeof viewport.y === 'undefined') ||
            (typeof viewport.width === 'undefined') ||
            (typeof viewport.height === 'undefined')) {
            throw new DeveloperError('A viewport with x, y, width, and height properties is required.');
        }

        var x = viewport.x;
        var y = viewport.y;
        var w = viewport.width;
        var h = viewport.height;

        if (w < 0) {
            throw new DeveloperError('viewport.width must be greater than or equal to zero.');
        }

        if (w > this.getMaximumViewportWidth()) {
            throw new RuntimeError('viewport.width must be less than or equal to the maximum viewport width (' + this.getMaximumViewportWidth().toString() + ').  Check getMaximumViewportWidth().');
        }

        if (h < 0) {
            throw new DeveloperError('viewport.height must be greater than or equal to zero.');
        }

        if (h > this.getMaximumViewportHeight()) {
            throw new RuntimeError('viewport.height must be less than or equal to the maximum viewport height (' + this.getMaximumViewportHeight().toString() + ').  Check getMaximumViewportHeight().');
        }

        var v = this._viewport;
        if ((x !== v[0]) || (y !== v[1]) || (w !== v[2]) || (h !== v[3])) {
            v[0] = x;
            v[1] = y;
            v[2] = w;
            v[3] = h;
            this._gl.viewport(viewport.x, viewport.y, w, h);
        }
    };

    /**
     * Returns the WebGL version or release number of the form &lt;WebGL&gt;&lt;space&gt;&lt;version number&gt;&lt;space&gt;&lt;vendor-specific information&gt;.
     *
     * @memberof Context
     *
     * @returns {String} The WebGL version or release number.
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGetString.xml'>glGetString</a> with <code>VERSION</code>.
     */
    Context.prototype.getVersion = function() {
        return this._version;
    };

    /**
     * Returns the version or release number for the shading language of the form WebGL&lt;space&gt;GLSL&lt;space&gt;ES&lt;space&gt;&lt;version number&gt;&lt;space&gt;&lt;vendor-specific information&gt;.
     *
     * @memberof Context
     *
     * @returns {String} The version or release number for the shading language.
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGetString.xml'>glGetString</a> with <code>SHADING_LANGUAGE_VERSION</code>.
     */
    Context.prototype.getShadingLanguageVersion = function() {
        return this._shadingLanguageVersion;
    };

    /**
     * Returns the company responsible for the WebGL implementation.
     *
     * @memberof Context
     *
     * @returns {String} The company responsible for the WebGL implementation.
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGetString.xml'>glGetString</a> with <code>VENDOR</code>.
     */
    Context.prototype.getVendor = function() {
        return this._vendor;
    };

    /**
     * Returns the name of the renderer/configuration/hardware platform. For example, this may be the model of the
     * video card, e.g., 'GeForce 8800 GTS/PCI/SSE2', or the browser-dependent name of the GL implementation, e.g.
     * 'Mozilla' or 'ANGLE.'
     *
     * @memberof Context
     *
     * @returns {String} The name of the renderer.
     *
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGetString.xml'>glGetString</a> with <code>RENDERER</code>.
     * @see <a href='http://code.google.com/p/angleproject/'>ANGLE</a>
     */
    Context.prototype.getRenderer = function() {
        return this._renderer;
    };

    /**
     * Returns the number of red bits per component in the default framebuffer's color buffer.  The minimum is eight.
     *
     * @memberof Context
     *
     * @returns {Number} The number of red bits per component in the color buffer.
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml'>glGet</a> with <code>RED_BITS</code>.
     */
    Context.prototype.getRedBits = function() {
        return this._redBits;
    };

    /**
     * Returns the number of green bits per component in the default framebuffer's color buffer.  The minimum is eight.
     *
     * @memberof Context
     *
     * @returns {Number} The number of green bits per component in the color buffer.
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml'>glGet</a> with <code>GREEN_BITS</code>.
     */
    Context.prototype.getGreenBits = function() {
        return this._greenBits;
    };

    /**
     * Returns the number of blue bits per component in the default framebuffer's color buffer.  The minimum is eight.
     *
     * @memberof Context
     *
     * @returns {Number} The number of blue bits per component in the color buffer.
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml'>glGet</a> with <code>BLUE_BITS</code>.
     */
    Context.prototype.getBlueBits = function() {
        return this._blueBits;
    };

    /**
     * Returns the number of alpha bits per component in the default framebuffer's color buffer.  The minimum is eight.
     * <br /><br />
     * The alpha channel is used for GL destination alpha operations and by the HTML compositor to combine the color buffer
     * with the rest of the page.
     *
     * @memberof Context
     *
     * @returns {Number} The number of alpha bits per component in the color buffer.
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml'>glGet</a> with <code>ALPHA_BITS</code>.
     */
    Context.prototype.getAlphaBits = function() {
        return this._alphaBits;
    };

    /**
     * Returns the number of depth bits per pixel in the default bound framebuffer.  The minimum is 16 bits; most
     * implementations will have 24 bits.
     *
     * @memberof Context
     *
     * @returns {Number} The number of depth bits per pixel in the default bound framebuffer.
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml'>glGet</a> with <code>DEPTH_BITS</code>.
     */
    Context.prototype.getDepthBits = function() {
        return this._depthBits;
    };

    /**
     * Returns the number of stencil bits per pixel in the default bound framebuffer.  The minimum is eight bits.
     *
     * @memberof Context
     *
     * @returns {Number} The number of stencil bits per pixel in the default bound framebuffer.
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml'>glGet</a> with <code>STENCIL_BITS</code>.
     */
    Context.prototype.getStencilBits = function() {
        return this._stencilBits;
    };

    /**
     * Returns the maximum number of texture units that can be used from the vertex and fragment
     * shader with this WebGL implementation.  The minimum is eight.  If both shaders access the
     * same texture unit, this counts as two texture units.
     *
     * @memberof Context
     *
     * @returns {Number} The maximum supported texture image units.
     *
     * @see Context#getMaximumTextureImageUnits
     * @see Context#getMaximumVertexTextureImageUnits
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml'>glGet</a> with <code>MAX_COMBINED_TEXTURE_IMAGE_UNITS</code>.
     */
    Context.prototype.getMaximumCombinedTextureImageUnits = function() {
        return this._maximumCombinedTextureImageUnits;
    };

    /**
     * Returns the approximate maximum cube mape width and height supported by this WebGL implementation.
     * The minimum is 16, but most desktop and laptop implementations will support much larger sizes like 8,192.
     *
     * @memberof Context
     *
     * @returns {Number} The approximate maximum cube mape width and height.
     *
     * @see Context#createCubeMap
     * @see Context#getMaximumTextureSize
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml'>glGet</a> with <code>MAX_CUBE_MAP_TEXTURE_SIZE</code>.
     */
    Context.prototype.getMaximumCubeMapSize = function() {
        return this._maximumCubeMapSize;
    };

    /**
     * Returns the maximum number of <code>vec4</code>, <code>ivec4</code>, and <code>bvec4</code>
     * uniforms that can be used by a fragment shader with this WebGL implementation.  The minimum is 16.
     *
     * @memberof Context
     *
     * @returns {Number} The maximum number of <code>vec4</code>, <code>ivec4</code>, and <code>bvec4</code> uniforms that can be used by a fragment shader.
     *
     * @see Context#getMaximumVertexUniformVectors
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml'>glGet</a> with <code>MAX_FRAGMENT_UNIFORM_VECTORS</code>.
     */
    Context.prototype.getMaximumFragmentUniformVectors = function() {
        return this._maximumFragmentUniformVectors;
    };

    /**
     * Returns the maximum number of texture units that can be used from the fragment shader with this WebGL implementation.  The minimum is eight.
     *
     * @memberof Context
     *
     * @returns {Number} The maximum number of texture units that can be used from the fragment shader.
     *
     * @see Context#getMaximumCombinedTextureImageUnits
     * @see Context#getMaximumVertexTextureImageUnits
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml'>glGet</a> with <code>MAX_TEXTURE_IMAGE_UNITS</code>.
     */
    Context.prototype.getMaximumTextureImageUnits = function() {
        return this._maximumTextureImageUnits;
    };

    /**
     * Returns the maximum renderbuffer width and height supported by this WebGL implementation.
     * The minimum is 16, but most desktop and laptop implementations will support much larger sizes like 8,192.
     *
     * @memberof Context
     *
     * @returns {Number} The maximum renderbuffer width and height.
     *
     * @see Context#createRenderbuffer
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml'>glGet</a> with <code>MAX_RENDERBUFFER_SIZE</code>.
     */
    Context.prototype.getMaximumRenderbufferSize = function() {
        return this._maximumRenderbufferSize;
    };

    /**
     * Returns the approximate maximum texture width and height supported by this WebGL implementation.
     * The minimum is 64, but most desktop and laptop implementations will support much larger sizes like 8,192.
     *
     * @memberof Context
     *
     * @returns {Number} The approximate maximum texture width and height.
     *
     * @see Context#createTexture2D
     * @see Context#getMaximumCubeMapSize
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml'>glGet</a> with <code>MAX_TEXTURE_SIZE</code>.
     */
    Context.prototype.getMaximumTextureSize = function() {
        return this._maximumTextureSize;
    };

    /**
     * Returns the maximum number of <code>vec4</code> varying variables supported by this WebGL implementation.
     * The minimum is eight.  Matrices and arrays count as multiple <code>vec4</code>s.
     *
     * @memberof Context
     *
     * @returns {Number} Returns the maximum number of <code>vec4</code> varying variables.
     *
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml'>glGet</a> with <code>MAX_VARYING_VECTORS</code>.
     */
    Context.prototype.getMaximumVaryingVectors = function() {
        return this._maximumVaryingVectors;
    };

    /**
     * Returns the maximum number of <code>vec4</code> vertex attributes supported by this WebGL implementation.  The minimum is eight.
     *
     * @memberof Context
     *
     * @returns {Number} The maximum number of <code>vec4</code> vertex attributes.
     *
     * @see Context#createVertexArray
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml'>glGet</a> with <code>MAX_VERTEX_ATTRIBS</code>.
     */
    Context.prototype.getMaximumVertexAttributes = function() {
        return this._maximumVertexAttributes;
    };

    /**
     * Returns the maximum number of texture units that can be used from the vertex shader with this WebGL implementation.
     * The minimum is zero, which means the GL does not support vertex texture fetch.
     *
     * @memberof Context
     *
     * @returns {Number} The maximum number of texture units that can be used from the vertex shader.
     *
     * @see Context#getMaximumCombinedTextureImageUnits
     * @see Context#getMaximumTextureImageUnits
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml'>glGet</a> with <code>MAX_VERTEX_TEXTURE_IMAGE_UNITS</code>.
     */
    Context.prototype.getMaximumVertexTextureImageUnits = function() {
        return this._maximumVertexTextureImageUnits;
    };

    /**
     * Returns the maximum number of <code>vec4</code>, <code>ivec4</code>, and <code>bvec4</code>
     * uniforms that can be used by a vertex shader with this WebGL implementation.  The minimum is 16.
     *
     * @memberof Context
     *
     * @returns {Number} The maximum number of <code>vec4</code>, <code>ivec4</code>, and <code>bvec4</code> uniforms that can be used by a vertex shader.
     *
     * @see Context#getMaximumFragmentUniformVectors
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml'>glGet</a> with <code>MAX_VERTEX_UNIFORM_VECTORS</code>.
     */
    Context.prototype.getMaximumVertexUniformVectors = function() {
        return this._maximumVertexUniformVectors;
    };

    /**
     * Returns the minimum aliased line width, in pixels, supported by this WebGL implementation.  It will be at most one.
     *
     * @memberof Context
     *
     * @returns {Number} The minimum aliased line in pixels.
     *
     * @see Context#getMaximumAliasedLineWidth
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml'>glGet</a> with <code>ALIASED_LINE_WIDTH_RANGE</code>.
     */
    Context.prototype.getMinimumAliasedLineWidth = function() {
        return this._aliasedLineWidthRange[0];
    };

    /**
     * Returns the maximum aliased line width, in pixels, supported by this WebGL implementation.  It will be at least one.
     *
     * @memberof Context
     *
     * @returns {Number} The maximum aliased line in pixels.
     *
     * @see Context#getMinimumAliasedLineWidth
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml'>glGet</a> with <code>ALIASED_LINE_WIDTH_RANGE</code>.
     */
    Context.prototype.getMaximumAliasedLineWidth = function() {
        return this._aliasedLineWidthRange[1];
    };

    /**
     * Returns the minimum aliased point size, in pixels, supported by this WebGL implementation.  It will be at most one.
     *
     * @memberof Context
     *
     * @returns {Number} The minimum aliased point size in pixels.
     *
     * @see Context#getMaximumAliasedPointSize
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml'>glGet</a> with <code>ALIASED_POINT_SIZE_RANGE</code>.
     */
    Context.prototype.getMinimumAliasedPointSize = function() {
        return this._aliasedPointSizeRange[0];
    };

    /**
     * Returns the maximum aliased point size, in pixels, supported by this WebGL implementation.  It will be at least one.
     *
     * @memberof Context
     *
     * @returns {Number} The maximum aliased point size in pixels.
     *
     * @see Context#getMinimumAliasedPointSize
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml'>glGet</a> with <code>ALIASED_POINT_SIZE_RANGE</code>.
     */
    Context.prototype.getMaximumAliasedPointSize = function() {
        return this._aliasedPointSizeRange[1];
    };

    /**
     * Returns the maximum supported width of the viewport.  It will be at least as large as the visible width of the associated canvas.
     *
     * @memberof Context
     *
     * @returns {Number} The maximum supported width of the viewport.
     *
     * @see Context#getMaximumViewportHeight
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml'>glGet</a> with <code>MAX_VIEWPORT_DIMS</code>.
     */
    Context.prototype.getMaximumViewportWidth = function() {
        return this._maximumViewportDimensions[0];
    };

    /**
     * Returns the maximum supported height of the viewport.  It will be at least as large as the visible height of the associated canvas.
     *
     * @memberof Context
     *
     * @returns {Number} The maximum supported height of the viewport.
     *
     * @see Context#getMaximumViewportHeight
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGet.xml'>glGet</a> with <code>MAX_VIEWPORT_DIMS</code>.
     */
    Context.prototype.getMaximumViewportHeight = function() {
        return this._maximumViewportDimensions[1];
    };

    /**
     * Returns <code>true</code> if the OES_standard_derivatives extension is supported.  This
     * extension provides access to <code>dFdx<code>, <code>dFdy<code>, and <code>fwidth<code>
     * functions from GLSL.  A shader using these functions still needs to explicitly enable the
     * extension with <code>#extension GL_OES_standard_derivatives : enable</code>.
     *
     * @memberof Context
     *
     * @returns {Boolean} <code>true</code> if OES_standard_derivatives is supported; otherwise, <code>false</code>.
     *
     * @see <a href='http://www.khronos.org/registry/gles/extensions/OES/OES_standard_derivatives.txt'>OES_standard_derivatives</a>
     */
    Context.prototype.getStandardDerivatives = function() {
        return !!this._standardDerivatives;
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     *
     * @returns {Boolean} <code>true</code> if EXT_texture_filter_anisotropic is supported; otherwise, <code>false</code>.
     *
     * @see <a href='http://www.khronos.org/registry/webgl/extensions/EXT_texture_filter_anisotropic/'>EXT_texture_filter_anisotropic</a>
     */
    Context.prototype.getTextureFilterAnisotropic = function() {
        return !!this._textureFilterAnisotropic;
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     *
     * @see Context#getTextureFilterAnisotropic
     */
    Context.prototype.getMaximumTextureFilterAnisotropy = function() {
        return this._maximumTextureFilterAnisotropy;
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     *
     * @see Context#setValidateFramebuffer
     */
    Context.prototype.getValidateFramebuffer = function() {
        return this._validateFB;
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     *
     * @performance DOC_TBA: slow.
     *
     * @see Context#setValidateShaderProgram
     * @see Context#getValidateFramebuffer
     */
    Context.prototype.setValidateFramebuffer = function(value) {
        this._validateFB = value;
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     *
     * @see Context#setValidateShaderProgram
     */
    Context.prototype.getValidateShaderProgram = function() {
        return this._validateSP;
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     *
     * @performance DOC_TBA: slow.
     *
     * @see Context#setValidateFramebuffer
     * @see Context#getValidateShaderProgram
     */
    Context.prototype.setValidateShaderProgram = function(value) {
        this._validateSP = value;
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     *
     * @see Context#setThrowOnWebGLError
     */
    Context.prototype.getThrowOnWebGLError = function() {
        return this._throwOnWebGLError;
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     *
     * @performance DOC_TBA: slow.
     *
     * @see Context#setValidateFramebuffer
     * @see Context#setValidateShaderProgram
     * @see Context#getThrowOnWebGLError
     */
    Context.prototype.setThrowOnWebGLError = function(value) {
        this._throwOnWebGLError = value;
        this._gl = wrapGL(this._originalGLContext, value ? throwOnError : null);
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     *
     * @see Context#setLogShaderCompilation
     */
    Context.prototype.getLogShaderCompilation = function() {
        return this._logShaderCompilation;
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     *
     * @see Context#getLogShaderCompilation
     */
    Context.prototype.setLogShaderCompilation = function(value) {
        this._logShaderCompilation = value;
    };

    /**
     * Creates a shader program given the GLSL source for a vertex and fragment shader.
     * <br /><br />
     * The vertex and fragment shader are individually compiled, and then linked together
     * to create a shader program.  An exception is thrown if any errors are encountered,
     * as described below.
     * <br /><br />
     * The program's active uniforms and attributes are queried and can be accessed using
     * the returned shader program.  The caller can explicitly define the vertex
     * attribute indices using the optional <code>attributeLocations</code> argument as
     * shown in example two below.
     *
     * @memberof Context
     *
     * @param {String} vertexShaderSource The GLSL source for the vertex shader.
     * @param {String} fragmentShaderSource The GLSL source for the fragment shader.
     * @param {Object} [attributeLocations=undefined] An optional object that maps vertex attribute names to indices for use with vertex arrays.
     *
     * @return {ShaderProgram} The compiled and linked shader program, ready for use in a draw call.
     *
     * @exception {RuntimeError} Vertex shader failed to compile.
     * @exception {RuntimeError} Fragment shader failed to compile.
     * @exception {RuntimeError} Program failed to link.
     *
     * @see Context#draw
     * @see Context#createVertexArray
     * @see Context#getShaderCache
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glCreateShader.xml'>glCreateShader</a>
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glShaderSource.xml'>glShaderSource</a>
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glCompileShader.xml'>glCompileShader</a>
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glCreateProgram.xml'>glCreateProgram</a>
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glAttachShader.xml'>glAttachShader</a>
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glLinkProgram.xml'>glLinkProgram</a>
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGetShaderiv.xml'>glGetShaderiv</a>
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGetActiveUniform.xml'>glGetActiveUniform</a>
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGetUniformLocation.xml'>glGetUniformLocation</a>
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGetUniform.xml'>glGetUniform</a>
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glBindAttribLocation.xml'>glBindAttribLocation</a>
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGetActiveAttrib.xml'>glGetActiveAttrib</a>
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGetAttribLocation.xml'>glGetAttribLocation</a>
     *
     * @example
     * // Example 1. Create a shader program allowing the GL to determine
     * // attribute indices.
     * var vs = 'attribute vec4 position; void main() { gl_Position = position; }';
     * var fs = 'void main() { gl_FragColor = vec4(1.0); }';
     * var sp = context.createShaderProgram(vs, fs);
     *
     * ////////////////////////////////////////////////////////////////////////////////
     *
     * // Example 2. Create a shader program with explicit attribute indices.
     * var vs = 'attribute vec4 position;' +
     *          'attribute vec3 normal;' +
     *          'void main() { ... }';
     * var fs = 'void main() { gl_FragColor = vec4(1.0); }';
     * var attributes = {
     *     position : 0,
     *     normal   : 1
     * };
     * sp = context.createShaderProgram(vs, fs, attributes);            *
     */
    Context.prototype.createShaderProgram = function(vertexShaderSource, fragmentShaderSource, attributeLocations) {
        return new ShaderProgram(this._gl, this._logShaderCompilation, ShadersBuiltinFunctions, vertexShaderSource, fragmentShaderSource, attributeLocations);
    };

    function createBuffer(gl, bufferTarget, typedArrayOrSizeInBytes, usage) {
        var sizeInBytes;

        if (typeof typedArrayOrSizeInBytes === 'number') {
            sizeInBytes = typedArrayOrSizeInBytes;
        } else if (typeof typedArrayOrSizeInBytes === 'object' && typeof typedArrayOrSizeInBytes.byteLength !== 'undefined') {
            sizeInBytes = typedArrayOrSizeInBytes.byteLength;
        } else {
            throw new DeveloperError('typedArrayOrSizeInBytes must be either a typed array or a number.');
        }

        if (sizeInBytes <= 0) {
            throw new DeveloperError('typedArrayOrSizeInBytes must be greater than zero.');
        }

        if (!BufferUsage.validate(usage)) {
            throw new DeveloperError('usage is invalid.');
        }

        var buffer = gl.createBuffer();
        gl.bindBuffer(bufferTarget, buffer);
        gl.bufferData(bufferTarget, typedArrayOrSizeInBytes, usage);
        gl.bindBuffer(bufferTarget, null);

        return new Buffer(gl, bufferTarget, sizeInBytes, usage, buffer);
    }

    /**
     * Creates a vertex buffer, which contains untyped vertex data in GPU-controlled memory.
     * <br /><br />
     * A vertex array defines the actual makeup of a vertex, e.g., positions, normals, texture coordinates,
     * etc., by interpreting the raw data in one or more vertex buffers.
     *
     * @memberof Context
     *
     * @param {ArrayBufferView|Number} typedArrayOrSizeInBytes A typed array containing the data to copy to the buffer, or a <code>Number</code> defining the size of the buffer in bytes.
     * @param {BufferUsage} usage Specifies the expected usage pattern of the buffer.  On some GL implementations, this can significantly affect performance.  See {@link BufferUsage}.
     *
     * @return {VertexBuffer} The vertex buffer, ready to be attached to a vertex array.
     *
     * @exception {DeveloperError} The size in bytes must be greater than zero.
     * @exception {DeveloperError} Invalid <code>usage</code>.
     *
     * @see Context#createVertexArray
     * @see Context#createIndexBuffer
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGenBuffer.xml'>glGenBuffer</a>
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glBindBuffer.xml'>glBindBuffer</a> with <code>ARRAY_BUFFER</code>
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glBufferData.xml'>glBufferData</a> with <code>ARRAY_BUFFER</code>
     *
     * @example
     * // Example 1. Create a dynamic vertex buffer 16 bytes in size.
     * var buffer = context.createVertexBuffer(16, BufferUsage.DYNAMIC_DRAW);
     *
     * ////////////////////////////////////////////////////////////////////////////////
     *
     * // Example 2. Create a dynamic vertex buffer from three floating-point values.
     * // The data copied to the vertex buffer is considered raw bytes until it is
     * // interpreted as vertices using a vertex array.
     * var positionBuffer = context.createVertexBuffer(new Float32Array([0, 0, 0]),
     *     BufferUsage.STATIC_DRAW);
     */
    Context.prototype.createVertexBuffer = function(typedArrayOrSizeInBytes, usage) {
        return createBuffer(this._gl, this._gl.ARRAY_BUFFER, typedArrayOrSizeInBytes, usage);
    };

    /**
     * Creates an index buffer, which contains typed indices in GPU-controlled memory.
     * <br /><br />
     * An index buffer can be attached to a vertex array to select vertices for rendering.
     * <code>Context.draw</code> can render using the entire index buffer or a subset
     * of the index buffer defined by an offset and count.
     *
     * @memberof Context
     *
     * @param {ArrayBufferView|Number} typedArrayOrSizeInBytes A typed array containing the data to copy to the buffer, or a <code>Number</code> defining the size of the buffer in bytes.
     * @param {BufferUsage} usage Specifies the expected usage pattern of the buffer.  On some GL implementations, this can significantly affect performance.  See {@link BufferUsage}.
     * @param {IndexDatatype} indexDatatype The datatype of indices in the buffer.
     *
     * @return {IndexBuffer} The index buffer, ready to be attached to a vertex array.
     *
     * @exception {DeveloperError} The size in bytes must be greater than zero.
     * @exception {DeveloperError} Invalid <code>usage</code>.
     * @exception {DeveloperError} Invalid <code>indexDatatype</code>.
     *
     * @see Context#createVertexArray
     * @see Context#createVertexBuffer
     * @see Context#draw
     * @see VertexArray
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glGenBuffer.xml'>glGenBuffer</a>
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glBindBuffer.xml'>glBindBuffer</a> with <code>ELEMENT_ARRAY_BUFFER</code>
     * @see <a href='http://www.khronos.org/opengles/sdk/2.0/docs/man/glBufferData.xml'>glBufferData</a> with <code>ELEMENT_ARRAY_BUFFER</code>
     *
     * @example
     * // Example 1. Create a stream index buffer of unsigned shorts that is
     * // 16 bytes in size.
     * var buffer = context.createIndexBuffer(16, BufferUsage.STREAM_DRAW,
     *     IndexType.unsignedShort);
     *
     * ////////////////////////////////////////////////////////////////////////////////
     *
     * // Example 2. Create a static index buffer containing three unsigned shorts.
     * var buffer = context.createIndexBuffer(new Uint16Array([0, 1, 2]),
     *     BufferUsage.STATIC_DRAW, IndexType.unsignedShort)
     */
    Context.prototype.createIndexBuffer = function(typedArrayOrSizeInBytes, usage, indexDatatype) {
        var bytesPerIndex;

        if (indexDatatype === IndexDatatype.UNSIGNED_BYTE) {
            bytesPerIndex = Uint8Array.BYTES_PER_ELEMENT;
        } else if (indexDatatype === IndexDatatype.UNSIGNED_SHORT) {
            bytesPerIndex = Uint16Array.BYTES_PER_ELEMENT;
        } else {
            throw new DeveloperError('Invalid indexDatatype.');
        }

        var gl = this._gl;
        var buffer = createBuffer(gl, gl.ELEMENT_ARRAY_BUFFER, typedArrayOrSizeInBytes, usage);
        var numberOfIndices = buffer.getSizeInBytes() / bytesPerIndex;

        buffer.getIndexDatatype = function() {
            return indexDatatype;
        };

        buffer.getBytesPerIndex = function() {
            return bytesPerIndex;
        };

        buffer.getNumberOfIndices = function() {
            return numberOfIndices;
        };

        return buffer;
    };

    /**
     * Creates a vertex array, which defines the attributes making up a vertex, and contains an optional index buffer
     * to select vertices for rendering.  Attributes are defined using object literals as shown in Example 1 below.
     *
     * @memberof Context
     *
     * @param {Array} [attributes=undefined] An optional array of attributes.
     * @param {IndexBuffer} [indexBuffer=undefined] An optional index buffer.
     *
     * @return {VertexArray} The vertex array, ready for use with drawing.
     *
     * @exception {DeveloperError} Attribute must have a <code>vertexBuffer</code>.
     * @exception {DeveloperError} Attribute must have a <code>componentsPerAttribute</code>.
     * @exception {DeveloperError} Attribute must have a valid <code>componentDatatype</code> or not specify it.
     * @exception {DeveloperError} Attribute must have a <code>strideInBytes</code> less than or equal to 255 or not specify it.
     * @exception {DeveloperError} Index n is used by more than one attribute.
     *
     * @see Context#createVertexArrayFromMesh
     * @see Context#createVertexBuffer
     * @see Context#createIndexBuffer
     * @see Context#draw
     *
     * @example
     * // Example 1. Create a vertex array with vertices made up of three floating point
     * // values, e.g., a position, from a single vertex buffer.  No index buffer is used.
     * var positionBuffer = context.createVertexBuffer(12, BufferUsage.STATIC_DRAW);
     * var attributes = [
     *     {
     *         index                  : 0,
     *         enabled                : true,
     *         vertexBuffer           : positionBuffer,
     *         componentsPerAttribute : 3,
     *         componentDatatype      : ComponentDatatype.FLOAT,
     *         normalize              : false,
     *         offsetInBytes          : 0,
     *         strideInBytes          : 0 // tightly packed
     *     }
     * ];
     * var va = context.createVertexArray(attributes);
     *
     * ////////////////////////////////////////////////////////////////////////////////
     *
     * // Example 2. Create a vertex array with vertices from two different vertex buffers.
     * // Each vertex has a three-component position and three-component normal.
     * var positionBuffer = context.createVertexBuffer(12, BufferUsage.STATIC_DRAW);
     * var normalBuffer = context.createVertexBuffer(12, BufferUsage.STATIC_DRAW);
     * var attributes = [
     *     {
     *         index                  : 0,
     *         vertexBuffer           : positionBuffer,
     *         componentsPerAttribute : 3,
     *         componentDatatype      : ComponentDatatype.FLOAT
     *     },
     *     {
     *         index                  : 1,
     *         vertexBuffer           : normalBuffer,
     *         componentsPerAttribute : 3,
     *         componentDatatype      : ComponentDatatype.FLOAT
     *     }
     * ];
     * var va = context.createVertexArray(attributes);
     *
     * ////////////////////////////////////////////////////////////////////////////////
     *
     * // Example 3. Creates the same vertex layout as Example 2 using a single
     * // vertex buffer, instead of two.
     * var buffer = context.createVertexBuffer(24, BufferUsage.STATIC_DRAW);
     * var attributes = [
     *     {
     *         vertexBuffer           : buffer,
     *         componentsPerAttribute : 3,
     *         componentDatatype      : ComponentDatatype.FLOAT,
     *         offsetInBytes          : 0,
     *         strideInBytes          : 24
     *     },
     *     {
     *         vertexBuffer           : buffer,
     *         componentsPerAttribute : 3,
     *         componentDatatype      : ComponentDatatype.FLOAT,
     *         normalize              : true,
     *         offsetInBytes          : 12,
     *         strideInBytes          : 24
     *     }
     * ];
     * var va = context.createVertexArray(attributes);
     */
    Context.prototype.createVertexArray = function(attributes, indexBuffer) {
        return new VertexArray(this._gl, attributes, indexBuffer);
    };

    /**
     * DOC_TBA.
     *
     * description.source can be {ImageData}, {HTMLImageElement}, {HTMLCanvasElement}, or {HTMLVideoElement}.
     *
     * @memberof Context
     *
     * @return {Texture} DOC_TBA.
     *
     * @exception {DeveloperError} description is required.
     * @exception {DeveloperError} description requires a source field to create an initialized texture or width and height fields to create a blank texture.
     * @exception {DeveloperError} Width must be greater than zero.
     * @exception {DeveloperError} Width must be less than or equal to the maximum texture size.
     * @exception {DeveloperError} Height must be greater than zero.
     * @exception {DeveloperError} Height must be less than or equal to the maximum texture size.
     * @exception {DeveloperError} Invalid description.pixelFormat.
     * @exception {DeveloperError} Invalid description.pixelDatatype.
     *
     * @see Context#createTexture2DFromFramebuffer
     * @see Context#createCubeMap
     * @see Context#createSampler
     */
    Context.prototype.createTexture2D = function(description) {
        if (!description) {
            throw new DeveloperError('description is required.');
        }

        var source = description.source;
        var width = typeof source !== 'undefined' ? source.width : description.width;
        var height = typeof source !== 'undefined' ? source.height : description.height;

        if (typeof width === 'undefined' || typeof height === 'undefined') {
            throw new DeveloperError('description requires a source field to create an initialized texture or width and height fields to create a blank texture.');
        }

        if (width <= 0) {
            throw new DeveloperError('Width must be greater than zero.');
        }

        if (width > this._maximumTextureSize) {
            throw new DeveloperError('Width must be less than or equal to the maximum texture size (' + this._maximumTextureSize + ').  Check getMaximumTextureSize().');
        }

        if (height <= 0) {
            throw new DeveloperError('Height must be greater than zero.');
        }

        if (height > this._maximumTextureSize) {
            throw new DeveloperError('Height must be less than or equal to the maximum texture size (' + this._maximumTextureSize + ').  Check getMaximumTextureSize().');
        }

        var pixelFormat = description.pixelFormat || PixelFormat.RGBA;
        if (!PixelFormat.validate(pixelFormat)) {
            throw new DeveloperError('Invalid description.pixelFormat.');
        }

        var pixelDatatype = description.pixelDatatype || PixelDatatype.UNSIGNED_BYTE;
        if (!PixelDatatype.validate(pixelDatatype)) {
            throw new DeveloperError('Invalid description.pixelDatatype.');
        }

        // Use premultiplied alpha for opaque textures should perform better on Chrome:
        // http://media.tojicode.com/webglCamp4/#20
        var preMultiplyAlpha = description.preMultiplyAlpha || pixelFormat === PixelFormat.RGB || pixelFormat === PixelFormat.LUMINANCE;

        var gl = this._gl;
        var textureTarget = gl.TEXTURE_2D;
        var texture = gl.createTexture();

        // TODO: _gl.pixelStorei(_gl._UNPACK_ALIGNMENT, 4);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, preMultiplyAlpha);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(textureTarget, texture);

        if (source) {
            if (source.arrayBufferView) {
                // Source: typed array
                gl.texImage2D(textureTarget, 0, pixelFormat, width, height, 0, pixelFormat, pixelDatatype, source.arrayBufferView);
            } else {
                // Source: ImageData, HTMLImageElement, HTMLCanvasElement, or HTMLVideoElement
                gl.texImage2D(textureTarget, 0, pixelFormat, pixelFormat, pixelDatatype, source);
            }
        } else {
            gl.texImage2D(textureTarget, 0, pixelFormat, width, height, 0, pixelFormat, pixelDatatype, null);
        }
        gl.bindTexture(textureTarget, null);

        return new Texture(gl, this._textureFilterAnisotropic, textureTarget, texture, pixelFormat, pixelDatatype, width, height, preMultiplyAlpha);
    };

    /**
     * DOC_TBA.
     *
     * @memberof Context
     *
     * @param {PixelFormat} pixelFormat optional.
     * @param {PixelFormat} framebufferXOffset optional.
     * @param {PixelFormat} framebufferYOffset optional.
     * @param {PixelFormat} width optional.
     * @param {PixelFormat} height optional.
     *
     * @return {Texture} DOC_TBA.
     *
     * @exception {DeveloperError} Invalid pixelFormat.
     * @exception {DeveloperError} framebufferXOffset must be greater than or equal to zero.
     * @exception {DeveloperError} framebufferYOffset must be greater than or equal to zero.
     * @exception {DeveloperError} framebufferXOffset + width must be less than or equal to getCanvas().clientWidth.
     * @exception {DeveloperError} framebufferYOffset + height must be less than or equal to getCanvas().clientHeight.
     *
     * @see Context#createTexture2D
     * @see Context#createCubeMap
     * @see Context#createSampler
     */
    Context.prototype.createTexture2DFromFramebuffer = function(pixelFormat, framebufferXOffset, framebufferYOffset, width, height) {
        pixelFormat = pixelFormat || PixelFormat.RGB;
        if (!PixelFormat.validate(pixelFormat)) {
            throw new DeveloperError('Invalid pixelFormat.');
        }

        if (framebufferXOffset < 0) {
            throw new DeveloperError('framebufferXOffset must be greater than or equal to zero.');
        }

        if (framebufferYOffset < 0) {
            throw new DeveloperError('framebufferYOffset must be greater than or equal to zero.');
        }

        if (framebufferXOffset + width > this._canvas.clientWidth) {
            throw new DeveloperError('framebufferXOffset + width must be less than or equal to getCanvas().clientWidth');
        }

        if (framebufferYOffset + height > this._canvas.clientHeight) {
            throw new DeveloperError('framebufferYOffset + height must be less than or equal to getCanvas().clientHeight.');
        }

        framebufferXOffset = framebufferXOffset || 0;
        framebufferYOffset = framebufferYOffset || 0;
        width = width || this._canvas.clientWidth;
        height = height || this._canvas.clientHeight;

        var gl = this._gl;
        var textureTarget = gl.TEXTURE_2D;
        var texture = gl.createTexture();

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(textureTarget, texture);
        gl.copyTexImage2D(textureTarget, 0, pixelFormat, framebufferXOffset, framebufferYOffset, width, height, 0);
        gl.bindTexture(textureTarget, null);

        return new Texture(gl, this._textureFilterAnisotropic, textureTarget, texture, pixelFormat, undefined, width, height);
    };

    /**
     * Creates a new texture atlas with this context.
     *
     * @memberof Context
     *
     * @param {Context} description.context The context in which the texture gets created.
     * @param {PixelFormat} [description.pixelFormat = PixelFormat.RGBA] The pixel format of the texture.
     * @param {Number} [description.borderWidthInPixels = 1] The amount of spacing between adjacent images in pixels.
     * @param {Cartesian2} [description.initialSize = new Cartesian2(16.0, 16.0)] The initial side lengths of the texture.
     * @param {Array} description.images Optional array of {@link Image} to be added to the atlas. Same as calling addImages(images).
     * @param {Image} description.image Optional single image to be added to the atlas. Same as calling addImage(image).
     *
     * @returns {TextureAtlas} The new texture atlas.
     *
     * @see TextureAtlas
     */
    Context.prototype.createTextureAtlas = function(description) {
        description = description || {};
        description.context = this;
        return new TextureAtlas(description);
    };

    /**
     * DOC_TBA.
     *
     * description.source can be {ImageData}, {HTMLImageElement}, {HTMLCanvasElement}, or {HTMLVideoElement}.
     *
     * @memberof Context
     *
     * @return {CubeMap} DOC_TBA.
     *
     * @exception {DeveloperError} description is required.
     * @exception {DeveloperError} description.source requires positiveX, negativeX, positiveY, negativeY, positiveZ, and negativeZ faces.
     * @exception {DeveloperError} Each face in description.sources must have the same width and height.
     * @exception {DeveloperError} description requires a source field to create an initialized cube map or width and height fields to create a blank cube map.
     * @exception {DeveloperError} Width must equal height.
     * @exception {DeveloperError} Width and height must be greater than zero.
     * @exception {DeveloperError} Width and height must be less than or equal to the maximum cube map size.
     * @exception {DeveloperError} Invalid description.pixelFormat.
     * @exception {DeveloperError} Invalid description.pixelDatatype.
     *
     * @see Context#createTexture2D
     * @see Context#createTexture2DFromFramebuffer
     * @see Context#createSampler
     */
    Context.prototype.createCubeMap = function(description) {
        if (!description) {
            throw new DeveloperError('description is required.');
        }

        var source = description.source;
        var width;
        var height;

        if (source) {
            var faces = [source.positiveX, source.negativeX, source.positiveY, source.negativeY, source.positiveZ, source.negativeZ];

            if (!faces[0] || !faces[1] || !faces[2] || !faces[3] || !faces[4] || !faces[5]) {
                throw new DeveloperError('description.source requires positiveX, negativeX, positiveY, negativeY, positiveZ, and negativeZ faces.');
            }

            width = faces[0].width;
            height = faces[0].height;

            for ( var i = 1; i < 6; ++i) {
                if ((Number(faces[i].width) !== width) || (Number(faces[i].height) !== height)) {
                    throw new DeveloperError('Each face in description.source must have the same width and height.');
                }
            }
        } else {
            width = description.width;
            height = description.height;
        }

        if (typeof width === 'undefined' || typeof height === 'undefined') {
            throw new DeveloperError('description requires a source field to create an initialized cube map or width and height fields to create a blank cube map.');
        }

        if (width !== height) {
            throw new DeveloperError('Width must equal height.');
        }

        var size = width;

        if (size <= 0) {
            throw new DeveloperError('Width and height must be greater than zero.');
        }

        if (size > this._maximumCubeMapSize) {
            throw new DeveloperError('Width and height must be less than or equal to the maximum cube map size (' + this._maximumCubeMapSize + ').  Check getMaximumCubeMapSize().');
        }

        var pixelFormat = description.pixelFormat || PixelFormat.RGBA;
        if (!PixelFormat.validate(pixelFormat)) {
            throw new DeveloperError('Invalid description.pixelFormat.');
        }

        var pixelDatatype = description.pixelDatatype || PixelDatatype.UNSIGNED_BYTE;
        if (!PixelDatatype.validate(pixelDatatype)) {
            throw new DeveloperError('Invalid description.pixelDatatype.');
        }

        // Use premultiplied alpha for opaque textures should perform better on Chrome:
        // http://media.tojicode.com/webglCamp4/#20
        var preMultiplyAlpha = description.preMultiplyAlpha || ((pixelFormat === PixelFormat.RGB) || (pixelFormat === PixelFormat.LUMINANCE));

        var gl = this._gl;
        var textureTarget = gl.TEXTURE_CUBE_MAP;
        var texture = gl.createTexture();

        // TODO: _gl.pixelStorei(_gl._UNPACK_ALIGNMENT, 4);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, preMultiplyAlpha);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(textureTarget, texture);

        function createFace(target, sourceFace) {
            if (sourceFace.arrayBufferView) {
                gl.texImage2D(target, 0, pixelFormat, size, size, 0, pixelFormat, pixelDatatype, sourceFace.arrayBufferView);
            } else {
                gl.texImage2D(target, 0, pixelFormat, pixelFormat, pixelDatatype, sourceFace);
            }
        }

        if (source) {
            createFace(gl.TEXTURE_CUBE_MAP_POSITIVE_X, source.positiveX);
            createFace(gl.TEXTURE_CUBE_MAP_NEGATIVE_X, source.negativeX);
            createFace(gl.TEXTURE_CUBE_MAP_POSITIVE_Y, source.positiveY);
            createFace(gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, source.negativeY);
            createFace(gl.TEXTURE_CUBE_MAP_POSITIVE_Z, source.positiveZ);
            createFace(gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, source.negativeZ);
        } else {
            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X, 0, pixelFormat, size, size, 0, pixelFormat, pixelDatatype, null);
            gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, pixelFormat, size, size, 0, pixelFormat, pixelDatatype, null);
            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, pixelFormat, size, size, 0, pixelFormat, pixelDatatype, null);
            gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, pixelFormat, size, size, 0, pixelFormat, pixelDatatype, null);
            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, pixelFormat, size, size, 0, pixelFormat, pixelDatatype, null);
            gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, pixelFormat, size, size, 0, pixelFormat, pixelDatatype, null);
        }
        gl.bindTexture(textureTarget, null);

        return new CubeMap(gl, this._textureFilterAnisotropic, textureTarget, texture, pixelFormat, pixelDatatype, size, preMultiplyAlpha);
    };

    /**
     * DOC_TBA.
     *
     * @memberof Context
     *
     * @param {Object} description optional.
     *
     * @return {Framebuffer} DOC_TBA.
     *
     * @exception {DeveloperError} Cannot have both a depth and depth-stencil renderbuffer.
     * @exception {DeveloperError} Cannot have both a stencil and depth-stencil renderbuffer.
     * @exception {DeveloperError} Cannot have both a depth and stencil renderbuffer.
     *
     * @see Context#createTexture2D
     * @see Context#createCubeMap
     * @see Context#createRenderbuffer
     */
    Context.prototype.createFramebuffer = function(description) {
        if (description) {
            if (description.depthRenderbuffer && description.depthStencilRenderbuffer) {
                throw new DeveloperError('Cannot have both a depth and depth-stencil attachment.');
            }

            if (description.stencilRenderbuffer && description.depthStencilRenderbuffer) {
                throw new DeveloperError('Cannot have both a stencil and depth-stencil attachment.');
            }

            if (description.depthRenderbuffer && description.stencilRenderbuffer) {
                throw new DeveloperError('Cannot have both a depth and stencil attachment.');
            }
        }
        return new Framebuffer(this._gl, description);
    };

    /**
     * DOC_TBA.
     *
     * @memberof Context
     *
     * @param {Object} description optional.
     *
     * @return {createRenderbuffer} DOC_TBA.
     *
     * @exception {DeveloperError} Invalid format.
     * @exception {DeveloperError} Width must be greater than zero.
     * @exception {DeveloperError} Width must be less than or equal to the maximum renderbuffer size.
     * @exception {DeveloperError} Height must be greater than zero.
     * @exception {DeveloperError} Height must be less than or equal to the maximum renderbuffer size.
     *
     * @see Context#createFramebuffer
     */
    Context.prototype.createRenderbuffer = function(description) {
        description = description || {};
        var format = description.format || RenderbufferFormat.RGBA4;
        var width = (typeof description.width === 'undefined') ? this._canvas.clientWidth : description.width;
        var height = (typeof description.height === 'undefined') ? this._canvas.clientHeight : description.height;


        var gl = this._gl;
        if (!RenderbufferFormat.validate(format)) {
            throw new DeveloperError('Invalid format.');
        }

        if (width <= 0) {
            throw new DeveloperError('Width must be greater than zero.');
        }

        if (width > this.getMaximumRenderbufferSize()) {
            throw new DeveloperError('Width must be less than or equal to the maximum renderbuffer size (' + this.getMaximumRenderbufferSize() + ').  Check getMaximumRenderbufferSize().');
        }

        if (height <= 0) {
            throw new DeveloperError('Height must be greater than zero.');
        }

        if (height > this.getMaximumRenderbufferSize()) {
            throw new DeveloperError('Height must be less than or equal to the maximum renderbuffer size (' + this.getMaximumRenderbufferSize() + ').  Check getMaximumRenderbufferSize().');
        }

        return new Renderbuffer(gl, format, width, height);
    };

    /**
     * DOC_TBA.
     *
     * Validates and adds defaults for missing states.
     *
     * @memberof Context
     *
     * @exception {RuntimeError} renderState.lineWidth is out of range.
     * @exception {DeveloperError} Invalid renderState.frontFace.
     * @exception {DeveloperError} Invalid renderState.cull.face.
     * @exception {DeveloperError} scissorTest.rectangle.width and scissorTest.rectangle.height must be greater than or equal to zero.
     * @exception {DeveloperError} renderState.depthRange.near can't be greater than renderState.depthRange.far.
     * @exception {DeveloperError} renderState.depthRange.near must be greater than or equal to zero.
     * @exception {DeveloperError} renderState.depthRange.far must be less than or equal to zero.
     * @exception {DeveloperError} Invalid renderState.depthTest.func.
     * @exception {DeveloperError} renderState.blending.color components must be greater than or equal to zero and less than or equal to one
     * @exception {DeveloperError} Invalid renderState.blending.equationRgb.
     * @exception {DeveloperError} Invalid renderState.blending.equationAlpha.
     * @exception {DeveloperError} Invalid renderState.blending.functionSourceRgb.
     * @exception {DeveloperError} Invalid renderState.blending.functionSourceAlpha.
     * @exception {DeveloperError} Invalid renderState.blending.functionDestinationRgb.
     * @exception {DeveloperError} Invalid renderState.blending.functionDestinationAlpha.
     * @exception {DeveloperError} Invalid renderState.stencilTest.frontFunction.
     * @exception {DeveloperError} Invalid renderState.stencilTest.backFunction.
     * @exception {DeveloperError} Invalid renderState.stencilTest.frontOperation.fail.
     * @exception {DeveloperError} Invalid renderState.stencilTest.frontOperation.zFail.
     * @exception {DeveloperError} Invalid renderState.stencilTest.frontOperation.zPass.
     * @exception {DeveloperError} Invalid renderState.stencilTest.backOperation.fail.
     * @exception {DeveloperError} Invalid renderState.stencilTest.backOperation.zFail.
     * @exception {DeveloperError} Invalid renderState.stencilTest.backOperation.zPass.
     */
    Context.prototype.createRenderState = function(renderState) {
        var rs = renderState || {};
        var cull = rs.cull || {};
        var polygonOffset = rs.polygonOffset || {};
        var scissorTest = rs.scissorTest || {};
        var scissorTestRectangle = scissorTest.rectangle || {};
        var depthRange = rs.depthRange || {};
        var depthTest = rs.depthTest || {};
        var colorMask = rs.colorMask || {};
        var blending = rs.blending || {};
        var blendingColor = blending.color || {};
        var stencilTest = rs.stencilTest || {};
        var stencilTestFrontOperation = stencilTest.frontOperation || {};
        var stencilTestBackOperation = stencilTest.backOperation || {};
        var sampleCoverage = rs.sampleCoverage || {};

        var r = {
            frontFace : (typeof rs.frontFace === 'undefined') ? WindingOrder.COUNTER_CLOCKWISE : rs.frontFace,
            cull : {
                enabled : (typeof cull.enabled === 'undefined') ? false : cull.enabled,
                face : (typeof cull.face === 'undefined') ? CullFace.BACK : cull.face
            },
            lineWidth : (typeof rs.lineWidth === 'undefined') ? 1 : rs.lineWidth,
            polygonOffset : {
                enabled : (typeof polygonOffset.enabled === 'undefined') ? false : polygonOffset.enabled,
                factor : (typeof polygonOffset.factor === 'undefined') ? 0 : polygonOffset.factor,
                units : (typeof polygonOffset.units === 'undefined') ? 0 : polygonOffset.units
            },
            scissorTest : {
                enabled : (typeof scissorTest.enabled === 'undefined') ? false : scissorTest.enabled,
                rectangle : {
                    x : (typeof scissorTestRectangle.x === 'undefined') ? 0 : scissorTestRectangle.x,
                    y : (typeof scissorTestRectangle.y === 'undefined') ? 0 : scissorTestRectangle.y,
                    width : (typeof scissorTestRectangle.width === 'undefined') ? 0 : scissorTestRectangle.width,
                    height : (typeof scissorTestRectangle.height === 'undefined') ? 0 : scissorTestRectangle.height
                }
            },
            depthRange : {
                near : (typeof depthRange.near === 'undefined') ? 0 : depthRange.near,
                far : (typeof depthRange.far === 'undefined') ? 1 : depthRange.far
            },
            depthTest : {
                enabled : (typeof depthTest.enabled === 'undefined') ? false : depthTest.enabled,
                func : (typeof depthTest.func === 'undefined') ? DepthFunction.LESS : depthTest.func // func, because function is a JavaScript keyword
            },
            colorMask : {
                red : (typeof colorMask.red === 'undefined') ? true : colorMask.red,
                green : (typeof colorMask.green === 'undefined') ? true : colorMask.green,
                blue : (typeof colorMask.blue === 'undefined') ? true : colorMask.blue,
                alpha : (typeof colorMask.alpha === 'undefined') ? true : colorMask.alpha
            },
            depthMask : (typeof rs.depthMask === 'undefined') ? true : rs.depthMask,
            stencilMask : (typeof rs.stencilMask === 'undefined') ? ~0 : rs.stencilMask,
            blending : {
                enabled : (typeof blending.enabled === 'undefined') ? false : blending.enabled,
                color : new Color(
                    (typeof blendingColor.red === 'undefined') ? 0.0 : blendingColor.red,
                    (typeof blendingColor.green === 'undefined') ? 0.0 : blendingColor.green,
                    (typeof blendingColor.blue === 'undefined') ? 0.0 : blendingColor.blue,
                    (typeof blendingColor.alpha === 'undefined') ? 0.0 : blendingColor.alpha
                ),
                equationRgb : (typeof blending.equationRgb === 'undefined') ? BlendEquation.ADD : blending.equationRgb,
                equationAlpha : (typeof blending.equationAlpha === 'undefined') ? BlendEquation.ADD : blending.equationAlpha,
                functionSourceRgb : (typeof blending.functionSourceRgb === 'undefined') ? BlendFunction.ONE : blending.functionSourceRgb,
                functionSourceAlpha : (typeof blending.functionSourceAlpha === 'undefined') ? BlendFunction.ONE : blending.functionSourceAlpha,
                functionDestinationRgb : (typeof blending.functionDestinationRgb === 'undefined') ? BlendFunction.ZERO : blending.functionDestinationRgb,
                functionDestinationAlpha : (typeof blending.functionDestinationAlpha === 'undefined') ? BlendFunction.ZERO : blending.functionDestinationAlpha
            },
            stencilTest : {
                enabled : (typeof stencilTest.enabled === 'undefined') ? false : stencilTest.enabled,
                frontFunction : (typeof stencilTest.frontFunction === 'undefined') ? StencilFunction.ALWAYS : stencilTest.frontFunction,
                backFunction : (typeof stencilTest.backFunction === 'undefined') ? StencilFunction.ALWAYS : stencilTest.backFunction,
                reference : (typeof stencilTest.reference === 'undefined') ? 0 : stencilTest.reference,
                mask : (typeof stencilTest.mask === 'undefined') ? ~0 : stencilTest.mask,
                frontOperation : {
                    fail : (typeof stencilTestFrontOperation.fail === 'undefined') ? StencilOperation.KEEP : stencilTestFrontOperation.fail,
                    zFail : (typeof stencilTestFrontOperation.zFail === 'undefined') ? StencilOperation.KEEP : stencilTestFrontOperation.zFail,
                    zPass : (typeof stencilTestFrontOperation.zPass === 'undefined') ? StencilOperation.KEEP : stencilTestFrontOperation.zPass
                },
                backOperation : {
                    fail : (typeof stencilTestBackOperation.fail === 'undefined') ? StencilOperation.KEEP : stencilTestBackOperation.fail,
                    zFail : (typeof stencilTestBackOperation.zFail === 'undefined') ? StencilOperation.KEEP : stencilTestBackOperation.zFail,
                    zPass : (typeof stencilTestBackOperation.zPass === 'undefined') ? StencilOperation.KEEP : stencilTestBackOperation.zPass
                }
            },
            // TODO:  Also need point_size and point_size_enable for ColladaFX
            // TODO:  Also need sample_alpha_to_coverage_enable for ColladaFX
            sampleCoverage : {
                enabled : (typeof sampleCoverage.enabled === 'undefined') ? false : sampleCoverage.enabled,
                value : (typeof sampleCoverage.value === 'undefined') ? 1.0 : sampleCoverage.value,
                invert : (typeof sampleCoverage.invert === 'undefined') ? false : sampleCoverage.invert
            },
            dither : (typeof rs.dither === 'undefined') ? true : rs.dither
        };

        // Validate

        if (!WindingOrder.validate(r.frontFace)) {
            throw new DeveloperError('Invalid renderState.frontFace.');
        }

        if (!CullFace.validate(r.cull.face)) {
            throw new DeveloperError('Invalid renderState.cull.face.');
        }

        if ((r.lineWidth < this._aliasedLineWidthRange[0]) ||
            (r.lineWidth > this._aliasedLineWidthRange[1])) {
            throw new RuntimeError('renderState.lineWidth is out of range.  Check getMinimumAliasedLineWidth() and getMaximumAliasedLineWidth().');
        }

        if ((r.scissorTest.rectangle.width < 0) ||
            (r.scissorTest.rectangle.height < 0)) {
            throw new DeveloperError('renderState.scissorTest.rectangle.width and renderState.scissorTest.rectangle.height must be greater than or equal to zero.');
        }

        if (r.depthRange.near > r.depthRange.far) {
            // WebGL specific - not an error in GL ES
            throw new DeveloperError('renderState.depthRange.near can not be greater than renderState.depthRange.far.');
        }

        if (r.depthRange.near < 0) {
            // Would be clamped by GL
            throw new DeveloperError('renderState.depthRange.near must be greater than or equal to zero.');
        }

        if (r.depthRange.far > 1) {
            // Would be clamped by GL
            throw new DeveloperError('renderState.depthRange.far must be less than or equal to one.');
        }


        if (!DepthFunction.validate(r.depthTest.func)) {
            throw new DeveloperError('Invalid renderState.depthTest.func.');
        }

        if ((r.blending.color.red < 0.0) || (r.blending.color.red > 1.0) ||
            (r.blending.color.green < 0.0) || (r.blending.color.green > 1.0) ||
            (r.blending.color.blue < 0.0) || (r.blending.color.blue > 1.0) ||
            (r.blending.color.alpha < 0.0) || (r.blending.color.alpha > 1.0)) {
            // Would be clamped by GL
            throw new DeveloperError('renderState.blending.color components must be greater than or equal to zero and less than or equal to one.');
        }

        if (!BlendEquation.validate(r.blending.equationRgb)) {
            throw new DeveloperError('Invalid renderState.blending.equationRgb.');
        }

        if (!BlendEquation.validate(r.blending.equationAlpha)) {
            throw new DeveloperError('Invalid renderState.blending.equationAlpha.');
        }

        if (!BlendFunction.validate(r.blending.functionSourceRgb)) {
            throw new DeveloperError('Invalid renderState.blending.functionSourceRgb.');
        }

        if (!BlendFunction.validate(r.blending.functionSourceAlpha)) {
            throw new DeveloperError('Invalid renderState.blending.functionSourceAlpha.');
        }

        if (!BlendFunction.validate(r.blending.functionDestinationRgb)) {
            throw new DeveloperError('Invalid renderState.blending.functionDestinationRgb.');
        }

        if (!BlendFunction.validate(r.blending.functionDestinationAlpha)) {
            throw new DeveloperError('Invalid renderState.blending.functionDestinationAlpha.');
        }

        if (!StencilFunction.validate(r.stencilTest.frontFunction)) {
            throw new DeveloperError('Invalid renderState.stencilTest.frontFunction.');
        }

        if (!StencilFunction.validate(r.stencilTest.backFunction)) {
            throw new DeveloperError('Invalid renderState.stencilTest.backFunction.');
        }

        if (!StencilOperation.validate(r.stencilTest.frontOperation.fail)) {
            throw new DeveloperError('Invalid renderState.stencilTest.frontOperation.fail.');
        }

        if (!StencilOperation.validate(r.stencilTest.frontOperation.zFail)) {
            throw new DeveloperError('Invalid renderState.stencilTest.frontOperation.zFail.');
        }

        if (!StencilOperation.validate(r.stencilTest.frontOperation.zPass)) {
            throw new DeveloperError('Invalid renderState.stencilTest.frontOperation.zPass.');
        }

        if (!StencilOperation.validate(r.stencilTest.backOperation.fail)) {
            throw new DeveloperError('Invalid renderState.stencilTest.backOperation.fail.');
        }

        if (!StencilOperation.validate(r.stencilTest.backOperation.zFail)) {
            throw new DeveloperError('Invalid renderState.stencilTest.backOperation.zFail.');
        }

        if (!StencilOperation.validate(r.stencilTest.backOperation.zPass)) {
            throw new DeveloperError('Invalid renderState.stencilTest.backOperation.zPass.');
        }

        return r;
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     *
     * @exception {DeveloperError} Invalid sampler.wrapS.
     * @exception {DeveloperError} Invalid sampler.wrapT.
     * @exception {DeveloperError} Invalid sampler.minificationFilter.
     * @exception {DeveloperError} Invalid sampler.magnificationFilter.
     *
     * @see Context#createTexture2D
     * @see Context#createCubeMap
     */
    Context.prototype.createSampler = function(sampler) {
        var s = {
            wrapS : sampler.wrapS || TextureWrap.CLAMP,
            wrapT : sampler.wrapT || TextureWrap.CLAMP,
            minificationFilter : sampler.minificationFilter || TextureMinificationFilter.LINEAR,
            magnificationFilter : sampler.magnificationFilter || TextureMagnificationFilter.LINEAR,
            maximumAnisotropy : (typeof sampler.maximumAnisotropy !== 'undefined') ? sampler.maximumAnisotropy : 1.0
        };

        if (!TextureWrap.validate(s.wrapS)) {
            throw new DeveloperError('Invalid sampler.wrapS.');
        }

        if (!TextureWrap.validate(s.wrapT)) {
            throw new DeveloperError('Invalid sampler.wrapT.');
        }

        if (!TextureMinificationFilter.validate(s.minificationFilter)) {
            throw new DeveloperError('Invalid sampler.minificationFilter.');
        }

        if (!TextureMagnificationFilter.validate(s.magnificationFilter)) {
            throw new DeveloperError('Invalid sampler.magnificationFilter.');
        }

        if (s.maximumAnisotropy < 1.0) {
            throw new DeveloperError('sampler.maximumAnisotropy must be greater than or equal to one.');
        }

        return s;
    };

    /**
     * DOC_TBA.
     *
     * @memberof Context
     *
     * Validates and adds defaults for missing states.
     *
     * @exception {DeveloperError} clearState.scissorTest.rectangle.width and clearState.scissorTest.rectangle.height must be greater than or equal to zero.
     *
     * @see Context#clear
     */
    Context.prototype.createClearState = function(clearState) {
        var cs = clearState || {};
        var scissorTest = cs.scissorTest || {};
        var scissorTestRectangle = scissorTest.rectangle || {};
        var colorMask = cs.colorMask || {};

        var color = cs.color;
        var depth = cs.depth;
        var stencil = cs.stencil;

        // Clear everything if nothing is specified
        if ((typeof color === 'undefined') && (typeof depth === 'undefined') && (typeof stencil === 'undefined')) {
            color = this._defaultClearColor;
            depth = this._defaultClearDepth;
            stencil = this._defaultClearStencil;
        }

        var c = {
            scissorTest : {
                enabled : (typeof scissorTest.enabled === 'undefined') ? false : scissorTest.enabled,
                rectangle : {
                    x : (typeof scissorTestRectangle.x === 'undefined') ? 0 : scissorTestRectangle.x,
                    y : (typeof scissorTestRectangle.y === 'undefined') ? 0 : scissorTestRectangle.y,
                    width : (typeof scissorTestRectangle.width === 'undefined') ? 0 : scissorTestRectangle.width,
                    height : (typeof scissorTestRectangle.height === 'undefined') ? 0 : scissorTestRectangle.height
                }
            },
            colorMask : {
                red : (typeof colorMask.red === 'undefined') ? true : colorMask.red,
                green : (typeof colorMask.green === 'undefined') ? true : colorMask.green,
                blue : (typeof colorMask.blue === 'undefined') ? true : colorMask.blue,
                alpha : (typeof colorMask.alpha === 'undefined') ? true : colorMask.alpha
            },
            depthMask : (typeof cs.depthMask === 'undefined') ? true : cs.depthMask,
            stencilMask : (typeof cs.stencilMask === 'undefined') ? ~0 : cs.stencilMask,
            dither : (typeof cs.dither === 'undefined') ? true : cs.dither,

            framebuffer : cs.framebuffer,

            color : Color.clone(color),
            depth : depth,
            stencil : stencil
        };

        if ((c.scissorTest.rectangle.width < 0) || (c.scissorTest.rectangle.height < 0)) {
            throw new DeveloperError('clearState.scissorTest.rectangle.width and clearState.scissorTest.rectangle.height must be greater than or equal to zero.');
        }

        return c;
    };

    Context.prototype._validateFramebuffer = function(framebuffer) {
        if (this._validateFB) {
            var gl = this._gl;
            var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

            if (status !== gl.FRAMEBUFFER_COMPLETE) {
                var message;

                switch (status) {
                case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                    message = 'Framebuffer is not complete.  Incomplete attachment: at least one attachment point with a renderbuffer or texture attached has its attached object no longer in existence or has an attached image with a width or height of zero, or the color attachment point has a non-color-renderable image attached, or the depth attachment point has a non-depth-renderable image attached, or the stencil attachment point has a non-stencil-renderable image attached.  Color-renderable formats include GL_RGBA4, GL_RGB5_A1, and GL_RGB565. GL_DEPTH_COMPONENT16 is the only depth-renderable format. GL_STENCIL_INDEX8 is the only stencil-renderable format.';
                    break;
                case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                    message = 'Framebuffer is not complete.  Incomplete dimensions: not all attached images have the same width and height.';
                    break;
                case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                    message = 'Framebuffer is not complete.  Missing attachment: no images are attached to the framebuffer.';
                    break;
                case gl.FRAMEBUFFER_UNSUPPORTED:
                    message = 'Framebuffer is not complete.  Unsupported: the combination of internal formats of the attached images violates an implementation-dependent set of restrictions.';
                    break;
                }

                throw new DeveloperError(message);
            }
        }
    };

    /**
     * DOC_TBA.
     *
     * clearState is optional.
     *
     * @memberof Context
     *
     * @see Context#createClearState
     */
    Context.prototype.clear = function(clearState) {
        var gl = this._gl;
        var bitmask = 0;

        clearState = clearState || this.createClearState();
        var c = clearState.color;
        var d = clearState.depth;
        var s = clearState.stencil;

        if (typeof c !== 'undefined') {
            if (!Color.equals(this._clearColor, c)) {
                Color.clone(c, this._clearColor);
                gl.clearColor(c.red, c.green, c.blue, c.alpha);
            }
            bitmask |= gl.COLOR_BUFFER_BIT;
        }

        if (typeof d !== 'undefined') {
            if (d !== this._clearDepth) {
                this._clearDepth = d;
                gl.clearDepth(d);
            }
            bitmask |= gl.DEPTH_BUFFER_BIT;
        }

        if (typeof s !== 'undefined') {
            if (s !== this._clearStencil) {
                this._clearStencil = s;
                gl.clearStencil(s);
            }
            bitmask |= gl.STENCIL_BUFFER_BIT;
        }

        this._applyScissorTest(clearState.scissorTest);
        this._applyColorMask(clearState.colorMask);
        this._applyDepthMask(clearState.depthMask);
        this._applyStencilMask(clearState.stencilMask);
        this._applyDither(clearState.dither);

        var framebuffer = clearState.framebuffer;

        if (framebuffer) {
            framebuffer._bind();
            this._validateFramebuffer(framebuffer);
        }

        gl.clear(bitmask);

        if (framebuffer) {
            framebuffer._unBind();
        }
    };

    Context.prototype._validateShaderProgram = function(sp) {
        if (this._validateSP) {
            var gl = this._gl;
            var program = sp._getProgram();
            gl.validateProgram(program);

            if (!gl.getProgramParameter(program, gl.VALIDATE_STATUS)) {
                throw new DeveloperError('Program validation failed.  Link log: ' + gl.getProgramInfoLog(program));
            }
        }
    };

    /**
     * DOC_TBA.
     *
     * @memberof Context
     *
     * @exception {DeveloperError} drawArguments is required.
     * @exception {DeveloperError} drawArguments.primitiveType is required and must be valid.
     * @exception {DeveloperError} drawArguments.shaderProgram is required.
     * @exception {DeveloperError} drawArguments.vertexArray is required.
     * @exception {DeveloperError} drawArguments.offset must be omitted or greater than or equal to zero.
     * @exception {DeveloperError} Program validation failed.
     * @exception {DeveloperError} Framebuffer is not complete.
     *
     * @see Context#createShaderProgram
     * @see Context#createVertexArray
     * @see Context#createFramebuffer
     * @see Context#createRenderState
     *
     * @example
     * // Example 1.  Draw a single triangle specifying only required arguments
     * context.draw({
     *     primitiveType : PrimitiveType.TRIANGLES,
     *     shaderProgram : sp,
     *     vertexArray   : va,
     * });
     *
     * ////////////////////////////////////////////////////////////////////////////////
     *
     * // Example 2.  Draw a single triangle specifying every argument
     * context.draw({
     *     primitiveType : PrimitiveType.TRIANGLES,
     *     offset        : 0,
     *     count         : 3,
     *     framebuffer   : fb,
     *     shaderProgram : sp,
     *     vertexArray   : va,
     *     renderState   : rs
     * });
     */
    Context.prototype.draw = function(drawArguments) {
        this.beginDraw(drawArguments);
        this.continueDraw(drawArguments);
        this.endDraw();
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     */
    Context.prototype.beginDraw = function(drawArguments) {
        if (typeof drawArguments === 'undefined') {
            throw new DeveloperError('drawArguments is required.');
        }

        if (!drawArguments.shaderProgram) {
            throw new DeveloperError('drawArguments.shaderProgram is required.');
        }

        var framebuffer = drawArguments.framebuffer;
        var sp = drawArguments.shaderProgram;
        var rs = drawArguments.renderState || this.createRenderState();

        if (framebuffer && rs.depthTest) {
            if (rs.depthTest.enabled &&
                !framebuffer.getDepthRenderbuffer() &&
                !framebuffer.getDepthStencilRenderbuffer()) {
                throw new DeveloperError('The depth test can not be enabled (drawArguments.renderState.depthTest.enabled) because the framebuffer (drawArguments.framebuffer) does not have a depth or depth-stencil renderbuffer.');
            }
        }

        ///////////////////////////////////////////////////////////////////////

        this._applyRenderState(rs);
        if (framebuffer) {
            framebuffer._bind();
            this._validateFramebuffer(framebuffer);
        }
        sp._bind();

        this._currentFramebuffer = framebuffer;
        this._currentSp = sp;
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     */
    Context.prototype.continueDraw = function(drawArguments) {
        var sp = this._currentSp;
        if (typeof sp === 'undefined') {
            throw new DeveloperError('beginDraw must be called before continueDraw.');
        }

        if (typeof drawArguments === 'undefined') {
            throw new DeveloperError('drawArguments is required.');
        }

        var primitiveType = drawArguments.primitiveType;
        if (!PrimitiveType.validate(primitiveType)) {
            throw new DeveloperError('drawArguments.primitiveType is required and must be valid.');
        }

        if (!drawArguments.vertexArray) {
            throw new DeveloperError('drawArguments.vertexArray is required.');
        }

        var va = drawArguments.vertexArray;
        var indexBuffer = va.getIndexBuffer();

        var offset = drawArguments.offset;
        var count = drawArguments.count;

        if (indexBuffer) {
            offset = (offset || 0) * indexBuffer.getBytesPerIndex(); // in bytes
            count = count || indexBuffer.getNumberOfIndices();
        } else {
            offset = offset || 0; // in vertices
            count = count || va._getNumberOfVertices();
        }

        if (offset < 0) {
            throw new DeveloperError('drawArguments.offset must be omitted or greater than or equal to zero.');
        }

        if (count > 0) {
            sp._setUniforms(drawArguments.uniformMap, this._us);
            this._validateShaderProgram(sp);

            va._bind();

            if (indexBuffer) {
                this._gl.drawElements(primitiveType, count, indexBuffer.getIndexDatatype().value, offset);
            } else {
                this._gl.drawArrays(primitiveType, offset, count);
            }

            va._unBind();
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     */
    Context.prototype.endDraw = function(drawArguments) {
        if (this._currentFramebuffer) {
            this._currentFramebuffer._unBind();
            this._currentFramebuffer = undefined;
        }
        this._currentSp._unBind();
        this._currentSp = undefined;
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     *
     * @exception {DeveloperError} readState.width must be greater than zero.
     * @exception {DeveloperError} readState.height must be greater than zero.
     */
    Context.prototype.readPixels = function(readState) {
        readState = readState || {};
        var x = Math.max(readState.x || 0, 0);
        var y = Math.max(readState.y || 0, 0);
        var width = readState.width || this._canvas.clientWidth;
        var height = readState.height || this._canvas.clientHeight;
        var framebuffer = readState.framebuffer || null;

        if (width <= 0) {
            throw new DeveloperError('readState.width must be greater than zero.');
        }

        if (height <= 0) {
            throw new DeveloperError('readState.height must be greater than zero.');
        }

        var pixels = new Uint8Array(4 * width * height);

        if (framebuffer) {
            framebuffer._bind();
            this._validateFramebuffer(framebuffer);
        }

        var gl = this._gl;
        gl.readPixels(x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);

        if (framebuffer) {
            framebuffer._unBind();
        }

        return pixels;
    };

    //////////////////////////////////////////////////////////////////////////////////////////

    Context.prototype._interleaveAttributes = function(attributes) {
        function computeNumberOfVertices(attribute) {
            return attribute.values.length / attribute.componentsPerAttribute;
        }

        function computeAttributeSizeInBytes(attribute) {
            return attribute.componentDatatype.sizeInBytes * attribute.componentsPerAttribute;
        }

        var j;
        var name;
        var attribute;

        // Extract attribute names.
        var names = [];
        for (name in attributes) {
            // Attribute needs to have per-vertex values; not a constant value for all vertices.
            if (attributes.hasOwnProperty(name) && attributes[name].values) {
                names.push(name);
            }
        }

        // Validation.  Compute number of vertices.
        var numberOfVertices;
        var namesLength = names.length;

        if (namesLength > 0) {
            numberOfVertices = computeNumberOfVertices(attributes[names[0]]);

            for (j = 1; j < namesLength; ++j) {
                var currentNumberOfVertices = computeNumberOfVertices(attributes[names[j]]);

                if (currentNumberOfVertices !== numberOfVertices) {
                    throw new RuntimeError(
                        'Each attribute list must have the same number of vertices.  ' +
                        'Attribute ' + names[j] + ' has a different number of vertices ' +
                        '(' + currentNumberOfVertices.toString() + ')' +
                        ' than attribute ' + names[0] +
                        ' (' + numberOfVertices.toString() + ').');
                }
            }
        }

        // Sort attributes by the size of their components.  From left to right, a vertex stores floats, shorts, and then bytes.
        names.sort(function(left, right) {
            return attributes[right].componentDatatype.sizeInBytes - attributes[left].componentDatatype.sizeInBytes;
        });

        // Compute sizes and strides.
        var vertexSizeInBytes = 0;
        var offsetsInBytes = {};

        for (j = 0; j < namesLength; ++j) {
            name = names[j];
            attribute = attributes[name];

            offsetsInBytes[name] = vertexSizeInBytes;
            vertexSizeInBytes += computeAttributeSizeInBytes(attribute);
        }

        if (vertexSizeInBytes > 0) {
            // Pad each vertex to be a multiple of the largest component datatype so each
            // attribute can be addressed using typed arrays.
            var maxComponentSizeInBytes = attributes[names[0]].componentDatatype.sizeInBytes; // Sorted large to small
            var remainder = vertexSizeInBytes % maxComponentSizeInBytes;
            if (remainder !== 0) {
                vertexSizeInBytes += (maxComponentSizeInBytes - remainder);
            }

            // Total vertex buffer size in bytes, including per-vertex padding.
            var vertexBufferSizeInBytes = numberOfVertices * vertexSizeInBytes;

            // Create array for interleaved vertices.  Each attribute has a different view (pointer) into the array.
            var buffer = new ArrayBuffer(vertexBufferSizeInBytes);
            var views = {};

            for (j = 0; j < namesLength; ++j) {
                name = names[j];
                var sizeInBytes = attributes[name].componentDatatype.sizeInBytes;

                views[name] = {
                    pointer : attributes[name].componentDatatype.toTypedArray(buffer),
                    index : offsetsInBytes[name] / sizeInBytes, // Offset in ComponentType
                    strideInComponentType : vertexSizeInBytes / sizeInBytes
                };
            }

            // Copy attributes into one interleaved array.
            // PERFORMANCE_IDEA:  Can we optimize these loops?
            for (j = 0; j < numberOfVertices; ++j) {
                for ( var n = 0; n < namesLength; ++n) {
                    name = names[n];
                    attribute = attributes[name];
                    var values = attribute.values;
                    var view = views[name];
                    var pointer = view.pointer;

                    var numberOfComponents = attribute.componentsPerAttribute;
                    for ( var k = 0; k < numberOfComponents; ++k) {
                        pointer[view.index + k] = values[(j * numberOfComponents) + k];
                    }

                    view.index += view.strideInComponentType;
                }
            }

            return {
                buffer : buffer,
                offsetsInBytes : offsetsInBytes,
                vertexSizeInBytes : vertexSizeInBytes
            };
        }

        // No attributes to interleave.
        return undefined;
    };

    Context.prototype._createVertexArrayAttributes = function(creationArguments) {
        var ca = creationArguments || {};
        var mesh = ca.mesh || {};
        var attributeIndices = ca.attributeIndices || {};
        var bufferUsage = ca.bufferUsage || BufferUsage.DYNAMIC_DRAW;
        var interleave = ca.vertexLayout && (ca.vertexLayout === VertexLayout.INTERLEAVED);

        var name;
        var attribute;
        var vaAttributes = [];
        var attributes = mesh.attributes;

        if (interleave) {
            // Use a single vertex buffer with interleaved vertices.
            var interleavedAttributes = this._interleaveAttributes(attributes);
            if (interleavedAttributes) {
                var vertexBuffer = this.createVertexBuffer(interleavedAttributes.buffer, bufferUsage);
                var offsetsInBytes = interleavedAttributes.offsetsInBytes;
                var strideInBytes = interleavedAttributes.vertexSizeInBytes;

                for (name in attributes) {
                    if (attributes.hasOwnProperty(name)) {
                        attribute = attributes[name];

                        if (attribute.values) {
                            // Common case: per-vertex attributes
                            vaAttributes.push({
                                index : attributeIndices[name],
                                vertexBuffer : vertexBuffer,
                                componentDatatype : attribute.componentDatatype,
                                componentsPerAttribute : attribute.componentsPerAttribute,
                                normalize : attribute.normalize,
                                offsetInBytes : offsetsInBytes[name],
                                strideInBytes : strideInBytes
                            });
                        } else {
                            // Constant attribute for all vertices
                            vaAttributes.push({
                                index : attributeIndices[name],
                                value : attribute.value,
                                componentDatatype : attribute.componentDatatype,
                                normalize : attribute.normalize
                            });
                        }
                    }
                }
            }
        } else {
            // One vertex buffer per attribute.
            for (name in attributes) {
                if (attributes.hasOwnProperty(name)) {
                    attribute = attributes[name];
                    vaAttributes.push({
                        index : attributeIndices[name],
                        vertexBuffer : attribute.values ? this.createVertexBuffer(attribute.componentDatatype.toTypedArray(attribute.values), bufferUsage) : undefined,
                        value : attribute.value ? attribute.value : undefined,
                        componentDatatype : attribute.componentDatatype,
                        componentsPerAttribute : attribute.componentsPerAttribute,
                        normalize : attribute.normalize
                    });
                }
            }
        }

        return this.createVertexArray(vaAttributes);
    };

    /**
     * Creates a vertex array from a mesh.  A mesh contains vertex attributes and optional index data
     * in system memory, whereas a vertex array contains vertex buffers and an optional index buffer in WebGL
     * memory for use with rendering.
     * <br /><br />
     * The <code>mesh</code> argument should use the standard layout like the mesh returned by {@link BoxTessellator}.
     * <br /><br />
     * <code>creationArguments</code> can have four properties:
     * <ul>
     *   <li><code>mesh</code>:  The source mesh containing data used to create the vertex array.</li>
     *   <li><code>attributeIndices</code>:  An object that maps mesh attribute names to vertex shader attribute indices.</li>
     *   <li><code>bufferUsage</code>:  The expected usage pattern of the vertex array's buffers.  On some WebGL implementations, this can significantly affect performance.  See {@link BufferUsage}.  Default: <code>BufferUsage.DYNAMIC_DRAW</code>.</li>
     *   <li><code>vertexLayout</code>:  Determines if all attributes are interleaved in a single vertex buffer or if each attribute is stored in a separate vertex buffer.  Default: <code>VertexLayout.SEPARATE</code>.</li>
     * </ul>
     * <br />
     * If <code>creationArguments</code> is not specified or the <code>mesh</code> contains no data, the returned vertex array is empty.
     *
     * @memberof Context
     *
     * @param {Object} [creationArguments=undefined] An object defining the mesh, attribute indices, buffer usage, and vertex layout used to create the vertex array.
     *
     * @exception {RuntimeError} Each attribute list must have the same number of vertices.
     * @exception {DeveloperError} The mesh must have zero or one index lists.
     * @exception {DeveloperError} Index n is used by more than one attribute.
     *
     * @see Context#createVertexArray
     * @see Context#createVertexBuffer
     * @see Context#createIndexBuffer
     * @see MeshFilters.createAttributeIndices
     * @see ShaderProgram
     * @see BoxTessellator
     *
     * @example
     * // Example 1. Creates a vertex array for rendering a box.  The default dynamic draw
     * // usage is used for the created vertex and index buffer.  The attributes are not
     * // interleaved by default.
     * var mesh = BoxTessellator.compute();
     * var va = context.createVertexArrayFromMesh({
     *     mesh             : mesh,
     *     attributeIndices : MeshFilters.createAttributeIndices(mesh),
     * });
     *
     * ////////////////////////////////////////////////////////////////////////////////
     *
     * // Example 2. Creates a vertex array with interleaved attributes in a
     * // single vertex buffer.  The vertex and index buffer have static draw usage.
     * var va = context.createVertexArrayFromMesh({
     *     mesh             : mesh,
     *     attributeIndices : MeshFilters.createAttributeIndices(mesh),
     *     bufferUsage      : BufferUsage.STATIC_DRAW,
     *     vertexLayout     : VertexLayout.INTERLEAVED
     * });
     *
     * ////////////////////////////////////////////////////////////////////////////////
     *
     * // Example 3.  When the caller destroys the vertex array, it also destroys the
     * // attached vertex buffer(s) and index buffer.
     * va = va.destroy();
     */
    Context.prototype.createVertexArrayFromMesh = function(creationArguments) {
        var ca = creationArguments || {};
        var mesh = ca.mesh || {};
        var bufferUsage = ca.bufferUsage || BufferUsage.DYNAMIC_DRAW;
        var indexLists;

        if (mesh.indexLists) {
            indexLists = mesh.indexLists;
            if (indexLists.length !== 1) {
                throw new DeveloperError('The mesh must have zero or one index lists.  This mesh has ' + indexLists.length.toString() + ' index lists.');
            }
        }

        var va = this._createVertexArrayAttributes(creationArguments);

        if (indexLists) {
            va.setIndexBuffer(this.createIndexBuffer(new Uint16Array(indexLists[0].values), bufferUsage, IndexDatatype.UNSIGNED_SHORT));
        }

        return va;
    };

    /*
     * DOC_TBA
     *
     * @memberof Context
     *
     * @see Context#pick
     */
    Context.prototype.createPickFramebuffer = function() {
        return new PickFramebuffer(this);
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     *
     * @see Context#createPickId
     */
    Context.prototype.getObjectByPickId = function(pickId) {
        return undefined;
    };

    /**
     * DOC_TBA
     *
     * @memberof Context
     *
     * @see Context#getObjectByPickId
     */
    Context.prototype.createPickId = function(object) {
        var objects = {};
        var nextRgb = new Color(0, 0, 0, 0);

        function rgbToObjectIndex(unnormalizedRgb) {
            // TODO:  Use alpha?
            var index = 'r' + unnormalizedRgb.red + 'g' + unnormalizedRgb.green + 'b' + unnormalizedRgb.blue;
            return index;
        }

        function _createPickId(object) {
            // TODO:  Use alpha?
            if (++nextRgb.blue === 256) {
                nextRgb.blue = 0;

                if (++nextRgb.green === 256) {
                    nextRgb.green = 0;

                    if (++nextRgb.red === 256) {
                        throw new RuntimeError('Out of unique Rgb colors.');
                    }
                }
            }

            var pickId = {
                unnormalizedRgb : new Color(nextRgb.red, nextRgb.green, nextRgb.blue, 1.0),
                normalizedRgba : Color.fromBytes(nextRgb.red, nextRgb.green, nextRgb.blue, 255.0),
                destroy : function() {
                    // TODO: Remove from objects
                    return null;
                }
            };

            objects[rgbToObjectIndex(pickId.unnormalizedRgb)] = object;

            return pickId;
        }

        function _getObjectByPickId(unnormalizedRgb) {
            return objects[rgbToObjectIndex(unnormalizedRgb)];
        }

        this.createPickId = _createPickId;
        this.getObjectByPickId = _getObjectByPickId;

        return _createPickId(object);
    };

    Context.prototype.isDestroyed = function() {
        return false;
    };

    Context.prototype.destroy = function() {
        this._shaderCache = this._shaderCache.destroy();
        return destroyObject(this);
    };

    return Context;
});

/*global define*/
define('Shaders/CentralBodyFS',[],function() {
  
  return "uniform sampler2D u_dayTexture;\n" +
"varying vec3 v_positionMC;\n" +
"varying vec3 v_positionEC;\n" +
"varying vec3 v_rayleighColor;\n" +
"varying vec3 v_mieColor;\n" +
"varying vec2 v_textureCoordinates;\n" +
"void main()\n" +
"{\n" +
"vec3 normalMC = normalize(agi_geodeticSurfaceNormal(v_positionMC, vec3(0.0), vec3(1.0)));\n" +
"vec3 normalEC = normalize(agi_normal * normalMC);\n" +
"#ifdef SHOW_DAY\n" +
"vec3 startDayColor = texture2D(u_dayTexture, v_textureCoordinates).rgb;\n" +
"#else\n" +
"vec3 startDayColor = vec3(1.0);\n" +
"#endif\n" +
"#ifdef AFFECTED_BY_LIGHTING\n" +
"vec3 rgb = getCentralBodyColor(v_positionMC, v_positionEC, normalMC, normalEC, startDayColor, v_rayleighColor, v_mieColor);\n" +
"#else\n" +
"vec3 rgb = startDayColor;\n" +
"#endif\n" +
"gl_FragColor = vec4(rgb, 1.0);\n" +
"}\n" +
"";
});
/*!
 * Atmosphere code:
 *
 * Copyright (c) 2000-2005, Sean O'Neil (s_p_oneil@hotmail.com)
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * * Neither the name of the project nor the names of its contributors may be
 *   used to endorse or promote products derived from this software without
 *   specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Modifications made by Analytical Graphics, Inc.
 */
/*global define*/
define('Shaders/CentralBodyFSCommon',[],function() {
  
  return "#ifdef SHOW_TERMINATOR\n" +
"#ifdef GL_OES_standard_derivatives\n" +
"#extension GL_OES_standard_derivatives : enable\n" +
"#endif\n" +
"#endif\n" +
"#ifdef SHOW_NIGHT\n" +
"uniform sampler2D u_nightTexture;\n" +
"#endif\n" +
"uniform sampler2D u_specularMap;\n" +
"uniform sampler2D u_cloudMap;\n" +
"uniform sampler2D u_bumpMap;\n" +
"uniform float u_dayNightBlendDelta;\n" +
"uniform vec2 u_bumpMapResoltuion;\n" +
"uniform float u_bumpMapNormalZ;\n" +
"uniform float u_nightIntensity;\n" +
"uniform float u_dayIntensity;\n" +
"bool isCloud(float cloudCover)\n" +
"{\n" +
"return cloudCover > 0.7;\n" +
"}\n" +
"vec3 dayColor(vec3 positionMC, vec3 positionEC, vec3 normalEC, vec3 startColor, vec2 txCoord, float cloudCover)\n" +
"{\n" +
"#ifdef SHOW_GROUND_ATMOSPHERE\n" +
"vec4 diffuseSpecularAmbientShininess = vec4(0.35, 0.5, u_dayIntensity, 10.0);\n" +
"#else\n" +
"vec4 diffuseSpecularAmbientShininess = vec4(0.75, 0.5, u_dayIntensity, 10.0);\n" +
"#endif\n" +
"#ifdef SHOW_SPECULAR\n" +
"float specularWeight = texture2D(u_specularMap, txCoord).r;\n" +
"#else\n" +
"float specularWeight = 1.0;\n" +
"#endif\n" +
"float intensity = diffuseSpecularAmbientShininess.z;\n" +
"float diffuse = max(dot(agi_sunDirectionEC, normalEC), 0.0);\n" +
"#ifdef SHOW_BUMPS\n" +
"float center = texture2D(u_bumpMap, txCoord).r;\n" +
"float right = texture2D(u_bumpMap, txCoord + vec2(u_bumpMapResoltuion.x, 0.0)).r;\n" +
"float top = texture2D(u_bumpMap, txCoord + vec2(0.0, u_bumpMapResoltuion.y)).r;\n" +
"vec3 perturbedNormalTC = normalize(vec3(center - right, center - top, u_bumpMapNormalZ));\n" +
"vec3 perturbedNormalEC = agi_eastNorthUpToEyeCoordinates(positionMC, normalEC) * perturbedNormalTC;\n" +
"perturbedNormalEC = normalize(perturbedNormalEC);\n" +
"float perturbedDiffuse = max(dot(agi_sunDirectionEC, perturbedNormalEC), 0.0);\n" +
"#else\n" +
"float perturbedDiffuse = diffuse;\n" +
"#endif\n" +
"intensity += (diffuseSpecularAmbientShininess.x * perturbedDiffuse);\n" +
"if (specularWeight != 0.0)\n" +
"{\n" +
"vec3 positionToEyeEC = normalize(-positionEC);\n" +
"vec3 toReflectedLight = reflect(-agi_sunDirectionEC, normalEC);\n" +
"float specular = max(dot(toReflectedLight, normalize(positionToEyeEC)), 0.0);\n" +
"specular = pow(specular, diffuseSpecularAmbientShininess.w);\n" +
"specular *= specularWeight;\n" +
"intensity += (diffuseSpecularAmbientShininess.y * specular);\n" +
"}\n" +
"vec3 earthColor = vec3(intensity) * startColor;\n" +
"vec3 cloudColor = vec3(cloudCover * diffuse);\n" +
"vec3 earthUnderCloudColor = mix(earthColor, cloudColor, cloudCover);\n" +
"#ifdef SHOW_CLOUD_SHADOWS\n" +
"if (diffuse > 0.0)\n" +
"{\n" +
"if (!isCloud(texture2D(u_cloudMap, txCoord).r))\n" +
"{\n" +
"mat3 eyeToEastNorthUp = agi_transpose(agi_eastNorthUpToEyeCoordinates(positionMC, normalEC));\n" +
"vec3 positionToSunTC = eyeToEastNorthUp * agi_sunDirectionEC;\n" +
"float scale = (1.0 - positionToSunTC.z) * 0.005;\n" +
"float shadowCloudCover = texture2D(u_cloudMap, txCoord + (scale * positionToSunTC.xy)).r;\n" +
"float cloudBehind = texture2D(u_cloudMap, txCoord - (scale * positionToSunTC.xy)).r;\n" +
"float viewDistance = length(positionEC) * 10.0E-8;\n" +
"viewDistance = min(1.0, viewDistance);\n" +
"if (isCloud(shadowCloudCover))\n" +
"{\n" +
"if(isCloud(cloudBehind))\n" +
"{\n" +
"return mix(earthUnderCloudColor, vec3(0.1), shadowCloudCover * viewDistance);\n" +
"}\n" +
"return mix(earthUnderCloudColor, vec3(0.1), viewDistance);\n" +
"}\n" +
"else\n" +
"{\n" +
"scale = scale * 1.25;\n" +
"shadowCloudCover = texture2D(u_cloudMap, txCoord + (scale * positionToSunTC.xy)).r;\n" +
"if(isCloud(shadowCloudCover))\n" +
"{\n" +
"return mix(earthUnderCloudColor, vec3(0.1), shadowCloudCover * viewDistance);\n" +
"}\n" +
"}\n" +
"}\n" +
"}\n" +
"#endif\n" +
"return earthUnderCloudColor;\n" +
"}\n" +
"vec3 nightColor(vec2 txCoord, float cloudCover)\n" +
"{\n" +
"#ifdef SHOW_NIGHT\n" +
"return u_nightIntensity * texture2D(u_nightTexture, txCoord).rgb * (1.0 - cloudCover);\n" +
"#else\n" +
"return vec3(0.0);\n" +
"#endif\n" +
"}\n" +
"vec3 getCentralBodyColor(vec3 positionMC, vec3 positionEC, vec3 normalMC, vec3 normalEC, vec3 startDayColor, vec3 rayleighColor, vec3 mieColor) {\n" +
"float diffuse = dot(agi_sunDirectionEC, normalEC);\n" +
"#ifdef SHOW_TERMINATOR\n" +
"float absDiffuse = abs(diffuse);\n" +
"#ifdef GL_OES_standard_derivatives\n" +
"if ((absDiffuse < abs(dFdx(diffuse)) * 1.0) ||\n" +
"(absDiffuse < abs(dFdy(diffuse)) * 1.0))\n" +
"{\n" +
"gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n" +
"return;\n" +
"}\n" +
"#else\n" +
"if (absDiffuse < 0.005)\n" +
"{\n" +
"gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n" +
"return;\n" +
"}\n" +
"#endif\n" +
"#endif\n" +
"vec2 txCoord = agi_ellipsoidWgs84TextureCoordinates(normalMC);\n" +
"#ifdef SHOW_CLOUDS\n" +
"float cloudCover = texture2D(u_cloudMap, txCoord).r;\n" +
"#else\n" +
"float cloudCover = 0.0;\n" +
"#endif\n" +
"vec3 rgb = dayColor(positionMC, positionEC, normalEC, startDayColor, txCoord, cloudCover);\n" +
"#ifdef SHOW_GROUND_ATMOSPHERE\n" +
"const float fExposure = 2.0;\n" +
"vec3 color = mieColor + rgb * rayleighColor;\n" +
"rgb = vec3(1.0) - exp(-fExposure * color);\n" +
"#endif\n" +
"if (diffuse < -u_dayNightBlendDelta)\n" +
"{\n" +
"rgb = nightColor(txCoord, cloudCover);\n" +
"}\n" +
"else if (diffuse <= u_dayNightBlendDelta)\n" +
"{\n" +
"rgb = mix(\n" +
"nightColor(txCoord, cloudCover),\n" +
"rgb,\n" +
"(diffuse + u_dayNightBlendDelta) / (2.0 * u_dayNightBlendDelta));\n" +
"}\n" +
"return rgb;\n" +
"}\n" +
"";
});

/*global define*/
define('Shaders/CentralBodyFSDepth',[],function() {
  
  return "varying vec4 positionEC;\n" +
"void main()\n" +
"{\n" +
"agi_ellipsoid ellipsoid = agi_getWgs84EllipsoidEC();\n" +
"vec3 direction = normalize(positionEC.xyz);\n" +
"agi_ray ray = agi_ray(vec3(0.0, 0.0, 0.0), direction);\n" +
"agi_raySegment intersection = agi_rayEllipsoidIntersectionInterval(ray, ellipsoid);\n" +
"if (!agi_isEmpty(intersection))\n" +
"{\n" +
"gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);\n" +
"}\n" +
"else\n" +
"{\n" +
"discard;\n" +
"}\n" +
"}\n" +
"";
});

/*global define*/
define('Shaders/CentralBodyFSFilter',[],function() {
  
  return "#define KERNEL_SIZE 7\n" +
"uniform sampler2D u_texture;\n" +
"varying vec2 v_textureCoordinates[KERNEL_SIZE];\n" +
"void main()\n" +
"{\n" +
"float kernel[KERNEL_SIZE];\n" +
"kernel[0] = 8.0;\n" +
"kernel[1] = 28.0;\n" +
"kernel[2] = 56.0;\n" +
"kernel[3] = 70.0;\n" +
"kernel[4] = 56.0;\n" +
"kernel[5] = 28.0;\n" +
"kernel[6] = 8.0;\n" +
"vec4 color = texture2D(u_texture, v_textureCoordinates[KERNEL_SIZE / 2]);\n" +
"if (color.w == 0.0) {\n" +
"vec4 startColor = texture2D(u_texture, v_textureCoordinates[0]);\n" +
"vec4 endColor = texture2D(u_texture, v_textureCoordinates[KERNEL_SIZE - 1]);\n" +
"if (startColor.w != 0.0 && endColor.w != 0.0) {\n" +
"float startWeight = kernel[0];\n" +
"float endWeight = kernel[KERNEL_SIZE - 1];\n" +
"color = startWeight * startColor + endWeight * endColor;\n" +
"float sum = startWeight + endWeight;\n" +
"for (int i = 1; i < KERNEL_SIZE - 1; i++) {\n" +
"if (i != KERNEL_SIZE / 2) {\n" +
"float weight = kernel[i];\n" +
"vec4 tex = texture2D(u_texture, v_textureCoordinates[i]);\n" +
"color += tex.a * weight * tex;\n" +
"sum += tex.a * weight;\n" +
"}\n" +
"}\n" +
"color /= sum;\n" +
"}\n" +
"}\n" +
"gl_FragColor = color;\n" +
"}\n" +
"";
});

/*global define*/
define('Shaders/CentralBodyFSPole',[],function() {
  
  return "uniform sampler2D u_fbTexture;\n" +
"uniform vec3 u_color;\n" +
"varying vec2 v_textureCoordinates;\n" +
"void main()\n" +
"{\n" +
"vec4 color = texture2D(u_fbTexture, v_textureCoordinates);\n" +
"if (color.a == 1.0)\n" +
"discard;\n" +
"agi_ellipsoid ellipsoid = agi_getWgs84EllipsoidEC();\n" +
"vec3 direction = normalize(agi_windowToEyeCoordinates(gl_FragCoord).xyz);\n" +
"agi_ray ray = agi_ray(vec3(0.0, 0.0, 0.0), direction);\n" +
"agi_raySegment intersection = agi_rayEllipsoidIntersectionInterval(ray, ellipsoid);\n" +
"if (!agi_isEmpty(intersection))\n" +
"{\n" +
"vec3 positionEC = agi_pointAlongRay(ray, intersection.start);\n" +
"vec3 positionMC = (agi_inverseModelView * vec4(positionEC, 1.0)).xyz;\n" +
"vec3 normalMC = normalize(agi_geodeticSurfaceNormal(positionMC, vec3(0.0), vec3(1.0)));\n" +
"vec3 normalEC = normalize(agi_normal * normalMC);\n" +
"AtmosphereColor atmosphereColor = computeGroundAtmosphereFromSpace(positionMC);\n" +
"vec3 mieColor = atmosphereColor.mie;\n" +
"vec3 rayleighColor = atmosphereColor.rayleigh;\n" +
"#ifdef SHOW_DAY\n" +
"vec3 startDayColor = u_color;\n" +
"#else\n" +
"vec3 startDayColor = vec3(1.0);\n" +
"#endif\n" +
"#ifdef AFFECTED_BY_LIGHTING\n" +
"vec3 rgb = getCentralBodyColor(positionMC, positionEC, normalMC, normalEC, startDayColor, rayleighColor, mieColor);\n" +
"#else\n" +
"vec3 rgb = startDayColor;\n" +
"#endif\n" +
"gl_FragColor = vec4(rgb, 1.0);\n" +
"}\n" +
"else\n" +
"{\n" +
"discard;\n" +
"}\n" +
"}\n" +
"";
});

/*global define*/
define('Shaders/CentralBodyVS',[],function() {
  
  return "attribute vec3 position3D;\n" +
"attribute vec2 textureCoordinates;\n" +
"attribute vec2 position2D;\n" +
"uniform float u_morphTime;\n" +
"uniform int u_mode;\n" +
"uniform vec3 u_center3D;\n" +
"uniform vec2 u_center2D;\n" +
"uniform mat4 u_modifiedModelView;\n" +
"varying vec3 v_positionMC;\n" +
"varying vec3 v_positionEC;\n" +
"varying vec3 v_rayleighColor;\n" +
"varying vec3 v_mieColor;\n" +
"varying vec2 v_textureCoordinates;\n" +
"void main()\n" +
"{\n" +
"vec3 position3DWC = position3D + u_center3D;\n" +
"if (u_mode == 0) {\n" +
"v_positionEC = (u_modifiedModelView * vec4(position3D, 1.0)).xyz;\n" +
"gl_Position = agi_projection * (u_modifiedModelView * vec4(position3D, 1.0));\n" +
"}\n" +
"else if (u_mode == 1) {\n" +
"v_positionEC = (agi_modelView * vec4(position3DWC, 1.0)).xyz;\n" +
"gl_Position = agi_projection * (u_modifiedModelView * vec4(0.0, position2D.x, position2D.y, 1.0));\n" +
"}\n" +
"else {\n" +
"vec3 position2DWC = vec3(0.0, position2D.x + u_center2D.x, position2D.y + u_center2D.y);\n" +
"v_positionEC = (agi_modelView * vec4(position3DWC, 1.0)).xyz;\n" +
"vec4 position = agi_columbusViewMorph(position2DWC, position3DWC, u_morphTime);\n" +
"gl_Position = agi_modelViewProjection * position;\n" +
"}\n" +
"AtmosphereColor atmosphereColor = computeGroundAtmosphereFromSpace(position3DWC);\n" +
"v_positionMC = position3DWC;\n" +
"v_mieColor = atmosphereColor.mie;\n" +
"v_rayleighColor = atmosphereColor.rayleigh;\n" +
"v_textureCoordinates = textureCoordinates;\n" +
"}\n" +
"";
});

/*global define*/
define('Shaders/CentralBodyVSDepth',[],function() {
  
  return "attribute vec4 position;\n" +
"varying vec4 positionEC;\n" +
"void main()\n" +
"{\n" +
"positionEC = agi_modelView * position;\n" +
"gl_Position = agi_projection * positionEC;\n" +
"}\n" +
"";
});

/*global define*/
define('Shaders/CentralBodyVSFilter',[],function() {
  
  return "#define KERNEL_SIZE 7\n" +
"attribute vec4 position;\n" +
"attribute vec2 textureCoordinates;\n" +
"#ifdef VERTICAL\n" +
"uniform float u_height;\n" +
"#else\n" +
"uniform float u_width;\n" +
"#endif\n" +
"varying vec2 v_textureCoordinates[KERNEL_SIZE];\n" +
"void main()\n" +
"{\n" +
"#ifdef VERTICAL\n" +
"float stepSize = 1.0 / u_height;\n" +
"#else\n" +
"float stepSize = 1.0 / u_width;\n" +
"#endif\n" +
"const int center = KERNEL_SIZE / 2;\n" +
"for (int i = 0; i < KERNEL_SIZE; ++i) {\n" +
"#ifdef VERTICAL\n" +
"vec2 offset = vec2(0.0, stepSize * float(i - center));\n" +
"#else\n" +
"vec2 offset = vec2(stepSize * float(i - center), 0.0);\n" +
"#endif\n" +
"v_textureCoordinates[i] = textureCoordinates + offset;\n" +
"}\n" +
"gl_Position = agi_viewportOrthographic * position;\n" +
"}\n" +
"";
});

/*global define*/
define('Shaders/CentralBodyVSPole',[],function() {
  
  return "attribute vec4 position;\n" +
"varying vec2 v_textureCoordinates;\n" +
"void main()\n" +
"{\n" +
"float x = (position.x - float(agi_viewport.x)) / float(agi_viewport.z);\n" +
"float y = (position.y - float(agi_viewport.y)) / float(agi_viewport.w);\n" +
"v_textureCoordinates = vec2(x, y);\n" +
"gl_Position = agi_viewportOrthographic * position;\n" +
"}\n" +
"";
});

/*global define*/
define('Shaders/CheckerboardMaterial',[],function() {
  
  return "uniform vec4 u_lightColor;\n" +
"uniform vec4 u_darkColor;\n" +
"uniform vec2 u_repeat;\n" +
"vec4 agi_getMaterialColor(float zDistance, vec2 st, vec3 str)\n" +
"{\n" +
"const float fuzz = 0.03;\n" +
"float b = mod(floor(u_repeat.s * st.s) + floor(u_repeat.t * st.t), 2.0);\n" +
"float scaledWidth = fract(u_repeat.s * st.s);\n" +
"scaledWidth = abs(scaledWidth - floor(scaledWidth + 0.5));\n" +
"float scaledHeight = fract(u_repeat.t * st.t);\n" +
"scaledHeight = abs(scaledHeight - floor(scaledHeight + 0.5));\n" +
"float value = min(scaledWidth, scaledHeight);\n" +
"float val1 = clamp(value / fuzz, 0.0, 1.0);\n" +
"float val2 = clamp((value - 0.5) / fuzz, 0.0, 1.0);\n" +
"val1 = val1 * (1.0 - val2);\n" +
"val1 = val1 * val1 * (3.0 - (2.0 * val1));\n" +
"val1 = pow(val1, 0.5);\n" +
"vec4 midColor = (u_lightColor + u_darkColor) / 2.0;\n" +
"vec4 currentColor = mix(u_lightColor, u_darkColor, b);\n" +
"return mix(midColor, currentColor, val1);\n" +
"}\n" +
"";
});
/*global define*/
define('Scene/CheckerboardMaterial',[
        '../Core/Color',
        '../Shaders/CheckerboardMaterial'
       ], function(
         Color,
         ShadersCheckerboardMaterial) {
    

    /**
     * DOC_TBA
     *
     * @alias CheckerboardMaterial
     * @constructor
     */
    var CheckerboardMaterial = function(template) {
        var t = template || {};

        /**
         * DOC_TBA
         */
        this.lightColor = (typeof t.lightColor !== 'undefined') ? Color.clone(t.lightColor) : new Color(1.0, 1.0, 1.0, 0.5);

        /**
         * DOC_TBA
         */
        this.darkColor = (typeof t.darkColor !== 'undefined') ? Color.clone(t.darkColor) : new Color(0.0, 0.0, 0.0, 0.5);

        /**
         * DOC_TBA
         *
         * @type Number
         */
        this.sRepeat = t.sRepeat || 10.0;

        /**
         * DOC_TBA
         *
         * @type Number
         */
        this.tRepeat = t.tRepeat || 10.0;

        var that = this;
        this._uniforms = {
            u_lightColor : function() {
                return that.lightColor;
            },
            u_darkColor : function() {
                return that.darkColor;
            },
            u_repeat : function() {
                return {
                    x : that.sRepeat,
                    y : that.tRepeat
                };
            }
        };
    };

    CheckerboardMaterial.prototype._getShaderSource = function() {
        return '#line 0\n' + ShadersCheckerboardMaterial;
    };

    return CheckerboardMaterial;
});

/*global define*/
define('Shaders/ColorMaterial',[],function() {
  
  return "uniform vec4 u_color;\n" +
"vec4 agi_getMaterialColor(float zDistance, vec2 st, vec3 str)\n" +
"{\n" +
"return u_color;\n" +
"}\n" +
"";
});
/*global define*/
define('Scene/ColorMaterial',[
        '../Core/Color',
        '../Shaders/ColorMaterial'
       ], function(
         Color,
         ShadersColorMaterial) {
    

    /**
     * DOC_TBA
     *
     * @alias ColorMaterial
     * @constructor
     */
    var ColorMaterial = function(template) {
        var color = typeof template === 'undefined' ? undefined : template.color;

        /**
         * DOC_TBA
         */
        this.color = typeof color !== 'undefined' ? Color.clone(color) : new Color(1.0, 0.0, 0.0, 0.5);

        var that = this;
        this._uniforms = {
            u_color : function() {
                return that.color;
            }
        };
    };

    ColorMaterial.prototype._getShaderSource = function() {
        return '#line 0\n' + ShadersColorMaterial;
    };

    return ColorMaterial;
});

/*global define*/
define('DynamicScene/DynamicColorMaterial',[
        './DynamicProperty',
        './CzmlColor',
        '../Scene/ColorMaterial'
    ], function(
         DynamicProperty,
         CzmlColor,
         ColorMaterial) {
    

    /**
     * A utility class for processing CZML color materials.
     * @alias DynamicColorMaterial
     * @constructor
     */
    var DynamicColorMaterial = function() {
        this.color = undefined;
    };

    /**
     * Returns true if the provided CZML interval contains color material data.
     * @param czmlInterval The CZML interval to check.
     * @returns {Boolean} true if the interval contains CZML color material data, false otherwise.
     */
    DynamicColorMaterial.isMaterial = function(czmlInterval) {
        return typeof czmlInterval !== 'undefined' && typeof czmlInterval.solidColor !== 'undefined';
    };

    /**
     * Provided a CZML interval containing color material data, processes the
     * interval into a new or existing instance of this class.
     *
     * @param {Object} czmlInterval The interval to process.
     * @param {DynamicColorMaterial} [existingMaterial] The DynamicColorMaterial to modify.
     */
    DynamicColorMaterial.prototype.processCzmlIntervals = function(czmlInterval) {
        var materialData = czmlInterval.solidColor;
        if (typeof materialData !== 'undefined') {
            if (typeof materialData.color !== 'undefined') {
                var color = this.color;
                if (typeof color === 'undefined') {
                    this.color = color = new DynamicProperty(CzmlColor);
                }
                color.processCzmlIntervals(materialData.color);
            }
        }
    };

    /**
     * Get's a ColorMaterial that represents this dynamic material at the provided time.
     *
     * @param {JulianDate} time The desired time.
     * @param {Context} context The context in which this material exists.
     * @param {ColorMaterial} [existingMaterial] An existing material to be modified.  If the material is undefined or not a ColorMaterial, a new instance is created.
     * @returns The modified existingMaterial parameter or a new ColorMaterial instance if existingMaterial was undefined or not a ColorMaterial.
     */
    DynamicColorMaterial.prototype.getValue = function(time, context, existingMaterial) {
        if (typeof existingMaterial === 'undefined' || !(existingMaterial instanceof ColorMaterial)) {
            existingMaterial = new ColorMaterial();
        }
        existingMaterial.color = this.color.getValue(time, existingMaterial.color);
        return existingMaterial;
    };

    return DynamicColorMaterial;
});

/*global define*/
define('Shaders/ComplexConicSensorVolumeFS',[],function() {
  
  return "#ifdef GL_OES_standard_derivatives\n" +
"#extension GL_OES_standard_derivatives : enable\n" +
"#endif\n" +
"uniform float u_sensorRadius;\n" +
"uniform float u_outerHalfAngle;\n" +
"uniform float u_innerHalfAngle;\n" +
"uniform float u_maximumClockAngle;\n" +
"uniform float u_minimumClockAngle;\n" +
"uniform bool u_showIntersection;\n" +
"uniform vec4 u_pickColor;\n" +
"varying vec3 v_positionEC;\n" +
"varying vec3 v_sensorVertexWC;\n" +
"varying vec3 v_sensorVertexEC;\n" +
"varying vec3 v_sensorAxisEC;\n" +
"#ifndef RENDER_FOR_PICK\n" +
"vec4 getOuterColor(float sensorRadius, vec3 pointEC)\n" +
"{\n" +
"sensorErode(sensorRadius, pointEC);\n" +
"vec3 pointMC = (agi_inverseModelView * vec4(pointEC, 1.0)).xyz;\n" +
"float zDistance = pointMC.z;\n" +
"vec2 st = sensor2dTextureCoordinates(sensorRadius, pointMC);\n" +
"vec3 str = pointMC / sensorRadius;\n" +
"return agi_getOuterMaterialColor(zDistance, st, str);\n" +
"}\n" +
"vec4 getInnerColor(float sensorRadius, vec3 pointEC)\n" +
"{\n" +
"sensorErode(sensorRadius, pointEC);\n" +
"vec3 pointMC = (agi_inverseModelView * vec4(pointEC, 1.0)).xyz;\n" +
"float zDistance = pointMC.z;\n" +
"vec2 st = sensor2dTextureCoordinates(sensorRadius, pointMC);\n" +
"vec3 str = pointMC / sensorRadius;\n" +
"return agi_getInnerMaterialColor(zDistance, st, str);\n" +
"}\n" +
"vec4 getCapColor(float sensorRadius, vec3 pointEC)\n" +
"{\n" +
"sensorErode(sensorRadius, pointEC);\n" +
"vec3 pointMC = (agi_inverseModelView * vec4(pointEC, 1.0)).xyz;\n" +
"float zDistance = pointMC.z;\n" +
"vec2 st = sensor2dTextureCoordinates(sensorRadius, pointMC);\n" +
"vec3 str = pointMC / sensorRadius;\n" +
"return agi_getCapMaterialColor(zDistance, st, str);\n" +
"}\n" +
"vec4 getSilhouetteColor(float sensorRadius, vec3 pointEC)\n" +
"{\n" +
"sensorErode(sensorRadius, pointEC);\n" +
"vec3 pointMC = (agi_inverseModelView * vec4(pointEC, 1.0)).xyz;\n" +
"float zDistance = pointMC.z;\n" +
"vec2 st = sensor2dTextureCoordinates(sensorRadius, pointMC);\n" +
"vec3 str = pointMC / sensorRadius;\n" +
"return agi_getSilhouetteMaterialColor(zDistance, st, str);\n" +
"}\n" +
"#endif\n" +
"bool agi_isOnOrNear(float d, agi_raySegment interval, float epsilon)\n" +
"{\n" +
"bool answer = (agi_equalsEpsilon(d, interval.start, epsilon) || agi_equalsEpsilon(d, interval.stop, epsilon));\n" +
"return answer;\n" +
"}\n" +
"bool agi_isOnOrNear(float d, agi_raySegmentCollection coneIntervals, float epsilon)\n" +
"{\n" +
"bool answer = (coneIntervals.count > 0 && (agi_isOnOrNear(d, coneIntervals.intervals[0], epsilon)))\n" +
"|| (coneIntervals.count > 1 && (agi_isOnOrNear(d, coneIntervals.intervals[1], epsilon)));\n" +
"return answer;\n" +
"}\n" +
"bool agi_isOnOrNearSensor(float d, agi_raySegmentCollection outerIntervals, agi_raySegmentCollection innerIntervals, float epsilon)\n" +
"{\n" +
"bool answer = agi_isOnOrNear(d, outerIntervals, epsilon) || agi_isOnOrNear(d, innerIntervals, epsilon);\n" +
"return answer;\n" +
"}\n" +
"bool ellipsoidSensorIntersection(agi_raySegment sphereInterval,\n" +
"agi_raySegmentCollection outerIntervals, agi_raySegmentCollection innerIntervals,\n" +
"agi_raySegmentCollection clockIntervals,\n" +
"agi_raySegment ellipsoidInterval, agi_raySegment silhouetteHalfspaceInterval, agi_raySegmentCollection solid)\n" +
"{\n" +
"if (agi_isEmpty(ellipsoidInterval))\n" +
"{\n" +
"return false;\n" +
"}\n" +
"float t = ellipsoidInterval.start;\n" +
"#ifdef GL_OES_standard_derivatives\n" +
"float epsilon = max(abs(dFdx(t)), abs(dFdy(t)));\n" +
"#else\n" +
"float epsilon = t / 500.0;\n" +
"#endif\n" +
"float width = 2.0;\n" +
"epsilon *= width;\n" +
"if (solid.count > 0)\n" +
"{\n" +
"float d = solid.intervals[0].start;\n" +
"if (d == ellipsoidInterval.start\n" +
"&& (agi_isOnOrNear(d, silhouetteHalfspaceInterval, epsilon)\n" +
"|| agi_isOnOrNear(d, sphereInterval, epsilon)\n" +
"|| agi_isOnOrNear(d, clockIntervals, epsilon)\n" +
"|| agi_isOnOrNearSensor(d, outerIntervals, innerIntervals, epsilon))) return true;\n" +
"d = solid.intervals[0].stop;\n" +
"if (d == ellipsoidInterval.start\n" +
"&& (agi_isOnOrNear(d, silhouetteHalfspaceInterval, epsilon)\n" +
"|| agi_isOnOrNear(d, sphereInterval, epsilon)\n" +
"|| agi_isOnOrNear(d, clockIntervals, epsilon)\n" +
"|| agi_isOnOrNearSensor(d, outerIntervals, innerIntervals, epsilon))) return true;\n" +
"if (solid.count > 1)\n" +
"{\n" +
"d = solid.intervals[1].start;\n" +
"if (d == ellipsoidInterval.start\n" +
"&& (agi_isOnOrNear(d, silhouetteHalfspaceInterval, epsilon)\n" +
"|| agi_isOnOrNear(d, sphereInterval, epsilon)\n" +
"|| agi_isOnOrNear(d, clockIntervals, epsilon)\n" +
"|| agi_isOnOrNearSensor(d, outerIntervals, innerIntervals, epsilon))) return true;\n" +
"d = solid.intervals[1].stop;\n" +
"if (d == ellipsoidInterval.start\n" +
"&& (agi_isOnOrNear(d, silhouetteHalfspaceInterval, epsilon)\n" +
"|| agi_isOnOrNear(d, sphereInterval, epsilon)\n" +
"|| agi_isOnOrNear(d, clockIntervals, epsilon)\n" +
"|| agi_isOnOrNearSensor(d, outerIntervals, innerIntervals, epsilon))) return true;\n" +
"}\n" +
"return false;\n" +
"}\n" +
"else\n" +
"{\n" +
"false;\n" +
"}\n" +
"}\n" +
"vec4 shade(\n" +
"agi_ray ray,\n" +
"float nearestRayTime,\n" +
"agi_sphere sphere,\n" +
"agi_cone outerCone,\n" +
"agi_cone innerCone,\n" +
"agi_halfspace maxClock,\n" +
"agi_halfspace minClock,\n" +
"agi_ellipsoidSilhouetteCone silhouetteCone,\n" +
"agi_ellipsoidSilhouetteHalfspace silhouetteHalfspace,\n" +
"agi_raySegment sphereInterval,\n" +
"agi_raySegmentCollection outerConeInterval,\n" +
"agi_raySegmentCollection innerConeInterval,\n" +
"agi_raySegment maxClockInterval,\n" +
"agi_raySegment minClockInterval,\n" +
"agi_raySegmentCollection clockIntervals,\n" +
"agi_raySegment silhouetteConeInterval,\n" +
"agi_raySegment silhouetteHalfspaceInterval,\n" +
"agi_raySegment ellipsoidInterval,\n" +
"agi_raySegmentCollection intervals)\n" +
"{\n" +
"#ifdef RENDER_FOR_PICK\n" +
"return u_pickColor;\n" +
"#else\n" +
"vec3 nearestPoint = agi_pointAlongRay(ray, nearestRayTime);\n" +
"if (u_showIntersection && ellipsoidSensorIntersection(sphereInterval,\n" +
"outerConeInterval, innerConeInterval, clockIntervals,\n" +
"ellipsoidInterval, silhouetteHalfspaceInterval, intervals))\n" +
"{\n" +
"return getIntersectionColor(u_sensorRadius, nearestPoint);\n" +
"}\n" +
"vec3 positionToEyeEC = -ray.direction;\n" +
"vec3 agi_sunDirectionEC = agi_sunDirectionEC;\n" +
"for (int i = 0; i < agi_raySegmentCollectionCapacity; ++i)\n" +
"{\n" +
"if (i < outerConeInterval.count &&\n" +
"((nearestRayTime == outerConeInterval.intervals[i].start) ||\n" +
"(nearestRayTime == outerConeInterval.intervals[i].stop)))\n" +
"{\n" +
"vec4 color = getOuterColor(u_sensorRadius, nearestPoint);\n" +
"vec3 normal = agi_coneNormal(outerCone, nearestPoint);\n" +
"normal = mix(normal, -normal, step(normal.z, 0.0));\n" +
"float intensity = agi_twoSidedLightIntensity(normal, agi_sunDirectionEC, positionToEyeEC);\n" +
"return vec4(color.rgb * intensity, color.a);\n" +
"}\n" +
"}\n" +
"for (int i = 0; i < agi_raySegmentCollectionCapacity; ++i)\n" +
"{\n" +
"if (i < innerConeInterval.count &&\n" +
"((nearestRayTime == innerConeInterval.intervals[i].start) ||\n" +
"(nearestRayTime == innerConeInterval.intervals[i].stop)))\n" +
"{\n" +
"vec4 color = getInnerColor(u_sensorRadius, nearestPoint);\n" +
"vec3 normal = -agi_coneNormal(innerCone, nearestPoint);\n" +
"normal = mix(normal, -normal, step(normal.z, 0.0));\n" +
"float intensity = agi_twoSidedLightIntensity(normal, agi_sunDirectionEC, positionToEyeEC);\n" +
"return vec4(color.rgb * intensity, color.a);\n" +
"}\n" +
"}\n" +
"if ((nearestRayTime == sphereInterval.start) ||\n" +
"(nearestRayTime == sphereInterval.stop))\n" +
"{\n" +
"vec4 color = getCapColor(u_sensorRadius, nearestPoint);\n" +
"vec3 normal = agi_sphereNormal(sphere, nearestPoint);\n" +
"normal = mix(normal, -normal, step(normal.z, 0.0));\n" +
"float intensity = agi_twoSidedLightIntensity(normal, agi_sunDirectionEC, positionToEyeEC);\n" +
"return vec4(color.rgb * intensity, color.a);\n" +
"}\n" +
"if ((nearestRayTime == maxClockInterval.start) ||\n" +
"(nearestRayTime == maxClockInterval.stop))\n" +
"{\n" +
"vec4 color = getOuterColor(u_sensorRadius, nearestPoint);\n" +
"vec3 normal = maxClock.normal;\n" +
"normal = mix(normal, -normal, step(normal.z, 0.0));\n" +
"float intensity = agi_lightIntensity(normal, agi_sunDirectionEC, positionToEyeEC);\n" +
"return vec4(color.rgb * intensity, color.a);\n" +
"}\n" +
"if ((nearestRayTime == minClockInterval.start) ||\n" +
"(nearestRayTime == minClockInterval.stop))\n" +
"{\n" +
"vec4 color = getOuterColor(u_sensorRadius, nearestPoint);\n" +
"vec3 normal = minClock.normal;\n" +
"normal = mix(normal, -normal, step(normal.z, 0.0));\n" +
"float intensity = agi_lightIntensity(normal, agi_sunDirectionEC, positionToEyeEC);\n" +
"return vec4(color.rgb * intensity, color.a);\n" +
"}\n" +
"if ((nearestRayTime == silhouetteConeInterval.start) ||\n" +
"(nearestRayTime == silhouetteConeInterval.stop))\n" +
"{\n" +
"vec4 color = getSilhouetteColor(u_sensorRadius, nearestPoint);\n" +
"vec3 normal = agi_ellipsoidSilhouetteConeNormal(silhouetteCone, nearestPoint);\n" +
"normal = mix(normal, -normal, step(normal.z, 0.0));\n" +
"float intensity = agi_twoSidedLightIntensity(normal, agi_sunDirectionEC, positionToEyeEC);\n" +
"return vec4(color.rgb * intensity, color.a);\n" +
"}\n" +
"return vec4(1.0, 0.0, 0.0, 1.0);\n" +
"#endif\n" +
"}\n" +
"vec4 shade(\n" +
"agi_ray ray,\n" +
"float nearestRayTime,\n" +
"agi_sphere sphere,\n" +
"agi_cone outerCone,\n" +
"agi_cone innerCone,\n" +
"agi_halfspace maxClock,\n" +
"agi_halfspace minClock,\n" +
"agi_raySegment sphereInterval,\n" +
"agi_raySegmentCollection outerConeInterval,\n" +
"agi_raySegmentCollection innerConeInterval,\n" +
"agi_raySegment maxClockInterval,\n" +
"agi_raySegment minClockInterval,\n" +
"agi_raySegmentCollection intervals)\n" +
"{\n" +
"#ifdef RENDER_FOR_PICK\n" +
"return u_pickColor;\n" +
"#else\n" +
"vec3 nearestPoint = agi_pointAlongRay(ray, nearestRayTime);\n" +
"vec3 positionToEyeEC = -ray.direction;\n" +
"for (int i = 0; i < agi_raySegmentCollectionCapacity; ++i)\n" +
"{\n" +
"if (i < outerConeInterval.count &&\n" +
"((nearestRayTime == outerConeInterval.intervals[i].start) ||\n" +
"(nearestRayTime == outerConeInterval.intervals[i].stop)))\n" +
"{\n" +
"vec4 color = getOuterColor(u_sensorRadius, nearestPoint);\n" +
"vec3 normal = agi_coneNormal(outerCone, nearestPoint);\n" +
"normal = mix(normal, -normal, step(normal.z, 0.0));\n" +
"float intensity = agi_twoSidedLightIntensity(normal, agi_sunDirectionEC, positionToEyeEC);\n" +
"return vec4(color.rgb * intensity, color.a);\n" +
"}\n" +
"}\n" +
"for (int i = 0; i < agi_raySegmentCollectionCapacity; ++i)\n" +
"{\n" +
"if (i < innerConeInterval.count &&\n" +
"((nearestRayTime == innerConeInterval.intervals[i].start) ||\n" +
"(nearestRayTime == innerConeInterval.intervals[i].stop)))\n" +
"{\n" +
"vec4 color = getInnerColor(u_sensorRadius, nearestPoint);\n" +
"vec3 normal = -agi_coneNormal(innerCone, nearestPoint);\n" +
"normal = mix(normal, -normal, step(normal.z, 0.0));\n" +
"float intensity = agi_twoSidedLightIntensity(normal, agi_sunDirectionEC, positionToEyeEC);\n" +
"return vec4(color.rgb * intensity, color.a);\n" +
"}\n" +
"}\n" +
"if ((nearestRayTime == sphereInterval.start) ||\n" +
"(nearestRayTime == sphereInterval.stop))\n" +
"{\n" +
"vec4 color = getCapColor(u_sensorRadius, nearestPoint);\n" +
"vec3 normal = agi_sphereNormal(sphere, nearestPoint);\n" +
"normal = mix(normal, -normal, step(normal.z, 0.0));\n" +
"float intensity = agi_twoSidedLightIntensity(normal, agi_sunDirectionEC, positionToEyeEC);\n" +
"return vec4(color.rgb * intensity, color.a);\n" +
"}\n" +
"if ((nearestRayTime == maxClockInterval.start) ||\n" +
"(nearestRayTime == maxClockInterval.stop))\n" +
"{\n" +
"vec4 color = getOuterColor(u_sensorRadius, nearestPoint);\n" +
"vec3 normal = maxClock.normal;\n" +
"normal = mix(normal, -normal, step(normal.z, 0.0));\n" +
"float intensity = agi_lightIntensity(normal, agi_sunDirectionEC, positionToEyeEC);\n" +
"return vec4(color.rgb * intensity, color.a);\n" +
"}\n" +
"if ((nearestRayTime == minClockInterval.start) ||\n" +
"(nearestRayTime == minClockInterval.stop))\n" +
"{\n" +
"vec4 color = getOuterColor(u_sensorRadius, nearestPoint);\n" +
"vec3 normal = minClock.normal;\n" +
"normal = mix(normal, -normal, step(normal.z, 0.0));\n" +
"float intensity = agi_lightIntensity(normal, agi_sunDirectionEC, positionToEyeEC);\n" +
"return vec4(color.rgb * intensity, color.a);\n" +
"}\n" +
"return vec4(1.0, 0.0, 0.0, 1.0);\n" +
"#endif\n" +
"}\n" +
"void main()\n" +
"{\n" +
"agi_ray ray = agi_ray(vec3(0.0), normalize(v_positionEC));\n" +
"agi_sphere sphere = agi_sphere(v_sensorVertexEC, u_sensorRadius);\n" +
"agi_raySegment sphereInterval = agi_raySphereIntersectionInterval(ray, sphere);\n" +
"if (agi_isEmpty(sphereInterval))\n" +
"{\n" +
"discard;\n" +
"}\n" +
"vec3 coneAxisEC = normalize(v_sensorAxisEC);\n" +
"agi_cone outerCone = agi_coneNew(v_sensorVertexEC, coneAxisEC, u_outerHalfAngle);\n" +
"agi_raySegmentCollection outerConeInterval = agi_rayConeIntersectionInterval(ray, outerCone);\n" +
"if (outerConeInterval.count == 0)\n" +
"{\n" +
"discard;\n" +
"}\n" +
"agi_cone innerCone = agi_coneNew(v_sensorVertexEC, coneAxisEC, u_innerHalfAngle);\n" +
"agi_raySegmentCollection innerConeInterval = agi_rayConeIntersectionInterval(ray, innerCone);\n" +
"agi_raySegmentCollection difference = (innerConeInterval.count == 0) ? outerConeInterval : agi_subtraction(outerConeInterval, innerConeInterval);\n" +
"if (difference.count == 0)\n" +
"{\n" +
"discard;\n" +
"}\n" +
"agi_raySegmentCollection capped = agi_intersection(difference, sphereInterval);\n" +
"if (capped.count == 0)\n" +
"{\n" +
"discard;\n" +
"}\n" +
"vec3 maxNormal = normalize((agi_modelView * vec4(-sin(u_maximumClockAngle), cos(u_maximumClockAngle), 0.0, 0.0)).xyz);\n" +
"agi_halfspace maxClock = agi_halfspace(v_sensorVertexEC, maxNormal);\n" +
"agi_raySegment maxClockInterval = agi_rayHalfspaceIntersectionInterval(ray, maxClock);\n" +
"vec3 minNormal = normalize((agi_modelView * vec4(sin(u_minimumClockAngle), -cos(u_minimumClockAngle), 0.0, 0.0)).xyz);\n" +
"agi_halfspace minClock = agi_halfspace(v_sensorVertexEC, minNormal);\n" +
"agi_raySegment minClockInterval = agi_rayHalfspaceIntersectionInterval(ray, minClock);\n" +
"agi_raySegmentCollection clockIntervals = ((u_maximumClockAngle - u_minimumClockAngle) > agi_pi)\n" +
"? (agi_isEmpty(maxClockInterval)\n" +
"? (agi_isEmpty(minClockInterval) ? agi_raySegmentCollectionNew() : agi_raySegmentCollectionNew(minClockInterval))\n" +
": (agi_isEmpty(minClockInterval) ? agi_raySegmentCollectionNew(maxClockInterval) : agi_union(maxClockInterval, minClockInterval)))\n" +
": ((agi_isEmpty(maxClockInterval) || agi_isEmpty(minClockInterval)) ? agi_raySegmentCollectionNew() : agi_raySegmentCollectionNew(agi_intersection(maxClockInterval, minClockInterval)));\n" +
"agi_raySegmentCollection sensor = (clockIntervals.count == 0) ? agi_raySegmentCollectionNew() : agi_intersection(capped, clockIntervals);\n" +
"if (sensor.count == 0)\n" +
"{\n" +
"discard;\n" +
"}\n" +
"agi_ellipsoid ellipsoid = agi_getWgs84EllipsoidEC();\n" +
"agi_ellipsoidSilhouetteCone silhouetteCone = agi_ellipsoidSilhouetteConeNew(ellipsoid, v_sensorVertexEC);\n" +
"agi_raySegment silhouetteConeInterval = agi_rayEllipsoidSilhouetteConeIntersectionInterval(ray, silhouetteCone);\n" +
"if (agi_isEmpty(silhouetteConeInterval))\n" +
"{\n" +
"gl_FragColor = shade(ray, sensor.intervals[0].start,\n" +
"sphere, outerCone, innerCone, maxClock, minClock,\n" +
"sphereInterval, outerConeInterval, innerConeInterval, maxClockInterval, minClockInterval,\n" +
"sensor);\n" +
"}\n" +
"else\n" +
"{\n" +
"agi_ellipsoidSilhouetteHalfspace silhouetteHalfspace = agi_ellipsoidSilhouetteHalfspaceNew(ellipsoid, v_sensorVertexEC);\n" +
"agi_raySegment silhouetteHalfspaceInterval = agi_rayEllipsoidSilhouetteHalfspaceIntersectionInterval(ray, silhouetteHalfspace);\n" +
"agi_raySegment temp = (agi_isEmpty(silhouetteHalfspaceInterval)) ? agi_emptyRaySegment : agi_intersection(silhouetteConeInterval, silhouetteHalfspaceInterval);\n" +
"agi_raySegmentCollection stuff = (agi_isEmpty(temp)) ? sensor : agi_subtraction(sensor, temp);\n" +
"if (stuff.count == 0)\n" +
"{\n" +
"discard;\n" +
"}\n" +
"agi_raySegment ellipsoidInterval = agi_rayEllipsoidIntersectionInterval(ray, ellipsoid);\n" +
"agi_raySegmentCollection result = (agi_isEmpty(ellipsoidInterval)) ? stuff : agi_subtraction(stuff, ellipsoidInterval);\n" +
"if ((result.count == 0)\n" +
"|| (!agi_isEmpty(ellipsoidInterval) && (result.intervals[0].start > ellipsoidInterval.start)))\n" +
"{\n" +
"discard;\n" +
"}\n" +
"gl_FragColor = shade(ray, result.intervals[0].start,\n" +
"sphere, outerCone, innerCone, maxClock, minClock,\n" +
"silhouetteCone, silhouetteHalfspace,\n" +
"sphereInterval, outerConeInterval, innerConeInterval, maxClockInterval, minClockInterval, clockIntervals,\n" +
"silhouetteConeInterval, silhouetteHalfspaceInterval, ellipsoidInterval,\n" +
"result);\n" +
"}\n" +
"}\n" +
"";
});

/*global define*/
define('Shaders/ComplexConicSensorVolumeVS',[],function() {
  
  return "attribute vec4 position;\n" +
"varying vec3 v_positionEC;\n" +
"varying vec3 v_sensorVertexWC;\n" +
"varying vec3 v_sensorVertexEC;\n" +
"varying vec3 v_sensorAxisEC;\n" +
"void main()\n" +
"{\n" +
"gl_Position = agi_modelViewInfiniteProjection * position;\n" +
"v_positionEC = (agi_modelView * position).xyz;\n" +
"vec4 sensorVertexMC = vec4(0.0, 0.0, 0.0, 1.0);\n" +
"v_sensorVertexWC = (agi_model * sensorVertexMC).xyz;\n" +
"v_sensorVertexEC = (agi_modelView * sensorVertexMC).xyz;\n" +
"v_sensorAxisEC = agi_normal * vec3(0.0, 0.0, 1.0);\n" +
"}\n" +
"";
});

/*global define*/
define('Shaders/ConstructiveSolidGeometry',[],function() {
  
  return "float _agi_addWithCancellationCheck(float left, float right, float tolerance)\n" +
"{\n" +
"float difference = left + right;\n" +
"if ((sign(left) != sign(right)) && abs(difference / max(abs(left), abs(right))) < tolerance)\n" +
"{\n" +
"return 0.0;\n" +
"}\n" +
"else\n" +
"{\n" +
"return difference;\n" +
"}\n" +
"}\n" +
"struct agi_quadraticRoots\n" +
"{\n" +
"int numberOfRoots;\n" +
"float root0;\n" +
"float root1;\n" +
"};\n" +
"agi_quadraticRoots agi_quadraticRealPolynomialRealRoots(float a, float b, float c)\n" +
"{\n" +
"const float tolerance = agi_epsilon7;\n" +
"if (a == 0.0)\n" +
"{\n" +
"if (b == 0.0)\n" +
"{\n" +
"agi_quadraticRoots r = agi_quadraticRoots(0, 0.0, 0.0);\n" +
"return r;\n" +
"}\n" +
"else\n" +
"{\n" +
"agi_quadraticRoots r = agi_quadraticRoots(1, -c / b, 0.0);\n" +
"return r;\n" +
"}\n" +
"}\n" +
"else if (b == 0.0)\n" +
"{\n" +
"if (c == 0.0)\n" +
"{\n" +
"agi_quadraticRoots r = agi_quadraticRoots(2, 0.0, 0.0);\n" +
"return r;\n" +
"}\n" +
"else\n" +
"{\n" +
"float cMagnitude = abs(c);\n" +
"float aMagnitude = abs(a);\n" +
"if ((cMagnitude < aMagnitude) && (cMagnitude / aMagnitude < tolerance))\n" +
"{\n" +
"agi_quadraticRoots r = agi_quadraticRoots(2, 0.0, 0.0);\n" +
"return r;\n" +
"}\n" +
"else if ((cMagnitude > aMagnitude) && (aMagnitude / cMagnitude < tolerance))\n" +
"{\n" +
"agi_quadraticRoots r = agi_quadraticRoots(0, 0.0, 0.0);\n" +
"return r;\n" +
"}\n" +
"else\n" +
"{\n" +
"float ratio = -c / a;\n" +
"if (ratio < 0.0)\n" +
"{\n" +
"agi_quadraticRoots r = agi_quadraticRoots(0, 0.0, 0.0);\n" +
"return r;\n" +
"}\n" +
"else\n" +
"{\n" +
"float root = sqrt(ratio);\n" +
"agi_quadraticRoots r = agi_quadraticRoots(2, -root, root);\n" +
"return r;\n" +
"}\n" +
"}\n" +
"}\n" +
"}\n" +
"else if (c == 0.0)\n" +
"{\n" +
"float ratio = -b / a;\n" +
"if (ratio < 0.0)\n" +
"{\n" +
"agi_quadraticRoots r = agi_quadraticRoots(2, ratio, 0.0);\n" +
"return r;\n" +
"}\n" +
"else\n" +
"{\n" +
"agi_quadraticRoots r = agi_quadraticRoots(2, 0.0, ratio);\n" +
"return r;\n" +
"}\n" +
"}\n" +
"else\n" +
"{\n" +
"float b2 = b * b;\n" +
"float four_ac = 4.0 * a * c;\n" +
"float radicand = _agi_addWithCancellationCheck(b2, -four_ac, tolerance);\n" +
"if (radicand < 0.0)\n" +
"{\n" +
"agi_quadraticRoots r = agi_quadraticRoots(0, 0.0, 0.0);\n" +
"return r;\n" +
"}\n" +
"else\n" +
"{\n" +
"float q = -0.5 * _agi_addWithCancellationCheck(b, sign(b) * sqrt(radicand), tolerance);\n" +
"if (b > 0.0)\n" +
"{\n" +
"agi_quadraticRoots r = agi_quadraticRoots(2, q / a, c / q);\n" +
"return r;\n" +
"}\n" +
"else\n" +
"{\n" +
"agi_quadraticRoots r = agi_quadraticRoots(2, c / q, q / a);\n" +
"return r;\n" +
"}\n" +
"}\n" +
"}\n" +
"}\n" +
"struct agi_sphere\n" +
"{\n" +
"vec3 center;\n" +
"float radius;\n" +
"};\n" +
"agi_raySegment agi_raySphereIntersectionInterval(agi_ray ray, agi_sphere sphere)\n" +
"{\n" +
"vec3 l = sphere.center - ray.origin;\n" +
"float s = dot(l, ray.direction);\n" +
"float l2 = dot(l, l);\n" +
"float r2 = sphere.radius * sphere.radius;\n" +
"if ((s < 0.0)\n" +
"&& (l2 > r2))\n" +
"{\n" +
"return agi_emptyRaySegment;\n" +
"}\n" +
"float s2 = s * s;\n" +
"float m2 = l2 - s2;\n" +
"if (m2 > r2)\n" +
"{\n" +
"return agi_emptyRaySegment;\n" +
"}\n" +
"float q = sqrt(r2 - m2);\n" +
"if (agi_equalsEpsilon(q, 0.0))\n" +
"{\n" +
"return agi_raySegment(s, s);\n" +
"}\n" +
"if (l2 > r2)\n" +
"{\n" +
"agi_raySegment i = agi_raySegment(s - q, s + q);\n" +
"return i;\n" +
"}\n" +
"else if (l2 < r2)\n" +
"{\n" +
"agi_raySegment i = agi_raySegment(0.0, s + q);\n" +
"return i;\n" +
"}\n" +
"else if (s > 0.0)\n" +
"{\n" +
"agi_raySegment i = agi_raySegment(0.0, s + q);\n" +
"return i;\n" +
"}\n" +
"else\n" +
"{\n" +
"return agi_emptyRaySegment;\n" +
"}\n" +
"}\n" +
"vec3 agi_sphereNormal(agi_sphere sphere, vec3 pointOnSphere)\n" +
"{\n" +
"return normalize(pointOnSphere - sphere.center);\n" +
"}\n" +
"struct agi_cone\n" +
"{\n" +
"vec3 vertex;\n" +
"vec3 axis;\n" +
"float halfAperture;\n" +
"float cosineOfHalfAperture;\n" +
"float cosineSquaredOfHalfAperture;\n" +
"float sineOfHalfAperture;\n" +
"float sineSquaredOfHalfAperture;\n" +
"mat3 intersectionMatrix;\n" +
"};\n" +
"agi_cone agi_coneNew(vec3 vertex, vec3 axis, float halfAperture)\n" +
"{\n" +
"float cosineOfHalfAperture = cos(halfAperture);\n" +
"float cosineSquaredOfHalfAperture = cosineOfHalfAperture * cosineOfHalfAperture;\n" +
"float sineOfHalfAperture = sin(halfAperture);\n" +
"float sineSquaredOfHalfAperture = sineOfHalfAperture * sineOfHalfAperture;\n" +
"float x2 = axis.x * axis.x;\n" +
"float y2 = axis.y * axis.y;\n" +
"float z2 = axis.z * axis.z;\n" +
"float xy = axis.x * axis.y;\n" +
"float yz = axis.y * axis.z;\n" +
"float zx = axis.z * axis.x;\n" +
"mat3 intersectionMatrix = mat3(\n" +
"cosineSquaredOfHalfAperture - x2, -xy,                              -zx,\n" +
"-xy,                              cosineSquaredOfHalfAperture - y2, -yz,\n" +
"-zx,                              -yz,                              cosineSquaredOfHalfAperture - z2);\n" +
"agi_cone temp = agi_cone(vertex, axis, halfAperture,\n" +
"cosineOfHalfAperture, cosineSquaredOfHalfAperture,\n" +
"sineOfHalfAperture, sineSquaredOfHalfAperture, intersectionMatrix);\n" +
"return temp;\n" +
"}\n" +
"bool agi_coneContainsPoint(agi_cone cone, vec3 point)\n" +
"{\n" +
"vec3 n = normalize(point - cone.vertex);\n" +
"return (dot(n, cone.axis) >= cone.cosineOfHalfAperture);\n" +
"}\n" +
"bool _agi_rayIntersectsReflectedCone(agi_ray ray, agi_cone cone, float time, float cosine)\n" +
"{\n" +
"vec3 s = ray.origin + (time * ray.direction) - cone.vertex;\n" +
"vec3 sUnit = normalize(s);\n" +
"float c = dot(sUnit, cone.axis);\n" +
"return (sign(c) != sign(cosine));\n" +
"}\n" +
"agi_raySegmentCollection agi_rayConeIntersectionInterval(agi_ray ray, agi_cone cone)\n" +
"{\n" +
"vec3 temp = ray.origin - cone.vertex;\n" +
"float t2 = dot(temp, temp);\n" +
"float cosineNu = dot(ray.direction, cone.axis);\n" +
"if (t2 == 0.0)\n" +
"{\n" +
"if (cosineNu >= cone.cosineOfHalfAperture)\n" +
"{\n" +
"return agi_raySegmentCollectionNew(agi_fullRaySegment);\n" +
"}\n" +
"else\n" +
"{\n" +
"return agi_raySegmentCollectionNew();\n" +
"}\n" +
"}\n" +
"else\n" +
"{\n" +
"float projection = dot(normalize(temp), cone.axis);\n" +
"if (projection == cone.cosineOfHalfAperture)\n" +
"{\n" +
"vec3 u = ray.direction;\n" +
"mat3 crossProductMatrix = mat3(0.0, -u.z, u.y,\n" +
"u.z, 0.0, -u.x,\n" +
"-u.y, u.x, 0.0);\n" +
"if (length(crossProductMatrix * temp) == 0.0)\n" +
"{\n" +
"if (dot(temp, u) > 0.0)\n" +
"{\n" +
"return agi_raySegmentCollectionNew(agi_fullRaySegment);\n" +
"}\n" +
"else\n" +
"{\n" +
"agi_raySegment i = agi_raySegment(0.0, length(temp));\n" +
"return agi_raySegmentCollectionNew(i);\n" +
"}\n" +
"}\n" +
"else\n" +
"{\n" +
"return agi_raySegmentCollectionNew();\n" +
"}\n" +
"}\n" +
"else\n" +
"{\n" +
"vec3 t = normalize(temp);\n" +
"float cosineAlpha2 = cone.cosineOfHalfAperture * cone.cosineOfHalfAperture;\n" +
"float cosineTau = dot(t, cone.axis);\n" +
"float cosineDelta = dot(t, ray.direction);\n" +
"float cosineNu2 = cosineNu * cosineNu;\n" +
"float cosineTau2 = cosineTau * cosineTau;\n" +
"float stuff = cosineTau * cosineNu;\n" +
"float positiveTerm = cosineNu2 + cosineTau2;\n" +
"float negativeTerm = (cosineDelta * cosineDelta - 1.0) * cosineAlpha2;\n" +
"float signedTerm = -2.0 * stuff * cosineDelta;\n" +
"if (signedTerm > 0.0)\n" +
"{\n" +
"positiveTerm = positiveTerm + signedTerm;\n" +
"}\n" +
"else if (signedTerm < 0.0)\n" +
"{\n" +
"negativeTerm = negativeTerm + signedTerm;\n" +
"}\n" +
"float d = 4.0 * cosineAlpha2 * (positiveTerm + negativeTerm);\n" +
"if (d < 0.0)\n" +
"{\n" +
"if (cone.cosineOfHalfAperture < 0.0)\n" +
"{\n" +
"return agi_raySegmentCollectionNew(agi_fullRaySegment);\n" +
"}\n" +
"else\n" +
"{\n" +
"return agi_raySegmentCollectionNew();\n" +
"}\n" +
"}\n" +
"else if (d > 0.0)\n" +
"{\n" +
"float a = cosineNu2 - cosineAlpha2;\n" +
"float c = cosineTau2 - cosineAlpha2;\n" +
"float b = 2.0 * (stuff - cosineDelta * cosineAlpha2);\n" +
"float s = (b == 0.0) ? 1.0 : sign(b);\n" +
"float q = -(b + s * sqrt(d)) / 2.0;\n" +
"float first = q / a;\n" +
"float second = c / q;\n" +
"if (second < first)\n" +
"{\n" +
"float thing = first;\n" +
"first = second;\n" +
"second = thing;\n" +
"}\n" +
"bool firstTest = (first >= 0.0) && !(sign(dot(t + first * ray.direction, cone.axis)) == -sign(cone.cosineOfHalfAperture));\n" +
"bool secondTest = (second >= 0.0) && !(sign(dot(t + second * ray.direction, cone.axis)) == -sign(cone.cosineOfHalfAperture));\n" +
"float m = sqrt(t2);\n" +
"if (cosineTau > cone.cosineOfHalfAperture)\n" +
"{\n" +
"if (firstTest && secondTest)\n" +
"{\n" +
"agi_raySegment one = agi_raySegment(0.0, m * first);\n" +
"agi_raySegment two = agi_raySegment(m * second, agi_infinity);\n" +
"return agi_raySegmentCollectionNew(one, two);\n" +
"}\n" +
"else if (firstTest)\n" +
"{\n" +
"agi_raySegment i = agi_raySegment(0.0, m * first);\n" +
"return agi_raySegmentCollectionNew(i);\n" +
"}\n" +
"else if (secondTest)\n" +
"{\n" +
"agi_raySegment i = agi_raySegment(0.0, m * second);\n" +
"return agi_raySegmentCollectionNew(i);\n" +
"}\n" +
"else\n" +
"{\n" +
"return agi_raySegmentCollectionNew(agi_fullRaySegment);\n" +
"}\n" +
"}\n" +
"else\n" +
"{\n" +
"if (firstTest && secondTest)\n" +
"{\n" +
"agi_raySegment i = agi_raySegment(m * first, m * second);\n" +
"return agi_raySegmentCollectionNew(i);\n" +
"}\n" +
"else if (firstTest)\n" +
"{\n" +
"agi_raySegment i = agi_raySegment(m * first, agi_infinity);\n" +
"return agi_raySegmentCollectionNew(i);\n" +
"}\n" +
"else if (secondTest)\n" +
"{\n" +
"agi_raySegment i = agi_raySegment(m * second, agi_infinity);\n" +
"return agi_raySegmentCollectionNew(i);\n" +
"}\n" +
"else\n" +
"{\n" +
"return agi_raySegmentCollectionNew();\n" +
"}\n" +
"}\n" +
"}\n" +
"else\n" +
"{\n" +
"if (cone.cosineOfHalfAperture == 0.0)\n" +
"{\n" +
"if (cosineTau >= 0.0)\n" +
"{\n" +
"if (cosineNu >= 0.0)\n" +
"{\n" +
"return agi_raySegmentCollectionNew(agi_fullRaySegment);\n" +
"}\n" +
"else\n" +
"{\n" +
"agi_raySegment i = agi_raySegment(0.0, -sqrt(t2) * cosineTau / cosineNu);\n" +
"return agi_raySegmentCollectionNew(i);\n" +
"}\n" +
"}\n" +
"else\n" +
"{\n" +
"if (cosineNu <= 0.0)\n" +
"{\n" +
"return agi_raySegmentCollectionNew();\n" +
"}\n" +
"else\n" +
"{\n" +
"agi_raySegment i = agi_raySegment(-sqrt(t2) * cosineTau / cosineNu, agi_infinity);\n" +
"return agi_raySegmentCollectionNew(i);\n" +
"}\n" +
"}\n" +
"}\n" +
"else\n" +
"{\n" +
"float a = cosineNu2 - cosineAlpha2;\n" +
"float c = cosineTau2 - cosineAlpha2;\n" +
"float b = 2.0 * (stuff - cosineDelta * cosineAlpha2);\n" +
"float root = (a == 0.0) ? -sign(b) * agi_infinity : (-sign(b) / sign(a)) * sqrt(c / a);\n" +
"bool rootTest = (root >= 0.0) && !(sign(dot(t + root * ray.direction, cone.axis)) == -sign(cone.cosineOfHalfAperture));\n" +
"float m = sqrt(t2);\n" +
"if (cosineTau > cone.cosineOfHalfAperture)\n" +
"{\n" +
"if (rootTest)\n" +
"{\n" +
"agi_raySegment i = agi_raySegment(0.0, m * root);\n" +
"return agi_raySegmentCollectionNew(i);\n" +
"}\n" +
"else\n" +
"{\n" +
"return agi_raySegmentCollectionNew(agi_fullRaySegment);\n" +
"}\n" +
"}\n" +
"else\n" +
"{\n" +
"if (rootTest)\n" +
"{\n" +
"if (c < 0.0)\n" +
"{\n" +
"float thing = m * root;\n" +
"agi_raySegment i = agi_raySegment(thing, thing);\n" +
"return agi_raySegmentCollectionNew(i);\n" +
"}\n" +
"else\n" +
"{\n" +
"float thing = m * root;\n" +
"agi_raySegment i = agi_raySegment(thing, agi_infinity);\n" +
"return agi_raySegmentCollectionNew(i);\n" +
"}\n" +
"}\n" +
"else\n" +
"{\n" +
"return agi_raySegmentCollectionNew();\n" +
"}\n" +
"}\n" +
"}\n" +
"}\n" +
"}\n" +
"}\n" +
"}\n" +
"vec3 agi_coneNormal(agi_cone cone, vec3 pointOnCone)\n" +
"{\n" +
"vec3 s = pointOnCone - cone.vertex;\n" +
"vec3 sUnit = normalize(s);\n" +
"return normalize((cone.cosineOfHalfAperture * sUnit - cone.axis) / cone.sineOfHalfAperture);\n" +
"}\n" +
"struct agi_ellipsoidSilhouetteCone\n" +
"{\n" +
"agi_ellipsoid ellipsoid;\n" +
"vec3 pointOutsideEllipsoid;\n" +
"agi_cone coneInScaledSpace;\n" +
"};\n" +
"vec3 agi_ellipsoidSilhouetteConeNormal(agi_ellipsoidSilhouetteCone cone, vec3 pointOnCone)\n" +
"{\n" +
"vec3 pointOnScaledCone = cone.ellipsoid.inverseRadii * (agi_inverseView * vec4(pointOnCone, 1.0)).xyz;\n" +
"vec3 scaledNormal = agi_coneNormal(cone.coneInScaledSpace, pointOnScaledCone);\n" +
"vec3 temp = -normalize((agi_view * vec4(cone.ellipsoid.radii * scaledNormal, 0.0)).xyz);\n" +
"return temp;\n" +
"}\n" +
"agi_ellipsoidSilhouetteCone agi_ellipsoidSilhouetteConeNew(agi_ellipsoid ellipsoid, vec3 pointOutsideEllipsoid)\n" +
"{\n" +
"vec3 q = ellipsoid.inverseRadii * (agi_inverseView * vec4(pointOutsideEllipsoid, 1.0)).xyz;\n" +
"vec3 axis = -normalize(q);\n" +
"float q2 = dot(q, q);\n" +
"float sineSquaredOfHalfAperture = 1.0 / q2;\n" +
"float sineOfHalfAperture = sqrt(sineSquaredOfHalfAperture);\n" +
"float cosineSquaredOfHalfAperture = 1.0 - sineSquaredOfHalfAperture;\n" +
"float cosineOfHalfAperture = sqrt(cosineSquaredOfHalfAperture);\n" +
"float halfAperture = atan(sineOfHalfAperture / cosineOfHalfAperture);\n" +
"float x2 = axis.x * axis.x;\n" +
"float y2 = axis.y * axis.y;\n" +
"float z2 = axis.z * axis.z;\n" +
"float xy = axis.x * axis.y;\n" +
"float yz = axis.y * axis.z;\n" +
"float zx = axis.z * axis.x;\n" +
"mat3 intersectionMatrix = mat3(\n" +
"cosineSquaredOfHalfAperture - x2, -xy,                              -zx,\n" +
"-xy,                              cosineSquaredOfHalfAperture - y2, -yz,\n" +
"-zx,                              -yz,                              cosineSquaredOfHalfAperture - z2);\n" +
"agi_cone coneInScaledSpace = agi_cone(q, axis, halfAperture,\n" +
"cosineOfHalfAperture, cosineSquaredOfHalfAperture,\n" +
"sineOfHalfAperture, sineSquaredOfHalfAperture, intersectionMatrix);\n" +
"agi_ellipsoidSilhouetteCone temp = agi_ellipsoidSilhouetteCone(ellipsoid, pointOutsideEllipsoid, coneInScaledSpace);\n" +
"return temp;\n" +
"}\n" +
"agi_raySegment agi_rayEllipsoidSilhouetteConeIntersectionInterval(agi_ray ray, agi_ellipsoidSilhouetteCone cone)\n" +
"{\n" +
"vec3 origin = cone.ellipsoid.inverseRadii * (agi_inverseView * vec4(ray.origin, 1.0)).xyz;\n" +
"vec3 direction = normalize(cone.ellipsoid.inverseRadii * (agi_inverseView * vec4(ray.direction, 0.0)).xyz);\n" +
"agi_ray rayInScaledSpace = agi_ray(origin, direction);\n" +
"agi_raySegmentCollection collection = agi_rayConeIntersectionInterval(rayInScaledSpace, cone.coneInScaledSpace);\n" +
"if (collection.count == 0)\n" +
"{\n" +
"return agi_emptyRaySegment;\n" +
"}\n" +
"else\n" +
"{\n" +
"agi_raySegment interval = collection.intervals[0];\n" +
"float start = interval.start;\n" +
"if (start != 0.0)\n" +
"{\n" +
"vec3 temp = (agi_view * vec4(cone.ellipsoid.radii * agi_pointAlongRay(rayInScaledSpace, start), 1.0)).xyz;\n" +
"start = dot(temp, ray.direction);\n" +
"}\n" +
"float stop = interval.stop;\n" +
"if (stop != agi_infinity)\n" +
"{\n" +
"vec3 temp = (agi_view * vec4(cone.ellipsoid.radii * agi_pointAlongRay(rayInScaledSpace, stop), 1.0)).xyz;\n" +
"stop = dot(temp, ray.direction);\n" +
"}\n" +
"return agi_raySegment(start, stop);\n" +
"}\n" +
"}\n" +
"struct agi_halfspace\n" +
"{\n" +
"vec3 center;\n" +
"vec3 normal;\n" +
"};\n" +
"agi_raySegment agi_rayHalfspaceIntersectionInterval(agi_ray ray, agi_halfspace halfspace)\n" +
"{\n" +
"float numerator = dot(halfspace.center - ray.origin, halfspace.normal);\n" +
"float denominator = dot(ray.direction, halfspace.normal);\n" +
"if (numerator > 0.0)\n" +
"{\n" +
"if (denominator > 0.0)\n" +
"{\n" +
"return agi_raySegment(0.0, numerator / denominator);\n" +
"}\n" +
"else\n" +
"{\n" +
"return agi_fullRaySegment;\n" +
"}\n" +
"}\n" +
"else if (numerator < 0.0)\n" +
"{\n" +
"if (denominator < 0.0 )\n" +
"{\n" +
"return agi_raySegment(numerator / denominator, agi_infinity);\n" +
"}\n" +
"else\n" +
"{\n" +
"return agi_emptyRaySegment;\n" +
"}\n" +
"}\n" +
"else\n" +
"{\n" +
"if (denominator < 0.0 )\n" +
"{\n" +
"return agi_fullRaySegment;\n" +
"}\n" +
"else\n" +
"{\n" +
"return agi_emptyRaySegment;\n" +
"}\n" +
"}\n" +
"}\n" +
"struct agi_ellipsoidSilhouetteHalfspace\n" +
"{\n" +
"agi_ellipsoid ellipsoid;\n" +
"vec3 pointOutsideEllipsoid;\n" +
"agi_halfspace halfspaceInScaledSpace;\n" +
"};\n" +
"agi_ellipsoidSilhouetteHalfspace agi_ellipsoidSilhouetteHalfspaceNew(agi_ellipsoid ellipsoid, vec3 pointOutsideEllipsoid)\n" +
"{\n" +
"vec3 q = ellipsoid.inverseRadii * (agi_inverseView * vec4(pointOutsideEllipsoid, 1.0)).xyz;\n" +
"float magnitude = 1.0 / length(q);\n" +
"vec3 normal = normalize(q);\n" +
"vec3 center = magnitude * normal;\n" +
"agi_halfspace halfspaceInScaledSpace = agi_halfspace(center, normal);\n" +
"agi_ellipsoidSilhouetteHalfspace temp = agi_ellipsoidSilhouetteHalfspace(ellipsoid, pointOutsideEllipsoid, halfspaceInScaledSpace);\n" +
"return temp;\n" +
"}\n" +
"agi_raySegment agi_rayEllipsoidSilhouetteHalfspaceIntersectionInterval(agi_ray ray, agi_ellipsoidSilhouetteHalfspace halfspace)\n" +
"{\n" +
"vec3 origin = halfspace.ellipsoid.inverseRadii * (agi_inverseView * vec4(ray.origin, 1.0)).xyz;\n" +
"vec3 direction = halfspace.ellipsoid.inverseRadii * (agi_inverseView * vec4(ray.direction, 0.0)).xyz;\n" +
"agi_ray rayInScaledSpace = agi_ray(origin, direction);\n" +
"agi_raySegment interval = agi_rayHalfspaceIntersectionInterval(rayInScaledSpace, halfspace.halfspaceInScaledSpace);\n" +
"if (agi_isEmpty(interval))\n" +
"{\n" +
"return interval;\n" +
"}\n" +
"else\n" +
"{\n" +
"float start = interval.start;\n" +
"if (start != 0.0)\n" +
"{\n" +
"vec3 temp = (agi_view * vec4(halfspace.ellipsoid.radii * agi_pointAlongRay(rayInScaledSpace, start), 1.0)).xyz;\n" +
"start = dot(temp, ray.direction);\n" +
"}\n" +
"float stop = interval.stop;\n" +
"if (stop != agi_infinity)\n" +
"{\n" +
"vec3 temp = (agi_view * vec4(halfspace.ellipsoid.radii * agi_pointAlongRay(rayInScaledSpace, stop), 1.0)).xyz;\n" +
"stop = dot(temp, ray.direction);\n" +
"}\n" +
"return agi_raySegment(start, stop);\n" +
"}\n" +
"}\n" +
"";
});

/*global define*/
define('Shaders/CustomSensorVolumeFS',[],function() {
  
  return "#ifdef GL_OES_standard_derivatives\n" +
"#extension GL_OES_standard_derivatives : enable\n" +
"#endif\n" +
"uniform bool u_showIntersection;\n" +
"uniform bool u_showThroughEllipsoid;\n" +
"uniform float u_sensorRadius;\n" +
"uniform vec4 u_pickColor;\n" +
"varying vec3 v_positionWC;\n" +
"varying vec3 v_positionEC;\n" +
"varying vec3 v_normalEC;\n" +
"varying vec3 v_sensorVertexWC;\n" +
"varying vec3 v_sensorVertexEC;\n" +
"#ifndef RENDER_FOR_PICK\n" +
"vec4 getColor(float sensorRadius, vec3 pointEC)\n" +
"{\n" +
"sensorErode(sensorRadius, pointEC);\n" +
"vec3 pointMC = (agi_inverseModelView * vec4(pointEC, 1.0)).xyz;\n" +
"float zDistance = pointMC.z;\n" +
"vec2 st = sensor2dTextureCoordinates(sensorRadius, pointMC);\n" +
"vec3 str = pointMC / sensorRadius;\n" +
"return agi_getMaterialColor(zDistance, st, str);\n" +
"}\n" +
"#endif\n" +
"bool ellipsoidSensorIntersection(agi_raySegment ellipsoidInterval)\n" +
"{\n" +
"if (agi_isEmpty(ellipsoidInterval))\n" +
"{\n" +
"return false;\n" +
"}\n" +
"float t = ellipsoidInterval.start;\n" +
"#ifdef GL_OES_standard_derivatives\n" +
"float epsilon = max(abs(dFdx(t)), abs(dFdy(t)));\n" +
"if (epsilon >= ellipsoidInterval.start)\n" +
"{\n" +
"return false;\n" +
"}\n" +
"#else\n" +
"float epsilon = t / 500.0;\n" +
"#endif\n" +
"float width = 2.0;\n" +
"epsilon *= width;\n" +
"return agi_equalsEpsilon(t, length(v_positionEC), epsilon);\n" +
"}\n" +
"vec4 shade(agi_raySegment ellipsoidInterval)\n" +
"{\n" +
"#ifdef RENDER_FOR_PICK\n" +
"return u_pickColor;\n" +
"#else\n" +
"if (u_showIntersection && ellipsoidSensorIntersection(ellipsoidInterval))\n" +
"{\n" +
"return getIntersectionColor(u_sensorRadius, v_positionEC);\n" +
"}\n" +
"vec3 positionToEyeEC = normalize(-v_positionEC);\n" +
"vec3 normal = normalize(v_normalEC);\n" +
"normal = mix(normal, -normal, step(normal.z, 0.0));\n" +
"vec4 color = getColor(u_sensorRadius, v_positionEC);\n" +
"float intensity = agi_twoSidedLightIntensity(normal, agi_sunDirectionEC, positionToEyeEC);\n" +
"return vec4(color.rgb * intensity, color.a);\n" +
"#endif\n" +
"}\n" +
"bool agi_pointInEllipsoid(agi_ellipsoid ellipsoid, vec3 point)\n" +
"{\n" +
"return (((point.x * point.x) / (ellipsoid.radii.x * ellipsoid.radii.x)) +\n" +
"((point.y * point.y) / (ellipsoid.radii.y * ellipsoid.radii.y)) +\n" +
"((point.z * point.z) / (ellipsoid.radii.z * ellipsoid.radii.z)) < 1.0);\n" +
"}\n" +
"void main()\n" +
"{\n" +
"agi_ellipsoid ellipsoid = agi_getWgs84EllipsoidEC();\n" +
"if (!u_showThroughEllipsoid)\n" +
"{\n" +
"if (agi_pointInEllipsoid(ellipsoid, v_positionWC))\n" +
"{\n" +
"discard;\n" +
"}\n" +
"if (inSensorShadow(v_sensorVertexWC, ellipsoid, v_positionEC))\n" +
"{\n" +
"discard;\n" +
"}\n" +
"}\n" +
"if (distance(v_positionEC, v_sensorVertexEC) > u_sensorRadius)\n" +
"{\n" +
"discard;\n" +
"}\n" +
"agi_ray ray = agi_ray(vec3(0.0), normalize(v_positionEC));\n" +
"agi_raySegment ellipsoidInterval = agi_rayEllipsoidIntersectionInterval(ray, ellipsoid);\n" +
"gl_FragColor = shade(ellipsoidInterval);\n" +
"}\n" +
"";
});

/*global define*/
define('Shaders/CustomSensorVolumeVS',[],function() {
  
  return "attribute vec4 position;\n" +
"attribute vec3 normal;\n" +
"varying vec3 v_positionWC;\n" +
"varying vec3 v_positionEC;\n" +
"varying vec3 v_normalEC;\n" +
"varying vec3 v_sensorVertexWC;\n" +
"varying vec3 v_sensorVertexEC;\n" +
"void main()\n" +
"{\n" +
"gl_Position = agi_modelViewProjection * position;\n" +
"v_positionWC = (agi_model * position).xyz;\n" +
"v_positionEC = (agi_modelView * position).xyz;\n" +
"v_normalEC = agi_normal * normal;\n" +
"vec4 sensorVertexMC = vec4(0.0, 0.0, 0.0, 1.0);\n" +
"v_sensorVertexWC = (agi_model * sensorVertexMC).xyz;\n" +
"v_sensorVertexEC = (agi_modelView * sensorVertexMC).xyz;\n" +
"}\n" +
"";
});

/*global define*/
define('Shaders/DiffuseMapMaterial',[],function() {
  
  return "uniform sampler2D u_texture;\n" +
"uniform vec2 u_repeat;\n" +
"vec4 agi_getMaterialColor(float zDistance, vec2 st, vec3 str)\n" +
"{\n" +
"return texture2D(u_texture, fract(u_repeat * st));\n" +
"}\n" +
"";
});
/*global define*/
define('Scene/DiffuseMapMaterial',['../Shaders/DiffuseMapMaterial'], function(ShadersDiffuseMapMaterial) {
    

    /**
     *
     * DOC_TBA
     *
     * @alias DiffuseMapMaterial
     * @constructor
     */
    var DiffuseMapMaterial = function(template) {
        var t = template || {};

        /**
         * DOC_TBA
         */
        this.texture = t.texture || null;

        /**
         * DOC_TBA
         */
        this.sRepeat = t.sRepeat || 1.0;

        /**
         * DOC_TBA
         */
        this.tRepeat = t.tRepeat || 1.0;

        var that = this;
        this._uniforms = {
            u_texture : function() {
                return that.texture;
            },
            u_repeat : function() {
                return {
                    x : that.sRepeat,
                    y : that.tRepeat
                };
            }
        };
    };

    DiffuseMapMaterial.prototype._getShaderSource = function() {
        return '#line 0\n' + ShadersDiffuseMapMaterial;
    };

    return DiffuseMapMaterial;
});



/*global define*/
define('Shaders/DistanceIntervalMaterial',[],function() {
  
  return "uniform vec4 u_colors[NUMBER_OF_DISTANCES];\n" +
"uniform float u_distances[NUMBER_OF_DISTANCES];\n" +
"vec4 agi_getMaterialColor(float zDistance, vec2 st, vec3 str)\n" +
"{\n" +
"vec4 color = vec4(0.0);\n" +
"for (int i = 0; i < NUMBER_OF_DISTANCES; ++i)\n" +
"{\n" +
"if (zDistance < u_distances[i])\n" +
"{\n" +
"color = u_colors[i];\n" +
"break;\n" +
"}\n" +
"}\n" +
"return color;\n" +
"}\n" +
"";
});
/*global define*/
define('Scene/DistanceIntervalMaterial',['../Shaders/DistanceIntervalMaterial'], function(ShadersDistanceIntervalMaterial) {
    

    /**
     * DOC_TBA
     *
     * @alias DistanceIntervalMaterial
     * @constructor
     */
    var DistanceIntervalMaterial = function(template) {
        var t = template || {};

        /**
         * DOC_TBA
         */
        this.intervals = t.intervals || [];

        // TODO: Expose get/set - can change distance/color, but not number of intervals
        var distances = [];
        var colors = [];

        for ( var i = 0; i < this.intervals.length; ++i) {
            distances.push(this.intervals[i].distance);
            colors.push(this.intervals[i].color);
        }

        this._uniforms = {
            u_distances : function() {
                return distances;
            },
            u_colors : function() {
                return colors;
            }
        };
    };

    DistanceIntervalMaterial.prototype._getShaderSource = function() {
        return '#define NUMBER_OF_DISTANCES ' + this.intervals.length.toString() + '\n' +
               '#line 0\n' + ShadersDistanceIntervalMaterial;
    };

    return DistanceIntervalMaterial;
});

/*global define*/
define('Shaders/DotMaterial',[],function() {
  
  return "uniform vec4 u_lightColor;\n" +
"uniform vec4 u_darkColor;\n" +
"uniform vec2 u_repeat;\n" +
"vec4 agi_getMaterialColor(float zDistance, vec2 st, vec3 str)\n" +
"{\n" +
"float b = smoothstep(0.3, 0.32, length(fract(u_repeat * st) - 0.5));\n" +
"return mix(u_lightColor, u_darkColor, b);\n" +
"}\n" +
"";
});
/*global define*/
define('Scene/DotMaterial',[
        '../Core/Color',
        '../Shaders/DotMaterial'
       ], function(
         Color,
         ShadersDotMaterial) {
    

    /**
     * DOC_TBA
     *
     * @alias DotMaterial
     * @constructor
     */
    var DotMaterial = function(template) {
        var t = template || {};

        /**
         * DOC_TBA
         */
        this.lightColor = (typeof t.lightColor !== 'undefined') ? Color.clone(t.lightColor) : new Color(1.0, 1.0, 1.0, 0.5);

        /**
         * DOC_TBA
         */
        this.darkColor = (typeof t.darkColor !== 'undefined') ? Color.clone(t.darkColor) : new Color(0.0, 0.0, 1.0, 0.5);

        /**
         * DOC_TBA
         *
         * @type Number
         */
        this.sRepeat = t.sRepeat || 10.0;

        /**
         * DOC_TBA
         *
         * @type Number
         */
        this.tRepeat = t.tRepeat || 10.0;

        var that = this;
        this._uniforms = {
            u_lightColor : function() {
                return that.lightColor;
            },
            u_darkColor : function() {
                return that.darkColor;
            },
            u_repeat : function() {
                return {
                    x : that.sRepeat,
                    y : that.tRepeat
                };
            }
        };
    };

    DotMaterial.prototype._getShaderSource = function() {
        return '#line 0\n' + ShadersDotMaterial;
    };

    return DotMaterial;
});

/*global define*/
define('Shaders/FacetMaterial',[],function() {
  
  return "uniform vec4 u_lightColor;\n" +
"uniform vec4 u_darkColor;\n" +
"uniform float u_repeat;\n" +
"vec4 agi_getMaterialColor(float zDistance, vec2 st, vec3 str)\n" +
"{\n" +
"vec2 F = agi_cellular(st * u_repeat);\n" +
"float t = 0.1 + (F.y - F.x);\n" +
"return mix(u_lightColor, u_darkColor, t);\n" +
"}\n" +
"";
});
/*!
 * Atmosphere code:
 *
 * Copyright (c) 2000-2005, Sean O'Neil (s_p_oneil@hotmail.com)
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * * Neither the name of the project nor the names of its contributors may be
 *   used to endorse or promote products derived from this software without
 *   specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Modifications made by Analytical Graphics, Inc.
 */
/*global define*/
define('Shaders/GroundAtmosphere',[],function() {
  
  return "uniform vec3 v3InvWavelength;\n" +
"uniform float fCameraHeight;\n" +
"uniform float fCameraHeight2;\n" +
"uniform float fOuterRadius;\n" +
"uniform float fOuterRadius2;\n" +
"uniform float fInnerRadius;\n" +
"uniform float fInnerRadius2;\n" +
"uniform float fKrESun;\n" +
"uniform float fKmESun;\n" +
"uniform float fKr4PI;\n" +
"uniform float fKm4PI;\n" +
"uniform float fScale;\n" +
"uniform float fScaleDepth;\n" +
"uniform float fScaleOverScaleDepth;\n" +
"uniform float fMinGroundFromAtmosphereHeight;\n" +
"uniform float fstartFadeGroundFromAtmosphere;\n" +
"struct AtmosphereColor\n" +
"{\n" +
"vec3 mie;\n" +
"vec3 rayleigh;\n" +
"};\n" +
"#ifdef SHOW_GROUND_ATMOSPHERE\n" +
"const int nSamples = 2;\n" +
"const float fSamples = 2.0;\n" +
"float scale(float fCos)\n" +
"{\n" +
"float x = 1.0 - fCos;\n" +
"return fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\n" +
"}\n" +
"AtmosphereColor computeGroundAtmosphereFromSpace(vec3 v3Pos)\n" +
"{\n" +
"vec3 v3Ray = v3Pos - agi_viewerPositionWC;\n" +
"float fFar = length(v3Ray);\n" +
"v3Ray /= fFar;\n" +
"#ifdef SHOW_GROUND_ATMOSPHERE_FROM_SPACE\n" +
"float B = 2.0 * length(agi_viewerPositionWC) * dot(normalize(agi_viewerPositionWC), v3Ray);\n" +
"float C = fCameraHeight2 - fOuterRadius2;\n" +
"float fDet = max(0.0, B*B - 4.0 * C);\n" +
"float fNear = 0.5 * (-B - sqrt(fDet));\n" +
"vec3 v3Start = agi_viewerPositionWC + v3Ray * fNear;\n" +
"fFar -= fNear;\n" +
"float fDepth = exp((fInnerRadius - fOuterRadius) / fScaleDepth);\n" +
"#else\n" +
"vec3 v3Start = agi_viewerPositionWC;\n" +
"float fDepth = exp((fInnerRadius - fCameraHeight) / fScaleDepth);\n" +
"#endif\n" +
"float fCameraAngle = dot(-v3Ray, v3Pos) / length(v3Pos);\n" +
"float fLightAngle = dot(agi_sunDirectionWC, v3Pos) / length(v3Pos);\n" +
"float fCameraScale = scale(fCameraAngle);\n" +
"float fLightScale = scale(fLightAngle);\n" +
"float fCameraOffset = fDepth*fCameraScale;\n" +
"float fTemp = (fLightScale + fCameraScale);\n" +
"float fSampleLength = fFar / fSamples;\n" +
"float fScaledLength = fSampleLength * fScale;\n" +
"vec3 v3SampleRay = v3Ray * fSampleLength;\n" +
"vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\n" +
"vec3 v3FrontColor = vec3(0.0);\n" +
"vec3 v3Attenuate = vec3(0.0);\n" +
"for(int i=0; i<nSamples; i++)\n" +
"{\n" +
"float fHeight = length(v3SamplePoint);\n" +
"float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));\n" +
"float fScatter = fDepth*fTemp - fCameraOffset;\n" +
"v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));\n" +
"v3FrontColor += v3Attenuate * (fDepth * fScaledLength);\n" +
"v3SamplePoint += v3SampleRay;\n" +
"}\n" +
"vec3 mie = v3FrontColor * (v3InvWavelength * fKrESun + fKmESun);\n" +
"vec3 rayleigh = v3Attenuate;\n" +
"float fade = clamp((fCameraHeight - fMinGroundFromAtmosphereHeight) / fstartFadeGroundFromAtmosphere, 0.0, 1.0);\n" +
"AtmosphereColor color;\n" +
"color.mie = mix(vec3(0.0), mie,fade);\n" +
"color.rayleigh = rayleigh;\n" +
"return color;\n" +
"}\n" +
"#else\n" +
"AtmosphereColor computeGroundAtmosphereFromSpace(vec3 v3Pos)\n" +
"{\n" +
"AtmosphereColor color;\n" +
"color.mie = vec3(0.0);\n" +
"color.rayleigh = vec3(1.0);\n" +
"return color;\n" +
"}\n" +
"#endif\n" +
"";
});

/*global define*/
define('Shaders/HorizontalStripeMaterial',[],function() {
  
  return "uniform vec4 u_lightColor;\n" +
"uniform vec4 u_darkColor;\n" +
"uniform float u_offset;\n" +
"uniform float u_repeat;\n" +
"vec4 agi_getMaterialColor(float zDistance, vec2 st, vec3 str)\n" +
"{\n" +
"const float fuzz = 0.1;\n" +
"float value = fract((st.t - u_offset) * (u_repeat * 0.5));\n" +
"float val1 = clamp(value / fuzz, 0.0, 1.0);\n" +
"float val2 = clamp((value - 0.5) / fuzz, 0.0, 1.0);\n" +
"val1 = val1 * (1.0 - val2);\n" +
"val1 = val1 * val1 * (3.0 - (2.0 * val1));\n" +
"return mix(u_lightColor, u_darkColor, val1);\n" +
"}\n" +
"";
});
/*global define*/
define('Scene/HorizontalStripeMaterial',[
        '../Core/Color',
        '../Shaders/HorizontalStripeMaterial'
       ], function(
         Color,
         ShadersHorizontalStripeMaterial) {
    

    /**
     * DOC_TBA
     *
     * @alias HorizontalStripeMaterial
     * @constructor
     */
    var HorizontalStripeMaterial = function(template) {
        var t = template || {};

        /**
         * DOC_TBA
         */
        this.lightColor = (typeof t.lightColor !== 'undefined') ? Color.clone(t.lightColor) : new Color(1.0, 1.0, 1.0, 0.5);

        /**
         * DOC_TBA
         */
        this.darkColor = (typeof t.darkColor !== 'undefined') ? Color.clone(t.darkColor) : new Color(0.0, 0.0, 1.0, 0.5);

        /**
         * DOC_TBA
         *
         * @type Number
         */
        this.offset = t.offset || 0.0;

        /**
         * DOC_TBA
         *
         * @type Number
         */
        this.repeat = t.repeat || 10.0;

        var that = this;
        this._uniforms = {
            u_lightColor : function() {
                return that.lightColor;
            },
            u_darkColor : function() {
                return that.darkColor;
            },
            u_offset : function() {
                return that.offset;
            },
            u_repeat : function() {
                return that.repeat;
            }
        };
    };

    HorizontalStripeMaterial.prototype._getShaderSource = function() {
        return '#line 0\n' + ShadersHorizontalStripeMaterial;
    };

    return HorizontalStripeMaterial;
});

/*global define*/
define('Shaders/Materials/AsphaltMaterial',[],function() {
  
  return "uniform vec4 asphaltColor;\n" +
"uniform float bumpSize;\n" +
"uniform float roughness;\n" +
"agi_material agi_getMaterial(agi_materialInput materialInput)\n" +
"{\n" +
"agi_material material = agi_getDefaultMaterial(materialInput);\n" +
"vec4 color = asphaltColor;\n" +
"vec2 st = materialInput.st;\n" +
"vec2 F = agi_cellular(st / bumpSize);\n" +
"color.rgb -= (F.x / F.y) * 0.1;\n" +
"float noise = agi_snoise(st / bumpSize);\n" +
"noise = pow(noise, 5.0) * roughness;\n" +
"color.rgb += noise;\n" +
"material.diffuse = color.rgb;\n" +
"material.alpha = color.a;\n" +
"return material;\n" +
"}\n" +
"";
});
;
define("Shaders/Materials/AsphaltMaterialComments", function(){});


/*global define*/
define('Shaders/Materials/BlobMaterial',[],function() {
  
  return "uniform vec4 lightColor;\n" +
"uniform vec4 darkColor;\n" +
"uniform float frequency;\n" +
"agi_material agi_getMaterial(agi_materialInput materialInput)\n" +
"{\n" +
"agi_material material = agi_getDefaultMaterial(materialInput);\n" +
"vec2 F = agi_cellular(materialInput.st * frequency);\n" +
"float t = 1.0 - F.x * F.x;\n" +
"vec4 color = mix(lightColor, darkColor, t);\n" +
"material.diffuse = color.rgb;\n" +
"material.alpha = color.a;\n" +
"return material;\n" +
"}\n" +
"";
});
;
define("Shaders/Materials/BlobMaterialComments", function(){});


/*global define*/
define('Shaders/Materials/BrickMaterial',[],function() {
  
  return "uniform vec4 brickColor;\n" +
"uniform vec4 mortarColor;\n" +
"uniform vec2 brickSize;\n" +
"uniform vec2 brickPct;\n" +
"uniform float brickRoughness;\n" +
"uniform float mortarRoughness;\n" +
"#define Integral(x, p) ((floor(x) * p) + max(fract(x) - (1.0 - p), 0.0))\n" +
"agi_material agi_getMaterial(agi_materialInput materialInput)\n" +
"{\n" +
"agi_material material = agi_getDefaultMaterial(materialInput);\n" +
"vec2 st = materialInput.st;\n" +
"vec2 position = st / brickSize;\n" +
"if(fract(position.y * 0.5) > 0.5) {\n" +
"position.x += 0.5;\n" +
"}\n" +
"vec2 filterWidth = vec2(0.02);\n" +
"vec2 useBrick = (Integral(position + filterWidth, brickPct) -\n" +
"Integral(position, brickPct)) / filterWidth;\n" +
"float useBrickFinal = useBrick.x * useBrick.y;\n" +
"vec4 color = mix(mortarColor, brickColor, useBrickFinal);\n" +
"vec2 brickScaled = vec2(st.x / 0.1, st.y / 0.006);\n" +
"float brickNoise = abs(agi_snoise(brickScaled) * brickRoughness / 5.0);\n" +
"color.rg += brickNoise * useBrickFinal;\n" +
"vec2 mortarScaled = st / 0.005;\n" +
"float mortarNoise = max(agi_snoise(mortarScaled) * mortarRoughness, 0.0);\n" +
"color.rgb += mortarNoise * (1.0 - useBrickFinal);\n" +
"material.diffuse = color.rgb;\n" +
"material.alpha = color.a;\n" +
"return material;\n" +
"}\n" +
"";
});
;
define("Shaders/Materials/BrickMaterialComments", function(){});


/*global define*/
define('Shaders/Materials/BumpMapMaterial',[],function() {
  
  return "uniform sampler2D image;\n" +
"uniform float strength;\n" +
"uniform vec2 repeat;\n" +
"agi_material agi_getMaterial(agi_materialInput materialInput)\n" +
"{\n" +
"agi_material material = agi_getDefaultMaterial(materialInput);\n" +
"vec2 st = materialInput.st;\n" +
"vec2 centerPixel = fract(repeat * st);\n" +
"float centerBump = texture2D(image, centerPixel).channel;\n" +
"float imageWidth = float(imageDimensions.x);\n" +
"vec2 rightPixel = fract(repeat * (st + vec2(1.0 / imageWidth, 0.0)));\n" +
"float rightBump = texture2D(image, rightPixel).channel;\n" +
"float imageHeight = float(imageDimensions.y);\n" +
"vec2 leftPixel = fract(repeat * (st + vec2(0.0, 1.0 / imageHeight)));\n" +
"float topBump = texture2D(image, leftPixel).channel;\n" +
"vec3 normalTangentSpace = normalize(vec3(centerBump - rightBump, centerBump - topBump, clamp(1.0 - strength, 0.1, 1.0)));\n" +
"vec3 normalEC = materialInput.tangentToEyeMatrix * normalTangentSpace;\n" +
"material.normal = normalEC;\n" +
"return material;\n" +
"}\n" +
"";
});
;
define("Shaders/Materials/BumpMapMaterialComments", function(){});


/*global define*/
define('Shaders/Materials/CementMaterial',[],function() {
  
  return "uniform vec4 cementColor;\n" +
"uniform float grainScale;\n" +
"uniform float roughness;\n" +
"agi_material agi_getMaterial(agi_materialInput materialInput)\n" +
"{\n" +
"agi_material material = agi_getDefaultMaterial(materialInput);\n" +
"float noise = agi_snoise(materialInput.st / grainScale);\n" +
"noise = pow(noise, 5.0) * roughness;\n" +
"vec4 color = cementColor;\n" +
"color.rgb += noise;\n" +
"material.diffuse = color.rgb;\n" +
"material.alpha = color.a;\n" +
"return material;\n" +
"}\n" +
"";
});
;
define("Shaders/Materials/CementMaterialComments", function(){});


/*global define*/
define('Shaders/Materials/CheckerboardMaterial',[],function() {
  
  return "uniform vec4 lightColor;\n" +
"uniform vec4 darkColor;\n" +
"uniform vec2 repeat;\n" +
"agi_material agi_getMaterial(agi_materialInput materialInput)\n" +
"{\n" +
"agi_material material = agi_getDefaultMaterial(materialInput);\n" +
"vec2 st = materialInput.st;\n" +
"const float fuzz = 0.03;\n" +
"float b = mod(floor(repeat.s * st.s) + floor(repeat.t * st.t), 2.0);\n" +
"float scaledWidth = fract(repeat.s * st.s);\n" +
"scaledWidth = abs(scaledWidth - floor(scaledWidth + 0.5));\n" +
"float scaledHeight = fract(repeat.t * st.t);\n" +
"scaledHeight = abs(scaledHeight - floor(scaledHeight + 0.5));\n" +
"float value = min(scaledWidth, scaledHeight);\n" +
"float val1 = clamp(value / fuzz, 0.0, 1.0);\n" +
"float val2 = clamp((value - 0.5) / fuzz, 0.0, 1.0);\n" +
"val1 = val1 * (1.0 - val2);\n" +
"val1 = val1 * val1 * (3.0 - (2.0 * val1));\n" +
"val1 = pow(val1, 0.5);\n" +
"vec4 midColor = (lightColor + darkColor) / 2.0;\n" +
"vec4 currentColor = mix(lightColor, darkColor, b);\n" +
"vec4 color = mix(midColor, currentColor, val1);\n" +
"material.diffuse = color.rgb;\n" +
"material.alpha = color.a;\n" +
"return material;\n" +
"}\n" +
"";
});
;
define("Shaders/Materials/CheckerboardMaterialComments", function(){});


/*global define*/
define('Shaders/Materials/DistanceIntervalMaterial',[],function() {
  
  return "uniform vec4 u_colors[NUMBER_OF_DISTANCES];\n" +
"uniform float u_distances[NUMBER_OF_DISTANCES];\n" +
"agi_material agi_getMaterial(agi_materialInput materialInput)\n" +
"{\n" +
"agi_material material = agi_getDefaultMaterial(materialInput);\n" +
"vec4 color = vec4(0.0);\n" +
"for (int i = 0; i < NUMBER_OF_DISTANCES; ++i)\n" +
"{\n" +
"if (materialInput.positionMC.z < u_distances[i])\n" +
"{\n" +
"color = u_colors[i];\n" +
"break;\n" +
"}\n" +
"}\n" +
"material.diffuse = color.rgb;\n" +
"material.alpha = color.a;\n" +
"return material;\n" +
"}\n" +
"";
});
;
define("Shaders/Materials/DistanceIntervalMaterialComments", function(){});


/*global define*/
define('Shaders/Materials/DotMaterial',[],function() {
  
  return "uniform vec4 lightColor;\n" +
"uniform vec4 darkColor;\n" +
"uniform vec2 repeat;\n" +
"agi_material agi_getMaterial(agi_materialInput materialInput)\n" +
"{\n" +
"agi_material material = agi_getDefaultMaterial(materialInput);\n" +
"float b = smoothstep(0.3, 0.32, length(fract(repeat * materialInput.st) - 0.5));\n" +
"vec4 color = mix(lightColor, darkColor, b);\n" +
"material.diffuse = color.rgb;\n" +
"material.alpha = color.a;\n" +
"return material;\n" +
"}\n" +
"";
});
;
define("Shaders/Materials/DotMaterialComments", function(){});


/*global define*/
define('Shaders/Materials/FacetMaterial',[],function() {
  
  return "uniform vec4 lightColor;\n" +
"uniform vec4 darkColor;\n" +
"uniform float frequency;\n" +
"agi_material agi_getMaterial(agi_materialInput materialInput)\n" +
"{\n" +
"agi_material material = agi_getDefaultMaterial(materialInput);\n" +
"vec2 F = agi_cellular(materialInput.st * frequency);\n" +
"float t = 0.1 + (F.y - F.x);\n" +
"vec4 color = mix(lightColor, darkColor, t);\n" +
"material.diffuse = color.rgb;\n" +
"material.alpha = color.a;\n" +
"return material;\n" +
"}\n" +
"";
});
;
define("Shaders/Materials/FacetMaterialComments", function(){});


/*global define*/
define('Shaders/Materials/FresnelMaterial',[],function() {
  
  return "agi_material agi_getMaterial(agi_materialInput materialInput)\n" +
"{\n" +
"agi_material material = agi_getDefaultMaterial(materialInput);\n" +
"vec3 normalEC = material.normal;\n" +
"vec3 normalWC = normalize(vec3(agi_inverseView * vec4(normalEC, 0.0)));\n" +
"float cosAngIncidence = max(dot(normalWC, materialInput.positionToEyeWC), 0.0);\n" +
"material.diffuse = mix(reflection.diffuse, refraction.diffuse, cosAngIncidence);\n" +
"return material;\n" +
"}\n" +
"";
});
;
define("Shaders/Materials/FresnelMaterialComments", function(){});


/*global define*/
define('Shaders/Materials/GrassMaterial',[],function() {
  
  return "uniform vec4 grassColor;\n" +
"uniform vec4 dirtColor;\n" +
"uniform float patchiness;\n" +
"agi_material agi_getMaterial(agi_materialInput materialInput)\n" +
"{\n" +
"agi_material material = agi_getDefaultMaterial(materialInput);\n" +
"vec2 st = materialInput.st;\n" +
"float noise1 = (agi_snoise(st * patchiness * 1.0)) * 1.0;\n" +
"float noise2 = (agi_snoise(st * patchiness * 2.0)) * 0.5;\n" +
"float noise3 = (agi_snoise(st * patchiness * 4.0)) * 0.25;\n" +
"float noise = sin(noise1 + noise2 + noise3) * 0.1;\n" +
"vec4 color = mix(grassColor, dirtColor, noise);\n" +
"float verticalNoise = agi_snoise(vec2(st.x * 100.0, st.y * 20.0)) * 0.02;\n" +
"float horizontalNoise = agi_snoise(vec2(st.x * 20.0, st.y * 100.0)) * 0.02;\n" +
"float stripeNoise = min(verticalNoise, horizontalNoise);\n" +
"color.rgb += stripeNoise;\n" +
"material.diffuse = color.rgb;\n" +
"material.alpha = color.a;\n" +
"return material;\n" +
"}\n" +
"";
});
;
define("Shaders/Materials/GrassMaterialComments", function(){});


/*global define*/
define('Shaders/Materials/NormalMapMaterial',[],function() {
  
  return "uniform sampler2D image;\n" +
"uniform float strength;\n" +
"uniform vec2 repeat;\n" +
"agi_material agi_getMaterial(agi_materialInput materialInput)\n" +
"{\n" +
"agi_material material = agi_getDefaultMaterial(materialInput);\n" +
"vec4 textureValue = texture2D(image, fract(repeat * materialInput.st));\n" +
"vec3 normalTangentSpace = textureValue.channels;\n" +
"normalTangentSpace.xy = normalTangentSpace.xy * 2.0 - 1.0;\n" +
"normalTangentSpace.z = clamp(1.0 - strength, 0.1, 1.0);\n" +
"normalTangentSpace = normalize(normalTangentSpace);\n" +
"vec3 normalEC = materialInput.tangentToEyeMatrix * normalTangentSpace;\n" +
"material.normal = normalEC;\n" +
"return material;\n" +
"}\n" +
"";
});
;
define("Shaders/Materials/NormalMapMaterialComments", function(){});


/*global define*/
define('Shaders/Materials/ReflectionMaterial',[],function() {
  
  return "uniform samplerCube cubeMap;\n" +
"agi_material agi_getMaterial(agi_materialInput materialInput)\n" +
"{\n" +
"agi_material material = agi_getDefaultMaterial(materialInput);\n" +
"vec3 normalEC = material.normal;\n" +
"vec3 normalWC = normalize(vec3(agi_inverseView * vec4(normalEC, 0.0)));\n" +
"vec3 reflectedWC = reflect(materialInput.positionToEyeWC, normalWC);\n" +
"material.diffuse = textureCube(cubeMap, reflectedWC).channels;\n" +
"return material;\n" +
"}\n" +
"";
});
;
define("Shaders/Materials/ReflectionMaterialComments", function(){});


/*global define*/
define('Shaders/Materials/RefractionMaterial',[],function() {
  
  return "uniform samplerCube cubeMap;\n" +
"uniform float indexOfRefractionRatio;\n" +
"agi_material agi_getMaterial(agi_materialInput materialInput)\n" +
"{\n" +
"agi_material material = agi_getDefaultMaterial(materialInput);\n" +
"vec3 normalEC = material.normal;\n" +
"vec3 normalWC = normalize(vec3(agi_inverseView * vec4(normalEC, 0.0)));\n" +
"vec3 refractedWC = refract(materialInput.positionToEyeWC, -normalWC, indexOfRefractionRatio);\n" +
"material.diffuse = textureCube(cubeMap, refractedWC).channels;\n" +
"return material;\n" +
"}\n" +
"";
});
;
define("Shaders/Materials/RefractionMaterialComments", function(){});


/*global define*/
define('Shaders/Materials/StripeMaterial',[],function() {
  
  return "uniform vec4 lightColor;\n" +
"uniform vec4 darkColor;\n" +
"uniform float offset;\n" +
"uniform float repeat;\n" +
"uniform bool horizontal;\n" +
"agi_material agi_getMaterial(agi_materialInput materialInput)\n" +
"{\n" +
"agi_material material = agi_getDefaultMaterial(materialInput);\n" +
"const float fuzz = 0.1;\n" +
"float coord = mix(materialInput.st.s, materialInput.st.t, float(horizontal));\n" +
"float value = fract((coord - offset) * (repeat * 0.5));\n" +
"float val1 = clamp(value / fuzz, 0.0, 1.0);\n" +
"float val2 = clamp((value - 0.5) / fuzz, 0.0, 1.0);\n" +
"val1 = val1 * (1.0 - val2);\n" +
"val1 = val1 * val1 * (3.0 - (2.0 * val1));\n" +
"vec4 color = mix(lightColor, darkColor, val1);\n" +
"material.diffuse = color.rgb;\n" +
"material.alpha = color.a;\n" +
"return material;\n" +
"}\n" +
"";
});
;
define("Shaders/Materials/StripeMaterialComments", function(){});


/*global define*/
define('Shaders/Materials/TieDyeMaterial',[],function() {
  
  return "uniform vec4 lightColor;\n" +
"uniform vec4 darkColor;\n" +
"uniform float frequency;\n" +
"agi_material agi_getMaterial(agi_materialInput materialInput)\n" +
"{\n" +
"agi_material material = agi_getDefaultMaterial(materialInput);\n" +
"vec3 scaled = materialInput.str * frequency;\n" +
"float t = abs(agi_snoise(scaled));\n" +
"vec4 color = mix(lightColor, darkColor, t);\n" +
"material.diffuse = color.rgb;\n" +
"material.alpha = color.a;\n" +
"return material;\n" +
"}\n" +
"";
});
;
define("Shaders/Materials/TieDyeMaterialComments", function(){});


/*global define*/
define('Shaders/Materials/WoodMaterial',[],function() {
  
  return "uniform vec4 lightWoodColor;\n" +
"uniform vec4 darkWoodColor;\n" +
"uniform float ringFrequency;\n" +
"uniform vec2 noiseScale;\n" +
"uniform float grainFrequency;\n" +
"agi_material agi_getMaterial(agi_materialInput materialInput)\n" +
"{\n" +
"agi_material material = agi_getDefaultMaterial(materialInput);\n" +
"vec2 st = materialInput.st;\n" +
"vec2 noisevec;\n" +
"noisevec.x = agi_snoise(st * noiseScale.x);\n" +
"noisevec.y = agi_snoise(st * noiseScale.y);\n" +
"vec2 location = st + noisevec;\n" +
"float dist = sqrt(location.x * location.x + location.y * location.y);\n" +
"dist *= ringFrequency;\n" +
"float r = fract(dist + noisevec[0] + noisevec[1]) * 2.0;\n" +
"if(r > 1.0)\n" +
"r = 2.0 - r;\n" +
"vec4 color = mix(lightWoodColor, darkWoodColor, r);\n" +
"r = abs(agi_snoise(vec2(st.x * grainFrequency, st.y * grainFrequency * 0.02))) * 0.2;\n" +
"color.rgb += lightWoodColor.rgb * r;\n" +
"material.diffuse = color.rgb;\n" +
"material.alpha = color.a;\n" +
"return material;\n" +
"}\n" +
"";
});
;
define("Shaders/Materials/WoodMaterialComments", function(){});

/*!
 * Description : Array and textureless GLSL 2D/3D/4D simplex 
 *               noise functions.
 *      Author : Ian McEwan, Ashima Arts.
 *  Maintainer : ijm
 *     Lastmod : 20110822 (ijm)
 *     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
 *               Distributed under the MIT License. See LICENSE file.
 *               https://github.com/ashima/webgl-noise
 */
/*!
 * Cellular noise ("Worley noise") in 2D in GLSL.
 * Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.
 * This code is released under the conditions of the MIT license.
 * See LICENSE file for details.
 */
/*global define*/
define('Shaders/Noise',[],function() {
  
  return "#ifndef AGI_NOISE\n" +
"#define AGI_NOISE 1\n" +
"vec4 _agi_mod289(vec4 x)\n" +
"{\n" +
"return x - floor(x * (1.0 / 289.0)) * 289.0;\n" +
"}\n" +
"vec3 _agi_mod289(vec3 x)\n" +
"{\n" +
"return x - floor(x * (1.0 / 289.0)) * 289.0;\n" +
"}\n" +
"vec2 _agi_mod289(vec2 x)\n" +
"{\n" +
"return x - floor(x * (1.0 / 289.0)) * 289.0;\n" +
"}\n" +
"float _agi_mod289(float x)\n" +
"{\n" +
"return x - floor(x * (1.0 / 289.0)) * 289.0;\n" +
"}\n" +
"vec4 _agi_permute(vec4 x)\n" +
"{\n" +
"return _agi_mod289(((x*34.0)+1.0)*x);\n" +
"}\n" +
"vec3 _agi_permute(vec3 x)\n" +
"{\n" +
"return _agi_mod289(((x*34.0)+1.0)*x);\n" +
"}\n" +
"float _agi_permute(float x)\n" +
"{\n" +
"return _agi_mod289(((x*34.0)+1.0)*x);\n" +
"}\n" +
"vec4 _agi_taylorInvSqrt(vec4 r)\n" +
"{\n" +
"return 1.79284291400159 - 0.85373472095314 * r;\n" +
"}\n" +
"float _agi_taylorInvSqrt(float r)\n" +
"{\n" +
"return 1.79284291400159 - 0.85373472095314 * r;\n" +
"}\n" +
"vec4 _agi_grad4(float j, vec4 ip)\n" +
"{\n" +
"const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n" +
"vec4 p,s;\n" +
"p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n" +
"p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n" +
"s = vec4(lessThan(p, vec4(0.0)));\n" +
"p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n" +
"return p;\n" +
"}\n" +
"float agi_snoise(vec2 v)\n" +
"{\n" +
"const vec4 C = vec4(0.211324865405187,\n" +
"0.366025403784439,\n" +
"-0.577350269189626,\n" +
"0.024390243902439);\n" +
"vec2 i  = floor(v + dot(v, C.yy) );\n" +
"vec2 x0 = v -   i + dot(i, C.xx);\n" +
"vec2 i1;\n" +
"i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n" +
"vec4 x12 = x0.xyxy + C.xxzz;\n" +
"x12.xy -= i1;\n" +
"i = _agi_mod289(i);\n" +
"vec3 p = _agi_permute( _agi_permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));\n" +
"vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n" +
"m = m*m ;\n" +
"m = m*m ;\n" +
"vec3 x = 2.0 * fract(p * C.www) - 1.0;\n" +
"vec3 h = abs(x) - 0.5;\n" +
"vec3 ox = floor(x + 0.5);\n" +
"vec3 a0 = x - ox;\n" +
"m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n" +
"vec3 g;\n" +
"g.x  = a0.x  * x0.x  + h.x  * x0.y;\n" +
"g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n" +
"return 130.0 * dot(m, g);\n" +
"}\n" +
"float agi_snoise(vec3 v)\n" +
"{\n" +
"const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n" +
"const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n" +
"vec3 i  = floor(v + dot(v, C.yyy) );\n" +
"vec3 x0 =   v - i + dot(i, C.xxx) ;\n" +
"vec3 g = step(x0.yzx, x0.xyz);\n" +
"vec3 l = 1.0 - g;\n" +
"vec3 i1 = min( g.xyz, l.zxy );\n" +
"vec3 i2 = max( g.xyz, l.zxy );\n" +
"vec3 x1 = x0 - i1 + C.xxx;\n" +
"vec3 x2 = x0 - i2 + C.yyy;\n" +
"vec3 x3 = x0 - D.yyy;\n" +
"i = _agi_mod289(i);\n" +
"vec4 p = _agi_permute( _agi_permute( _agi_permute(\n" +
"i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n" +
"+ i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n" +
"+ i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n" +
"float n_ = 0.142857142857;\n" +
"vec3  ns = n_ * D.wyz - D.xzx;\n" +
"vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n" +
"vec4 x_ = floor(j * ns.z);\n" +
"vec4 y_ = floor(j - 7.0 * x_ );\n" +
"vec4 x = x_ *ns.x + ns.yyyy;\n" +
"vec4 y = y_ *ns.x + ns.yyyy;\n" +
"vec4 h = 1.0 - abs(x) - abs(y);\n" +
"vec4 b0 = vec4( x.xy, y.xy );\n" +
"vec4 b1 = vec4( x.zw, y.zw );\n" +
"vec4 s0 = floor(b0)*2.0 + 1.0;\n" +
"vec4 s1 = floor(b1)*2.0 + 1.0;\n" +
"vec4 sh = -step(h, vec4(0.0));\n" +
"vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n" +
"vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n" +
"vec3 p0 = vec3(a0.xy,h.x);\n" +
"vec3 p1 = vec3(a0.zw,h.y);\n" +
"vec3 p2 = vec3(a1.xy,h.z);\n" +
"vec3 p3 = vec3(a1.zw,h.w);\n" +
"vec4 norm = _agi_taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n" +
"p0 *= norm.x;\n" +
"p1 *= norm.y;\n" +
"p2 *= norm.z;\n" +
"p3 *= norm.w;\n" +
"vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n" +
"m = m * m;\n" +
"return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n" +
"dot(p2,x2), dot(p3,x3) ) );\n" +
"}\n" +
"float agi_snoise(vec4 v)\n" +
"{\n" +
"const vec4  C = vec4( 0.138196601125011,\n" +
"0.276393202250021,\n" +
"0.414589803375032,\n" +
"-0.447213595499958);\n" +
"#define F4 0.309016994374947451\n" +
"vec4 i  = floor(v + dot(v, vec4(F4)) );\n" +
"vec4 x0 = v -   i + dot(i, C.xxxx);\n" +
"vec4 i0;\n" +
"vec3 isX = step( x0.yzw, x0.xxx );\n" +
"vec3 isYZ = step( x0.zww, x0.yyz );\n" +
"i0.x = isX.x + isX.y + isX.z;\n" +
"i0.yzw = 1.0 - isX;\n" +
"i0.y += isYZ.x + isYZ.y;\n" +
"i0.zw += 1.0 - isYZ.xy;\n" +
"i0.z += isYZ.z;\n" +
"i0.w += 1.0 - isYZ.z;\n" +
"vec4 i3 = clamp( i0, 0.0, 1.0 );\n" +
"vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n" +
"vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n" +
"vec4 x1 = x0 - i1 + C.xxxx;\n" +
"vec4 x2 = x0 - i2 + C.yyyy;\n" +
"vec4 x3 = x0 - i3 + C.zzzz;\n" +
"vec4 x4 = x0 + C.wwww;\n" +
"i = _agi_mod289(i);\n" +
"float j0 = _agi_permute( _agi_permute( _agi_permute( _agi_permute(i.w) + i.z) + i.y) + i.x);\n" +
"vec4 j1 = _agi_permute( _agi_permute( _agi_permute( _agi_permute (\n" +
"i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n" +
"+ i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n" +
"+ i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n" +
"+ i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n" +
"vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n" +
"vec4 p0 = _agi_grad4(j0,   ip);\n" +
"vec4 p1 = _agi_grad4(j1.x, ip);\n" +
"vec4 p2 = _agi_grad4(j1.y, ip);\n" +
"vec4 p3 = _agi_grad4(j1.z, ip);\n" +
"vec4 p4 = _agi_grad4(j1.w, ip);\n" +
"vec4 norm = _agi_taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n" +
"p0 *= norm.x;\n" +
"p1 *= norm.y;\n" +
"p2 *= norm.z;\n" +
"p3 *= norm.w;\n" +
"p4 *= _agi_taylorInvSqrt(dot(p4,p4));\n" +
"vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n" +
"vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n" +
"m0 = m0 * m0;\n" +
"m1 = m1 * m1;\n" +
"return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n" +
"+ dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n" +
"}\n" +
"vec3 _agi_permute289(vec3 x)\n" +
"{\n" +
"return mod((34.0 * x + 1.0) * x, 289.0);\n" +
"}\n" +
"vec2 agi_cellular(vec2 P)\n" +
"{\n" +
"#define K 0.142857142857\n" +
"#define Ko 0.428571428571\n" +
"#define jitter 1.0\n" +
"vec2 Pi = mod(floor(P), 289.0);\n" +
"vec2 Pf = fract(P);\n" +
"vec3 oi = vec3(-1.0, 0.0, 1.0);\n" +
"vec3 of = vec3(-0.5, 0.5, 1.5);\n" +
"vec3 px = _agi_permute289(Pi.x + oi);\n" +
"vec3 p = _agi_permute289(px.x + Pi.y + oi);\n" +
"vec3 ox = fract(p*K) - Ko;\n" +
"vec3 oy = mod(floor(p*K),7.0)*K - Ko;\n" +
"vec3 dx = Pf.x + 0.5 + jitter*ox;\n" +
"vec3 dy = Pf.y - of + jitter*oy;\n" +
"vec3 d1 = dx * dx + dy * dy;\n" +
"p = _agi_permute289(px.y + Pi.y + oi);\n" +
"ox = fract(p*K) - Ko;\n" +
"oy = mod(floor(p*K),7.0)*K - Ko;\n" +
"dx = Pf.x - 0.5 + jitter*ox;\n" +
"dy = Pf.y - of + jitter*oy;\n" +
"vec3 d2 = dx * dx + dy * dy;\n" +
"p = _agi_permute289(px.z + Pi.y + oi);\n" +
"ox = fract(p*K) - Ko;\n" +
"oy = mod(floor(p*K),7.0)*K - Ko;\n" +
"dx = Pf.x - 1.5 + jitter*ox;\n" +
"dy = Pf.y - of + jitter*oy;\n" +
"vec3 d3 = dx * dx + dy * dy;\n" +
"vec3 d1a = min(d1, d2);\n" +
"d2 = max(d1, d2);\n" +
"d2 = min(d2, d3);\n" +
"d1 = min(d1a, d2);\n" +
"d2 = max(d1a, d2);\n" +
"d1.xy = (d1.x < d1.y) ? d1.xy : d1.yx;\n" +
"d1.xz = (d1.x < d1.z) ? d1.xz : d1.zx;\n" +
"d1.yz = min(d1.yz, d2.yz);\n" +
"d1.y = min(d1.y, d1.z);\n" +
"d1.y = min(d1.y, d2.x);\n" +
"return sqrt(d1.xy);\n" +
"}\n" +
"#endif\n" +
"";
});
/*global define*/
define('Scene/BlobMaterial',[
        '../Core/Color',
        '../Shaders/Noise',
        '../Shaders/BlobMaterial'
    ], function(
        Color,
        ShadersNoise,
        ShadersBlobMaterial) {
    

    /**
     * DOC_TBA
     *
     * @alias BlobMaterial
     * @constructor
     */
    var BlobMaterial = function(template) {
        var t = template || {};

        /**
         * DOC_TBA
         */
        this.lightColor = (typeof t.lightColor !== 'undefined') ? Color.clone(t.lightColor) : new Color(1.0, 1.0, 1.0, 0.5);

        /**
         * DOC_TBA
         */
        this.darkColor = (typeof t.darkColor !== 'undefined') ? Color.clone(t.darkColor) : new Color(0.0, 0.0, 1.0, 0.5);

        /**
         * DOC_TBA
         *
         * @type Number
         */
        this.repeat = t.repeat || 20.0;

        var that = this;
        this._uniforms = {
            u_lightColor : function() {
                return that.lightColor;
            },
            u_darkColor : function() {
                return that.darkColor;
            },
            u_repeat : function() {
                return that.repeat;
            }
        };
    };

    BlobMaterial.prototype._getShaderSource = function() {
        return '#line 0\n' +
               ShadersNoise +
               '#line 0\n' +
               ShadersBlobMaterial;
    };

    return BlobMaterial;
});
/*global define*/
define('Scene/FacetMaterial',[
        '../Core/Color',
        '../Shaders/Noise',
        '../Shaders/FacetMaterial'
    ], function(
        Color,
        ShadersNoise,
        ShadersFacetMaterial){
    

    /**
     * DOC_TBA
     *
     * @alias FacetMaterial
     * @constructor
     */
    var FacetMaterial = function(template) {
        var t = template || {};

        /**
         * DOC_TBA
         */
        this.lightColor = (typeof t.lightColor !== 'undefined') ? Color.clone(t.lightColor) : new Color(1.0, 1.0, 1.0, 0.5);

        /**
         * DOC_TBA
         */
        this.darkColor = (typeof t.darkColor !== 'undefined') ? Color.clone(t.darkColor) : new Color(0.0, 0.0, 1.0, 0.5);

        /**
         * DOC_TBA
         *
         * @type Number
         */
        this.repeat = t.repeat || 20.0;

        var that = this;
        this._uniforms = {
            u_lightColor : function() {
                return that.lightColor;
            },
            u_darkColor : function() {
                return that.darkColor;
            },
            u_repeat : function() {
                return that.repeat;
            }
        };
    };

    FacetMaterial.prototype._getShaderSource = function() {
        return '#line 0\n' +
               ShadersNoise +
               '#line 0\n' +
               ShadersFacetMaterial;
    };

    return FacetMaterial;
});

/*global define*/
define('Shaders/PolygonFS',[],function() {
  
  return "uniform float u_erosion;\n" +
"varying vec3 v_positionMC;\n" +
"varying vec3 v_positionEC;\n" +
"varying vec2 v_textureCoordinates;\n" +
"#ifndef RENDER_FOR_PICK\n" +
"void erode(vec3 str)\n" +
"{\n" +
"if (u_erosion != 1.0)\n" +
"{\n" +
"float t = 0.5 + (0.5 * agi_snoise(str / (1.0 / 10.0)));\n" +
"if (t > u_erosion)\n" +
"{\n" +
"discard;\n" +
"}\n" +
"}\n" +
"}\n" +
"#endif\n" +
"vec4 getColor()\n" +
"{\n" +
"float zDistance = 0.0;\n" +
"vec2 st = v_textureCoordinates;\n" +
"vec3 str = vec3(st, 0.0);\n" +
"erode(str);\n" +
"return agi_getMaterialColor(zDistance, st, str);\n" +
"}\n" +
"void main()\n" +
"{\n" +
"vec3 normalEC = normalize(agi_normal * agi_geodeticSurfaceNormal(v_positionMC, vec3(0.0), vec3(1.0)));\n" +
"vec3 positionToEyeEC = normalize(-v_positionEC);\n" +
"#ifdef AFFECTED_BY_LIGHTING\n" +
"float intensity = agi_lightIntensity(normalEC, agi_sunDirectionEC, positionToEyeEC);\n" +
"#else\n" +
"float intensity = 1.0;\n" +
"#endif\n" +
"vec4 color = getColor();\n" +
"gl_FragColor = vec4(intensity * color.rgb, color.a);\n" +
"}\n" +
"";
});

/*global define*/
define('Shaders/PolygonFSPick',[],function() {
  
  return "uniform vec4 u_pickColor;\n" +
"void main()\n" +
"{\n" +
"gl_FragColor = u_pickColor;\n" +
"}\n" +
"";
});

/*global define*/
define('Shaders/PolygonVS',[],function() {
  
  return "attribute vec2 position2D;\n" +
"attribute vec3 position3D;\n" +
"attribute vec2 textureCoordinates;\n" +
"uniform float u_morphTime;\n" +
"uniform float u_height;\n" +
"varying vec3 v_positionMC;\n" +
"varying vec3 v_positionEC;\n" +
"varying vec2 v_textureCoordinates;\n" +
"void main()\n" +
"{\n" +
"vec4 p = agi_columbusViewMorph(vec3(u_height, position2D), position3D, u_morphTime);\n" +
"v_positionMC = position3D;\n" +
"v_positionEC = (agi_modelView * vec4(position3D, 1.0)).xyz;\n" +
"v_textureCoordinates = textureCoordinates;\n" +
"gl_Position = agi_modelViewProjection * p;\n" +
"}\n" +
"";
});

/*global define*/
define('Shaders/PolygonVSPick',[],function() {
  
  return "attribute vec2 position2D;\n" +
"attribute vec3 position3D;\n" +
"uniform float u_morphTime;\n" +
"uniform float u_height;\n" +
"void main()\n" +
"{\n" +
"vec4 p = agi_columbusViewMorph(vec3(u_height, position2D), position3D, u_morphTime);\n" +
"gl_Position = agi_modelViewProjection * p;\n" +
"}\n" +
"";
});
/*global define*/
define('Scene/Polygon',[
        '../Core/DeveloperError',
        '../Core/Color',
        '../Core/combine',
        '../Core/destroyObject',
        '../Core/Cartesian2',
        '../Core/Math',
        '../Core/Ellipsoid',
        '../Core/Rectangle',
        '../Core/Cartesian3',
        '../Core/Cartographic',
        '../Core/ComponentDatatype',
        '../Core/MeshFilters',
        '../Core/PrimitiveType',
        '../Core/EllipsoidTangentPlane',
        '../Core/PolygonPipeline',
        '../Core/WindingOrder',
        '../Core/ExtentTessellator',
        '../Renderer/BlendingState',
        '../Renderer/BufferUsage',
        '../Renderer/CullFace',
        '../Renderer/VertexLayout',
        './ColorMaterial',
        './SceneMode',
        '../Shaders/Noise',
        '../Shaders/PolygonVS',
        '../Shaders/PolygonFS',
        '../Shaders/PolygonVSPick',
        '../Shaders/PolygonFSPick'
    ], function(
        DeveloperError,
        Color,
        combine,
        destroyObject,
        Cartesian2,
        CesiumMath,
        Ellipsoid,
        Rectangle,
        Cartesian3,
        Cartographic,
        ComponentDatatype,
        MeshFilters,
        PrimitiveType,
        EllipsoidTangentPlane,
        PolygonPipeline,
        WindingOrder,
        ExtentTessellator,
        BlendingState,
        BufferUsage,
        CullFace,
        VertexLayout,
        ColorMaterial,
        SceneMode,
        Noise,
        PolygonVS,
        PolygonFS,
        PolygonVSPick,
        PolygonFSPick) {
    

    var attributeIndices = {
        position2D : 0,
        position3D : 1,
        textureCoordinates : 2
    };

    function PositionVertices() {
        this._va = null;
    }

    PositionVertices.prototype.getVertexArrays = function() {
        return this._va;
    };

    PositionVertices.prototype.update = function(context, meshes, bufferUsage) {
        if (typeof meshes !== 'undefined') {
            // Initially create or recreate vertex array and buffers
            this._destroyVA();

            var va = [];

            var length = meshes.length;
            for ( var i = 0; i < length; ++i) {
                va.push(context.createVertexArrayFromMesh({
                    mesh : meshes[i],
                    attributeIndices : attributeIndices,
                    bufferUsage : bufferUsage,
                    vertexLayout : VertexLayout.INTERLEAVED
                }));
            }

            this._va = va;
        } else {
            this._destroyVA();
        }
    };

    PositionVertices.prototype._destroyVA = function() {
        var va = this._va;
        if (va) {
            this._va = null;

            var length = va.length;
            for ( var i = 0; i < length; ++i) {
                va[i].destroy();
            }
        }
    };

    PositionVertices.prototype.isDestroyed = function() {
        return false;
    };

    PositionVertices.prototype.destroy = function() {
        this._destroyVA();
        return destroyObject(this);
    };

    /**
     * DOC_TBA
     *
     * @alias Polygon
     * @constructor
     *
     * @example
     * var polygon = new Polygon();
     * polygon.material.color = {
     *   red   : 1.0,
     *   green : 0.0,
     *   blue  : 0.0,
     *   alpha : 1.0
     * };
     * polygon.setPositions([
     *   ellipsoid.cartographicToCartesian(new Cartographic(...)),
     *   ellipsoid.cartographicToCartesian(new Cartographic(...)),
     *   ellipsoid.cartographicToCartesian(new Cartographic(...))
     * ]);
     */
    var Polygon = function() {
        this._sp = undefined;
        this._rs = undefined;

        this._spPick = undefined;
        this._rsPick = undefined;

        this._vertices = new PositionVertices();
        this._pickId = null;

        /**
         * DOC_TBA
         */
        this.ellipsoid = Ellipsoid.WGS84;
        this._ellipsoid = undefined;

        /**
         * DOC_TBA
         */
        this.height = 0.0;
        this._height = undefined;

        /**
         * DOC_TBA
         */
        this.granularity = CesiumMath.toRadians(1.0);
        this._granularity = undefined;

        /**
         * DOC_TBA
         */
        this.scene2D = {
            /**
             * DOC_TBA
             */
            granularity : CesiumMath.toRadians(30.0)
        };

        /**
         * DOC_TBA
         */
        this.scene3D = {
        /**
         * DOC_TBA
         *
         * granularity can override object-level granularity
         */
        };

        this._positions = undefined;
        this._extent = undefined;
        this._createVertexArray = false;

        /**
         * Determines if this polygon will be shown.
         *
         * @type Boolean
         */
        this.show = true;

        /**
         * The usage hint for the polygon's vertex buffer.
         *
         * @type BufferUsage
         *
         * @performance If <code>bufferUsage</code> changes, the next time
         * {@link Polygon#update} is called, the polygon's vertex buffer
         * is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.
         * For best performance, it is important to provide the proper usage hint.  If the polygon
         * will not change over several frames, use <code>BufferUsage.STATIC_DRAW</code>.
         * If the polygon will change every frame, use <code>BufferUsage.STREAM_DRAW</code>.
         */
        this.bufferUsage = BufferUsage.STATIC_DRAW;
        this._bufferUsage = BufferUsage.STATIC_DRAW;

        /**
         * <p>
         * Determines if the polygon is affected by lighting, i.e., if the polygon is bright on the
         * day side of the globe, and dark on the night side.  When <code>true</code>, the polygon
         * is affected by lighting; when <code>false</code>, the polygon is uniformly shaded regardless
         * of the sun position.
         * </p>
         * <p>
         * The default is <code>true</code>.
         * </p>
         */
        this.affectedByLighting = true;
        this._affectedByLighting = true;

        /**
         * DOC_TBA
         */
        this.material = new ColorMaterial({
            color : new Color(1.0, 1.0, 0.0, 0.5)
        });
        this._material = undefined;

        /**
         * DOC_TBA
         *
         * @type Number
         */
        this.erosion = 1.0;

        this._mode = SceneMode.SCENE3D;
        this._projection = undefined;

        /**
         * The current morph transition time between 2D/Columbus View and 3D,
         * with 0.0 being 2D or Columbus View and 1.0 being 3D.
         *
         * @type Number
         */
        this.morphTime = this._mode.morphTime;

        var that = this;
        this._uniforms = {
            u_erosion : function() {
                return that.erosion;
            },
            u_morphTime : function() {
                return that.morphTime;
            },
            u_height : function() {
                return (that._mode !== SceneMode.SCENE2D) ? that.height : 0.0;
            }
        };
        this._pickUniforms = undefined;
        this._drawUniforms = undefined;
    };

    /**
     * DOC_TBA
     *
     * @memberof Polygon
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see Polygon#setPositions
     */
    Polygon.prototype.getPositions = function() {
        return this._positions;
    };

    /**
     * DOC_TBA
     *
     * @memberof Polygon
     *
     * @exception {DeveloperError} At least three positions are required.
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see Polygon#getPositions
     *
     * @param {Array} positions. The cartesian positions of the polygon.
     * @param {double} [height=0.0]. The height of the polygon.
     *
     * @example
     * polygon.setPositions([
     *   ellipsoid.cartographicToCartesian(new Cartographic(...)),
     *   ellipsoid.cartographicToCartesian(new Cartographic(...)),
     *   ellipsoid.cartographicToCartesian(new Cartographic(...))
     * ], 10.0);
     */
    Polygon.prototype.setPositions = function(positions, height) {
        // positions can be undefined
        if (typeof positions !== 'undefined' && (positions.length < 3)) {
            throw new DeveloperError('At least three positions are required.');
        }
        this.height = height || 0.0;
        this._extent = undefined;
        this._positions = positions;
        this._createVertexArray = true;
    };

    /**
     * DOC_TBA
     *
     * @memberof Polygon
     *
     * @param {extent} extent. The cartographic extent of the tile, with north, south, east and
     * west properties in radians.
     *
     * @param {double} [height=0.0]. The height of the cartographic extent.
     * @example
     * polygon.configureExtent(new Extent(
     *     CesiumMath.toRadians(0.0),
     *     CesiumMath.toRadians(0.0),
     *     CesiumMath.toRadians(10.0),
     *     CesiumMath.toRadians(10.0)
     * ));
     */
    Polygon.prototype.configureExtent = function(extent, height){
        this._extent = extent;
        this.height = height || 0.0;
        this._positions = undefined;
        this._createVertexArray = true;
    };

    Polygon._appendTextureCoordinates = function(tangentPlane, positions2D, mesh) {
        var boundingRectangle = new Rectangle.createAxisAlignedBoundingRectangle(positions2D);
        var origin = new Cartesian2(boundingRectangle.x, boundingRectangle.y);

        var positions = mesh.attributes.position.values;
        var length = positions.length;

        var textureCoordinates = new Float32Array(2 * (length / 3));
        var j = 0;

        // PERFORMANCE_IDEA:  Instead of storing texture coordinates per-vertex, we could
        // save memory by computing them in the fragment shader.  However, projecting
        // the point onto the plane may have precision issues.
        for ( var i = 0; i < length; i += 3) {
            var p = new Cartesian3(positions[i], positions[i + 1], positions[i + 2]);
            var st = tangentPlane.projectPointOntoPlane(p);
            st = st.subtract(origin);

            textureCoordinates[j++] = st.x / boundingRectangle.width;
            textureCoordinates[j++] = st.y / boundingRectangle.height;
        }

        mesh.attributes.textureCoordinates = {
            componentDatatype : ComponentDatatype.FLOAT,
            componentsPerAttribute : 2,
            values : textureCoordinates
        };

        return mesh;
    };

    Polygon.prototype._createMeshes = function() {
        // PERFORMANCE_IDEA:  Move this to a web-worker.
        var mesh;
        var meshes = null;

        if(typeof this._extent !== 'undefined'){
            mesh = ExtentTessellator.compute({extent: this._extent, generateTextureCoords:true});
        }
        else if(typeof this._positions !== 'undefined'){
            var cleanedPositions = PolygonPipeline.cleanUp(this._positions);
            var tangentPlane = EllipsoidTangentPlane.create(this.ellipsoid, cleanedPositions);
            var positions2D = tangentPlane.projectPointsOntoPlane(cleanedPositions);

            var originalWindingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);
            if (originalWindingOrder === WindingOrder.CLOCKWISE) {
                positions2D.reverse();
                cleanedPositions.reverse();
            }
            var indices = PolygonPipeline.earClip2D(positions2D);
            mesh = PolygonPipeline.computeSubdivision(cleanedPositions, indices, this._granularity);
            // PERFORMANCE_IDEA:  Only compute texture coordinates if the material requires them.
            mesh = Polygon._appendTextureCoordinates(tangentPlane, positions2D, mesh);
        }
        else {
            return undefined;
        }
        mesh = PolygonPipeline.scaleToGeodeticHeight(this.ellipsoid, mesh, this.height);
        mesh = MeshFilters.reorderForPostVertexCache(mesh);
        mesh = MeshFilters.reorderForPreVertexCache(mesh);

        if (this._mode === SceneMode.SCENE3D) {
            mesh.attributes.position2D = { // Not actually used in shader
                    value : [0.0, 0.0]
                };
            mesh.attributes.position3D = mesh.attributes.position;
            delete mesh.attributes.position;
        } else {
            mesh = MeshFilters.projectTo2D(mesh, this._projection);
        }
        meshes = MeshFilters.fitToUnsignedShortIndices(mesh);

        return meshes;
    };

    Polygon.prototype._getGranularity = function(mode) {
        if (mode === SceneMode.SCENE3D) {
            return this.scene3D.granularity || this.granularity;
        }

        return this.scene2D.granularity || this.granularity;
    };

    /**
     * Commits changes to properties before rendering by updating the object's WebGL resources.
     * This must be called before calling {@link Polygon#render} in order to realize
     * changes to polygon's positions and properties.
     *
     * @memberof Polygon
     *
     * @exception {DeveloperError} this.ellipsoid must be defined.
     * @exception {DeveloperError} this.granularity must be greater than zero.
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see Polygon#render
     */
    Polygon.prototype.update = function(context, sceneState) {
        if (!this.ellipsoid) {
            throw new DeveloperError('this.ellipsoid must be defined.');
        }

        var mode = sceneState.mode;
        var granularity = this._getGranularity(mode);

        if (granularity < 0.0) {
            throw new DeveloperError('this.granularity and scene2D/scene3D overrides must be greater than zero.');
        }

        if (!this.show) {
            return;
        }

        if (this._ellipsoid !== this.ellipsoid) {
            this._createVertexArray = true;
            this._ellipsoid = this.ellipsoid;
        }

        if (this._height !== this.height) {
            this._createVertexArray = true;
            this._height = this.height;
        }

        if (this._granularity !== granularity) {
            this._createVertexArray = true;
            this._granularity = granularity;
        }

        if (this._bufferUsage !== this.bufferUsage) {
            this._createVertexArray = true;
            this._bufferUsage = this.bufferUsage;
        }

        var projection = sceneState.scene2D.projection;
        if (this._projection !== projection) {
            this._createVertexArray = true;
            this._projection = projection;
        }

        if (this._mode !== mode) {
            // SCENE2D, COLUMBUS_VIEW, and MORPHING use the same rendering path, so a
            // transition only occurs when switching from/to SCENE3D
            this._createVertexArray = this._mode === SceneMode.SCENE3D || mode === SceneMode.SCENE3D;
            this._mode = mode;

            if (typeof mode.morphTime !== 'undefined') {
                this.morphTime = mode.morphTime;
            }
        }

        if (this._createVertexArray) {
            this._createVertexArray = false;
            this._vertices.update(context, this._createMeshes(), this.bufferUsage);
        }

        if (!this._rs) {
            // TODO: Should not need this in 2D/columbus view, but is hiding a triangulation issue.
            this._rs = context.createRenderState({
                cull : {
                    enabled : true,
                    face : CullFace.BACK
                },
                blending : BlendingState.ALPHA_BLEND
            });
        }

        // Recompile shader when material or lighting changes
        if (typeof this._material === 'undefined' ||
            this._material !== this.material ||
            this._affectedByLighting !== this.affectedByLighting) {

            this.material = this.material || new ColorMaterial();
            this._material = this.material;
            this._affectedByLighting = this.affectedByLighting;

            var fsSource =
                '#line 0\n' +
                Noise +
                '#line 0\n' +
                this._material._getShaderSource() +
                (this._affectedByLighting ? '#define AFFECTED_BY_LIGHTING 1\n' : '') +
                '#line 0\n' +
                PolygonFS;

            this._sp = this._sp && this._sp.release();
            this._sp = context.getShaderCache().getShaderProgram(PolygonVS, fsSource, attributeIndices);

            this._drawUniforms = combine(this._uniforms, this._material._uniforms);
        }
    };

    /**
     * Renders the polygon.  In order for changes to positions and properties to be realized,
     * {@link Polygon#update} must be called before <code>render</code>.
     *
     * @memberof Polygon
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see Polygon#update
     * @see Polygon#setTextureAtlas
     */
    Polygon.prototype.render = function(context) {
        if (this.show) {
            var vas = this._vertices.getVertexArrays();
            var length = vas.length;
            for ( var j = 0; j < length; ++j) {
                context.draw({
                    primitiveType : PrimitiveType.TRIANGLES,
                    shaderProgram : this._sp,
                    uniformMap : this._drawUniforms,
                    vertexArray : vas[j],
                    renderState : this._rs
                });
            }
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof Polygon
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     */
    Polygon.prototype.updateForPick = function(context) {
        if (this.show) {
            this._spPick = context.getShaderCache().getShaderProgram(PolygonVSPick, PolygonFSPick, attributeIndices);

            this._rsPick = context.createRenderState({
                // TODO: Should not need this in 2D/columbus view, but is hiding a triangulation issue.
                cull : {
                    enabled : true,
                    face : CullFace.BACK
                }
            });

            this._pickId = context.createPickId(this);

            var that = this;
            this._pickUniforms = {
                u_pickColor : function() {
                    return that._pickId.normalizedRgba;
                },
                u_morphTime : function() {
                    return that.morphTime;
                },
                u_height : function() {
                    return that.height;
                }
            };

            this.updateForPick = function(context) {
            };
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof Polygon
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     */
    Polygon.prototype.renderForPick = function(context, framebuffer) {
        if (this.show) {
            var vas = this._vertices.getVertexArrays();
            var length = vas.length;
            for ( var j = 0; j < length; ++j) {
                context.draw({
                    primitiveType : PrimitiveType.TRIANGLES,
                    shaderProgram : this._spPick,
                    uniformMap : this._pickUniforms,
                    vertexArray : vas[j],
                    renderState : this._rsPick,
                    framebuffer : framebuffer
                });
            }
        }
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof Polygon
     *
     * @return {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     *
     * @see Polygon#destroy
     */
    Polygon.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof Polygon
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see Polygon#isDestroyed
     *
     * @example
     * polygon = polygon && polygon.destroy();
     */
    Polygon.prototype.destroy = function() {
        this._sp = this._sp && this._sp.release();
        this._spPick = this._spPick && this._spPick.release();
        this._vertices = this._vertices.destroy();
        this._pickId = this._pickId && this._pickId.destroy();
        return destroyObject(this);
    };

    return Polygon;
});

/*global define*/
define('DynamicScene/DynamicPolygonVisualizer',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Scene/Polygon',
        '../Scene/ColorMaterial'
       ], function(
         DeveloperError,
         destroyObject,
         Polygon,
         ColorMaterial) {
    

    /**
     * A DynamicObject visualizer which maps the DynamicPolygon instance
     * in DynamicObject.polygon to a Polygon primitive.
     * @alias DynamicPolygonVisualizer
     * @constructor
     *
     * @param {Scene} scene The scene the primitives will be rendered in.
     * @param {DynamicObjectCollection} [dynamicObjectCollection] The dynamicObjectCollection to visualize.
     *
     * @exception {DeveloperError} scene is required.
     *
     * @see DynamicPolygon
     * @see Scene
     * @see DynamicObject
     * @see DynamicObjectCollection
     * @see CompositeDynamicObjectCollection
     * @see VisualizerCollection
     * @see DynamicBillboardVisualizer
     * @see DynamicConeVisualizer
     * @see DynamicConeVisualizerUsingCustomSensorr
     * @see DynamicLabelVisualizer
     * @see DynamicPointVisualizer
     * @see DynamicPolylineVisualizer
     * @see DynamicPyramidVisualizer
     *
     */
    var DynamicPolygonVisualizer = function(scene, dynamicObjectCollection) {
        if (typeof scene === 'undefined') {
            throw new DeveloperError('scene is required.');
        }
        this._scene = scene;
        this._unusedIndexes = [];
        this._primitives = scene.getPrimitives();
        this._polygonCollection = [];
        this._dynamicObjectCollection = undefined;
        this.setDynamicObjectCollection(dynamicObjectCollection);
    };

    /**
     * Returns the scene being used by this visualizer.
     *
     * @returns {Scene} The scene being used by this visualizer.
     */
    DynamicPolygonVisualizer.prototype.getScene = function() {
        return this._scene;
    };

    /**
     * Gets the DynamicObjectCollection being visualized.
     *
     * @returns {DynamicObjectCollection} The DynamicObjectCollection being visualized.
     */
    DynamicPolygonVisualizer.prototype.getDynamicObjectCollection = function() {
        return this._dynamicObjectCollection;
    };

    /**
     * Sets the DynamicObjectCollection to visualize.
     *
     * @param dynamicObjectCollection The DynamicObjectCollection to visualizer.
     */
    DynamicPolygonVisualizer.prototype.setDynamicObjectCollection = function(dynamicObjectCollection) {
        var oldCollection = this._dynamicObjectCollection;
        if (oldCollection !== dynamicObjectCollection) {
            if (typeof oldCollection !== 'undefined') {
                oldCollection.objectsRemoved.removeEventListener(DynamicPolygonVisualizer.prototype._onObjectsRemoved);
                this.removeAllPrimitives();
            }
            this._dynamicObjectCollection = dynamicObjectCollection;
            if (typeof dynamicObjectCollection !== 'undefined') {
                dynamicObjectCollection.objectsRemoved.addEventListener(DynamicPolygonVisualizer.prototype._onObjectsRemoved, this);
            }
        }
    };

    /**
     * Updates all of the primitives created by this visualizer to match their
     * DynamicObject counterpart at the given time.
     *
     * @param {JulianDate} time The time to update to.
     *
     * @exception {DeveloperError} time is required.
     */
    DynamicPolygonVisualizer.prototype.update = function(time) {
        if (typeof time === 'undefined') {
            throw new DeveloperError('time is requied.');
        }
        if (typeof this._dynamicObjectCollection !== 'undefined') {
            var dynamicObjects = this._dynamicObjectCollection.getObjects();
            for ( var i = 0, len = dynamicObjects.length; i < len; i++) {
                this._updateObject(time, dynamicObjects[i]);
            }
        }
    };

    /**
     * Removes all primitives from the scene.
     */
    DynamicPolygonVisualizer.prototype.removeAllPrimitives = function() {
        var i, len;
        for (i = 0, len = this._polygonCollection.length; i < len; i++) {
            this._primitives.remove(this._polygonCollection[i]);
        }

        if (typeof this._dynamicObjectCollection !== 'undefined') {
            var dynamicObjects = this._dynamicObjectCollection.getObjects();
            for (i = dynamicObjects.length - 1; i > -1; i--) {
                dynamicObjects[i]._polygonVisualizerIndex = undefined;
            }
        }

        this._unusedIndexes = [];
        this._polygonCollection = [];
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof DynamicPolygonVisualizer
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see DynamicPolygonVisualizer#destroy
     */
    DynamicPolygonVisualizer.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof DynamicPolygonVisualizer
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see DynamicPolygonVisualizer#isDestroyed
     *
     * @example
     * visualizer = visualizer && visualizer.destroy();
     */
    DynamicPolygonVisualizer.prototype.destroy = function() {
        this.removeAllPrimitives();
        return destroyObject(this);
    };

    DynamicPolygonVisualizer.prototype._updateObject = function(time, dynamicObject) {
        var dynamicPolygon = dynamicObject.polygon;
        if (typeof dynamicPolygon === 'undefined') {
            return;
        }

        var vertexPositionsProperty = dynamicObject.vertexPositions;
        if (typeof vertexPositionsProperty === 'undefined') {
            return;
        }

        var vertexPositions = vertexPositionsProperty.getValueCartesian(time);

        var polygon;
        var showProperty = dynamicPolygon.show;
        var polygonVisualizerIndex = dynamicObject._polygonVisualizerIndex;
        var show = dynamicObject.isAvailable(time) && (typeof showProperty === 'undefined' || showProperty.getValue(time));


        if (!show || typeof vertexPositions === 'undefined' || vertexPositions.length < 3) {
            //don't bother creating or updating anything else
            if (typeof polygonVisualizerIndex !== 'undefined') {
                polygon = this._polygonCollection[polygonVisualizerIndex];
                polygon.show = false;
                dynamicObject._polygonVisualizerIndex = undefined;
                this._unusedIndexes.push(polygonVisualizerIndex);
            }
            return;
        }

        if (typeof polygonVisualizerIndex === 'undefined') {
            var unusedIndexes = this._unusedIndexes;
            var length = unusedIndexes.length;
            if (length > 0) {
                polygonVisualizerIndex = unusedIndexes.pop();
                polygon = this._polygonCollection[polygonVisualizerIndex];
            } else {
                polygonVisualizerIndex = this._polygonCollection.length;
                polygon = new Polygon();
                this._polygonCollection.push(polygon);
                this._primitives.add(polygon);
            }
            dynamicObject._polygonVisualizerIndex = polygonVisualizerIndex;
            polygon.dynamicObject = dynamicObject;

            // CZML_TODO Determine official defaults
            polygon.material = new ColorMaterial();
        } else {
            polygon = this._polygonCollection[polygonVisualizerIndex];
        }

        polygon.show = true;

        if (polygon._visualizerPositions !== vertexPositions) {
            polygon.setPositions(vertexPositions);
            polygon._visualizerPositions = vertexPositions;
        }

        var material = dynamicPolygon.material;
        if (typeof material !== 'undefined') {
            polygon.material = material.getValue(time, this._scene.getContext(), polygon.material);
        }
    };

    DynamicPolygonVisualizer.prototype._onObjectsRemoved = function(dynamicObjectCollection, dynamicObjects) {
        var thisPolygonCollection = this._polygonCollection;
        var thisUnusedIndexes = this._unusedIndexes;
        for ( var i = dynamicObjects.length - 1; i > -1; i--) {
            var dynamicObject = dynamicObjects[i];
            var polygonVisualizerIndex = dynamicObject._polygonVisualizerIndex;
            if (typeof polygonVisualizerIndex !== 'undefined') {
                var polygon = thisPolygonCollection[polygonVisualizerIndex];
                polygon.show = false;
                thisUnusedIndexes.push(polygonVisualizerIndex);
                dynamicObject._polygonVisualizerIndex = undefined;
            }
        }
    };

    return DynamicPolygonVisualizer;
});

/*global define*/
define('Shaders/PolylineFS',[],function() {
  
  return "varying vec4 v_color;\n" +
"void main()\n" +
"{\n" +
"gl_FragColor = v_color;\n" +
"}\n" +
"";
});

/*global define*/
define('Shaders/PolylineVS',[],function() {
  
  return "attribute vec3 position2D;\n" +
"attribute vec3 position3D;\n" +
"attribute vec4 color;\n" +
"attribute float show;\n" +
"varying vec4 v_color;\n" +
"uniform float u_morphTime;\n" +
"void main()\n" +
"{\n" +
"#ifdef GROUND_TRACK\n" +
"vec4 p = agi_columbusViewMorph(vec3(0.0, position2D.xy), position3D, u_morphTime);\n" +
"#elif defined(HEIGHT_TRACK)\n" +
"vec4 p = agi_columbusViewMorph(vec3(position2D.z, position2D.x, 10000000.0), position3D, u_morphTime);\n" +
"#else\n" +
"vec4 p = agi_columbusViewMorph(position2D.zxy, position3D, u_morphTime);\n" +
"#endif\n" +
"gl_Position = agi_modelViewProjection * p * show;\n" +
"v_color = color;\n" +
"}\n" +
"";
});
/*global define*/
define('Scene/PolylineCollection',[
        '../Core/DeveloperError',
        '../Core/combine',
        '../Core/destroyObject',
        '../Core/Cartesian3',
        '../Core/Cartesian4',
        '../Core/Matrix4',
        '../Core/ComponentDatatype',
        '../Core/IndexDatatype',
        '../Core/PrimitiveType',
        '../Core/PolylinePipeline',
        '../Core/Color',
        '../Renderer/BlendingState',
        '../Renderer/BufferUsage',
        './SceneMode',
        './Polyline',
        '../Shaders/PolylineVS',
        '../Shaders/PolylineFS',
        '../Renderer/StencilFunction',
        '../Renderer/StencilOperation'
    ], function(
        DeveloperError,
        combine,
        destroyObject,
        Cartesian3,
        Cartesian4,
        Matrix4,
        ComponentDatatype,
        IndexDatatype,
        PrimitiveType,
        PolylinePipeline,
        Color,
        BlendingState,
        BufferUsage,
        SceneMode,
        Polyline,
        PolylineVS,
        PolylineFS,
        StencilFunction,
        StencilOperation) {
    

    var SHOW_INDEX = Polyline.SHOW_INDEX;
    var POSITION_INDEX = Polyline.POSITION_INDEX;
    var COLOR_INDEX = Polyline.COLOR_INDEX;
    var OUTLINE_COLOR_INDEX = Polyline.OUTLINE_COLOR_INDEX;
    var WIDTH_INDEX = Polyline.WIDTH_INDEX;
    var OUTLINE_WIDTH_INDEX = Polyline.OUTLINE_WIDTH_INDEX;
    //POSITION_SIZE_INDEX is needed for when the polyline's position array changes size.
    //When it does, we need to recreate the indicesBuffer.
    var POSITION_SIZE_INDEX = Polyline.POSITION_SIZE_INDEX;
    var NUMBER_OF_PROPERTIES = Polyline.NUMBER_OF_PROPERTIES;
    var SIXTYFOURK = 64 * 1024;

    var attributeIndices = {
        position3D : 0,
        position2D : 1,
        color : 2,
        pickColor : 3,
        show : 4
    };

    /**
     * A renderable collection of polylines.
     * <br /><br />
     * <div align="center">
     * <img src="images/Polyline.png" width="400" height="300" /><br />
     * Example polylines
     * </div>
     * <br /><br />
     * Polylines are added and removed from the collection using {@link PolylineCollection#add}
     * and {@link PolylineCollection#remove}.
     *
     * @alias PolylineCollection
     * @constructor
     *
     * @performance For best performance, prefer a few collections, each with many polylines, to
     * many collections with only a few polylines each.  Organize collections so that polylines
     * with the same update frequency are in the same collection, i.e., polylines that do not
     * change should be in one collection; polylines that change every frame should be in another
     * collection; and so on.
     *
     * @see PolylineCollection#add
     * @see PolylineCollection#remove
     * @see Polyline
     * @see LabelCollection
     *
     * @example
     * // Create a polyline collection with two polylines
     * var polylines = new Cesium.PolylineCollection(undefined);
     * polylines.add({positions:ellipsoid.cartographicDegreesToCartesians([
     *     new Cesium.Cartographic2(-75.10, 39.57),
     *     new Cesium.Cartographic2(-77.02, 38.53),
     *     new Cesium.Cartographic2(-80.50, 35.14),
     *     new Cesium.Cartographic2(-80.12, 25.46)]),
           width:2
           });

     * polylines.add({positions:ellipsoid.cartographicDegreesToCartesians([
     *     new Cesium.Cartographic2(-73.10, 37.57),
     *     new Cesium.Cartographic2(-75.02, 36.53),
     *     new Cesium.Cartographic2(-78.50, 33.14),
     *     new Cesium.Cartographic2(-78.12, 23.46)]),
     *     width:4
     * });
     */
    var PolylineCollection = function() {
        this._polylinesUpdated = false;
        this._polylinesRemoved = false;
        this._createVertexArray = false;
        this.morphTime = 1.0;
        this._propertiesChanged = new Uint32Array(NUMBER_OF_PROPERTIES);
        this._polylines = [];
        this._polylineBuckets = {};

        this.modelMatrix = Matrix4.IDENTITY;
        this._modelMatrix = Matrix4.IDENTITY;

        // The buffer usage for each attribute is determined based on the usage of the attribute over time.
        this._buffersUsage = [
                              {bufferUsage: BufferUsage.STATIC_DRAW, frameCount:0},// SHOW_INDEX
                              {bufferUsage: BufferUsage.STATIC_DRAW, frameCount:0}, // POSITION_INDEX
                              {bufferUsage: BufferUsage.STATIC_DRAW, frameCount:0}, // COLOR_INDEX
                              {bufferUsage: BufferUsage.STATIC_DRAW, frameCount:0}, // OUTLINE_COLOR_INDEX
                              {bufferUsage: BufferUsage.STATIC_DRAW, frameCount:0}, // WIDTH_INDEX
                              {bufferUsage: BufferUsage.STATIC_DRAW, frameCount:0} // OUTLINE_WIDTH_INDEX
        ];

        this._mode = undefined;
        var that = this;

        var drawUniformsOne = {
            u_morphTime : function() {
                return that.morphTime;
            }
        };
        var drawUniformsTwo = {
            u_morphTime : function() {
                return that.morphTime;
            }
        };
        var drawUniformsThree = {
            u_morphTime : function() {
                return that.morphTime;
            }
        };
        var pickUniforms = {
            u_morphTime : function() {
                return that.morphTime;
            }
        };

        this._drawUniformsOne3D = combine(drawUniformsOne, {
            u_model : function() {
                return that._getModelMatrix(that._mode);
            }
        });

        this._drawUniformsTwo3D = combine(drawUniformsTwo, {
            u_model : function() {
                return that._getModelMatrix(that._mode);
            }
        });
        this._drawUniformsThree3D = combine(drawUniformsThree, {
            u_model : function() {
                return that._getModelMatrix(that._mode);
            }
        });
        this._pickUniforms3D = combine(pickUniforms, {
            u_model : function() {
                return that._getModelMatrix(that._mode);
            }
        });

        this._drawUniformsOne2D = combine(drawUniformsOne, {
            u_model : function() {
                return Matrix4.IDENTITY;
            }
        });
        this._drawUniformsTwo2D = combine(drawUniformsTwo, {
            u_model : function() {
                return Matrix4.IDENTITY;
            }
        });
        this._drawUniformsThree2D = combine(drawUniformsThree, {
            u_model : function() {
                return Matrix4.IDENTITY;
            }
        });
        this._pickUniforms2D = combine(pickUniforms, {
            u_model : function() {
                return Matrix4.IDENTITY;
            }
        });

        this._drawUniformsOne = undefined;
        this._drawUniformsTwo = undefined;
        this._drawUniformsThree = undefined;
        this._polylinesToUpdate = [];
        this._colorVertexArrays = [];
        this._outlineColorVertexArrays = [];
        this._pickColorVertexArrays = [];
        this._positionBuffer = undefined;
        this._outlineColorBuffer = undefined;
        this._colorBuffer = undefined;
        this._pickColorBuffer = undefined;
        this._showBuffer = undefined;
    };

    /**
     * Creates and adds a polyline with the specified initial properties to the collection.
     * The added polyline is returned so it can be modified or removed from the collection later.
     *
     * @memberof PolylineCollection
     *
     * @param {Object}[polyline=undefined] A template describing the polyline's properties as shown in Example 1.
     *
     * @return {Polyline} The polyline that was added to the collection.
     *
     * @performance After calling <code>add</code>, {@link PolylineCollection#update} is called and
     * the collection's vertex buffer is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.
     * For best performance, add as many polylines as possible before calling <code>update</code>.
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see PolylineCollection#remove
     * @see PolylineCollection#removeAll
     * @see PolylineCollection#update
     *
     * @example
     * // Example 1:  Add a polyline, specifying all the default values.
     * var p = polylines.add({
     *   show : true,
     *   positions : ellipsoid.cartographicDegreesToCartesians([
     *     new Cesium.Cartographic2(-75.10, 39.57),
     *     new Cesium.Cartographic2(-77.02, 38.53)]),
     *     color : { red : 1.0, green : 1.0, blue : 1.0, alpha : 1.0 },
     *     width : 1,
     *     outlineWidth : 2
     * });
     *
     */
    PolylineCollection.prototype.add = function(polyline) {
        var p = new Polyline(polyline, this);
        p._index = this._polylines.length;
        this._polylines.push(p);
        this._createVertexArray = true;
        return p;
    };

    /**
     * Removes a polyline from the collection.
     *
     * @memberof PolylineCollection
     *
     * @param {Polyline} polyline The polyline to remove.
     *
     * @return {Boolean} <code>true</code> if the polyline was removed; <code>false</code> if the polyline was not found in the collection.
     *
     * @performance After calling <code>remove</code>, {@link PolylineCollection#update} is called and
     * the collection's vertex buffer is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.
     * For best performance, remove as many polylines as possible before calling <code>update</code>.
     * If you intend to temporarily hide a polyline, it is usually more efficient to call
     * {@link Polyline#setShow} instead of removing and re-adding the polyline.
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see PolylineCollection#add
     * @see PolylineCollection#removeAll
     * @see PolylineCollection#update
     * @see Polyline#setShow
     *
     * @example
     * var p = polylines.add(...);
     * polylines.remove(p);  // Returns true
     */
    PolylineCollection.prototype.remove = function(polyline) {
        if (this.contains(polyline)) {
            this._polylines[polyline._index] = null; // Removed later
            this._polylinesRemoved = true;
            this._createVertexArray = true;
            polyline._destroy();
            return true;
        }

        return false;
    };

    /**
     * Removes all polylines from the collection.
     *
     * @performance <code>O(n)</code>.  It is more efficient to remove all the polylines
     * from a collection and then add new ones than to create a new collection entirely.
     *
     * @memberof PolylineCollection
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see PolylineCollection#add
     * @see PolylineCollection#remove
     * @see PolylineCollection#update
     *
     * @example
     * polylines.add(...);
     * polylines.add(...);
     * polylines.removeAll();
     */
    PolylineCollection.prototype.removeAll = function() {
        this._destroyPolylines();
        this._polylineBuckets = {};
        this._polylinesRemoved = false;
        this._polylines.length = 0;
        this._polylinesToUpdate.length = 0;
        this._createVertexArray = true;
    };

    /**
     * Determines if this collection contains the specified polyline.
     *
     * @memberof PolylineCollection
     *
     * @param {Object} polyline
     *
     * @see PolylineCollection#get
     */
    PolylineCollection.prototype.contains = function(polyline) {
        return (polyline && (polyline._getCollection() === this));
    };

    /**
     * Returns the polyline in the collection at the specified index.  Indices are zero-based
     * and increase as polylines are added.  Removing a polyline shifts all polylines after
     * it to the left, changing their indices.  This function is commonly used with
     * {@link PolylineCollection#getLength} to iterate over all the polylines
     * in the collection.
     *
     * @memberof PolylineCollection
     *
     * @param {Number} index The zero-based index of the polyline.
     *
     * @return {Polyline} The polyline at the specified index.
     *
     * @performance If polylines were removed from the collection and
     * {@link PolylineCollection#update} was not called, an implicit <code>O(n)</code>
     * operation is performed.
     *
     * @exception {DeveloperError} index is required.
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see PolylineCollection#getLength
     *
     * @example
     * // Toggle the show property of every polyline in the collection
     * var len = polylines.getLength();
     * for (var i = 0; i < len; ++i) {
     *   var p = polylines.get(i);
     *   p.setShow(!p.getShow());
     * }
     */
    PolylineCollection.prototype.get = function(index) {
        if (typeof index === 'undefined') {
            throw new DeveloperError('index is required.');
        }

        this._removePolylines();
        return this._polylines[index];
    };

    /**
     * Returns the number of polylines in this collection.  This is commonly used with
     * {@link PolylineCollection#get} to iterate over all the polylines
     * in the collection.
     *
     * @memberof PolylineCollection
     *
     * @return {Number} The number of polylines in this collection.
     *
     * @performance If polylines were removed from the collection and
     * {@link PolylineCollection#update} was not called, an implicit <code>O(n)</code>
     * operation is performed.
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see PolylineCollection#get
     *
     * @example
     * // Toggle the show property of every polyline in the collection
     * var len = polylines.getLength();
     * for (var i = 0; i < len; ++i) {
     *   var p = polylines.get(i);
     *   p.setShow(!p.getShow());
     * }
     */
    PolylineCollection.prototype.getLength = function() {
        this._removePolylines();
        return this._polylines.length;
    };

    /**
     * Renders the polylines.  In order for changes to properties to be realized,
     * {@link PolylineCollection#update} must be called before <code>render</code>.
     * <br /><br />
     * <br /><br />
     * Polylines are rendered in a single pass using an uber-shader.
     *
     * @memberof PolylineCollection
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see PolylineCollection#update
     */
    PolylineCollection.prototype.render = function(context) {
        var polylineBuckets = this._polylineBuckets;
        if (polylineBuckets) {
            var length = this._colorVertexArrays.length;
            for ( var i = 0; i < length; ++i) {
                var vaColor = this._colorVertexArrays[i];
                var vaOutlineColor = this._outlineColorVertexArrays[i];
                var buckets = this._colorVertexArrays[i].buckets;
                var bucketLength = buckets.length;
                for ( var j = 0; j < bucketLength; ++j) {
                    var bucketLocator = buckets[j];
                    context.draw({
                        primitiveType : PrimitiveType.LINES,
                        count : bucketLocator.count,
                        offset : bucketLocator.offset,
                        shaderProgram : this._sp,
                        uniformMap : this._drawUniformsOne,
                        vertexArray : vaOutlineColor.va,
                        renderState : bucketLocator.rsOne
                    });
                    context.draw({
                        primitiveType : PrimitiveType.LINES,
                        count : bucketLocator.count,
                        offset : bucketLocator.offset,
                        shaderProgram : this._sp,
                        uniformMap : this._drawUniformsTwo,
                        vertexArray : vaColor.va,
                        renderState : bucketLocator.rsTwo
                    });
                    context.draw({
                        primitiveType : PrimitiveType.LINES,
                        count : bucketLocator.count,
                        offset : bucketLocator.offset,
                        shaderProgram : this._sp,
                        uniformMap : this._drawUniformsThree,
                        vertexArray : vaOutlineColor.va,
                        renderState : bucketLocator.rsThree
                    });
                }
            }
        }
    };

    /**
     * DOC_TBA
     * @memberof PolylineCollection
     */
    PolylineCollection.prototype.renderForPick = function(context, framebuffer) {
        var polylineBuckets = this._polylineBuckets;
        if (polylineBuckets) {
            var length = this._pickColorVertexArrays.length;
            for ( var i = 0; i < length; ++i) {
                var vaPickColor = this._pickColorVertexArrays[i];
                var buckets = vaPickColor.buckets;
                var bucketLength = buckets.length;
                for ( var j = 0; j < bucketLength; ++j) {
                    var bucketLocator = buckets[j];
                    context.draw({
                        primitiveType : PrimitiveType.LINES,
                        count : bucketLocator.count,
                        offset : bucketLocator.offset,
                        shaderProgram : this._sp,
                        uniformMap : this._pickUniforms,
                        vertexArray : vaPickColor.va,
                        renderState : bucketLocator.rsPick,
                        framebuffer : framebuffer
                    });
                }
            }
        }
    };

    /**
     * Commits changes to properties before rendering by updating the object's WebGL resources.
     * This must be called before calling {@link PolylineCollection#render} in order to realize
     * changes to PolylineCollection positions and properties.
     *
     *
     * @memberof PolylineCollection
     *
     */
    PolylineCollection.prototype.update = function(context, sceneState) {
        if (!this._sp) {
            this._sp = context.getShaderCache().getShaderProgram(PolylineVS, PolylineFS, attributeIndices);
        }
        this._removePolylines();
        this._updateMode(sceneState);
        var bucket;
        var polyline;
        var properties = this._propertiesChanged;
        if (this._createVertexArray || this._computeNewBuffersUsage()) {
            this._createVertexArrays(context);
        } else if (this._polylinesUpdated) {
            // Polylines were modified, but no polylines were added or removed.
            var polylinesToUpdate = this._polylinesToUpdate;
            var createVertexArrays = false;
            if (this._mode !== SceneMode.SCENE3D) {
                var updateLength = polylinesToUpdate.length;
                for ( var i = 0; i < updateLength; ++i) {
                    polyline = polylinesToUpdate[i];
                    var changedProperties = polyline._getChangedProperties();
                    if (changedProperties[POSITION_INDEX]) {
                        bucket = polyline._bucket;
                        if (bucket.getPolylinePositionsLength(polyline) !== polyline._actualLength) {
                            createVertexArrays = true;
                            break;
                        }
                    }
                }
            }
            //if a polyline's positions size changes, we need to recreate the vertex arrays and vertex buffers because the indices will be different.
            if (properties[POSITION_SIZE_INDEX] || properties[WIDTH_INDEX] || properties[OUTLINE_WIDTH_INDEX] || createVertexArrays) {
                this._createVertexArrays(context);
            } else {
                var length = polylinesToUpdate.length;
                var polylineBuckets = this._polylineBuckets;
                for ( var ii = 0; ii < length; ++ii) {
                    polyline = polylinesToUpdate[ii];
                    properties = polyline._getChangedProperties();
                    bucket = polyline._bucket;
                    var index = 0;
                    for ( var x in polylineBuckets) {
                        if (polylineBuckets.hasOwnProperty(x)) {
                            if (polylineBuckets[x] === bucket) {
                                if (properties[POSITION_INDEX]) {
                                    bucket.writePositionsUpdate(index, polyline, this._positionBuffer);
                                }
                                if (properties[COLOR_INDEX]) {
                                    bucket.writeColorUpdate(index, polyline, this._colorBuffer);
                                }
                                if (properties[OUTLINE_COLOR_INDEX]) {
                                    bucket.writeColorUpdate(index, polyline, this._outlineColorBuffer);
                                }
                                if (properties[SHOW_INDEX]) {
                                    bucket.writeShowUpdate(index, polyline, this._showBuffer);
                                }
                                break;
                            }
                            index += polylineBuckets[x].lengthOfPositions;
                        }
                    }
                    polyline._clean();
                }
            }
            polylinesToUpdate.length = 0;
            this._polylinesUpdated = false;
        }
        for ( var k = 0; k < NUMBER_OF_PROPERTIES; ++k) {
            properties[k] = 0;
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof PolylineCollection
     */
    PolylineCollection.prototype.updateForPick = function(context) {
        var useDepthTest = (this.morphTime !== 0.0);
        var polylineBuckets = this._polylineBuckets;
        for ( var x in polylineBuckets) {
            if (polylineBuckets.hasOwnProperty(x)) {
                var obj = polylineBuckets[x];
                var rs = obj.rsPick || context.createRenderState();
                rs.depthTest.enabled = useDepthTest;
                rs.lineWidth = obj.width + obj.outlineWidth;
                rs.depthMask = !useDepthTest;
                obj.rsPick = rs;
            }
        }
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof PolylineCollection
     *
     * @return {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     *
     * @see PolylineCollection#destroy
     */
    PolylineCollection.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof PolylineCollection
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see PolylineCollection#isDestroyed
     *
     * @example
     * polylines = polylines && polylines.destroy();
     */
    PolylineCollection.prototype.destroy = function() {
        this._sp = this._sp && this._sp.release();
        this._destroyVertexArrays();
        this._destroyPolylines();
        return destroyObject(this);
    };

    PolylineCollection.prototype._computeNewBuffersUsage = function() {
        var buffersUsage = this._buffersUsage;
        var usageChanged = false;

        var properties = this._propertiesChanged;
        //subtract 1 from NUMBER_OF_PROPERTIES because we don't care about POSITION_SIZE_INDEX property change.
        for ( var k = 0; k < NUMBER_OF_PROPERTIES - 1; ++k) {
            var bufferUsage = buffersUsage[k];
            if(properties[k]){
                if(bufferUsage.bufferUsage !== BufferUsage.STREAM_DRAW){
                    usageChanged = true;
                    bufferUsage.bufferUsage = BufferUsage.STREAM_DRAW;
                    bufferUsage.frameCount = 100;
                }
                else{
                    bufferUsage.frameCount = 100;
                }
            } else {
                if(bufferUsage.bufferUsage !== BufferUsage.STATIC_DRAW){
                    if(bufferUsage.frameCount === 0){
                        usageChanged = true;
                        bufferUsage.bufferUsage = BufferUsage.STATIC_DRAW;
                    }
                    else{
                        bufferUsage.frameCount--;
                    }
                }
            }
        }
        return usageChanged;
    };

    PolylineCollection.prototype._createVertexArrays = function(context) {
        this._createVertexArray = false;
        this._destroyVertexArrays();
        this._sortPolylinesIntoBuckets();
        //stores all of the individual indices arrays.
        var totalIndices = [];
        var indices = [];

        //used to determine the vertexBuffer offset if the indicesArray goes over 64k.
        //if it's the same polyline while it goes over 64k, the offset needs to backtrack componentsPerAttribute * componentDatatype bytes
        //so that the polyline looks contiguous.
        //if the polyline ends at the 64k mark, then the offset is just 64k * componentsPerAttribute * componentDatatype
        var vertexBufferOffset = [0];
        totalIndices.push(indices);
        var offset = 0;
        var useDepthTest = (this.morphTime !== 0.0);
        var vertexArrayBuckets = [[]];
        var totalLength = 0;
        var polylineBuckets = this._polylineBuckets;
        var x;
        var bucket;
        for (x in polylineBuckets) {
            if (polylineBuckets.hasOwnProperty(x)) {
                bucket = polylineBuckets[x];
                bucket.updateRenderState(context, useDepthTest);
                totalLength += bucket.lengthOfPositions;
            }
        }
        if (totalLength > 0) {
            var positionArray = new Float32Array(totalLength * 3);
            var outlineColorArray = new Uint8Array(totalLength * 4);
            var colorArray = new Uint8Array(totalLength * 4);
            var pickColorArray = new Uint8Array(totalLength * 4);
            var showArray = new Uint8Array(totalLength);
            var position3DArray;

            var positionIndex = 0;
            var colorIndex = 0;
            var showIndex = 0;
            for (x in polylineBuckets) {
                if (polylineBuckets.hasOwnProperty(x)) {
                    bucket = polylineBuckets[x];
                    bucket.write(positionArray, colorArray, outlineColorArray, pickColorArray, showArray, positionIndex, showIndex, colorIndex, context);
                    if (this._mode === SceneMode.MORPHING) {
                        if (typeof position3DArray === 'undefined') {
                            position3DArray = new Float32Array(totalLength * 3);
                        }
                        bucket.writeForMorph(position3DArray, positionIndex);
                    }
                    var bucketLength = bucket.lengthOfPositions;
                    positionIndex += bucketLength * 3;
                    showIndex += bucketLength;
                    colorIndex += bucketLength * 4;
                    offset += bucket.updateIndices(totalIndices, vertexBufferOffset, vertexArrayBuckets, offset);
                }
            }
            this._positionBuffer = context.createVertexBuffer(positionArray, this._buffersUsage[POSITION_INDEX].bufferUsage);
            var position3DBuffer;
            if (typeof position3DArray !== 'undefined') {
                position3DBuffer = context.createVertexBuffer(position3DArray, this._buffersUsage[POSITION_INDEX].bufferUsage);
            }
            this._outlineColorBuffer = context.createVertexBuffer(outlineColorArray, this._buffersUsage[OUTLINE_COLOR_INDEX].bufferUsage);
            this._colorBuffer = context.createVertexBuffer(colorArray, this._buffersUsage[COLOR_INDEX].bufferUsage);
            this._pickColorBuffer = context.createVertexBuffer(pickColorArray, BufferUsage.STATIC_DRAW);
            this._showBuffer = context.createVertexBuffer(showArray, this._buffersUsage[SHOW_INDEX].bufferUsage);
            var colorSizeInBytes = 4 * Uint8Array.BYTES_PER_ELEMENT;
            var positionSizeInBytes = 3 * Float32Array.BYTES_PER_ELEMENT;
            var vbo = 0;
            var numberOfIndicesArrays = totalIndices.length;
            for ( var k = 0; k < numberOfIndicesArrays; ++k) {
                indices = totalIndices[k];
                if (indices.length > 0) {
                    var indicesArray = new Uint16Array(indices);
                    var indexBuffer = context.createIndexBuffer(indicesArray, BufferUsage.STATIC_DRAW, IndexDatatype.UNSIGNED_SHORT);
                    indexBuffer.setVertexArrayDestroyable(false);
                    vbo += vertexBufferOffset[k];
                    var vertexPositionBufferOffset = k * (positionSizeInBytes * SIXTYFOURK) - vbo * positionSizeInBytes;//componentsPerAttribute(3) * componentDatatype(4)
                    var vertexColorBufferOffset = k * (colorSizeInBytes * SIXTYFOURK) - vbo * colorSizeInBytes;
                    var vertexShowBufferOffset = k * SIXTYFOURK - vbo;
                    var attributes = [{
                        index : attributeIndices.position3D,
                        componentsPerAttribute : 3,
                        componentDatatype : ComponentDatatype.FLOAT,
                        offsetInBytes : vertexPositionBufferOffset
                    }, {
                        index : attributeIndices.position2D,
                        componentsPerAttribute : 3,
                        componentDatatype : ComponentDatatype.FLOAT,
                        offsetInBytes : vertexPositionBufferOffset
                    }, {
                        index : attributeIndices.color,
                        componentsPerAttribute : 4,
                        normalize : true,
                        componentDatatype : ComponentDatatype.UNSIGNED_BYTE,
                        vertexBuffer : this._colorBuffer,
                        offsetInBytes : vertexColorBufferOffset
                    }, {
                        index : attributeIndices.show,
                        componentsPerAttribute : 1,
                        componentDatatype : ComponentDatatype.UNSIGNED_BYTE,
                        vertexBuffer : this._showBuffer,
                        offsetInBytes : vertexShowBufferOffset
                    }];

                    var attributesOutlineColor = [{
                        index : attributeIndices.position3D,
                        componentsPerAttribute : 3,
                        componentDatatype : ComponentDatatype.FLOAT,
                        offsetInBytes : vertexPositionBufferOffset
                    }, {
                        index : attributeIndices.position2D,
                        componentsPerAttribute : 3,
                        componentDatatype : ComponentDatatype.FLOAT,
                        offsetInBytes : vertexPositionBufferOffset
                    }, {
                        index : attributeIndices.color,
                        componentsPerAttribute : 4,
                        normalize : true,
                        componentDatatype : ComponentDatatype.UNSIGNED_BYTE,
                        vertexBuffer : this._outlineColorBuffer,
                        offsetInBytes : vertexColorBufferOffset
                    }, {
                        index : attributeIndices.show,
                        componentsPerAttribute : 1,
                        componentDatatype : ComponentDatatype.UNSIGNED_BYTE,
                        vertexBuffer : this._showBuffer,
                        offsetInBytes : vertexShowBufferOffset
                    }];

                    var attributesPickColor = [{
                        index : attributeIndices.position3D,
                        componentsPerAttribute : 3,
                        componentDatatype : ComponentDatatype.FLOAT,
                        offsetInBytes : vertexPositionBufferOffset
                    }, {
                        index : attributeIndices.position2D,
                        componentsPerAttribute : 3,
                        componentDatatype : ComponentDatatype.FLOAT,
                        offsetInBytes : vertexPositionBufferOffset
                    }, {
                        index : attributeIndices.color,
                        componentsPerAttribute : 4,
                        normalize : true,
                        componentDatatype : ComponentDatatype.UNSIGNED_BYTE,
                        vertexBuffer : this._pickColorBuffer,
                        offsetInBytes : vertexColorBufferOffset
                    }, {
                        index : attributeIndices.show,
                        componentsPerAttribute : 1,
                        componentDatatype : ComponentDatatype.UNSIGNED_BYTE,
                        vertexBuffer : this._showBuffer,
                        offsetInBytes : vertexShowBufferOffset
                    }];

                    if (this._mode === SceneMode.SCENE3D) {
                        attributes[0].vertexBuffer = this._positionBuffer;
                        attributes[1].value = [0.0, 0.0];
                        attributesOutlineColor[0].vertexBuffer = this._positionBuffer;
                        attributesOutlineColor[1].value = [0.0, 0.0];
                        attributesPickColor[0].vertexBuffer = this._positionBuffer;
                        attributesPickColor[1].value = [0.0, 0.0];
                    } else if (this._mode === SceneMode.SCENE2D || this._mode === SceneMode.COLUMBUS_VIEW) {
                        attributes[0].value = [0.0, 0.0, 0.0];
                        attributes[1].vertexBuffer = this._positionBuffer;
                        attributesOutlineColor[0].value = [0.0, 0.0, 0.0];
                        attributesOutlineColor[1].vertexBuffer = this._positionBuffer;
                        attributesPickColor[0].value = [0.0, 0.0, 0.0];
                        attributesPickColor[1].vertexBuffer = this._positionBuffer;
                    } else {
                        attributes[0].vertexBuffer = position3DBuffer;
                        attributes[1].vertexBuffer = this._positionBuffer;
                        attributesOutlineColor[0].vertexBuffer = position3DBuffer;
                        attributesOutlineColor[1].vertexBuffer = this._positionBuffer;
                        attributesPickColor[0].vertexBuffer = position3DBuffer;
                        attributesPickColor[1].vertexBuffer = this._positionBuffer;
                    }
                    var va = context.createVertexArray(attributes, indexBuffer);
                    var vaOutlineColor = context.createVertexArray(attributesOutlineColor, indexBuffer);
                    var vaPickColor = context.createVertexArray(attributesPickColor, indexBuffer);

                    this._colorVertexArrays.push({
                        va : va,
                        buckets : vertexArrayBuckets[k]
                    });
                    this._outlineColorVertexArrays.push({
                        va : vaOutlineColor,
                        buckets : vertexArrayBuckets[k]
                    });
                    this._pickColorVertexArrays.push({
                        va : vaPickColor,
                        buckets : vertexArrayBuckets[k]
                    });
                }
            }
        }
    };

    PolylineCollection.prototype._sortPolylinesIntoBuckets = function() {
        var polylineBuckets = this._polylineBuckets = {};
        var polylines = this._polylines;
        var length = polylines.length;
        for ( var i = 0; i < length; ++i) {
            var p = polylines[i];
            var outlineWidth = p.getOutlineWidth();
            var width = p.getWidth();
            var hash = 'OL' + outlineWidth + 'W' + width;
            var value = polylineBuckets[hash];
            if (typeof value === 'undefined') {
                value = polylineBuckets[hash] = new PolylineBucket(outlineWidth, width, this._mode, this._projection, this._modelMatrix);
            }
            value.addPolyline(p);
        }
    };

    PolylineCollection.prototype._updateMode = function(sceneState) {
        var mode = sceneState.mode;
        var projection = sceneState.scene2D.projection;
        if (this._mode !== mode && typeof mode.morphTime !== 'undefined') {
            this.morphTime = mode.morphTime;
        }
        if (this._mode !== mode || (this._projection !== projection) || (!this._modelMatrix.equals(this.modelMatrix))) {
            this._mode = mode;
            this._projection = projection;
            this._modelMatrix = this.modelMatrix.clone();
            switch (mode) {
            case SceneMode.SCENE3D:
                this._drawUniformsOne = this._drawUniformsOne3D;
                this._drawUniformsTwo = this._drawUniformsTwo3D;
                this._drawUniformsThree = this._drawUniformsThree3D;
                this._pickUniforms = this._pickUniforms3D;
                break;
            case SceneMode.SCENE2D:
            case SceneMode.COLUMBUS_VIEW:
                this._drawUniformsOne = this._drawUniformsOne2D;
                this._drawUniformsTwo = this._drawUniformsTwo2D;
                this._drawUniformsThree = this._drawUniformsThree2D;
                this._pickUniforms = this._pickUniforms2D;
                break;
            }
            this._createVertexArray = true;
        }
    };

    PolylineCollection.prototype._getModelMatrix = function(mode) {
        switch (mode) {
        case SceneMode.SCENE3D:
            return this.modelMatrix;

        case SceneMode.SCENE2D:
        case SceneMode.COLUMBUS_VIEW:
            return this.modelMatrix;

        case SceneMode.MORPHING:
            return Matrix4.IDENTITY;
        }
    };

    PolylineCollection.prototype._removePolylines = function() {
        if (this._polylinesRemoved) {
            this._polylinesRemoved = false;

            var polylines = [];

            var length = this._polylines.length;
            for ( var i = 0, j = 0; i < length; ++i) {
                var polyline = this._polylines[i];
                if (polyline) {
                    polyline._index = j++;
                    polylines.push(polyline);
                }
            }

            this._polylines = polylines;
        }
    };

    PolylineCollection.prototype._destroyVertexArrays = function() {
        var length = this._colorVertexArrays.length;
        for ( var t = 0; t < length; ++t) {
            this._colorVertexArrays[t].va.destroy();
            this._pickColorVertexArrays[t].va.destroy();
            this._outlineColorVertexArrays[t].va.destroy();
        }
        this._colorVertexArrays.length = 0;
        this._pickColorVertexArrays.length = 0;
        this._outlineColorVertexArrays.length = 0;
    };

    PolylineCollection.prototype._updatePolyline = function(propertyChanged, polyline) {
        this._polylinesUpdated = true;
        this._polylinesToUpdate.push(polyline);
        ++this._propertiesChanged[propertyChanged];
    };

    PolylineCollection.prototype._destroyPolylines = function() {
        var polylines = this._polylines;
        var length = polylines.length;
        for ( var i = 0; i < length; ++i) {
            if (polylines[i]) {
                polylines[i]._destroy();
            }
        }
    };

    /**
     * @private
     */
    function VertexArrayBucketLocator(count, offset, bucket) {
        this.count = count;
        this.offset = offset;
        this.rsOne = bucket.rsOne;
        this.rsTwo = bucket.rsTwo;
        this.rsThree = bucket.rsThree;
        this.rsPick = bucket.rsPick;
    }

    /**
     * @private
     */
    var PolylineBucket = function(outlineWidth, width, mode, projection, modelMatrix) {
        this.width = width;
        this.outlineWidth = outlineWidth;
        this.polylines = [];
        this.lengthOfPositions = 0;
        this.rsOne = undefined;
        this.rsTwo = undefined;
        this.rsThree = undefined;
        this.rsPick = undefined;
        this.mode = mode;
        this.projection = projection;
        this.ellipsoid = projection.getEllipsoid();
        this.modelMatrix = modelMatrix;
    };

    /**
     * @private
     */
    PolylineBucket.prototype.addPolyline = function(p) {
        var polylines = this.polylines;
        polylines.push(p);
        p._actualLength = this.getPolylinePositionsLength(p);
        this.lengthOfPositions += p._actualLength;
        p._bucket = this;
    };

    /**
     * @private
     */
    PolylineBucket.prototype.updateRenderState = function(context, useDepthTest) {
        var rsOne = this.rsOne || context.createRenderState({
            colorMask : {
                red : false,
                green : false,
                blue : false,
                alpha : false
            },
            lineWidth : 1,
            blending : BlendingState.ALPHA_BLEND,
            stencilTest : {
                enabled : true,
                frontFunction : StencilFunction.ALWAYS,
                backFunction : StencilFunction.ALWAYS,
                reference : 0,
                mask : ~0,
                frontOperation : {
                    fail : StencilOperation.REPLACE,
                    zFail : StencilOperation.REPLACE,
                    zPass : StencilOperation.REPLACE
                },
                backOperation : {
                    fail : StencilOperation.REPLACE,
                    zFail : StencilOperation.REPLACE,
                    zPass : StencilOperation.REPLACE
                }
            }
        });
        rsOne.depthMask = !useDepthTest;
        rsOne.depthTest.enabled = useDepthTest;
        rsOne.lineWidth = this.width + this.outlineWidth;
        this.rsOne = rsOne;
        var rsTwo = this.rsTwo || context.createRenderState({
            lineWidth : 1,
            depthMask : false,
            blending : BlendingState.ALPHA_BLEND,
            stencilTest : {
                enabled : true,
                frontFunction : StencilFunction.ALWAYS,
                backFunction : StencilFunction.ALWAYS,
                reference : 1,
                mask : ~0,
                frontOperation : {
                    fail : StencilOperation.KEEP,
                    zFail : StencilOperation.KEEP,
                    zPass : StencilOperation.REPLACE
                },
                backOperation : {
                    fail : StencilOperation.KEEP,
                    zFail : StencilOperation.KEEP,
                    zPass : StencilOperation.REPLACE
                }
            }
        });
        rsTwo.depthTest.enabled = useDepthTest;
        rsTwo.lineWidth = this.width;
        this.rsTwo = rsTwo;
        var rsThree = this.rsThree || context.createRenderState({
            lineWidth : 1,
            depthMask : false,
            blending : BlendingState.ALPHA_BLEND,
            stencilTest : {
                enabled : true,
                frontFunction : StencilFunction.NOT_EQUAL,
                backFunction : StencilFunction.NOT_EQUAL,
                reference : 1,
                mask : ~0,
                frontOperation : {
                    fail : StencilOperation.KEEP,
                    zFail : StencilOperation.KEEP,
                    zPass : StencilOperation.KEEP
                },
                backOperation : {
                    fail : StencilOperation.KEEP,
                    zFail : StencilOperation.KEEP,
                    zPass : StencilOperation.KEEP
                }
            }
        });
        rsThree.lineWidth = this.width + this.outlineWidth;
        rsThree.depthTest.enabled = useDepthTest;
        this.rsThree = rsThree;
    };

    /**
     * @private
     */
    PolylineBucket.prototype.getPolylinePositionsLength = function(polyline) {
        if (this.mode === SceneMode.SCENE3D) {
            return polyline.getPositions().length;
        }
        var ellipsoid = this.ellipsoid;
        var positions = polyline.getPositions();
        var segments = PolylinePipeline.wrapLongitude(ellipsoid, positions);
        polyline._segments = segments;
        var numberOfSegments = segments.length;
        var length = 0;
        for ( var i = 0; i < numberOfSegments; ++i) {
            var segment = segments[i];
            var segmentLength = segment.length;
            var startN = ((i === 0) || (segmentLength === 2)) ? 0 : 1;
            length += segmentLength - startN;
        }
        return length;
    };

    /**
     * @private
     */
    PolylineBucket.prototype.write = function(positionArray, colorArray, outlineColorArray, pickColorArray, showArray, positionIndex, showIndex, colorIndex, context) {
        var polylines = this.polylines;
        var length = polylines.length;
        for ( var i = 0; i < length; ++i) {
            var polyline = polylines[i];
            var color = polyline.getColor();
            var show = polyline.getShow();
            var outlineColor = polyline.getOutlineColor();
            var pickColor = polyline.getPickId(context).unnormalizedRgb;
            var positions = this._getPositions(polyline);
            var positionsLength = positions.length;
            for ( var j = 0; j < positionsLength; ++j) {
                var position = positions[j];
                positionArray[positionIndex] = position.x;
                positionArray[positionIndex + 1] = position.y;
                positionArray[positionIndex + 2] = position.z;
                outlineColorArray[colorIndex] = Color.floatToByte(outlineColor.red);
                outlineColorArray[colorIndex + 1] = Color.floatToByte(outlineColor.green);
                outlineColorArray[colorIndex + 2] = Color.floatToByte(outlineColor.blue);
                outlineColorArray[colorIndex + 3] = Color.floatToByte(outlineColor.alpha);
                colorArray[colorIndex] = Color.floatToByte(color.red);
                colorArray[colorIndex + 1] = Color.floatToByte(color.green);
                colorArray[colorIndex + 2] = Color.floatToByte(color.blue);
                colorArray[colorIndex + 3] = Color.floatToByte(color.alpha);
                pickColorArray[colorIndex] = pickColor.red;
                pickColorArray[colorIndex + 1] = pickColor.green;
                pickColorArray[colorIndex + 2] = pickColor.blue;
                pickColorArray[colorIndex + 3] = 255;
                showArray[showIndex++] = show;
                positionIndex += 3;
                colorIndex += 4;
            }
        }
    };

    /**
     * @private
     */
    PolylineBucket.prototype.writeForMorph = function(positionArray, positionIndex) {
        var polylines = this.polylines;
        var length = polylines.length;
        for ( var i = 0; i < length; ++i) {
            var polyline = polylines[i];
            var positions = polyline.getPositions();
            var segments = PolylinePipeline.wrapLongitude(this.ellipsoid, positions);
            var numberOfSegments = segments.length;
            for ( var j = 0; j < numberOfSegments; ++j) {
                var segment = segments[j];
                var segmentLength = segment.length;
                var startN = ((j === 0) || (segmentLength === 2)) ? 0 : 1;
                for ( var n = startN; n < segmentLength; ++n) {
                    positionArray[positionIndex] = positions[segment[n].index].x;
                    positionArray[positionIndex + 1] = positions[segment[n].index].y;
                    positionArray[positionIndex + 2] = positions[segment[n].index].z;
                    positionIndex += 3;
                }
            }
        }
    };

    /**
     * @private
     */
    PolylineBucket.prototype._updateIndices3D = function(totalIndices, vertexBufferOffset, vertexArrayBuckets, offset) {
        var vaCount = vertexArrayBuckets.length - 1;
        var bucketLocator = new VertexArrayBucketLocator(0, offset, this);
        vertexArrayBuckets[vaCount].push(bucketLocator);
        var count = 0;
        var indices = totalIndices[totalIndices.length - 1];
        var indicesCount = 0;
        if (indices.length > 0) {
            indicesCount = indices[indices.length - 1] + 1;
        }
        var polylines = this.polylines;
        var length = polylines.length;
        for ( var i = 0; i < length; ++i) {
            var polyline = polylines[i];
            var positions = polyline.getPositions();
            var positionsLength = positions.length;
            for ( var j = 0; j < positionsLength; ++j) {
                if (j !== positionsLength - 1) {
                    if (indicesCount === SIXTYFOURK - 1) {
                        vertexBufferOffset.push(1);
                        indices = [];
                        totalIndices.push(indices);
                        indicesCount = 0;
                        bucketLocator.count = count;
                        count = 0;
                        offset = 0;
                        bucketLocator = new VertexArrayBucketLocator(0, 0, this);
                        vertexArrayBuckets[++vaCount] = [bucketLocator];
                    }
                    count += 2;
                    offset += 2;
                    indices.push(indicesCount++);
                    indices.push(indicesCount);
                }
            }
            polyline._clean();
            if (indicesCount < SIXTYFOURK - 1) {
                indicesCount++;
            } else {
                vertexBufferOffset.push(0);
                indices = [];
                totalIndices.push(indices);
                indicesCount = 0;
                bucketLocator.count = count;
                offset = 0;
                count = 0;
                bucketLocator = new VertexArrayBucketLocator(0, 0, this);
                vertexArrayBuckets[++vaCount] = [bucketLocator];
            }
        }
        bucketLocator.count = count;
        return offset;
    };

    /**
     * @private
     */
    PolylineBucket.prototype._updateIndices2D = function(totalIndices, vertexBufferOffset, vertexArrayBuckets, offset) {
        var vaCount = vertexArrayBuckets.length - 1;
        var bucketLocator = new VertexArrayBucketLocator(0, offset, this);
        vertexArrayBuckets[vaCount].push(bucketLocator);
        var count = 0;
        var indices = totalIndices[totalIndices.length - 1];
        var indicesCount = 0;
        if (indices.length > 0) {
            indicesCount = indices[indices.length - 1] + 1;
        }
        var polylines = this.polylines;
        var length = polylines.length;
        for ( var i = 0; i < length; ++i) {
            var polyline = polylines[i];
            var segments = polyline._segments;
            var numberOfSegments = segments.length;
            for ( var k = 0; k < numberOfSegments; ++k) {
                var segment = segments[k];
                var segmentLength = segment.length;
                var startN = ((k === 0) || (segmentLength === 2)) ? 0 : 1;
                for ( var n = startN; n < segmentLength; ++n) {
                    if (n !== segmentLength - 1) {
                        if (indicesCount === SIXTYFOURK - 1) {
                            vertexBufferOffset.push(1);
                            indices = [];
                            totalIndices.push(indices);
                            indicesCount = 0;
                            bucketLocator.count = count;
                            count = 0;
                            offset = 0;
                            bucketLocator = new VertexArrayBucketLocator(0, 0, this);
                            vertexArrayBuckets[++vaCount] = [bucketLocator];
                        }
                        count += 2;
                        offset += 2;
                        indices.push(indicesCount++);
                        indices.push(indicesCount);
                    }
                }
                if (k !== numberOfSegments - 1) {
                    indicesCount++;
                }
            }
            polyline._clean();
            if (indicesCount < SIXTYFOURK - 1) {
                indicesCount++;
            } else {
                vertexBufferOffset.push(0);
                indices = [];
                totalIndices.push(indices);
                indicesCount = 0;
                bucketLocator.count = count;
                offset = 0;
                count = 0;
                bucketLocator = new VertexArrayBucketLocator(0, 0, this);
                vertexArrayBuckets[++vaCount] = [bucketLocator];
            }
        }
        bucketLocator.count = count;
        return offset;
    };

    /**
     * @private
     */
    PolylineBucket.prototype.updateIndices = function(totalIndices, vertexBufferOffset, vertexArrayBuckets, offset) {
        if (this.mode === SceneMode.SCENE3D) {
            return this._updateIndices3D(totalIndices, vertexBufferOffset, vertexArrayBuckets, offset);
        }
        return this._updateIndices2D(totalIndices, vertexBufferOffset, vertexArrayBuckets, offset);
    };

    /**
     * @private
     */
    PolylineBucket.prototype._getPolylineStartIndex = function(polyline) {
        var polylines = this.polylines;
        var positionIndex = 0;
        var length = polylines.length;
        for ( var i = 0; i < length; ++i) {
            var p = polylines[i];
            if (p === polyline) {
                break;
            }
            positionIndex += p._actualLength;
        }
        return positionIndex;
    };

    /**
     * @private
     */
    PolylineBucket.prototype._getPositions = function(polyline) {
        if (this.mode === SceneMode.SCENE3D) {
            return polyline.getPositions();
        }
        var ellipsoid = this.ellipsoid;
        var projection = this.projection;
        var newPositions = [];
        var modelMatrix = this.modelMatrix;
        var segments = polyline._segments;
        var numberOfSegments = segments.length;

        for ( var i = 0; i < numberOfSegments; ++i) {
            var segment = segments[i];
            var segmentLength = segment.length;
            var startN = ((i === 0) || (segmentLength === 2)) ? 0 : 1;
            for ( var n = startN; n < segmentLength; ++n) {
                var position = segment[n].cartesian;
                var p = modelMatrix.multiplyByVector(new Cartesian4(position.x, position.y, position.z, 1.0));
                newPositions.push(projection.project(ellipsoid.cartesianToCartographic(Cartesian3.fromCartesian4(p))));
            }
        }
        return newPositions;
    };

    /**
     * @private
     */
    PolylineBucket.prototype.writePositionsUpdate = function(positionIndex, polyline, buffer) {
        var positionsLength = polyline._actualLength;
        if (positionsLength) {
            positionIndex += this._getPolylineStartIndex(polyline);
            var positionsArray = new Float32Array(positionsLength * 3);
            var index = 0;
            var positions = this._getPositions(polyline);
            for ( var i = 0; i < positionsLength; ++i) {
                var position = positions[i];
                positionsArray[index] = position.x;
                positionsArray[index + 1] = position.y;
                positionsArray[index + 2] = position.z;
                index += 3;
            }

            buffer.copyFromArrayView(positionsArray, 12 * positionIndex);
        }
    };

    /**
     * @private
     */
    PolylineBucket.prototype.writeColorUpdate = function(positionIndex, polyline, buffer) {
        var positionsLength = polyline._actualLength;
        if (positionsLength) {
            positionIndex += this._getPolylineStartIndex(polyline);

            var index = 0;
            var color = polyline.getColor();
            var red = Color.floatToByte(color.red);
            var green = Color.floatToByte(color.green);
            var blue = Color.floatToByte(color.blue);
            var alpha = Color.floatToByte(color.alpha);
            var colorsArray = new Uint8Array(positionsLength * 4);
            for ( var j = 0; j < positionsLength; ++j) {
                colorsArray[index] = red;
                colorsArray[index + 1] = green;
                colorsArray[index + 2] = blue;
                colorsArray[index + 3] = alpha;
                index += 4;
            }
            buffer.copyFromArrayView(colorsArray, 4 * positionIndex);
        }
    };

    /**
     * @private
     */
    PolylineBucket.prototype.writeShowUpdate = function(positionIndex, polyline, buffer) {
        var positionsLength = polyline._actualLength;
        if (positionsLength) {
            positionIndex += this._getPolylineStartIndex(polyline);
            var show = polyline.getShow();
            var showArray = new Uint8Array(positionsLength);
            for ( var j = 0; j < positionsLength; ++j) {
                showArray[j] = show;
            }
            buffer.copyFromArrayView(showArray, positionIndex);
        }
    };

    return PolylineCollection;
});
/*global define*/
define('DynamicScene/DynamicPolylineVisualizer',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/Color',
        '../Scene/PolylineCollection'
       ], function(
         DeveloperError,
         destroyObject,
         Color,
         PolylineCollection) {
    

    /**
     * A DynamicObject visualizer which maps the DynamicPolyline instance
     * in DynamicObject.polyline to a Polyline primitive.
     * @alias DynamicPolylineVisualizer
     * @constructor
     *
     * @param {Scene} scene The scene the primitives will be rendered in.
     * @param {DynamicObjectCollection} [dynamicObjectCollection] The dynamicObjectCollection to visualize.
     *
     * @exception {DeveloperError} scene is required.
     *
     * @see DynamicPolyline
     * @see Scene
     * @see DynamicObject
     * @see DynamicObjectCollection
     * @see CompositeDynamicObjectCollection
     * @see VisualizerCollection
     * @see DynamicBillboardVisualizer
     * @see DynamicConeVisualizer
     * @see DynamicConeVisualizerUsingCustomSensorr
     * @see DynamicLabelVisualizer
     * @see DynamicPointVisualizer
     * @see DynamicPolygonVisualizer
     * @see DynamicPyramidVisualizer
     *
     */
    var DynamicPolylineVisualizer = function(scene, dynamicObjectCollection) {
        if (typeof scene === 'undefined') {
            throw new DeveloperError('scene is required.');
        }
        this._scene = scene;
        this._unusedIndexes = [];
        this._primitives = scene.getPrimitives();
        var polylineCollection = this._polylineCollection = new PolylineCollection();
        scene.getPrimitives().add(polylineCollection);
        this._dynamicObjectCollection = undefined;
        this.setDynamicObjectCollection(dynamicObjectCollection);
    };

    /**
     * Returns the scene being used by this visualizer.
     *
     * @returns {Scene} The scene being used by this visualizer.
     */
    DynamicPolylineVisualizer.prototype.getScene = function() {
        return this._scene;
    };

    /**
     * Gets the DynamicObjectCollection being visualized.
     *
     * @returns {DynamicObjectCollection} The DynamicObjectCollection being visualized.
     */
    DynamicPolylineVisualizer.prototype.getDynamicObjectCollection = function() {
        return this._dynamicObjectCollection;
    };

    /**
     * Sets the DynamicObjectCollection to visualize.
     *
     * @param dynamicObjectCollection The DynamicObjectCollection to visualizer.
     */
    DynamicPolylineVisualizer.prototype.setDynamicObjectCollection = function(dynamicObjectCollection) {
        var oldCollection = this._dynamicObjectCollection;
        if (oldCollection !== dynamicObjectCollection) {
            if (typeof oldCollection !== 'undefined') {
                oldCollection.objectsRemoved.removeEventListener(DynamicPolylineVisualizer.prototype._onObjectsRemoved);
                this.removeAllPrimitives();
            }
            this._dynamicObjectCollection = dynamicObjectCollection;
            if (typeof dynamicObjectCollection !== 'undefined') {
                dynamicObjectCollection.objectsRemoved.addEventListener(DynamicPolylineVisualizer.prototype._onObjectsRemoved, this);
            }
        }
    };

    /**
     * Updates all of the primitives created by this visualizer to match their
     * DynamicObject counterpart at the given time.
     *
     * @param {JulianDate} time The time to update to.
     *
     * @exception {DeveloperError} time is required.
     */
    DynamicPolylineVisualizer.prototype.update = function(time) {
        if (typeof time === 'undefined') {
            throw new DeveloperError('time is requied.');
        }
        if (typeof this._dynamicObjectCollection !== 'undefined') {
            var dynamicObjects = this._dynamicObjectCollection.getObjects();
            for ( var i = 0, len = dynamicObjects.length; i < len; i++) {
                this._updateObject(time, dynamicObjects[i]);
            }
        }
    };

    /**
     * Removes all primitives from the scene.
     */
    DynamicPolylineVisualizer.prototype.removeAllPrimitives = function() {
        var i;
        this._polylineCollection.removeAll();

        if (typeof this._dynamicObjectCollection !== 'undefined') {
            var dynamicObjects = this._dynamicObjectCollection.getObjects();
            for (i = dynamicObjects.length - 1; i > -1; i--) {
                dynamicObjects[i]._polylineVisualizerIndex = undefined;
            }
        }

        this._unusedIndexes = [];
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof DynamicPolylineVisualizer
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see DynamicPolylineVisualizer#destroy
     */
    DynamicPolylineVisualizer.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof DynamicPolylineVisualizer
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see DynamicPolylineVisualizer#isDestroyed
     *
     * @example
     * visualizer = visualizer && visualizer.destroy();
     */
    DynamicPolylineVisualizer.prototype.destroy = function() {
        this.removeAllPrimitives();
        this._scene.getPrimitives().remove(this._polylineCollection);
        return destroyObject(this);
    };

    DynamicPolylineVisualizer.prototype._updateObject = function(time, dynamicObject) {
        var dynamicPolyline = dynamicObject.polyline;
        if (typeof dynamicPolyline === 'undefined') {
            return;
        }

        var vertexPositionsProperty = dynamicObject.vertexPositions;
        if (typeof vertexPositionsProperty === 'undefined') {
            return;
        }

        var polyline;
        var showProperty = dynamicPolyline.show;
        var polylineVisualizerIndex = dynamicObject._polylineVisualizerIndex;
        var show = dynamicObject.isAvailable(time) && (typeof showProperty === 'undefined' || showProperty.getValue(time));

        if (!show) {
            //don't bother creating or updating anything else
            if (typeof polylineVisualizerIndex !== 'undefined') {
                polyline = this._polylineCollection.get(polylineVisualizerIndex);
                polyline.setShow(false);
                dynamicObject._polylineVisualizerIndex = undefined;
                this._unusedIndexes.push(polylineVisualizerIndex);
            }
            return;
        }

        if (typeof polylineVisualizerIndex === 'undefined') {
            var unusedIndexes = this._unusedIndexes;
            var length = unusedIndexes.length;
            if (length > 0) {
                polylineVisualizerIndex = unusedIndexes.pop();
                polyline = this._polylineCollection.get(polylineVisualizerIndex);
            } else {
                polylineVisualizerIndex = this._polylineCollection.getLength();
                polyline = this._polylineCollection.add();
            }
            dynamicObject._polylineVisualizerIndex = polylineVisualizerIndex;
            polyline.dynamicObject = dynamicObject;

            // CZML_TODO Determine official defaults
            polyline.setColor(Color.WHITE);
            polyline.setOutlineColor(Color.BLACK);
            polyline.setOutlineWidth(1);
            polyline.setWidth(1);
        } else {
            polyline = this._polylineCollection.get(polylineVisualizerIndex);
        }

        polyline.setShow(true);

        var vertexPositions = vertexPositionsProperty.getValueCartesian(time);
        if (typeof vertexPositions !== 'undefined' && polyline._visualizerPositions !== vertexPositions) {
            polyline.setPositions(vertexPositions);
            polyline._visualizerPositions = vertexPositions;
        }

        var property = dynamicPolyline.color;
        if (typeof property !== 'undefined') {
            polyline.setColor(property.getValue(time, polyline.getColor()));
        }

        property = dynamicPolyline.outlineColor;
        if (typeof property !== 'undefined') {
            polyline.setOutlineColor(property.getValue(time, polyline.getOutlineColor()));
        }

        property = dynamicPolyline.outlineWidth;
        if (typeof property !== 'undefined') {
            var outlineWidth = property.getValue(time);
            if (typeof outlineWidth !== 'undefined') {
                polyline.setOutlineWidth(outlineWidth);
            }
        }

        property = dynamicPolyline.width;
        if (typeof property !== 'undefined') {
            var width = property.getValue(time);
            if (typeof width !== 'undefined') {
                polyline.setWidth(width);
            }
        }
    };

    DynamicPolylineVisualizer.prototype._onObjectsRemoved = function(dynamicObjectCollection, dynamicObjects) {
        var thisPolylineCollection = this._polylineCollection;
        var thisUnusedIndexes = this._unusedIndexes;
        for ( var i = dynamicObjects.length - 1; i > -1; i--) {
            var dynamicObject = dynamicObjects[i];
            var polylineVisualizerIndex = dynamicObject._polylineVisualizerIndex;
            if (typeof polylineVisualizerIndex !== 'undefined') {
                var polyline = thisPolylineCollection.get(polylineVisualizerIndex);
                polyline.setShow(false);
                thisUnusedIndexes.push(polylineVisualizerIndex);
                dynamicObject._polylineVisualizerIndex = undefined;
            }
        }
    };

    return DynamicPolylineVisualizer;
});

/*global define*/
define('Shaders/Ray',[],function() {
  
  return "const int agi_raySegmentCollectionCapacity = 4;\n" +
"struct agi_raySegmentCollection\n" +
"{\n" +
"agi_raySegment intervals[agi_raySegmentCollectionCapacity];\n" +
"int count;\n" +
"};\n" +
"agi_raySegmentCollection agi_raySegmentCollectionNew()\n" +
"{\n" +
"agi_raySegment intervals[agi_raySegmentCollectionCapacity];\n" +
"agi_raySegmentCollection i = agi_raySegmentCollection(intervals, 0);\n" +
"return i;\n" +
"}\n" +
"agi_raySegmentCollection agi_raySegmentCollectionNew(agi_raySegment segment)\n" +
"{\n" +
"agi_raySegment intervals[agi_raySegmentCollectionCapacity];\n" +
"intervals[0] = segment;\n" +
"agi_raySegmentCollection i = agi_raySegmentCollection(intervals, 1);\n" +
"return i;\n" +
"}\n" +
"agi_raySegmentCollection agi_raySegmentCollectionNew(agi_raySegment first, agi_raySegment second)\n" +
"{\n" +
"agi_raySegment intervals[agi_raySegmentCollectionCapacity];\n" +
"intervals[0] = first;\n" +
"intervals[1] = second;\n" +
"agi_raySegmentCollection i = agi_raySegmentCollection(intervals, 2);\n" +
"return i;\n" +
"}\n" +
"void agi_removeAt(inout agi_raySegmentCollection collection, int index)\n" +
"{\n" +
"--collection.count;\n" +
"for (int i = 0; i < agi_raySegmentCollectionCapacity; ++i)\n" +
"{\n" +
"if (i >= index && i < collection.count)\n" +
"{\n" +
"collection.intervals[i] = collection.intervals[i + 1];\n" +
"}\n" +
"else if (i == collection.count)\n" +
"{\n" +
"break;\n" +
"}\n" +
"}\n" +
"}\n" +
"void agi_insertAt(inout agi_raySegmentCollection collection, agi_raySegment segment, int index)\n" +
"{\n" +
"for (int i = agi_raySegmentCollectionCapacity - 1; i >= 0; --i)\n" +
"{\n" +
"if (i <= collection.count && i > index)\n" +
"{\n" +
"collection.intervals[i] = collection.intervals[i - 1];\n" +
"}\n" +
"else if (i == index)\n" +
"{\n" +
"collection.intervals[i] = segment;\n" +
"}\n" +
"else if (i < index)\n" +
"{\n" +
"break;\n" +
"}\n" +
"}\n" +
"++collection.count;\n" +
"}\n" +
"void agi_insertAt(inout agi_raySegmentCollection collection, agi_raySegmentCollection segments, int index)\n" +
"{\n" +
"if (segments.count == 1)\n" +
"{\n" +
"agi_insertAt(collection, segments.intervals[0], index);\n" +
"}\n" +
"else\n" +
"{\n" +
"for (int i = agi_raySegmentCollectionCapacity - 1; i >= 0; --i)\n" +
"{\n" +
"if (i < segments.count)\n" +
"{\n" +
"agi_insertAt(collection, segments.intervals[i], index);\n" +
"}\n" +
"}\n" +
"}\n" +
"}\n" +
"void agi_complement(agi_raySegment segment, out agi_raySegmentCollection collection)\n" +
"{\n" +
"if (agi_isEmpty(segment))\n" +
"{\n" +
"collection = agi_raySegmentCollectionNew(agi_fullRaySegment);\n" +
"}\n" +
"else if (segment.stop == agi_infinity)\n" +
"{\n" +
"if (segment.start == 0.0)\n" +
"{\n" +
"collection = agi_raySegmentCollectionNew();\n" +
"}\n" +
"else\n" +
"{\n" +
"collection = agi_raySegmentCollectionNew(agi_raySegment(0.0, segment.start));\n" +
"}\n" +
"}\n" +
"else if (segment.start == 0.0)\n" +
"{\n" +
"collection = agi_raySegmentCollectionNew(agi_raySegment(segment.stop, agi_infinity));\n" +
"}\n" +
"else\n" +
"{\n" +
"agi_raySegment head = agi_raySegment(0.0, segment.start);\n" +
"agi_raySegment tail = agi_raySegment(segment.stop, agi_infinity);\n" +
"collection = agi_raySegmentCollectionNew(head, tail);\n" +
"}\n" +
"}\n" +
"agi_raySegmentCollection agi_complement(agi_raySegmentCollection collection)\n" +
"{\n" +
"if (collection.count == 0)\n" +
"{\n" +
"agi_raySegmentCollection result = agi_raySegmentCollectionNew(agi_fullRaySegment);\n" +
"return result;\n" +
"}\n" +
"else if (collection.count == 1)\n" +
"{\n" +
"agi_raySegmentCollection result;\n" +
"agi_complement(collection.intervals[0], result);\n" +
"return result;\n" +
"}\n" +
"agi_raySegmentCollection result = agi_raySegmentCollectionNew();\n" +
"for (int i = 0; i < agi_raySegmentCollectionCapacity; ++i)\n" +
"{\n" +
"if (i < collection.count)\n" +
"{\n" +
"float start = collection.intervals[i].stop;\n" +
"if (i < collection.count - 1)\n" +
"{\n" +
"float stop = collection.intervals[i + 1].start;\n" +
"result.intervals[i] = agi_raySegment(start, stop);\n" +
"++result.count;\n" +
"}\n" +
"else if (start != agi_infinity)\n" +
"{\n" +
"result.intervals[i] = agi_raySegment(start, agi_infinity);\n" +
"++result.count;\n" +
"}\n" +
"}\n" +
"else\n" +
"{\n" +
"break;\n" +
"}\n" +
"}\n" +
"if (collection.count > 0)\n" +
"{\n" +
"float stop = collection.intervals[0].start;\n" +
"if (stop != 0.0)\n" +
"{\n" +
"agi_insertAt(result, agi_raySegment(0.0, stop), 0);\n" +
"}\n" +
"}\n" +
"return result;\n" +
"}\n" +
"agi_raySegmentCollection agi_union(agi_raySegment left, agi_raySegment right)\n" +
"{\n" +
"if (agi_isFull(left) || agi_isFull(right))\n" +
"{\n" +
"agi_raySegmentCollection result = agi_raySegmentCollectionNew(agi_fullRaySegment);\n" +
"return result;\n" +
"}\n" +
"float stop = min(left.stop, right.stop);\n" +
"float start = max(left.start, right.start);\n" +
"if (stop < start)\n" +
"{\n" +
"agi_raySegmentCollection result = (left.start < right.start) ? agi_raySegmentCollectionNew(left, right) : agi_raySegmentCollectionNew(right, left);\n" +
"return result;\n" +
"}\n" +
"agi_raySegmentCollection result = agi_raySegmentCollectionNew(agi_raySegment(min(left.start, right.start), max(left.stop, right.stop)));\n" +
"return result;\n" +
"}\n" +
"agi_raySegment agi_intersection(agi_raySegment left, agi_raySegment right)\n" +
"{\n" +
"float stop = min(left.stop, right.stop);\n" +
"if (stop < 0.0)\n" +
"{\n" +
"return agi_emptyRaySegment;\n" +
"}\n" +
"float start = max(left.start, right.start);\n" +
"if (stop < start)\n" +
"{\n" +
"return agi_emptyRaySegment;\n" +
"}\n" +
"agi_raySegment s = agi_raySegment(start, stop);\n" +
"return s;\n" +
"}\n" +
"agi_raySegmentCollection agi_intersection(agi_raySegmentCollection left, agi_raySegment right)\n" +
"{\n" +
"if (left.count == 1)\n" +
"{\n" +
"agi_raySegment intersection = agi_intersection(left.intervals[0], right);\n" +
"if (agi_isEmpty(intersection))\n" +
"{\n" +
"agi_raySegmentCollection result = agi_raySegmentCollectionNew();\n" +
"return result;\n" +
"}\n" +
"else\n" +
"{\n" +
"agi_raySegmentCollection result = agi_raySegmentCollectionNew(intersection);\n" +
"return result;\n" +
"}\n" +
"}\n" +
"agi_raySegmentCollection result = agi_raySegmentCollectionNew();\n" +
"for (int leftIndex = 0; leftIndex < agi_raySegmentCollectionCapacity; ++leftIndex)\n" +
"{\n" +
"if (leftIndex < left.count)\n" +
"{\n" +
"agi_raySegment intersection = agi_intersection(left.intervals[leftIndex], right);\n" +
"if (!agi_isEmpty(intersection))\n" +
"{\n" +
"agi_insertAt(result, intersection, result.count);\n" +
"}\n" +
"}\n" +
"else\n" +
"{\n" +
"break;\n" +
"}\n" +
"}\n" +
"return result;\n" +
"}\n" +
"agi_raySegmentCollection agi_intersection(agi_raySegmentCollection left, agi_raySegmentCollection right)\n" +
"{\n" +
"if (right.count == 1)\n" +
"{\n" +
"if (left.count == 1)\n" +
"{\n" +
"agi_raySegment intersection = agi_intersection(left.intervals[0], right.intervals[0]);\n" +
"if (agi_isEmpty(intersection))\n" +
"{\n" +
"agi_raySegmentCollection result = agi_raySegmentCollectionNew();\n" +
"return result;\n" +
"}\n" +
"else\n" +
"{\n" +
"agi_raySegmentCollection result = agi_raySegmentCollectionNew(intersection);\n" +
"return result;\n" +
"}\n" +
"}\n" +
"else\n" +
"{\n" +
"agi_raySegmentCollection result = agi_intersection(left, right.intervals[0]);\n" +
"return result;\n" +
"}\n" +
"}\n" +
"agi_raySegmentCollection result = agi_raySegmentCollectionNew();\n" +
"if (left.count > 0 && right.count > 0)\n" +
"{\n" +
"for (int leftIndex = 0; leftIndex < agi_raySegmentCollectionCapacity; ++leftIndex)\n" +
"{\n" +
"if (leftIndex < left.count)\n" +
"{\n" +
"for (int rightIndex = 0; rightIndex < agi_raySegmentCollectionCapacity; ++rightIndex)\n" +
"{\n" +
"if (rightIndex <= right.count && left.intervals[leftIndex].stop >= right.intervals[rightIndex].start)\n" +
"{\n" +
"agi_raySegment intersection = agi_intersection(left.intervals[leftIndex], right.intervals[rightIndex]);\n" +
"if (!agi_isEmpty(intersection))\n" +
"{\n" +
"agi_insertAt(result, intersection, result.count);\n" +
"}\n" +
"}\n" +
"else\n" +
"{\n" +
"break;\n" +
"}\n" +
"}\n" +
"}\n" +
"else\n" +
"{\n" +
"break;\n" +
"}\n" +
"}\n" +
"}\n" +
"return result;\n" +
"}\n" +
"agi_raySegmentCollection agi_subtraction(agi_raySegment outer, agi_raySegment inner)\n" +
"{\n" +
"agi_raySegmentCollection i = agi_raySegmentCollectionNew();\n" +
"agi_raySegment intersection = agi_intersection(outer, inner);\n" +
"if (agi_isEmpty(intersection) || (intersection.start == intersection.stop))\n" +
"{\n" +
"i.count = 1;\n" +
"i.intervals[0] = outer;\n" +
"}\n" +
"else\n" +
"{\n" +
"if ((intersection.start == outer.start) && (intersection.stop == outer.stop))\n" +
"{\n" +
"i.count = 0;\n" +
"}\n" +
"else if (intersection.start == outer.start)\n" +
"{\n" +
"i.count = 1;\n" +
"i.intervals[0] = agi_raySegment(inner.stop, outer.stop);\n" +
"}\n" +
"else if (intersection.stop == outer.stop)\n" +
"{\n" +
"i.count = 1;\n" +
"i.intervals[0] = agi_raySegment(outer.start, inner.start);\n" +
"}\n" +
"else\n" +
"{\n" +
"i.count = 2;\n" +
"i.intervals[0] = agi_raySegment(outer.start, inner.start);\n" +
"i.intervals[1] = agi_raySegment(inner.stop, outer.stop);\n" +
"}\n" +
"}\n" +
"return i;\n" +
"}\n" +
"agi_raySegmentCollection agi_subtraction(agi_raySegmentCollection left, agi_raySegment right)\n" +
"{\n" +
"if (left.count == 1)\n" +
"{\n" +
"agi_raySegmentCollection result = agi_subtraction(left.intervals[0], right);\n" +
"return result;\n" +
"}\n" +
"agi_raySegmentCollection result = agi_raySegmentCollectionNew();\n" +
"for (int leftIndex = 0; leftIndex < agi_raySegmentCollectionCapacity; ++leftIndex)\n" +
"{\n" +
"if (leftIndex < left.count)\n" +
"{\n" +
"agi_raySegmentCollection segments = agi_subtraction(left.intervals[leftIndex], right);\n" +
"if (segments.count != 0)\n" +
"{\n" +
"agi_insertAt(result, segments, result.count);\n" +
"}\n" +
"}\n" +
"else\n" +
"{\n" +
"break;\n" +
"}\n" +
"}\n" +
"return result;\n" +
"}\n" +
"agi_raySegmentCollection agi_subtraction(agi_raySegmentCollection left, agi_raySegmentCollection right)\n" +
"{\n" +
"if (right.count == 1)\n" +
"{\n" +
"if (left.count == 1)\n" +
"{\n" +
"agi_raySegmentCollection result = agi_subtraction(left.intervals[0], right.intervals[0]);\n" +
"return result;\n" +
"}\n" +
"else\n" +
"{\n" +
"agi_raySegmentCollection result = agi_subtraction(left, right.intervals[0]);\n" +
"return result;\n" +
"}\n" +
"}\n" +
"agi_raySegmentCollection complement = agi_complement(right);\n" +
"agi_raySegmentCollection result = agi_intersection(left, complement);\n" +
"return result;\n" +
"}\n" +
"";
});

/*global define*/
define('Shaders/SensorVolume',[],function() {
  
  return "uniform float u_erosion;\n" +
"uniform vec4 u_intersectionColor;\n" +
"bool inSensorShadow(vec3 coneVertexWC, agi_ellipsoid ellipsoidEC, vec3 pointEC)\n" +
"{\n" +
"vec3 D = ellipsoidEC.inverseRadii;\n" +
"vec3 q = D * coneVertexWC;\n" +
"float qMagnitudeSquared = dot(q, q);\n" +
"float test = qMagnitudeSquared - 1.0;\n" +
"vec3 t = (agi_inverseView * vec4(pointEC, 1.0)).xyz;\n" +
"vec3 temp = D * t - q;\n" +
"float d = dot(temp, q);\n" +
"return (d < -test) && (d / length(temp) < -sqrt(test));\n" +
"}\n" +
"#ifndef RENDER_FOR_PICK\n" +
"void sensorErode(float sensorRadius, vec3 pointEC)\n" +
"{\n" +
"if (u_erosion != 1.0)\n" +
"{\n" +
"vec3 pointMC = (agi_inverseModelView * vec4(pointEC, 1.0)).xyz;\n" +
"pointMC /= sensorRadius;\n" +
"pointMC /= (1.0 / 10.0);\n" +
"float t = 0.5 + (0.5 * agi_snoise(pointMC));\n" +
"if (t > u_erosion)\n" +
"{\n" +
"discard;\n" +
"}\n" +
"}\n" +
"}\n" +
"vec4 getIntersectionColor(float sensorRadius, vec3 pointEC)\n" +
"{\n" +
"sensorErode(sensorRadius, pointEC);\n" +
"return u_intersectionColor;\n" +
"}\n" +
"vec2 sensor2dTextureCoordinates(float sensorRadius, vec3 pointMC)\n" +
"{\n" +
"float t = pointMC.z / sensorRadius;\n" +
"float s = 1.0 + (atan(pointMC.y, pointMC.x) / agi_twoPi);\n" +
"s = s - floor(s);\n" +
"return vec2(s, t);\n" +
"}\n" +
"#endif\n" +
"";
});
/*global define*/
define('Scene/ComplexConicSensorVolume',[
        '../Core/DeveloperError',
        '../Core/Color',
        '../Core/combine',
        '../Core/destroyObject',
        '../Core/FAR',
        '../Core/Math',
        '../Core/Cartesian3',
        '../Core/Matrix4',
        '../Core/ComponentDatatype',
        '../Core/PrimitiveType',
        '../Core/BoxTessellator',
        '../Renderer/BufferUsage',
        '../Renderer/CullFace',
        '../Renderer/BlendEquation',
        '../Renderer/BlendFunction',
        './ColorMaterial',
        './combineMaterials',
        '../Shaders/Noise',
        '../Shaders/Ray',
        '../Shaders/ConstructiveSolidGeometry',
        '../Shaders/SensorVolume',
        '../Shaders/ComplexConicSensorVolumeVS',
        '../Shaders/ComplexConicSensorVolumeFS',
        './SceneMode'
    ], function(
        DeveloperError,
        Color,
        combine,
        destroyObject,
        FAR,
        CesiumMath,
        Cartesian3,
        Matrix4,
        ComponentDatatype,
        PrimitiveType,
        BoxTessellator,
        BufferUsage,
        CullFace,
        BlendEquation,
        BlendFunction,
        ColorMaterial,
        combineMaterials,
        ShadersNoise,
        ShadersRay,
        ShadersConstructiveSolidGeometry,
        ShadersSensorVolume,
        ComplexConicSensorVolumeVS,
        ComplexConicSensorVolumeFS,
        SceneMode) {
    

    var attributeIndices = {
        position : 0
    };

    /**
     * DOC_TBA
     *
     * @alias ComplexConicSensorVolume
     * @constructor
     *
     * @see SensorVolumeCollection#addComplexConic
     */
    var ComplexConicSensorVolume = function(template) {
        var t = template || {};

        this._va = undefined;
        this._sp = undefined;
        this._rs = undefined;

        this._spPick = undefined;
        this._pickId = undefined;

        /**
         * <code>true</code> if this sensor will be shown; otherwise, <code>false</code>
         *
         * @type Boolean
         */
        this.show = (typeof t.show === 'undefined') ? true : t.show;

        /**
         * DOC_TBA
         *
         * @type Boolean
         */
        this.showIntersection = (typeof t.showIntersection === 'undefined') ? true : t.showIntersection;

        /**
         * The 4x4 transformation matrix that transforms this sensor from model to world coordinates.  In it's model
         * coordinates, the sensor's principal direction is along the positive z-axis.  Minimum and maximum clock
         * angles are measured from the x-axis.  This matrix is available to GLSL vertex and fragment shaders via
         * {@link agi_model} and derived uniforms.
         * <br /><br />
         * <div align='center'>
         * <img src='images/ComplexConicSensorVolume.setModelMatrix.png' width='400' height='258' /><br />
         * Model coordinate system for a conic sensor
         * </div>
         *
         * @type Matrix4
         *
         * @see agi_model
         *
         * @example
         * // The sensor's vertex is located on the surface at -75.59777 degrees longitude and 40.03883 degrees latitude.
         * // The sensor's cone opens upward, along the surface normal.
         * var center = ellipsoid.cartographicToCartesian(Cartographic.fromDegrees(-75.59777, 40.03883));
         * sensor.modelMatrix = Transforms.eastNorthUpToFixedFrame(center);
         */
        this.modelMatrix = t.modelMatrix || Matrix4.IDENTITY;

        /**
         * DOC_TBA
         *
         * @type Number
         *
         * @see ComplexConicSensorVolume#outerHalfAngle
         */
        this.innerHalfAngle = (typeof t.innerHalfAngle === 'undefined') ? CesiumMath.PI_OVER_TWO : t.innerHalfAngle;

        /**
         * DOC_TBA
         *
         * @type Number
         *
         * @see ComplexConicSensorVolume#innerHalfAngle
         */
        this.outerHalfAngle = (typeof t.outerHalfAngle === 'undefined') ? CesiumMath.PI_OVER_TWO : t.outerHalfAngle;
        this._outerHalfAngle = undefined;

        /**
         * DOC_TBA
         *
         * @type Number
         *
         * @see ComplexConicSensorVolume#innerHalfAngle
         */
        this.maximumClockAngle = (typeof t.maximumClockAngle === 'undefined') ? Math.PI : t.maximumClockAngle;
        this._maximumClockAngle = undefined;

        /**
         * DOC_TBA
         *
         * @type Number
         *
         * @see ComplexConicSensorVolume#innerHalfAngle
         */
        this.minimumClockAngle = (typeof t.minimumClockAngle === 'undefined') ? -Math.PI : t.minimumClockAngle;
        this._minimumClockAnglee = undefined;

        /**
         * DOC_TBA
         *
         * @type Number
         */
        this.radius = (typeof t.radius === 'undefined') ? Number.POSITIVE_INFINITY : t.radius;
        this._radius = undefined;

        //        /**
        //         * DOC_TBA
        //         *
        //         * @type Number
        //         */
        //        this.minimumClockAngle = (typeof t.minimumClockAngle === 'undefined') ? (-Math.PI / 4.0) : t.minimumClockAngle;

        //        /**
        //         * DOC_TBA
        //         *
        //         * @type Number
        //         */
        //        this.maximumClockAngle = (typeof t.maximumClockAngle === 'undefined') ? (Math.PI / 4.0) : t.maximumClockAngle;

        /**
         * DOC_TBA
         */
        this.outerMaterial = t.outerMaterial || new ColorMaterial();
        this._outerMaterial = undefined;

        /**
         * DOC_TBA
         */
        this.innerMaterial = t.innerMaterial || new ColorMaterial();
        this._innerMaterial = undefined;

        /**
         * DOC_TBA
         */
        this.capMaterial = t.capMaterial || new ColorMaterial();
        this._capMaterial = undefined;

        /**
         * DOC_TBA
         */
        this.silhouetteMaterial = t.silhouetteMaterial || new ColorMaterial();
        this._silhouetteMaterial = undefined;

        /**
         * DOC_TBA
         */
        this.intersectionColor = (typeof t.intersectionColor !== 'undefined') ? Color.clone(t.intersectionColor) : new Color(1.0, 1.0, 0.0, 1.0);

        /**
         * DOC_TBA
         *
         * @type Number
         */
        this.erosion = (typeof t.erosion === 'undefined') ? 1.0 : t.erosion;

        var that = this;
        this._uniforms = {
            u_model : function() {
                return that.modelMatrix;
            },
            u_sensorRadius : function() {
                return isFinite(that.radius) ? that.radius : FAR;
            },
            u_outerHalfAngle : function() {
                return that.outerHalfAngle;
            },
            u_innerHalfAngle : function() {
                return that.innerHalfAngle;
            },
            u_maximumClockAngle : function() {
                return that.maximumClockAngle;
            },
            u_minimumClockAngle : function() {
                return that.minimumClockAngle;
            },
            u_showIntersection : function() {
                return that.showIntersection;
            },
            u_intersectionColor : function() {
                return that.intersectionColor;
            },
            u_erosion : function() {
                return that.erosion;
            }
        };
        this._drawUniforms = null;
        this._pickUniforms = null;
        this._mode = SceneMode.SCENE3D;
    };

    ComplexConicSensorVolume.prototype._getBoundingVolume = function() {
        var r = isFinite(this.radius) ? this.radius : FAR;

        if (this.outerHalfAngle <= CesiumMath.toRadians(45.0)) {
            // Bound sensor with a frustum
            var l = Math.tan(this.outerHalfAngle) * r;

            return {
                attributes : {
                    position : {
                        componentDatatype : ComponentDatatype.FLOAT,
                        componentsPerAttribute : 3,
                        values : [
                                  0.0, 0.0, 0.0, // Sensor vertex
                                    l,  -l,   r, // Sensor cap: ( x, -y)
                                    l,   l,   r, // Sensor cap: ( x,  y)
                                   -l,   l,   r, // Sensor cap: (-x,  y)
                                   -l,  -l,   r // Sensor cap: (-x, -y)
                              ]
                    }
                },
                indexLists : [{
                    primitiveType : PrimitiveType.TRIANGLES,
                    values : [
                              0, 1, 4, // bottom side
                              0, 4, 3, // left side
                              0, 3, 2, // top side
                              0, 2, 1, // right side
                              1, 2, 3, // top
                              1, 3, 4
                          ]
                }]
            };
        } else if (this.outerHalfAngle <= CesiumMath.toRadians(90.0)) {
            // Bound sensor with box in the +z half-space
            return BoxTessellator.compute({
                minimumCorner : new Cartesian3(-r, -r, 0.0),
                maximumCorner : new Cartesian3(r, r, r)
            });
        }

        // Bound sensor with box
        return BoxTessellator.compute({
            minimumCorner : new Cartesian3(-r, -r, -r),
            maximumCorner : new Cartesian3(r, r, r)
        });
    };

    ComplexConicSensorVolume.prototype._combineMaterials = function() {
        // On older/mobile hardware, we could do one pass per material to avoid
        // going over the maximum uniform limit
        return combineMaterials({
            material : this.outerMaterial,
            sourceTransform : function(source) {
                return source.replace(new RegExp('agi_getMaterialColor', 'g'), 'agi_getOuterMaterialColor');
            }
        }, {
            material : this.innerMaterial,
            sourceTransform : function(source) {
                return source.replace(new RegExp('agi_getMaterialColor', 'g'), 'agi_getInnerMaterialColor');
            }
        }, {
            material : this.capMaterial,
            sourceTransform : function(source) {
                return source.replace(new RegExp('agi_getMaterialColor', 'g'), 'agi_getCapMaterialColor');
            }
        }, {
            material : this.silhouetteMaterial,
            sourceTransform : function(source) {
                return source.replace(new RegExp('agi_getMaterialColor', 'g'), 'agi_getSilhouetteMaterialColor');
            }
        });
    };

    /**
     * DOC_TBA
     *
     * @memberof ComplexConicSensorVolume
     *
     * @exception {DeveloperError} this.innerHalfAngle cannot be greater than this.outerHalfAngle.
     * @exception {DeveloperError} this.radius must be greater than or equal to zero.
     */
    ComplexConicSensorVolume.prototype.update = function(context, sceneState) {
        this._mode = sceneState.mode;
        if (this._mode !== SceneMode.SCENE3D) {
            return;
        }

        if (this.innerHalfAngle > this.outerHalfAngle) {
            throw new DeveloperError('this.innerHalfAngle cannot be greater than this.outerHalfAngle.');
        }

        if (this.radius < 0.0) {
            throw new DeveloperError('this.radius must be greater than or equal to zero.');
        }

        if (this.show) {
            // Recreate vertex array when proxy geometry needs to change
            if ((this._outerHalfAngle !== this.outerHalfAngle) || (this._radius !== this.radius)) {
                this._outerHalfAngle = this.outerHalfAngle;
                this._radius = this.radius;

                this._va = context.createVertexArrayFromMesh({
                    mesh : this._getBoundingVolume(),
                    attributeIndices : attributeIndices,
                    bufferUsage : BufferUsage.STATIC_DRAW
                });
            }

            // Recompile shader when material changes
            if ((!this._outerMaterial || (this._outerMaterial !== this.outerMaterial)) ||
                (!this._innerMaterial || (this._innerMaterial !== this.innerMaterial)) ||
                (!this._capMaterial || (this._capMaterial !== this.capMaterial)) ||
                (!this._silhouetteMaterial || (this._silhouetteMaterial !== this.silhouetteMaterial))) {

                this._outerMaterial = this.outerMaterial || new ColorMaterial();
                this._innerMaterial = this.innerMaterial || new ColorMaterial();
                this._capMaterial = this.capMaterial || new ColorMaterial();
                this._silhouetteMaterial = this.silhouetteMaterial || new ColorMaterial();

                var material = this._combineMaterials();
                this._drawUniforms = combine(this._uniforms, material._uniforms);

                var fsSource =
                    '#line 0\n' +
                    ShadersNoise +
                    '#line 0\n' +
                    ShadersRay +
                    '#line 0\n' +
                    ShadersConstructiveSolidGeometry +
                    '#line 0\n' +
                    ShadersSensorVolume +
                    '#line 0\n' +
                    material._getShaderSource() +
                    '#line 0\n' +
                    ComplexConicSensorVolumeFS;

                this._sp = this._sp && this._sp.release();
                this._sp = context.getShaderCache().getShaderProgram(ComplexConicSensorVolumeVS, fsSource, attributeIndices);
            }

            // Initial render state creation
            this._rs = this._rs || context.createRenderState({
                cull : {
                    enabled : true,
                    face : CullFace.FRONT
                },
                blending : {
                    enabled : true,
                    equationRgb : BlendEquation.ADD,
                    equationAlpha : BlendEquation.ADD,
                    functionSourceRgb : BlendFunction.SOURCE_ALPHA,
                    functionSourceAlpha : BlendFunction.SOURCE_ALPHA,
                    functionDestinationRgb : BlendFunction.ONE_MINUS_SOURCE_ALPHA,
                    functionDestinationAlpha : BlendFunction.ONE_MINUS_SOURCE_ALPHA
                }
            // Does not read or write depth
            });
        }
    };

    /**
     * DOC_TBA
     * @memberof ComplexConicSensorVolume
     */
    ComplexConicSensorVolume.prototype.render = function(context) {
        if (this._mode === SceneMode.SCENE3D && this.show) {
            context.draw({
                primitiveType : PrimitiveType.TRIANGLES,
                shaderProgram : this._sp,
                uniformMap : this._drawUniforms,
                vertexArray : this._va,
                renderState : this._rs
            });
        }
    };

    /**
     * DOC_TBA
     * @memberof ComplexConicSensorVolume
     */
    ComplexConicSensorVolume.prototype.updateForPick = function(context) {
        if (this._mode === SceneMode.SCENE3D && this.show) {
            // Since this ignores all other materials, if a material does discard, the sensor will still be picked.
            var fsSource =
                '#define RENDER_FOR_PICK 1\n' +
                '#line 0\n' +
                ShadersRay +
                '#line 0\n' +
                ShadersConstructiveSolidGeometry +
                '#line 0\n' +
                ShadersSensorVolume +
                '#line 0\n' +
                ComplexConicSensorVolumeFS;

            this._spPick = context.getShaderCache().getShaderProgram(ComplexConicSensorVolumeVS, fsSource, attributeIndices);
            this._pickId = context.createPickId(this);

            var that = this;
            this._pickUniforms = combine(this._uniforms, {
                u_pickColor : function() {
                    return that._pickId.normalizedRgba;
                }
            });

            this.updateForPick = function(context) {
            };
        }
    };

    /**
     * DOC_TBA
     * @memberof ComplexConicSensorVolume
     */
    ComplexConicSensorVolume.prototype.renderForPick = function(context, framebuffer) {
        if (this._mode === SceneMode.SCENE3D && this.show) {
            context.draw({
                primitiveType : PrimitiveType.TRIANGLES,
                shaderProgram : this._spPick,
                uniformMap : this._pickUniforms,
                vertexArray : this._va,
                renderState : this._rs,
                framebuffer : framebuffer
            });
        }
    };

    /**
     * DOC_TBA
     * @memberof ComplexConicSensorVolume
     */
    ComplexConicSensorVolume.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * DOC_TBA
     * @memberof ComplexConicSensorVolume
     */
    ComplexConicSensorVolume.prototype.destroy = function() {
        this._va = this._va && this._va.destroy();
        this._sp = this._sp && this._sp.release();
        this._spPick = this._spPick && this._spPick.release();
        this._pickId = this._pickId && this._pickId.destroy();
        return destroyObject(this);
    };

    return ComplexConicSensorVolume;
});

/*global define*/
define('DynamicScene/DynamicConeVisualizer',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/Color',
        '../Core/Math',
        '../Core/Matrix3',
        '../Core/Matrix4',
        '../Scene/ComplexConicSensorVolume',
        '../Scene/ColorMaterial'
       ], function(
         DeveloperError,
         destroyObject,
         Color,
         CesiumMath,
         Matrix3,
         Matrix4,
         ComplexConicSensorVolume,
         ColorMaterial) {
    

    /**
     * A DynamicObject visualizer which maps the DynamicCone instance
     * in DynamicObject.cone to a ComplexConicSensor primitive.
     * @alias DynamicConeVisualizer
     * @constructor
     *
     * @param {Scene} scene The scene the primitives will be rendered in.
     * @param {DynamicObjectCollection} [dynamicObjectCollection] The dynamicObjectCollection to visualize.
     *
     * @exception {DeveloperError} scene is required.
     *
     * @see DynamicCone
     * @see Scene
     * @see DynamicObject
     * @see DynamicObjectCollection
     * @see CompositeDynamicObjectCollection
     * @see VisualizerCollection
     * @see DynamicBillboardVisualizer
     * @see DynamicConeVisualizerUsingCustomSensor
     * @see DynamicLabelVisualizer
     * @see DynamicPointVisualizer
     * @see DynamicPolygonVisualizer
     * @see DynamicPolylineVisualizer
     * @see DynamicPyramidVisualizer
     *
     */
    var DynamicConeVisualizer = function(scene, dynamicObjectCollection) {
        if (typeof scene === 'undefined') {
            throw new DeveloperError('scene is required.');
        }

        this._scene = scene;
        this._unusedIndexes = [];
        this._primitives = scene.getPrimitives();
        this._coneCollection = [];
        this._dynamicObjectCollection = undefined;
        this.setDynamicObjectCollection(dynamicObjectCollection);
    };

    /**
     * Returns the scene being used by this visualizer.
     *
     * @returns {Scene} The scene being used by this visualizer.
     */
    DynamicConeVisualizer.prototype.getScene = function() {
        return this._scene;
    };

    /**
     * Gets the DynamicObjectCollection being visualized.
     *
     * @returns {DynamicObjectCollection} The DynamicObjectCollection being visualized.
     */
    DynamicConeVisualizer.prototype.getDynamicObjectCollection = function() {
        return this._dynamicObjectCollection;
    };

    /**
     * Sets the DynamicObjectCollection to visualize.
     *
     * @param dynamicObjectCollection The DynamicObjectCollection to visualizer.
     */
    DynamicConeVisualizer.prototype.setDynamicObjectCollection = function(dynamicObjectCollection) {
        var oldCollection = this._dynamicObjectCollection;
        if (oldCollection !== dynamicObjectCollection) {
            if (typeof oldCollection !== 'undefined') {
                oldCollection.objectsRemoved.removeEventListener(DynamicConeVisualizer.prototype._onObjectsRemoved);
                this.removeAllPrimitives();
            }
            this._dynamicObjectCollection = dynamicObjectCollection;
            if (typeof dynamicObjectCollection !== 'undefined') {
                dynamicObjectCollection.objectsRemoved.addEventListener(DynamicConeVisualizer.prototype._onObjectsRemoved, this);
            }
        }
    };

    /**
     * Updates all of the primitives created by this visualizer to match their
     * DynamicObject counterpart at the given time.
     *
     * @param {JulianDate} time The time to update to.
     *
     * @exception {DeveloperError} time is required.
     */
    DynamicConeVisualizer.prototype.update = function(time) {
        if (typeof time === 'undefined') {
            throw new DeveloperError('time is requied.');
        }
        if (typeof this._dynamicObjectCollection !== 'undefined') {
            var dynamicObjects = this._dynamicObjectCollection.getObjects();
            for ( var i = 0, len = dynamicObjects.length; i < len; i++) {
                this._updateObject(time, dynamicObjects[i]);
            }
        }
    };

    /**
     * Removes all primitives from the scene.
     */
    DynamicConeVisualizer.prototype.removeAllPrimitives = function() {
        var i, len;
        for (i = 0, len = this._coneCollection.length; i < len; i++) {
            this._primitives.remove(this._coneCollection[i]);
        }

        if (typeof this._dynamicObjectCollection !== 'undefined') {
            var dynamicObjects = this._dynamicObjectCollection.getObjects();
            for (i = dynamicObjects.length - 1; i > -1; i--) {
                dynamicObjects[i]._coneVisualizerIndex = undefined;
            }
        }
        this._unusedIndexes = [];
        this._coneCollection = [];
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof DynamicConeVisualizer
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see DynamicConeVisualizer#destroy
     */
    DynamicConeVisualizer.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof DynamicConeVisualizer
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see DynamicConeVisualizer#isDestroyed
     *
     * @example
     * visualizer = visualizer && visualizer.destroy();
     */
    DynamicConeVisualizer.prototype.destroy = function() {
        this.removeAllPrimitives();
        return destroyObject(this);
    };

    var position;
    var orientation;
    var intersectionColor;
    DynamicConeVisualizer.prototype._updateObject = function(time, dynamicObject) {
        var dynamicCone = dynamicObject.cone;
        if (typeof dynamicCone === 'undefined') {
            return;
        }

        var positionProperty = dynamicObject.position;
        if (typeof positionProperty === 'undefined') {
            return;
        }

        var orientationProperty = dynamicObject.orientation;
        if (typeof orientationProperty === 'undefined') {
            return;
        }

        var cone;
        var showProperty = dynamicCone.show;
        var coneVisualizerIndex = dynamicObject._coneVisualizerIndex;
        var show = dynamicObject.isAvailable(time) && (typeof showProperty === 'undefined' || showProperty.getValue(time));

        if (!show) {
            //don't bother creating or updating anything else
            if (typeof coneVisualizerIndex !== 'undefined') {
                cone = this._coneCollection[coneVisualizerIndex];
                cone.show = false;
                dynamicObject._coneVisualizerIndex = undefined;
                this._unusedIndexes.push(coneVisualizerIndex);
            }
            return;
        }

        if (typeof coneVisualizerIndex === 'undefined') {
            var unusedIndexes = this._unusedIndexes;
            var length = unusedIndexes.length;
            if (length > 0) {
                coneVisualizerIndex = unusedIndexes.pop();
                cone = this._coneCollection[coneVisualizerIndex];
            } else {
                coneVisualizerIndex = this._coneCollection.length;
                cone = new ComplexConicSensorVolume();
                this._coneCollection.push(cone);
                this._primitives.add(cone);
            }
            dynamicObject._coneVisualizerIndex = coneVisualizerIndex;
            cone.dynamicObject = dynamicObject;

            // CZML_TODO Determine official defaults
            cone.capMaterial = new ColorMaterial();
            cone.innerHalfAngle = 0;
            cone.outerHalfAngle = Math.PI;
            cone.innerMaterial = new ColorMaterial();
            cone.intersectionColor = Color.YELLOW;
            cone.maximumClockAngle =  CesiumMath.TWO_PI;
            cone.minimumClockAngle = -CesiumMath.TWO_PI;
            cone.outerMaterial = new ColorMaterial();
            cone.radius = Number.POSITIVE_INFINITY;
            cone.showIntersection = true;
            cone.silhouetteMaterial = new ColorMaterial();
        } else {
            cone = this._coneCollection[coneVisualizerIndex];
        }

        cone.show = true;
        var property = dynamicCone.minimumClockAngle;
        if (typeof property !== 'undefined') {
            var minimumClockAngle = property.getValue(time);
            if (typeof minimumClockAngle !== 'undefined') {
                cone.minimumClockAngle = minimumClockAngle;
            }
        }

        property = dynamicCone.maximumClockAngle;
        if (typeof property !== 'undefined') {
            var maximumClockAngle = property.getValue(time);
            if (typeof maximumClockAngle !== 'undefined') {
                cone.maximumClockAngle = maximumClockAngle;
            } else {
                cone.maximumClockAngle = Math.pi;
            }
        }

        property = dynamicCone.innerHalfAngle;
        if (typeof property !== 'undefined') {
            var innerHalfAngle = property.getValue(time);
            if (typeof innerHalfAngle !== 'undefined') {
                cone.innerHalfAngle = innerHalfAngle;
            }
        }

        property = dynamicCone.outerHalfAngle;
        if (typeof property !== 'undefined') {
            var outerHalfAngle = property.getValue(time);
            if (typeof outerHalfAngle !== 'undefined') {
                cone.outerHalfAngle = outerHalfAngle;
            } else {
                cone.outerHalfAngle = Math.pi;
            }
        }

        property = dynamicCone.radius;
        if (typeof property !== 'undefined') {
            var radius = property.getValue(time);
            if (typeof radius !== 'undefined') {
                cone.radius = radius;
            }
        }

        position = positionProperty.getValueCartesian(time, position) || cone._visualizerPosition;
        orientation = orientationProperty.getValue(time, orientation) || cone._visualizerOrientation;

        if (typeof position !== 'undefined' &&
            typeof orientation !== 'undefined' &&
            (!position.equals(cone._visualizerPosition) ||
             !orientation.equals(cone._visualizerOrientation))) {
            cone.modelMatrix = Matrix4.fromRotationTranslation(Matrix3.fromQuaternion(orientation.conjugate(orientation)), position);
            position.clone(cone._visualizerPosition);
            orientation.clone(cone._visualizerOrientation);
        }

        var context = this._scene.getContext();
        var material = dynamicCone.capMaterial;
        if (typeof material !== 'undefined') {
            cone.capMaterial = material.getValue(time, context, cone.capMaterial);
        }

        material = dynamicCone.innerMaterial;
        if (typeof material !== 'undefined') {
            cone.innerMaterial = material.getValue(time, context, cone.innerMaterial);
        }

        material = dynamicCone.outerMaterial;
        if (typeof material !== 'undefined') {
            cone.outerMaterial = material.getValue(time, context, cone.outerMaterial);
        }

        material = dynamicCone.silhouetteMaterial;
        if (typeof material !== 'undefined') {
            cone.silhouetteMaterial = material.getValue(time, context, cone.silhouetteMaterial);
        }

        property = dynamicCone.intersectionColor;
        if (typeof property !== 'undefined') {
            intersectionColor = property.getValue(time, intersectionColor);
            if (typeof intersectionColor !== 'undefined') {
                cone.intersectionColor = intersectionColor;
            }
        }
    };

    DynamicConeVisualizer.prototype._onObjectsRemoved = function(dynamicObjectCollection, dynamicObjects) {
        var thisConeCollection = this._coneCollection;
        var thisUnusedIndexes = this._unusedIndexes;
        for ( var i = dynamicObjects.length - 1; i > -1; i--) {
            var dynamicObject = dynamicObjects[i];
            var coneVisualizerIndex = dynamicObject._coneVisualizerIndex;
            if (typeof coneVisualizerIndex !== 'undefined') {
                var cone = thisConeCollection[coneVisualizerIndex];
                cone.show = false;
                thisUnusedIndexes.push(coneVisualizerIndex);
                dynamicObject._coneVisualizerIndex = undefined;
            }
        }
    };

    return DynamicConeVisualizer;
});
/*global define*/
define('Scene/CustomSensorVolume',[
        '../Core/DeveloperError',
        '../Core/Color',
        '../Core/combine',
        '../Core/destroyObject',
        '../Core/FAR',
        '../Core/Math',
        '../Core/Cartesian3',
        '../Core/Matrix4',
        '../Core/ComponentDatatype',
        '../Core/PrimitiveType',
        '../Renderer/BufferUsage',
        '../Renderer/BlendEquation',
        '../Renderer/BlendFunction',
        './ColorMaterial',
        '../Shaders/Noise',
        '../Shaders/SensorVolume',
        '../Shaders/CustomSensorVolumeVS',
        '../Shaders/CustomSensorVolumeFS',
        './SceneMode'
    ], function(
        DeveloperError,
        Color,
        combine,
        destroyObject,
        FAR,
        CesiumMath,
        Cartesian3,
        Matrix4,
        ComponentDatatype,
        PrimitiveType,
        BufferUsage,
        BlendEquation,
        BlendFunction,
        ColorMaterial,
        ShadersNoise,
        ShadersSensorVolume,
        CustomSensorVolumeVS,
        CustomSensorVolumeFS,
        SceneMode) {
    

    var attributeIndices = {
        position : 0,
        normal : 1
    };

    /**
     * DOC_TBA
     *
     * @alias CustomSensorVolume
     * @constructor
     *
     * @see SensorVolumeCollection#addCustom
     */
    var CustomSensorVolume = function(template) {
        var t = template || {};

        this._va = undefined;
        this._sp = undefined;
        this._rs = undefined;

        this._spPick = undefined;
        this._pickId = undefined;
        this._pickIdThis = t._pickIdThis || this;

        /**
         * <code>true</code> if this sensor will be shown; otherwise, <code>false</code>
         *
         * @type Boolean
         */
        this.show = (typeof t.show === 'undefined') ? true : t.show;

        /**
         * DOC_TBA
         *
         * @type Boolean
         */
        this.showIntersection = (typeof t.showIntersection === 'undefined') ? true : t.showIntersection;

        /**
         * <p>
         * Determines if a sensor intersecting the ellipsoid is drawn through the ellipsoid and potentially out
         * to the other side, or if the part of the sensor intersecting the ellipsoid stops at the ellipsoid.
         * </p>
         * <p>
         * The default is <code>false</code>, meaning the sensor will not go through the ellipsoid.
         * </p>
         *
         * @type Boolean
         */
        this.showThroughEllipsoid = (typeof t.showThroughEllipsoid === 'undefined') ? false : t.showThroughEllipsoid;

        /**
         * The 4x4 transformation matrix that transforms this sensor from model to world coordinates.  In it's model
         * coordinates, the sensor's principal direction is along the positive z-axis.  The clock angle, sometimes
         * called azimuth, is the angle in the sensor's X-Y plane measured from the positive X-axis toward the positive
         * Y-axis.  The cone angle, sometimes called elevation, is the angle out of the X-Y plane along the positive Z-axis.
         * This matrix is available to GLSL vertex and fragment shaders via
         * {@link agi_model} and derived uniforms.
         * <br /><br />
         * <div align='center'>
         * <img src='images/CustomSensorVolume.setModelMatrix.png' /><br />
         * Model coordinate system for a custom sensor
         * </div>
         *
         * @type Matrix4
         *
         * @see agi_model
         *
         * @example
         * // The sensor's vertex is located on the surface at -75.59777 degrees longitude and 40.03883 degrees latitude.
         * // The sensor's opens upward, along the surface normal.
         * var center = ellipsoid.cartographicToCartesian(Cartographic.fromDegrees(-75.59777, 40.03883));
         * sensor.modelMatrix = Transforms.eastNorthUpToFixedFrame(center);
         */
        this.modelMatrix = t.modelMatrix || Matrix4.IDENTITY;

        /**
         * DOC_TBA
         *
         * @type BufferUsage
         */
        this.bufferUsage = t.bufferUsage || BufferUsage.STATIC_DRAW;
        this._bufferUsage = t.bufferUsage || BufferUsage.STATIC_DRAW;

        /**
         * DOC_TBA
         *
         * @type Number
         */
        this.radius = (typeof t.radius === 'undefined') ? Number.POSITIVE_INFINITY : t.radius;

        this._directions = undefined;
        this._directionsDirty = false;
        this.setDirections(t.directions);

        /**
         * DOC_TBA
         */
        this.material = t.material || new ColorMaterial();
        this._material = undefined;

        /**
         * DOC_TBA
         */
        this.intersectionColor = (typeof t.intersectionColor !== 'undefined') ? Color.clone(t.intersectionColor) : new Color(1.0, 1.0, 0.0, 1.0);

        /**
         * DOC_TBA
         *
         * @type Number
         */
        this.erosion = (typeof t.erosion === 'undefined') ? 1.0 : t.erosion;

        var that = this;
        this._uniforms = {
            u_model : function() {
                return that.modelMatrix;
            },
            u_showThroughEllipsoid : function() {
                return that.showThroughEllipsoid;
            },
            u_showIntersection : function() {
                return that.showIntersection;
            },
            u_sensorRadius : function() {
                return isFinite(that.radius) ? that.radius : FAR;
            },
            u_intersectionColor : function() {
                return that.intersectionColor;
            },
            u_erosion : function() {
                return that.erosion;
            }
        };
        this._drawUniforms = null;
        this._pickUniforms = null;

        this._mode = SceneMode.SCENE3D;
    };

    /**
     * DOC_TBA
     *
     * @memberof CustomSensorVolume
     *
     * @see CustomSensorVolume#getDirections
     */
    CustomSensorVolume.prototype.setDirections = function(directions) {
        this._directions = directions;
        this._directionsDirty = true;
    };

    /**
     * DOC_TBA
     *
     * @memberof CustomSensorVolume
     *
     * @see CustomSensorVolume#setDirections
     */
    CustomSensorVolume.prototype.getDirections = function() {
        return this._directions;
    };

    CustomSensorVolume._computePositions = function(directions, radius) {
        var length = directions.length;
        var positions = new Float32Array(3 * length);
        var r = isFinite(radius) ? radius : FAR;

        for ( var i = length - 2, j = length - 1, k = 0; k < length; i = j++, j = k++) {
            // PERFORMANCE_IDEA:  We can avoid redundant operations for adjacent edges.
            var n0 = Cartesian3.fromSpherical(directions[i]);
            var n1 = Cartesian3.fromSpherical(directions[j]);
            var n2 = Cartesian3.fromSpherical(directions[k]);

            // Extend position so the volume encompasses the sensor's radius.
            var theta = Math.max(Cartesian3.angleBetween(n0, n1), Cartesian3.angleBetween(n1, n2));
            var distance = r / Math.cos(theta * 0.5);
            var p = n1.multiplyByScalar(distance);

            positions[(j * 3) + 0] = p.x;
            positions[(j * 3) + 1] = p.y;
            positions[(j * 3) + 2] = p.z;
        }

        return positions;
    };

    CustomSensorVolume._createVertexArray = function(context, directions, radius, bufferUsage) {
        var positions = this._computePositions(directions, radius);

        var length = directions.length;
        var vertices = new Float32Array(2 * 3 * 3 * length);

        var k = 0;
        for ( var i = length - 1, j = 0; j < length; i = j++) {
            var p0 = new Cartesian3(positions[(i * 3) + 0], positions[(i * 3) + 1], positions[(i * 3) + 2]);
            var p1 = new Cartesian3(positions[(j * 3) + 0], positions[(j * 3) + 1], positions[(j * 3) + 2]);
            var n = p1.cross(p0).normalize(); // Per-face normals

            vertices[k++] = 0.0; // Sensor vertex
            vertices[k++] = 0.0;
            vertices[k++] = 0.0;
            vertices[k++] = n.x;
            vertices[k++] = n.y;
            vertices[k++] = n.z;

            vertices[k++] = p1.x;
            vertices[k++] = p1.y;
            vertices[k++] = p1.z;
            vertices[k++] = n.x;
            vertices[k++] = n.y;
            vertices[k++] = n.z;

            vertices[k++] = p0.x;
            vertices[k++] = p0.y;
            vertices[k++] = p0.z;
            vertices[k++] = n.x;
            vertices[k++] = n.y;
            vertices[k++] = n.z;
        }

        var vertexBuffer = context.createVertexBuffer(new Float32Array(vertices), bufferUsage);
        var stride = 2 * 3 * Float32Array.BYTES_PER_ELEMENT;

        var attributes = [{
            index : attributeIndices.position,
            vertexBuffer : vertexBuffer,
            componentsPerAttribute : 3,
            componentDatatype : ComponentDatatype.FLOAT,
            offsetInBytes : 0,
            strideInBytes : stride
        }, {
            index : attributeIndices.normal,
            vertexBuffer : vertexBuffer,
            componentsPerAttribute : 3,
            componentDatatype : ComponentDatatype.FLOAT,
            offsetInBytes : 3 * Float32Array.BYTES_PER_ELEMENT,
            strideInBytes : stride
        }];

        return context.createVertexArray(attributes);
    };

    /**
     * DOC_TBA
     *
     * @memberof CustomSensorVolume
     *
     * @exception {DeveloperError} this.radius must be greater than or equal to zero.
     */
    CustomSensorVolume.prototype.update = function(context, sceneState) {
        this._mode = sceneState.mode;
        if (this._mode !== SceneMode.SCENE3D) {
            return;
        }

        if (this.radius < 0.0) {
            throw new DeveloperError('this.radius must be greater than or equal to zero.');
        }

        if (this.show) {
            // Initial render state creation
            if (!this._rs) {
                this._rs = context.createRenderState({
                    blending : {
                        enabled : true,
                        equationRgb : BlendEquation.ADD,
                        equationAlpha : BlendEquation.ADD,
                        functionSourceRgb : BlendFunction.SOURCE_ALPHA,
                        functionSourceAlpha : BlendFunction.SOURCE_ALPHA,
                        functionDestinationRgb : BlendFunction.ONE_MINUS_SOURCE_ALPHA,
                        functionDestinationAlpha : BlendFunction.ONE_MINUS_SOURCE_ALPHA
                    },
                    depthTest : {
                        enabled : true
                    },
                    depthMask : false
                });
            }
            // This would be better served by depth testing with a depth buffer that does not
            // include the ellipsoid depth - or a g-buffer containing an ellipsoid mask
            // so we can selectively depth test.
            this._rs.depthTest.enabled = !this.showThroughEllipsoid;

            // Recompile shader when material changes
            if (!this._material || (this._material !== this.material)) {

                this.material = this.material || new ColorMaterial();
                this._material = this.material;

                var fsSource =
                    '#line 0\n' +
                    ShadersNoise +
                    '#line 0\n' +
                    ShadersSensorVolume +
                    '#line 0\n' +
                    this._material._getShaderSource() +
                    '#line 0\n' +
                    CustomSensorVolumeFS;

                this._sp = this._sp && this._sp.release();
                this._sp = context.getShaderCache().getShaderProgram(CustomSensorVolumeVS, fsSource, attributeIndices);

                this._drawUniforms = combine(this._uniforms, this._material._uniforms);
            }

            // Recreate vertex buffer when directions change
            if ((this._directionsDirty) || (this._bufferUsage !== this.bufferUsage)) {
                this._directionsDirty = false;
                this._bufferUsage = this.bufferUsage;
                this._va = this._va && this._va.destroy();

                var directions = this._directions;
                if (directions && (directions.length >= 3)) {
                    this._va = CustomSensorVolume._createVertexArray(context, directions, this.radius, this.bufferUsage);
                }
            }
        }
    };

    /**
     * DOC_TBA
     * @memberof CustomSensorVolume
     */
    CustomSensorVolume.prototype.render = function(context) {
        if (this._mode === SceneMode.SCENE3D && this.show && this._va) {
            context.draw({
                primitiveType : PrimitiveType.TRIANGLES,
                shaderProgram : this._sp,
                uniformMap : this._drawUniforms,
                vertexArray : this._va,
                renderState : this._rs
            });
        }
    };

    /**
     * DOC_TBA
     * @memberof CustomSensorVolume
     */
    CustomSensorVolume.prototype.updateForPick = function(context) {
        if (this._mode === SceneMode.SCENE3D && this.show && this._va) {
            // Since this ignores all other materials, if a material does discard, the sensor will still be picked.
            var fsSource =
                '#define RENDER_FOR_PICK 1\n' +
                '#line 0\n' +
                ShadersSensorVolume +
                '#line 0\n' +
                CustomSensorVolumeFS;

            this._spPick = context.getShaderCache().getShaderProgram(CustomSensorVolumeVS, fsSource, attributeIndices);
            this._pickId = context.createPickId(this._pickIdThis);

            var that = this;
            this._pickUniforms = combine(this._uniforms, {
                u_pickColor : function() {
                    return that._pickId.normalizedRgba;
                }
            });

            this.updateForPick = function(context) {
            };
        }
    };

    /**
     * DOC_TBA
     * @memberof CustomSensorVolume
     */
    CustomSensorVolume.prototype.renderForPick = function(context, framebuffer) {
        if (this._mode === SceneMode.SCENE3D && this.show && this._va) {
            context.draw({
                primitiveType : PrimitiveType.TRIANGLES,
                shaderProgram : this._spPick,
                uniformMap : this._pickUniforms,
                vertexArray : this._va,
                renderState : this._rs,
                framebuffer : framebuffer
            });
        }
    };

    /**
     * DOC_TBA
     * @memberof CustomSensorVolume
     */
    CustomSensorVolume.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * DOC_TBA
     * @memberof CustomSensorVolume
     */
    CustomSensorVolume.prototype.destroy = function() {
        this._va = this._va && this._va.destroy();
        this._sp = this._sp && this._sp.release();
        this._spPick = this._spPick && this._spPick.release();
        this._pickId = this._pickId && this._pickId.destroy();
        return destroyObject(this);
    };

    return CustomSensorVolume;
});

/*global define*/
define('DynamicScene/DynamicConeVisualizerUsingCustomSensor',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/Color',
        '../Core/Math',
        '../Core/Matrix3',
        '../Core/Matrix4',
        '../Core/Spherical',
        '../Scene/CustomSensorVolume',
        '../Scene/ColorMaterial'
       ], function(
         DeveloperError,
         destroyObject,
         Color,
         CesiumMath,
         Matrix3,
         Matrix4,
         Spherical,
         CustomSensorVolume,
         ColorMaterial) {
    

    //CZML_TODO DynamicConeVisualizerUsingCustomSensor is a temporary workaround
    //because ComplexConicSensor has major performance issues.  As soon as
    //ComplexConicSensor is working, this class can be deleted and
    //DynamicConeVisualizer is a drop in replacement that already does things
    //"the right way".

    function computeDirections(minimumClockAngle, maximumClockAngle, innerHalfAngle, outerHalfAngle) {
        var angle;
        var directions = [];
        var angleStep = CesiumMath.toRadians(2.0);
        if (minimumClockAngle === 0.0 && maximumClockAngle === CesiumMath.TWO_PI) {
            // No clock angle limits, so this is just a circle.
            // There might be a hole but we're ignoring it for now.
            for (angle = 0.0; angle < CesiumMath.TWO_PI; angle += angleStep) {
                directions.push(new Spherical(angle, outerHalfAngle));
            }
        } else {
            // There are clock angle limits.
            for (angle = minimumClockAngle; angle < maximumClockAngle; angle += angleStep) {
                directions.push(new Spherical(angle, outerHalfAngle));
            }
            directions.push(new Spherical(maximumClockAngle, outerHalfAngle));
            if (innerHalfAngle) {
                directions.push(new Spherical(maximumClockAngle, innerHalfAngle));
                for (angle = maximumClockAngle; angle > minimumClockAngle; angle -= angleStep) {
                    directions.push(new Spherical(angle, innerHalfAngle));
                }
                directions.push(new Spherical(minimumClockAngle, innerHalfAngle));
            } else {
                directions.push(new Spherical(maximumClockAngle, 0.0));
            }
        }
        return directions;
    }

    /**
     * A DynamicObject visualizer which maps the DynamicCone instance
     * in DynamicObject.cone to a CustomSensor primitive.
     * @alias DynamicConeVisualizerUsingCustomSensor
     * @constructor
     *
     * @param {Scene} scene The scene the primitives will be rendered in.
     * @param {DynamicObjectCollection} [dynamicObjectCollection] The dynamicObjectCollection to visualize.
     *
     * @exception {DeveloperError} scene is required.
     *
     * @see DynamicCone
     * @see Scene
     * @see DynamicObject
     * @see DynamicObjectCollection
     * @see CompositeDynamicObjectCollection
     * @see VisualizerCollection
     * @see DynamicBillboardVisualizer
     * @see DynamicConeVisualizer
     * @see DynamicLabelVisualizer
     * @see DynamicPointVisualizer
     * @see DynamicPolygonVisualizer
     * @see DynamicPolylineVisualizer
     * @see DynamicPyramidVisualizer
     *
     */
    var DynamicConeVisualizerUsingCustomSensor = function(scene, dynamicObjectCollection) {
        if (typeof scene === 'undefined') {
            throw new DeveloperError('scene is required.');
        }
        this._scene = scene;
        this._unusedIndexes = [];
        this._primitives = scene.getPrimitives();
        this._coneCollection = [];
        this._dynamicObjectCollection = undefined;
        this.setDynamicObjectCollection(dynamicObjectCollection);
    };

    /**
     * Returns the scene being used by this visualizer.
     *
     * @returns {Scene} The scene being used by this visualizer.
     */
    DynamicConeVisualizerUsingCustomSensor.prototype.getScene = function() {
        return this._scene;
    };

    /**
     * Gets the DynamicObjectCollection being visualized.
     *
     * @returns {DynamicObjectCollection} The DynamicObjectCollection being visualized.
     */
    DynamicConeVisualizerUsingCustomSensor.prototype.getDynamicObjectCollection = function() {
        return this._dynamicObjectCollection;
    };

    /**
     * Sets the DynamicObjectCollection to visualize.
     *
     * @param dynamicObjectCollection The DynamicObjectCollection to visualizer.
     */
    DynamicConeVisualizerUsingCustomSensor.prototype.setDynamicObjectCollection = function(dynamicObjectCollection) {
        var oldCollection = this._dynamicObjectCollection;
        if (oldCollection !== dynamicObjectCollection) {
            if (typeof oldCollection !== 'undefined') {
                oldCollection.objectsRemoved.removeEventListener(DynamicConeVisualizerUsingCustomSensor.prototype._onObjectsRemoved);
                this.removeAllPrimitives();
            }
            this._dynamicObjectCollection = dynamicObjectCollection;
            if (typeof dynamicObjectCollection !== 'undefined') {
                dynamicObjectCollection.objectsRemoved.addEventListener(DynamicConeVisualizerUsingCustomSensor.prototype._onObjectsRemoved, this);
            }
        }
    };

    /**
     * Updates all of the primitives created by this visualizer to match their
     * DynamicObject counterpart at the given time.
     *
     * @param {JulianDate} time The time to update to.
     *
     * @exception {DeveloperError} time is required.
     */
    DynamicConeVisualizerUsingCustomSensor.prototype.update = function(time) {
        if (typeof time === 'undefined') {
            throw new DeveloperError('time is requied.');
        }
        if (typeof this._dynamicObjectCollection !== 'undefined') {
            var dynamicObjects = this._dynamicObjectCollection.getObjects();
            for ( var i = 0, len = dynamicObjects.length; i < len; i++) {
                this._updateObject(time, dynamicObjects[i]);
            }
        }
    };

    /**
     * Removes all primitives from the scene.
     */
    DynamicConeVisualizerUsingCustomSensor.prototype.removeAllPrimitives = function() {
        var i, len;
        for (i = 0, len = this._coneCollection.length; i < len; i++) {
            this._primitives.remove(this._coneCollection[i]);
        }

        if (typeof this._dynamicObjectCollection !== 'undefined') {
            var dynamicObjects = this._dynamicObjectCollection.getObjects();
            for (i = dynamicObjects.length - 1; i > -1; i--) {
                dynamicObjects[i]._coneVisualizerIndex = undefined;
            }
        }

        this._unusedIndexes = [];
        this._coneCollection = [];
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof DynamicConeVisualizerUsingCustomSensor
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see DynamicConeVisualizerUsingCustomSensor#destroy
     */
    DynamicConeVisualizerUsingCustomSensor.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof DynamicConeVisualizerUsingCustomSensor
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see DynamicConeVisualizerUsingCustomSensor#isDestroyed
     *
     * @example
     * visualizer = visualizer && visualizer.destroy();
     */
    DynamicConeVisualizerUsingCustomSensor.prototype.destroy = function() {
        this.removeAllPrimitives();
        return destroyObject(this);
    };

    var position;
    var orientation;
    var intersectionColor;
    DynamicConeVisualizerUsingCustomSensor.prototype._updateObject = function(time, dynamicObject) {
        var dynamicCone = dynamicObject.cone;
        if (typeof dynamicCone === 'undefined') {
            return;
        }

        var maximumClockAngleProperty = dynamicCone.maximumClockAngle;
        if (typeof maximumClockAngleProperty === 'undefined') {
            return;
        }

        var outerHalfAngleProperty = dynamicCone.outerHalfAngle;
        if (typeof outerHalfAngleProperty === 'undefined') {
            return;
        }

        var positionProperty = dynamicObject.position;
        if (typeof positionProperty === 'undefined') {
            return;
        }

        var orientationProperty = dynamicObject.orientation;
        if (typeof orientationProperty === 'undefined') {
            return;
        }

        var cone;
        var showProperty = dynamicCone.show;
        var coneVisualizerIndex = dynamicObject._coneVisualizerIndex;
        var show = dynamicObject.isAvailable(time) && (typeof showProperty === 'undefined' || showProperty.getValue(time));

        if (!show) {
            //don't bother creating or updating anything else
            if (typeof coneVisualizerIndex !== 'undefined') {
                cone = this._coneCollection[coneVisualizerIndex];
                cone.show = false;
                dynamicObject._coneVisualizerIndex = undefined;
                this._unusedIndexes.push(coneVisualizerIndex);
            }
            return;
        }

        if (typeof coneVisualizerIndex === 'undefined') {
            var unusedIndexes = this._unusedIndexes;
            var length = unusedIndexes.length;
            if (length > 0) {
                coneVisualizerIndex = unusedIndexes.pop();
                cone = this._coneCollection[coneVisualizerIndex];
            } else {
                coneVisualizerIndex = this._coneCollection.length;
                //cone = new ComplexConicSensorVolume();
                cone = new CustomSensorVolume();
                cone.innerHalfAngle = 0;
                cone.minimumClockAngle = 0;
                this._coneCollection.push(cone);
                this._primitives.add(cone);
            }
            dynamicObject._coneVisualizerIndex = coneVisualizerIndex;
            cone.dynamicObject = dynamicObject;

            // CZML_TODO Determine official defaults
            cone.innerHalfAngle = 0;
            cone.outerHalfAngle = Math.PI;
            cone.material = new ColorMaterial();
            cone.intersectionColor = Color.YELLOW;
            cone.minimumClockAngle = -CesiumMath.TWO_PI;
            cone.maximumClockAngle =  CesiumMath.TWO_PI;
            cone.radius = Number.POSITIVE_INFINITY;
            cone.showIntersection = true;
        } else {
            cone = this._coneCollection[coneVisualizerIndex];
        }

        cone.show = true;

        var innerHalfAngle = 0;
        var outerHalfAngle = Math.PI;
        var maximumClockAngle =  CesiumMath.TWO_PI;
        var minimumClockAngle = -CesiumMath.TWO_PI;

        var property = dynamicCone.minimumClockAngle;
        if (typeof property !== 'undefined') {
            var tmpClock = property.getValue(time);
            if (typeof tmpClock !== 'undefined') {
                minimumClockAngle = tmpClock;
            }
        }

        maximumClockAngle = maximumClockAngleProperty.getValue(time) || Math.pi;

        property = dynamicCone.innerHalfAngle;
        if (typeof property !== 'undefined') {
            var tmpAngle = property.getValue(time);
            if (typeof tmpAngle !== 'undefined') {
                innerHalfAngle = tmpAngle;
            }
        }

        outerHalfAngle = outerHalfAngleProperty.getValue(time) || Math.pi;

        if (minimumClockAngle !== cone.minimumClockAngle ||
            maximumClockAngle !== cone.maximumClockAngle ||
            innerHalfAngle !== cone.innerHalfAngle ||
            outerHalfAngle !== cone.outerHalfAngle) {
            cone.setDirections(computeDirections(minimumClockAngle, maximumClockAngle, innerHalfAngle, outerHalfAngle));
            cone.innerHalfAngle = innerHalfAngle;
            cone.maximumClockAngle = maximumClockAngle;
            cone.outerHalfAngle = outerHalfAngle;
            cone.minimumClockAngle = minimumClockAngle;
        }

        property = dynamicCone.radius;
        if (typeof property !== 'undefined') {
            var radius = property.getValue(time);
            if (typeof radius !== 'undefined') {
                cone.radius = radius;
            }
        }

        position = positionProperty.getValueCartesian(time, position) || cone._visualizerPosition;
        orientation = orientationProperty.getValue(time, orientation) || cone._visualizerOrientation;

        if (typeof position !== 'undefined' &&
            typeof orientation !== 'undefined' &&
            (!position.equals(cone._visualizerPosition) ||
             !orientation.equals(cone._visualizerOrientation))) {
            cone.modelMatrix = Matrix4.fromRotationTranslation(Matrix3.fromQuaternion(orientation.conjugate(orientation)), position);
            position.clone(cone._visualizerPosition);
            orientation.clone(cone._visualizerOrientation);
        }

        var context = this._scene.getContext();
        var material = dynamicCone.outerMaterial;
        if (typeof material !== 'undefined') {
            cone.material = material.getValue(time, context, cone.material);
        }

        property = dynamicCone.intersectionColor;
        if (typeof property !== 'undefined') {
            intersectionColor = property.getValue(time, intersectionColor);
            if (typeof intersectionColor !== 'undefined') {
                cone.intersectionColor = intersectionColor;
            }
        }
    };

    DynamicConeVisualizerUsingCustomSensor.prototype._onObjectsRemoved = function(dynamicObjectCollection, dynamicObjects) {
        var thisConeCollection = this._coneCollection;
        var thisUnusedIndexes = this._unusedIndexes;
        for ( var i = dynamicObjects.length - 1; i > -1; i--) {
            var dynamicObject = dynamicObjects[i];
            var coneVisualizerIndex = dynamicObject._coneVisualizerIndex;
            if (typeof coneVisualizerIndex !== 'undefined') {
                var cone = thisConeCollection[coneVisualizerIndex];
                cone.show = false;
                thisUnusedIndexes.push(coneVisualizerIndex);
                dynamicObject._coneVisualizerIndex = undefined;
            }
        }
    };

    return DynamicConeVisualizerUsingCustomSensor;
});
/*global define*/
define('DynamicScene/DynamicPyramidVisualizer',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/Color',
        '../Core/Matrix3',
        '../Core/Matrix4',
        '../Scene/CustomSensorVolume',
        '../Scene/ColorMaterial'
       ], function(
         DeveloperError,
         destroyObject,
         Color,
         Matrix3,
         Matrix4,
         CustomSensorVolume,
         ColorMaterial) {
    

    /**
     * A DynamicObject visualizer which maps the DynamicPyramid instance
     * in DynamicObject.pyramid to a Pyramid primitive.
     * @alias DynamicPyramidVisualizer
     * @constructor
     *
     * @param {Scene} scene The scene the primitives will be rendered in.
     * @param {DynamicObjectCollection} [dynamicObjectCollection] The dynamicObjectCollection to visualize.
     *
     * @exception {DeveloperError} scene is required.
     *
     * @see DynamicPyramid
     * @see Scene
     * @see DynamicObject
     * @see DynamicObjectCollection
     * @see CompositeDynamicObjectCollection
     * @see VisualizerCollection
     * @see DynamicBillboardVisualizer
     * @see DynamicConeVisualizer
     * @see DynamicConeVisualizerUsingCustomSensorr
     * @see DynamicLabelVisualizer
     * @see DynamicPointVisualizer
     * @see DynamicPolygonVisualizer
     * @see DynamicPolylineVisualizer
     *
     */
    var DynamicPyramidVisualizer = function(scene, dynamicObjectCollection) {
        if (typeof scene === 'undefined') {
            throw new DeveloperError('scene is required.');
        }
        this._scene = scene;
        this._unusedIndexes = [];
        this._primitives = scene.getPrimitives();
        this._pyramidCollection = [];
        this._dynamicObjectCollection = undefined;
        this.setDynamicObjectCollection(dynamicObjectCollection);
    };

    /**
     * Returns the scene being used by this visualizer.
     *
     * @returns {Scene} The scene being used by this visualizer.
     */
    DynamicPyramidVisualizer.prototype.getScene = function() {
        return this._scene;
    };

    /**
     * Gets the DynamicObjectCollection being visualized.
     *
     * @returns {DynamicObjectCollection} The DynamicObjectCollection being visualized.
     */
    DynamicPyramidVisualizer.prototype.getDynamicObjectCollection = function() {
        return this._dynamicObjectCollection;
    };

    /**
     * Sets the DynamicObjectCollection to visualize.
     *
     * @param dynamicObjectCollection The DynamicObjectCollection to visualizer.
     */
    DynamicPyramidVisualizer.prototype.setDynamicObjectCollection = function(dynamicObjectCollection) {
        var oldCollection = this._dynamicObjectCollection;
        if (oldCollection !== dynamicObjectCollection) {
            if (typeof oldCollection !== 'undefined') {
                oldCollection.objectsRemoved.removeEventListener(DynamicPyramidVisualizer.prototype._onObjectsRemoved);
                this.removeAllPrimitives();
            }
            this._dynamicObjectCollection = dynamicObjectCollection;
            if (typeof dynamicObjectCollection !== 'undefined') {
                dynamicObjectCollection.objectsRemoved.addEventListener(DynamicPyramidVisualizer.prototype._onObjectsRemoved, this);
            }
        }
    };

    /**
     * Updates all of the primitives created by this visualizer to match their
     * DynamicObject counterpart at the given time.
     *
     * @param {JulianDate} time The time to update to.
     *
     * @exception {DeveloperError} time is required.
     */
    DynamicPyramidVisualizer.prototype.update = function(time) {
        if (typeof time === 'undefined') {
            throw new DeveloperError('time is requied.');
        }
        if (typeof this._dynamicObjectCollection !== 'undefined') {
            var dynamicObjects = this._dynamicObjectCollection.getObjects();
            for ( var i = 0, len = dynamicObjects.length; i < len; i++) {
                this._updateObject(time, dynamicObjects[i]);
            }
        }
    };

    /**
     * Removes all primitives from the scene.
     */
    DynamicPyramidVisualizer.prototype.removeAllPrimitives = function() {
        var i, len;
        for (i = 0, len = this._pyramidCollection.length; i < len; i++) {
            this._primitives.remove(this._pyramidCollection[i]);
        }

        if (typeof this._dynamicObjectCollection !== 'undefined') {
            var dynamicObjects = this._dynamicObjectCollection.getObjects();
            for (i = dynamicObjects.length - 1; i > -1; i--) {
                dynamicObjects[i]._pyramidVisualizerIndex = undefined;
            }
        }

        this._unusedIndexes = [];
        this._pyramidCollection = [];
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof DynamicPyramidVisualizer
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see DynamicPyramidVisualizer#destroy
     */
    DynamicPyramidVisualizer.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof DynamicPyramidVisualizer
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see DynamicPyramidVisualizer#isDestroyed
     *
     * @example
     * visualizer = visualizer && visualizer.destroy();
     */
    DynamicPyramidVisualizer.prototype.destroy = function() {
        this.removeAllPrimitives();
        return destroyObject(this);
    };

    var position;
    var orientation;
    DynamicPyramidVisualizer.prototype._updateObject = function(time, dynamicObject) {
        var dynamicPyramid = dynamicObject.pyramid;
        if (typeof dynamicPyramid === 'undefined') {
            return;
        }

        var directionsProperty = dynamicPyramid.directions;
        if (typeof directionsProperty === 'undefined') {
            return;
        }

        var positionProperty = dynamicObject.position;
        if (typeof positionProperty === 'undefined') {
            return;
        }

        var orientationProperty = dynamicObject.orientation;
        if (typeof orientationProperty === 'undefined') {
            return;
        }

        var pyramid;
        var showProperty = dynamicPyramid.show;
        var pyramidVisualizerIndex = dynamicObject._pyramidVisualizerIndex;
        var show = dynamicObject.isAvailable(time) && (typeof showProperty === 'undefined' || showProperty.getValue(time));

        if (!show) {
            //don't bother creating or updating anything else
            if (typeof pyramidVisualizerIndex !== 'undefined') {
                pyramid = this._pyramidCollection[pyramidVisualizerIndex];
                pyramid.show = false;
                dynamicObject._pyramidVisualizerIndex = undefined;
                this._unusedIndexes.push(pyramidVisualizerIndex);
            }
            return;
        }

        if (typeof pyramidVisualizerIndex === 'undefined') {
            var unusedIndexes = this._unusedIndexes;
            var length = unusedIndexes.length;
            if (length > 0) {
                pyramidVisualizerIndex = unusedIndexes.pop();
                pyramid = this._pyramidCollection[pyramidVisualizerIndex];
            } else {
                pyramidVisualizerIndex = this._pyramidCollection.length;
                pyramid = new CustomSensorVolume();
                this._pyramidCollection.push(pyramid);
                this._primitives.add(pyramid);
            }
            dynamicObject._pyramidVisualizerIndex = pyramidVisualizerIndex;
            pyramid.dynamicObject = dynamicObject;

            // CZML_TODO Determine official defaults
            pyramid.radius = Number.POSITIVE_INFINITY;
            pyramid.showIntersection = true;
            pyramid.intersectionColor = Color.YELLOW;
            pyramid.material = new ColorMaterial();
        } else {
            pyramid = this._pyramidCollection[pyramidVisualizerIndex];
        }

        pyramid.show = true;

        var directions = directionsProperty.getValueSpherical(time);
        if (typeof directions !== 'undefined' && pyramid._visualizerDirections !== directions) {
            pyramid.setDirections(directions);
            pyramid._visualizerDirections = directions;
        }

        position = positionProperty.getValueCartesian(time, position) || pyramid._visualizerPosition;
        orientation = orientationProperty.getValue(time, orientation) || pyramid._visualizerOrientation;

        if (typeof position !== 'undefined' &&
            typeof orientation !== 'undefined' &&
            (!position.equals(pyramid._visualizerPosition) ||
             !orientation.equals(pyramid._visualizerOrientation))) {
            pyramid.modelMatrix = Matrix4.fromRotationTranslation(Matrix3.fromQuaternion(orientation.conjugate(orientation)), position);
            position.clone(pyramid._visualizerPosition);
            orientation.clone(pyramid._visualizerOrientation);
        }

        var material = dynamicPyramid.material;
        if (typeof material !== 'undefined') {
            pyramid.material = material.getValue(time, this._scene.getContext(), pyramid.material);
        }

        var property = dynamicPyramid.intersectionColor;
        if (typeof property !== 'undefined') {
            var intersectionColor = property.getValue(time, intersectionColor);
            if (typeof intersectionColor !== 'undefined') {
                pyramid.intersectionColor = intersectionColor;
            }
        }

        property = dynamicPyramid.radius;
        if (typeof property !== 'undefined') {
            var radius = property.getValue(time, radius);
            if (typeof radius !== 'undefined') {
                pyramid.radius = radius;
            }
        }
    };

    DynamicPyramidVisualizer.prototype._onObjectsRemoved = function(dynamicObjectCollection, dynamicObjects) {
        var thisPyramidCollection = this._pyramidCollection;
        var thisUnusedIndexes = this._unusedIndexes;
        for ( var i = dynamicObjects.length - 1; i > -1; i--) {
            var dynamicObject = dynamicObjects[i];
            var pyramidVisualizerIndex = dynamicObject._pyramidVisualizerIndex;
            if (typeof pyramidVisualizerIndex !== 'undefined') {
                var pyramid = thisPyramidCollection[pyramidVisualizerIndex];
                pyramid.show = false;
                thisUnusedIndexes.push(pyramidVisualizerIndex);
                dynamicObject._pyramidVisualizerIndex = undefined;
            }
        }
    };

    return DynamicPyramidVisualizer;
});
/*global define*/
define('Scene/RectangularPyramidSensorVolume',[
        '../Core/DeveloperError',
        '../Core/Color',
        '../Core/destroyObject',
        '../Core/Math',
        '../Core/Matrix4',
        '../Renderer/BufferUsage',
        './ColorMaterial',
        './CustomSensorVolume'
    ], function(
        DeveloperError,
        Color,
        destroyObject,
        CesiumMath,
        Matrix4,
        BufferUsage,
        ColorMaterial,
        CustomSensorVolume) {
    

    /**
     * DOC_TBA
     *
     * @alias RectangularPyramidSensorVolume
     * @constructor
     *
     * @see SensorVolumeCollection#addRectangularPyramid
     */
    var RectangularPyramidSensorVolume = function(template) {
        var t = template || {};

        /**
         * <code>true</code> if this sensor will be shown; otherwise, <code>false</code>
         *
         * @type Boolean
         */
        this.show = (typeof t.show === 'undefined') ? true : t.show;

        /**
         * DOC_TBA
         *
         * @type Boolean
         */
        this.showIntersection = (typeof t.showIntersection === 'undefined') ? true : t.showIntersection;

        /**
         * <p>
         * Determines if a sensor intersecting the ellipsoid is drawn through the ellipsoid and potentially out
         * to the other side, or if the part of the sensor intersecting the ellipsoid stops at the ellipsoid.
         * </p>
         * <p>
         * The default is <code>false</code>, meaning the sensor will not go through the ellipsoid.
         * </p>
         *
         * @type Boolean
         */
        this.showThroughEllipsoid = (typeof t.showThroughEllipsoid === 'undefined') ? false : t.showThroughEllipsoid;

        /**
         * The 4x4 transformation matrix that transforms this sensor from model to world coordinates.  In it's model
         * coordinates, the sensor's principal direction is along the positive z-axis.  Half angles measured from the
         * principal direction and in the direction of the x-axis and y-axis define the extent of the rectangular
         * cross section.  This matrix is available to GLSL vertex and fragment shaders via
         * {@link agi_model} and derived uniforms.
         * <br /><br />
         * <div align='center'>
         * <img src='images/RectangularPyramidSensorVolume.setModelMatrix.png' /><br />
         * Model coordinate system for a sensor
         * </div>
         *
         * @type Matrix4
         *
         * @see agi_model
         *
         * @example
         * // The sensor's vertex is located on the surface at -75.59777 degrees longitude and 40.03883 degrees latitude.
         * // The sensor's opens upward, along the surface normal.
         * var center = ellipsoid.cartographicToCartesian(Cartographic.fromDegrees(-75.59777, 40.03883));
         * sensor.modelMatrix = Transforms.eastNorthUpToFixedFrame(center);
         */
        this.modelMatrix = t.modelMatrix || Matrix4.IDENTITY;

        /**
         * DOC_TBA
         *
         * @type BufferUsage
         */
        this.bufferUsage = t.bufferUsage || BufferUsage.STATIC_DRAW;

        /**
         * DOC_TBA
         *
         * @type Number
         */
        this.radius = (typeof t.radius === 'undefined') ? Number.POSITIVE_INFINITY : t.radius;

        /**
         * DOC_TBA
         *
         * @type Number
         *
         * @see RectangularPyramidSensorVolume#yHalfAngle
         */
        this.xHalfAngle = (typeof t.xHalfAngle === 'undefined') ? CesiumMath.PI_OVER_TWO : t.xHalfAngle;
        this._xHalfAngle = undefined;

        /**
         * DOC_TBA
         *
         * @type Number
         *
         * @see RectangularPyramidSensorVolume#xHalfAngle
         */
        this.yHalfAngle = (typeof t.yHalfAngle === 'undefined') ? CesiumMath.PI_OVER_TWO : t.yHalfAngle;
        this._yHalfAngle = undefined;

        /**
         * DOC_TBA
         */
        this.material = t.material || new ColorMaterial();

        /**
         * DOC_TBA
         */
        this.intersectionColor = (typeof t.intersectionColor !== 'undefined') ? Color.clone(t.intersectionColor) : new Color(1.0, 1.0, 0.0, 1.0);

        /**
         * DOC_TBA
         *
         * @type Number
         */
        this.erosion = (typeof t.erosion === 'undefined') ? 1.0 : t.erosion;

        t._pickIdThis = t._pickIdThis || this;
        this._customSensor = new CustomSensorVolume(t);
    };

    /**
     * DOC_TBA
     *
     * @memberof RectangularPyramidSensorVolume
     *
     * @exception {DeveloperError} this.xHalfAngle and this.yHalfAngle must each be less than 90 degrees.
     * @exception {DeveloperError} this.radius must be greater than or equal to zero.
     */
    RectangularPyramidSensorVolume.prototype.update = function(context, sceneState) {
        if ((this.xHalfAngle > CesiumMath.PI_OVER_TWO) || (this.yHalfAngle > CesiumMath.PI_OVER_TWO)) {
            throw new DeveloperError('this.xHalfAngle and this.yHalfAngle must each be less than or equal to 90 degrees.');
        }

        var s = this._customSensor;

        s.show = this.show;
        s.showIntersection = this.showIntersection;
        s.showThroughEllipsoid = this.showThroughEllipsoid;
        s.modelMatrix = this.modelMatrix;
        s.bufferUsage = this.bufferUsage;
        s.radius = this.radius;
        s.material = this.material;
        s.intersectionColor = this.intersectionColor;
        s.erosion = this.erosion;

        if ((this._xHalfAngle !== this.xHalfAngle) || (this._yHalfAngle !== this.yHalfAngle)) {

            this._xHalfAngle = this.xHalfAngle;
            this._yHalfAngle = this.yHalfAngle;

            // At 90 degrees the sensor is completely open, and tan() goes to infinity.
            var tanX = Math.tan(Math.min(this.xHalfAngle, CesiumMath.toRadians(89.0)));
            var tanY = Math.tan(Math.min(this.yHalfAngle, CesiumMath.toRadians(89.0)));
            var theta = Math.atan(tanX / tanY);
            var cone = Math.atan(Math.sqrt(tanX * tanX + tanY * tanY));

            s.setDirections([{
                clock : theta,
                cone : cone
            }, {
                clock : CesiumMath.toRadians(180.0) - theta,
                cone : cone
            }, {
                clock : CesiumMath.toRadians(180.0) + theta,
                cone : cone
            }, {
                clock : -theta,
                cone : cone
            }]);
        }

        s.update(context, sceneState);
    };

    /**
     * DOC_TBA
     * @memberof RectangularPyramidSensorVolume
     */
    RectangularPyramidSensorVolume.prototype.render = function(context) {
        this._customSensor.render(context);
    };

    /**
     * DOC_TBA
     * @memberof RectangularPyramidSensorVolume
     */
    RectangularPyramidSensorVolume.prototype.updateForPick = function(context) {
        this._customSensor.updateForPick(context);
    };

    /**
     * DOC_TBA
     * @memberof RectangularPyramidSensorVolume
     */
    RectangularPyramidSensorVolume.prototype.renderForPick = function(context, framebuffer) {
        this._customSensor.renderForPick(context, framebuffer);
    };

    /**
     * DOC_TBA
     * @memberof RectangularPyramidSensorVolume
     */
    RectangularPyramidSensorVolume.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * DOC_TBA
     * @memberof RectangularPyramidSensorVolume
     */
    RectangularPyramidSensorVolume.prototype.destroy = function() {
        this._customSensor = this._customSensor && this._customSensor.destroy();
        return destroyObject(this);
    };

    return RectangularPyramidSensorVolume;
});
/*global define*/
define('Scene/SensorVolumeCollection',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        './ComplexConicSensorVolume',
        './CustomSensorVolume',
        './RectangularPyramidSensorVolume'
    ], function(
        DeveloperError,
        destroyObject,
        ComplexConicSensorVolume,
        CustomSensorVolume,
        RectangularPyramidSensorVolume) {
    

    /**
     * DOC_TBA
     *
     * @alias SensorVolumeCollection
     * @constructor
     */
    var SensorVolumeCollection = function() {
        this._sensors = [];
    };

    /**
     * DOC_TBA
     *
     * @memberof SensorVolumeCollection
     *
     * @see SensorVolumeCollection#addCustom
     * @see SensorVolumeCollection#addComplexConic
     */
    SensorVolumeCollection.prototype.addRectangularPyramid = function(template) {
        var sensor = new RectangularPyramidSensorVolume(template);
        this._sensors.push(sensor);
        return sensor;
    };

    /**
     * DOC_TBA
     *
     * @memberof SensorVolumeCollection
     *
     * @see SensorVolumeCollection#addRectangularPyramid
     * @see SensorVolumeCollection#addCustom
     */
    SensorVolumeCollection.prototype.addComplexConic = function(template) {
        var sensor = new ComplexConicSensorVolume(template);
        this._sensors.push(sensor);
        return sensor;
    };

    /**
     * DOC_TBA
     *
     * @memberof SensorVolumeCollection
     *
     * @see SensorVolumeCollection#addRectangularPyramid
     * @see SensorVolumeCollection#addComplexConic
     */
    SensorVolumeCollection.prototype.addCustom = function(template) {
        var sensor = new CustomSensorVolume(template);
        this._sensors.push(sensor);
        return sensor;
    };

    /**
     * DOC_TBA
     *
     * @memberof SensorVolumeCollection
     *
     * @see SensorVolumeCollection#removeAll
     */
    SensorVolumeCollection.prototype.remove = function(sensor) {
        if (sensor) {
            var sensors = this._sensors;
            var i = sensors.indexOf(sensor);
            if (i !== -1) {
                sensors[i].destroy();
                sensors.splice(i, 1);
                return true;
            }
        }

        return false;
    };

    /**
     * DOC_TBA
     *
     * @memberof SensorVolumeCollection
     *
     * @see SensorVolumeCollection#remove
     */
    SensorVolumeCollection.prototype.removeAll = function() {
        var sensors = this._sensors;
        var length = sensors.length;
        for ( var i = 0; i < length; ++i) {
            sensors[i].destroy();
        }

        this._sensors = [];
    };

    /**
     * DOC_TBA
     * @memberof SensorVolumeCollection
     */
    SensorVolumeCollection.prototype.contains = function(sensor) {
        if (sensor) {
            return (this._sensors.indexOf(sensor) !== -1);
        }

        return false;
    };

    /**
     * DOC_TBA
     *
     * @memberof SensorVolumeCollection
     *
     * @see SensorVolumeCollection#getLength
     */
    SensorVolumeCollection.prototype.get = function(index) {
        if (typeof index === 'undefined') {
            throw new DeveloperError('index is required.');
        }

        return this._sensors[index];
    };

    /**
     * DOC_TBA
     *
     * @memberof SensorVolumeCollection
     *
     * @see SensorVolumeCollection#get
     */
    SensorVolumeCollection.prototype.getLength = function() {
        return this._sensors.length;
    };

    /**
     * @private
     */
    SensorVolumeCollection.prototype.update = function(context, sceneState) {
        var sensors = this._sensors;
        var length = sensors.length;
        for ( var i = 0; i < length; ++i) {
            sensors[i].update(context, sceneState);
        }
    };

    /**
     * @private
     */
    SensorVolumeCollection.prototype.render = function(context) {
        var sensors = this._sensors;
        var length = sensors.length;
        for ( var i = 0; i < length; ++i) {
            sensors[i].render(context);
        }
    };

    /**
     * @private
     */
    SensorVolumeCollection.prototype.updateForPick = function(context) {
        var sensors = this._sensors;
        var length = sensors.length;
        for ( var i = 0; i < length; ++i) {
            sensors[i].updateForPick(context);
        }
    };

    /**
     * @private
     */
    SensorVolumeCollection.prototype.renderForPick = function(context, framebuffer) {
        var sensors = this._sensors;
        var length = sensors.length;
        for ( var i = 0; i < length; ++i) {
            sensors[i].renderForPick(context, framebuffer);
        }
    };

    /**
     * DOC_TBA
     * @memberof SensorVolumeCollection
     */
    SensorVolumeCollection.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * DOC_TBA
     * @memberof SensorVolumeCollection
     */
    SensorVolumeCollection.prototype.destroy = function() {
        this.removeAll();
        return destroyObject(this);
    };

    return SensorVolumeCollection;
});
/*!
 * Copyright (c) 2000-2005, Sean O'Neil (s_p_oneil@hotmail.com)
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * * Neither the name of the project nor the names of its contributors may be
 *   used to endorse or promote products derived from this software without
 *   specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Modifications made by Analytical Graphics, Inc.
 */
/*global define*/
define('Shaders/SkyAtmosphereFS',[],function() {
  
  return "uniform float g;\n" +
"uniform float g2;\n" +
"varying vec3 v_rayleighColor;\n" +
"varying vec3 v_mieColor;\n" +
"varying vec3 v_toCamera;\n" +
"varying vec3 v_positionEC;\n" +
"void main (void)\n" +
"{\n" +
"agi_ellipsoid ellipsoid = agi_getWgs84EllipsoidEC();\n" +
"vec3 direction = normalize(v_positionEC);\n" +
"agi_ray ray = agi_ray(vec3(0.0, 0.0, 0.0), direction);\n" +
"agi_raySegment intersection = agi_rayEllipsoidIntersectionInterval(ray, ellipsoid);\n" +
"if (!agi_isEmpty(intersection)) {\n" +
"discard;\n" +
"}\n" +
"float fCos = dot(agi_sunDirectionWC, normalize(v_toCamera)) / length(v_toCamera);\n" +
"float fRayleighPhase = 0.75 * (1.0 + fCos*fCos);\n" +
"float fMiePhase = 1.5 * ((1.0 - g2) / (2.0 + g2)) * (1.0 + fCos*fCos) / pow(1.0 + g2 - 2.0*g*fCos, 1.5);\n" +
"const float fExposure = 2.0;\n" +
"vec3 rgb = fRayleighPhase * v_rayleighColor + fMiePhase * v_mieColor;\n" +
"gl_FragColor = vec4(vec3(1.0) - exp(-fExposure * rgb), 1.0);\n" +
"}\n" +
"";
});
/*!
 * Copyright (c) 2000-2005, Sean O'Neil (s_p_oneil@hotmail.com)
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * * Neither the name of the project nor the names of its contributors may be
 *   used to endorse or promote products derived from this software without
 *   specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Modifications made by Analytical Graphics, Inc.
 */
/*global define*/
define('Shaders/SkyAtmosphereVS',[],function() {
  
  return "attribute vec4 position;\n" +
"uniform float fCameraHeight;\n" +
"uniform float fCameraHeight2;\n" +
"uniform vec3 v3InvWavelength;\n" +
"uniform float fOuterRadius;\n" +
"uniform float fOuterRadius2;\n" +
"uniform float fInnerRadius;\n" +
"uniform float fInnerRadius2;\n" +
"uniform float fKrESun;\n" +
"uniform float fKmESun;\n" +
"uniform float fKr4PI;\n" +
"uniform float fKm4PI;\n" +
"uniform float fScale;\n" +
"uniform float fScaleDepth;\n" +
"uniform float fScaleOverScaleDepth;\n" +
"const int nSamples = 2;\n" +
"const float fSamples = 2.0;\n" +
"varying vec3 v_rayleighColor;\n" +
"varying vec3 v_mieColor;\n" +
"varying vec3 v_toCamera;\n" +
"varying vec3 v_positionEC;\n" +
"float scale(float fCos)\n" +
"{\n" +
"float x = 1.0 - fCos;\n" +
"return fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\n" +
"}\n" +
"void main(void)\n" +
"{\n" +
"vec3 v3Pos = position.xyz;\n" +
"vec3 v3Ray = v3Pos - agi_viewerPositionWC;\n" +
"float fFar = length(v3Ray);\n" +
"v3Ray /= fFar;\n" +
"#ifdef SKY_FROM_SPACE\n" +
"float B = 2.0 * dot(agi_viewerPositionWC, v3Ray);\n" +
"float C = fCameraHeight2 - fOuterRadius2;\n" +
"float fDet = max(0.0, B*B - 4.0 * C);\n" +
"float fNear = 0.5 * (-B - sqrt(fDet));\n" +
"vec3 v3Start = agi_viewerPositionWC + v3Ray * fNear;\n" +
"fFar -= fNear;\n" +
"float fStartAngle = dot(v3Ray, v3Start) / fOuterRadius;\n" +
"float fStartDepth = exp(-1.0 / fScaleDepth);\n" +
"float fStartOffset = fStartDepth*scale(fStartAngle);\n" +
"#else\n" +
"vec3 v3Start = agi_viewerPositionWC;\n" +
"float fHeight = length(v3Start);\n" +
"float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fCameraHeight));\n" +
"float fStartAngle = dot(v3Ray, v3Start) / fHeight;\n" +
"float fStartOffset = fDepth*scale(fStartAngle);\n" +
"#endif\n" +
"float fSampleLength = fFar / fSamples;\n" +
"float fScaledLength = fSampleLength * fScale;\n" +
"vec3 v3SampleRay = v3Ray * fSampleLength;\n" +
"vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\n" +
"vec3 v3FrontColor = vec3(0.0, 0.0, 0.0);\n" +
"for(int i=0; i<nSamples; i++)\n" +
"{\n" +
"float fHeight = length(v3SamplePoint);\n" +
"float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));\n" +
"float fLightAngle = dot(agi_sunDirectionWC, v3SamplePoint) / fHeight;\n" +
"float fCameraAngle = dot(v3Ray, v3SamplePoint) / fHeight;\n" +
"float fScatter = (fStartOffset + fDepth*(scale(fLightAngle) - scale(fCameraAngle)));\n" +
"vec3 v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));\n" +
"v3FrontColor += v3Attenuate * (fDepth * fScaledLength);\n" +
"v3SamplePoint += v3SampleRay;\n" +
"}\n" +
"v_mieColor = v3FrontColor * fKmESun;\n" +
"v_rayleighColor = v3FrontColor * (v3InvWavelength * fKrESun);\n" +
"v_toCamera = agi_viewerPositionWC - v3Pos;\n" +
"v_positionEC = (agi_modelView * position).xyz;\n" +
"gl_Position = agi_modelViewProjection * position;\n" +
"}\n" +
"";
});

/*global define*/
define('Shaders/TieDyeMaterial',[],function() {
  
  return "uniform vec4 u_lightColor;\n" +
"uniform vec4 u_darkColor;\n" +
"uniform float u_frequency;\n" +
"vec4 agi_getMaterialColor(float zDistance, vec2 st, vec3 str)\n" +
"{\n" +
"vec3 scaled = str / u_frequency;\n" +
"float t = abs(agi_snoise(scaled));\n" +
"return mix(u_lightColor, u_darkColor, t);\n" +
"}\n" +
"";
});
/*global define*/
define('Scene/TieDyeMaterial',[
        '../Core/Color',
        '../Shaders/Noise',
        '../Shaders/TieDyeMaterial'
    ], function(
        Color,
        ShadersNoise,
        ShadersTieDyeMaterial){
    

    /**
     * DOC_TBA
     *
     * @alias TieDyeMaterial
     * @constructor
     */
    var TieDyeMaterial = function(template) {
        var t = template || {};

        /**
         * DOC_TBA
         */
        this.lightColor = (typeof t.lightColor !== 'undefined') ? Color.clone(t.lightColor) : new Color(1.0, 1.0, 1.0, 0.5);

        /**
         * DOC_TBA
         */
        this.darkColor = (typeof t.darkColor !== 'undefined') ? Color.clone(t.darkColor) : new Color(0.0, 0.0, 1.0, 0.5);

        /**
         * DOC_TBA
         *
         * @type Number
         */
        this.frequency = t.frequency || (1.0 / 10.0);

        var that = this;
        this._uniforms = {
            u_lightColor : function() {
                return that.lightColor;
            },
            u_darkColor : function() {
                return that.darkColor;
            },
            u_frequency : function() {
                return that.frequency;
            }
        };
    };

    TieDyeMaterial.prototype._getShaderSource = function() {
        return '#line 0\n' +
               ShadersNoise +
               '#line 0\n' +
               ShadersTieDyeMaterial;
    };

    return TieDyeMaterial;
});

/*global define*/
define('Shaders/VerticalStripeMaterial',[],function() {
  
  return "uniform vec4 u_lightColor;\n" +
"uniform vec4 u_darkColor;\n" +
"uniform float u_offset;\n" +
"uniform float u_repeat;\n" +
"vec4 agi_getMaterialColor(float zDistance, vec2 st, vec3 str)\n" +
"{\n" +
"const float fuzz = 0.1;\n" +
"float value = fract((st.s - u_offset) * (u_repeat * 0.5));\n" +
"float val1 = clamp(value / fuzz, 0.0, 1.0);\n" +
"float val2 = clamp((value - 0.5) / fuzz, 0.0, 1.0);\n" +
"val1 = val1 * (1.0 - val2);\n" +
"val1 = val1 * val1 * (3.0 - (2.0 * val1));\n" +
"return mix(u_lightColor, u_darkColor, val1);\n" +
"}\n" +
"";
});
/*global define*/
define('Scene/VerticalStripeMaterial',[
        '../Core/Color',
        '../Shaders/VerticalStripeMaterial'
       ], function(
         Color,
         ShadersVerticalStripeMaterial) {
    

    /**
     * DOC_TBA
     *
     * @alias VerticalStripeMaterial
     * @constructor
     */
    var VerticalStripeMaterial = function(template) {
        var t = template || {};

        /**
         * DOC_TBA
         */
        this.lightColor = (typeof t.lightColor !== 'undefined') ? Color.clone(t.lightColor) : new Color(1.0, 1.0, 1.0, 0.5);

        /**
         * DOC_TBA
         */
        this.darkColor = (typeof t.darkColor !== 'undefined') ? Color.clone(t.darkColor) : new Color(0.0, 0.0, 1.0, 0.5);

        /**
         * DOC_TBA
         *
         * @type Number
         */
        this.offset = t.offset || 0.0;

        /**
         * DOC_TBA
         *
         * @type Number
         */
        this.repeat = t.repeat || 10.0;

        var that = this;
        this._uniforms = {
            u_lightColor : function() {
                return that.lightColor;
            },
            u_darkColor : function() {
                return that.darkColor;
            },
            u_offset : function() {
                return that.offset;
            },
            u_repeat : function() {
                return that.repeat;
            }
        };
    };

    VerticalStripeMaterial.prototype._getShaderSource = function() {
        return '#line 0\n' + ShadersVerticalStripeMaterial;
    };

    return VerticalStripeMaterial;
});

/*global define*/
define('Shaders/ViewportQuadFS',[],function() {
  
  return "uniform sampler2D u_texture;\n" +
"varying vec2 v_textureCoordinates;\n" +
"void main()\n" +
"{\n" +
"vec4 c = texture2D(u_texture, v_textureCoordinates);\n" +
"if (c.a == 0.0)\n" +
"{\n" +
"discard;\n" +
"}\n" +
"gl_FragColor = c;\n" +
"}\n" +
"";
});

/*global define*/
define('Shaders/ViewportQuadVS',[],function() {
  
  return "attribute vec4 position;\n" +
"attribute vec2 textureCoordinates;\n" +
"varying vec2 v_textureCoordinates;\n" +
"void main()\n" +
"{\n" +
"gl_Position = agi_viewportOrthographic * position;\n" +
"v_textureCoordinates = textureCoordinates;\n" +
"}\n" +
"";
});
/*global define*/
define('Scene/ViewportQuad',[
        '../Core/destroyObject',
        '../Core/Rectangle',
        '../Core/ComponentDatatype',
        '../Core/PrimitiveType',
        '../Renderer/BufferUsage',
        '../Renderer/BlendingState',
        '../Shaders/ViewportQuadVS',
        '../Shaders/ViewportQuadFS'
    ], function(
        destroyObject,
        Rectangle,
        ComponentDatatype,
        PrimitiveType,
        BufferUsage,
        BlendingState,
        ViewportQuadVS,
        ViewportQuadFS) {
    

    /**
     * DOC_TBA
     *
     * @alias ViewportQuad
     * @constructor
     */
    var ViewportQuad = function(rectangle) {
        this.renderState = null;
        this._sp = null;
        this._va = null;

        this.vertexShader = ViewportQuadVS;
        this.fragmentShader = ViewportQuadFS;

        this._texture = null;
        this._destroyTexture = true;

        this._framebuffer = null;
        this._destroyFramebuffer = false;

        this._rectangle = rectangle; // TODO: copy?
        this._dirtyRectangle = true;

        this.enableBlending = false;

        var that = this;
        this.uniforms = {
            u_texture : function() {
                return that._texture;
            }
        };
    };

    /**
     * DOC_TBA
     * @memberof ViewportQuad
     */
    ViewportQuad.prototype.getRectangle = function() {
        return this._rectangle;
    };

    /**
     * DOC_TBA
     *
     * @memberof ViewportQuad
     *
     * @param {Rectangle} value DOC_TBA
     */
    ViewportQuad.prototype.setRectangle = function(value) {
        if (value && !this._rectangle.equals(value)) {
            this._rectangle = new Rectangle(value.x, value.y, value.width, value.height);
            this._dirtyRectangle = true;
        }
    };

    /**
     * DOC_TBA
     * @memberof ViewportQuad
     */
    ViewportQuad.prototype.getTexture = function() {
        return this._texture;
    };

    /**
     * DOC_TBA
     * @memberof ViewportQuad
     */
    ViewportQuad.prototype.setTexture = function(value) {
        if (this._texture !== value) {
            this._texture = this._destroyTexture && this._texture && this._texture.destroy();
            this._texture = value;
        }
    };

    /**
     * DOC_TBA
     * @memberof ViewportQuad
     */
    ViewportQuad.prototype.getDestroyTexture = function() {
        return this._destroyTexture;
    };

    /**
     * DOC_TBA
     * @memberof ViewportQuad
     */
    ViewportQuad.prototype.setDestroyTexture = function(value) {
        this._destroyTexture = value;
    };

    /**
     * DOC_TBA
     * @memberof ViewportQuad
     */
    ViewportQuad.prototype.getFramebuffer = function() {
        return this._framebuffer;
    };

    /**
     * DOC_TBA
     * @memberof ViewportQuad
     */
    ViewportQuad.prototype.setFramebuffer = function(value) {
        if (this._framebuffer !== value) {
            this._framebuffer = this._destroyFramebuffer && this._framebuffer && this._framebuffer.destroy();
            this._framebuffer = value;
        }
    };

    /**
     * DOC_TBA
     * @memberof ViewportQuad
     */
    ViewportQuad.prototype.getDestroyFramebuffer = function() {
        return this._destroyFramebuffer;
    };

    /**
     * DOC_TBA
     * @memberof ViewportQuad
     */
    ViewportQuad.prototype.setDestroyFramebuffer = function(value) {
        this._destroyFramebuffer = value;
    };

    /**
     * DOC_TBA
     * @memberof ViewportQuad
     */
    ViewportQuad.prototype.render = function(context) {
        if (this._texture) {
            context.draw({
                primitiveType : PrimitiveType.TRIANGLE_FAN,
                shaderProgram : this._sp,
                uniformMap : this.uniforms,
                vertexArray : this._va,
                renderState : this.renderState,
                framebuffer : this._framebuffer
            });
        }
    };

    ViewportQuad._getAttributeIndices = function() {
        return {
            position : 0,
            textureCoordinates : 1
        };
    };

    ViewportQuad.prototype._update = function(context, sceneState) {
        if (this._dirtyRectangle) {
            this._dirtyRectangle = false;

            var rectangle = this._rectangle;
            var mesh = {
                attributes : {
                    position : {
                        componentDatatype : ComponentDatatype.FLOAT,
                        componentsPerAttribute : 2,
                        values : [rectangle.x, rectangle.y, rectangle.x + rectangle.width, rectangle.y, rectangle.x + rectangle.width, rectangle.y + rectangle.height, rectangle.x,
                                rectangle.y + rectangle.height]
                    },

                    textureCoordinates : {
                        componentDatatype : ComponentDatatype.FLOAT,
                        componentsPerAttribute : 2,
                        values : [0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0]
                    }
                }
            };

            this.renderState.blending.enabled = this.enableBlending;
            this._va = context.createVertexArrayFromMesh({
                mesh : mesh,
                attributeIndices : ViewportQuad._getAttributeIndices(),
                bufferUsage : BufferUsage.STATIC_DRAW
            });
        }
    };

    /**
     * @private
     */
    ViewportQuad.prototype.update = function(context, sceneState) {
        this._sp = context.getShaderCache().getShaderProgram(this.vertexShader, this.fragmentShader, ViewportQuad._getAttributeIndices());
        this.renderState = context.createRenderState({ blending : BlendingState.ALPHA_BLEND });

        this._update(context, sceneState);
        this.update = this._update;
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof ViewportQuad
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see ViewportQuad#destroy
     */
    ViewportQuad.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof ViewportQuad
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see ViewportQuad#isDestroyed
     *
     * @example
     * quad = quad && quad.destroy();
     */
    ViewportQuad.prototype.destroy = function() {
        this._va = this._va && this._va.destroy();
        this._sp = this._sp && this._sp.release();
        this._texture = this._destroyTexture && this._texture && this._texture.destroy();
        this._framebuffer = this._destroyFramebuffer && this._framebuffer && this._framebuffer.destroy();

        return destroyObject(this);
    };

    return ViewportQuad;
});
/*global define*/
define('Scene/CentralBody',[
        '../Core/DeveloperError',
        '../Core/RuntimeError',
        '../Core/Color',
        '../Core/combine',
        '../Core/destroyObject',
        '../Core/Math',
        '../Core/Intersect',
        '../Core/Occluder',
        '../Core/Ellipsoid',
        '../Core/Extent',
        '../Core/BoundingSphere',
        '../Core/Rectangle',
        '../Core/Cache',
        '../Core/Cartesian2',
        '../Core/Cartesian3',
        '../Core/Cartesian4',
        '../Core/Cartographic',
        '../Core/Matrix3',
        '../Core/Queue',
        '../Core/ComponentDatatype',
        '../Core/IndexDatatype',
        '../Core/MeshFilters',
        '../Core/PrimitiveType',
        '../Core/CubeMapEllipsoidTessellator',
        '../Core/ExtentTessellator',
        '../Core/PlaneTessellator',
        '../Core/JulianDate',
        '../Core/Transforms',
        '../Renderer/BufferUsage',
        '../Renderer/CullFace',
        '../Renderer/DepthFunction',
        '../Renderer/PixelFormat',
        '../Renderer/MipmapHint',
        '../Renderer/TextureMagnificationFilter',
        '../Renderer/TextureMinificationFilter',
        '../Renderer/TextureWrap',
        './Projections',
        './Tile',
        './TileState',
        './SceneMode',
        './Texture2DPool',
        './ViewportQuad',
        '../Shaders/CentralBodyVS',
        '../Shaders/CentralBodyFS',
        '../Shaders/CentralBodyFSCommon',
        '../Shaders/CentralBodyVSDepth',
        '../Shaders/CentralBodyFSDepth',
        '../Shaders/CentralBodyVSFilter',
        '../Shaders/CentralBodyFSFilter',
        '../Shaders/CentralBodyVSPole',
        '../Shaders/CentralBodyFSPole',
        '../Shaders/GroundAtmosphere',
        '../Shaders/SkyAtmosphereFS',
        '../Shaders/SkyAtmosphereVS'
    ], function(
        DeveloperError,
        RuntimeError,
        Color,
        combine,
        destroyObject,
        CesiumMath,
        Intersect,
        Occluder,
        Ellipsoid,
        Extent,
        BoundingSphere,
        Rectangle,
        Cache,
        Cartesian2,
        Cartesian3,
        Cartesian4,
        Cartographic,
        Matrix3,
        Queue,
        ComponentDatatype,
        IndexDatatype,
        MeshFilters,
        PrimitiveType,
        CubeMapEllipsoidTessellator,
        ExtentTessellator,
        PlaneTessellator,
        JulianDate,
        Transforms,
        BufferUsage,
        CullFace,
        DepthFunction,
        PixelFormat,
        MipmapHint,
        TextureMagnificationFilter,
        TextureMinificationFilter,
        TextureWrap,
        Projections,
        Tile,
        TileState,
        SceneMode,
        Texture2DPool,
        ViewportQuad,
        CentralBodyVS,
        CentralBodyFS,
        CentralBodyFSCommon,
        CentralBodyVSDepth,
        CentralBodyFSDepth,
        CentralBodyVSFilter,
        CentralBodyFSFilter,
        CentralBodyVSPole,
        CentralBodyFSPole,
        GroundAtmosphere,
        SkyAtmosphereFS,
        SkyAtmosphereVS) {
    

    function TileTextureCachePolicy(description) {
        var desc = description || {};

        if (!desc.fetchFunc || typeof desc.fetchFunc !== 'function') {
            throw new DeveloperError('description.fetchFunc is a required function.');
        }

        this._limit = desc.limit || 128;
        this._count = 0;
        this._fetchFunc = desc.fetchFunc;
        this._removeFunc = (typeof desc.removeFunc === 'function') ? desc.removeFunc : undefined;
    }

    TileTextureCachePolicy.prototype.hit = function(object) {
        var time = new JulianDate();
        var current = object.key;
        while (current) {
            current._lastHit = time;
            current = current.parent;
        }
        return object.value;
    };

    TileTextureCachePolicy.prototype.miss = function(name, key, object) {
        var property = {
            key : key,
            value : undefined
        };

        property.value = this._fetchFunc(key);
        var lruTime = new JulianDate();
        this.hit(property);

        if (this._count < this._limit) {
            ++this._count;
            object[name] = property;
            return property.value;
        }

        var element;
        var index = '';
        var keys = Object.keys(object);
        for ( var i = 0; i < keys.length; ++i) {
            element = object[keys[i]];
            if (element.key._lastHit.lessThan(lruTime) && element.key.zoom > 2) {
                lruTime = element.key._lastHit;
                index = keys[i];
            }
        }

        element = object[index];
        if (this._removeFunc) {
            this._removeFunc(element.key);
        }
        delete object[index];

        object[name] = property;
        return property.value;
    };

    var attributeIndices = {
        position3D : 0,
        textureCoordinates : 1,
        position2D : 2
    };

    /**
     * DOC_TBA
     *
     * @alias CentralBody
     * @constructor
     *
     * @param {Ellipsoid} [ellipsoid=WGS84 Ellipsoid] Determines the size and shape of the central body.
     *
     */
    var CentralBody = function(ellipsoid) {
        ellipsoid = ellipsoid || Ellipsoid.WGS84;

        this._ellipsoid = ellipsoid;
        this._maxExtent = new Extent(
            -CesiumMath.PI,
            -CesiumMath.PI_OVER_TWO,
            CesiumMath.PI,
            CesiumMath.PI_OVER_TWO
        );
        this._rootTile = new Tile({
            extent : this._maxExtent,
            zoom : 0,
            ellipsoid : ellipsoid
        });
        this._occluder = new Occluder(new BoundingSphere(Cartesian3.ZERO, ellipsoid.getMinimumRadius()), Cartesian3.ZERO);

        this._renderQueue = new Queue();
        this._imageQueue = new Queue();
        this._textureQueue = new Queue();
        this._reprojectQueue = new Queue();

        this._texturePool = undefined;
        this._textureCache = undefined;
        this._textureCacheLimit = 512; // TODO: pick appropriate cache limit

        // TODO: pick appropriate throttle limits
        this._textureThrottleLimit = 10;
        this._reprojectThrottleLimit = 10;
        this._imageThrottleLimit = 15;

        this._prefetchLimit = 1;
        this._tileFailCount = 0;
        this._lastFailedTime = undefined;

        /**
         * The maximum number of tiles that can fail consecutively before the
         * central body will stop loading tiles.
         *
         * @type {Number}
         * @default 3
         */
        this.perTileMaxFailCount = 3;

        /**
         * The maximum number of failures allowed for each tile before the
         * central body will stop loading a failing tile.
         *
         * @type {Number}
         * @default 30
         */
        this.maxTileFailCount = 30;

        /**
         * The number of seconds between attempts to retry a failing tile.
         *
         * @type {Number}
         * @default 30.0
         */
        this.failedTileRetryTime = 30.0;

        this._spWithoutAtmosphere = undefined;
        this._spGroundFromSpace = undefined;
        this._spGroundFromAtmosphere = undefined;
        this._sp = undefined; // Reference to without-atmosphere, ground-from-space, or ground-from-atmosphere
        this._rsColor = undefined;

        this._spSkyFromSpace = undefined;
        this._spSkyFromAtmosphere = undefined;
        this._vaSky = undefined; // Reference to sky-from-space or sky-from-atmosphere
        this._spSky = undefined;
        this._rsSky = undefined;

        this._spDepth = undefined;
        this._vaDepth = undefined;
        this._rsDepth = undefined;

        this._quadH = undefined;
        this._quadV = undefined;

        this._fb = undefined;

        this._vaNorthPole = undefined;
        this._vaSouthPole = undefined;
        this._spPolesWithoutAtmosphere = undefined;
        this._spPolesGroundFromSpace = undefined;
        this._spPolesGroundFromAtmosphere = undefined;
        this._spPoles = undefined; // Reference to without-atmosphere, ground-from-space, or ground-from-atmosphere
        this._northPoleUniforms = undefined;
        this._southPoleUniforms = undefined;
        this._drawNorthPole = false;
        this._drawSouthPole = false;

        /**
         * Determines the color of the north pole. If the day tile provider imagery does not
         * extend over the north pole, it will be filled with this color before applying lighting.
         *
         * @type {Cartesian3}
         */
        this.northPoleColor = new Cartesian3(2.0 / 255.0, 6.0 / 255.0, 18.0 / 255.0);

        /**
         * Determines the color of the south pole. If the day tile provider imagery does not
         * extend over the south pole, it will be filled with this color before applying lighting.
         *
         * @type {Cartesian3}
         */
        this.southPoleColor = new Cartesian3(1.0, 1.0, 1.0);

        /**
         * Determines the position of the day tile provider logo. The day tile provider logo
         * is displayed in the bottom left corner of the viewport. This is used to offset the
         * position of the logo.
         *
         * @type {Cartesian2}
         */
        this.logoOffset = Cartesian2.ZERO;
        this._logoOffset = this.logoOffset;
        this._imageLogo = undefined;
        this._quadLogo = undefined;

        this._minTileDistance = undefined;

        /**
         * DOC_TBA
         *
         * @type {Number}
         * @default 5.0
         */
        this.pixelError3D = 5.0;

        /**
         * DOC_TBA
         *
         * @type {Number}
         * @default 2.0
         */
        this.pixelError2D = 2.0;

        /**
         * Determines if the central body will be shown.
         *
         * @type {Boolean}
         * @default true
         */
        this.show = true;

        /**
         * Determines if the ground atmosphere will be shown.
         *
         * @type {Boolean}
         * @default false
         */
        this.showGroundAtmosphere = false;

        /**
         * Determines if the sky atmosphere will be shown.
         *
         * @type {Boolean}
         * @default false
         */
        this.showSkyAtmosphere = false;

        /**
         * <p>
         * Determines if the central body is affected by lighting, i.e., if sun light brightens the
         * day side of the globe, and and the night side appears dark.  When <code>true</code>, the
         * central body is affected by lighting; when <code>false</code>, the central body is uniformly
         * shaded with the day tile provider, i.e., no night lights, atmosphere, etc. are used.
         * </p>
         * <p>
         * The default is <code>true</code>.
         * </p>
         *
         * @default true
         */
        this.affectedByLighting = true;
        this._affectedByLighting = true;

        /**
         * DOC_TBA
         */
        this.dayTileProvider = undefined;
        this._dayTileProvider = undefined;

        /**
         * The URL of the image to use as a night texture.  An asynchronous
         * request is made for the image at the next call to {@link CentralBody#update}.
         * The night texture is shown once the image is loaded and {@link CentralBody#showNight}
         * is <code>true</code>.
         * <br /><br />
         * Example day image:
         * <div align='center'>
         * <img src='../images/CentralBody.nightImageSource.jpg' width='512' height='256' />
         * <a href='http://visibleearth.nasa.gov/view_rec.php?id=1438'>NASA Visible Earth</a>.
         * Data courtesy Marc Imhoff of NASA GSFC and Christopher Elvidge of
         * NOAA NGDC. Image by Craig Mayhew and Robert Simmon, NASA GSFC.
         * </div>
         *
         * @type {String}
         *
         * @see CentralBody#showNight
         */
        this.nightImageSource = undefined;
        this._nightImageSource = undefined;
        this._nightTexture = undefined;

        /**
         * The URL of the image to use as a specular map; a single-channel image where zero indicates
         * land cover, and 255 indicates water.  An asynchronous request is made for the image
         * at the next call to {@link CentralBody#update}. The specular map is used once the
         * image is loaded and {@link CentralBody#showSpecular} is <code>true</code>.
         * <br /><br />
         * Example specular map:
         * <div align='center'>
         * <img src='../images/CentralBody.specularMapSource.jpg' width='512' height='256' />
         * <a href='http://planetpixelemporium.com/earth.html'>Planet Texture Maps</a>
         * </div>
         *
         * @type {String}
         *
         * @see CentralBody#showSpecular
         */
        this.specularMapSource = undefined;
        this._specularMapSource = undefined;
        this._specularTexture = undefined;

        /**
         * The URL of the image to use as a cloud map; a single-channel image where 255 indicates
         * cloud cover, and zero indicates no clouds.  An asynchronous request is made for the image
         * at the next call to {@link CentralBody#update}. The cloud map is shown once the
         * image is loaded and {@link CentralBody#showClouds} is <code>true</code>.
         * <br /><br />
         * Example cloud map:
         * <div align='center'>
         * <img src='../images/CentralBody.cloudsMapSource.jpg' width='512' height='256' />
         * <a href='http://planetpixelemporium.com/earth.html'>Planet Texture Maps</a>
         * </div>
         *
         * @type {String}
         *
         * @see CentralBody#showClouds
         */
        this.cloudsMapSource = undefined;
        this._cloudsMapSource = undefined;
        this._cloudsTexture = undefined;

        /**
         * The URL of the image to use as a bump map; a single-channel image where zero indicates
         * sea level, and 255 indicates maximum height.  An asynchronous request is made for the image
         * at the next call to {@link CentralBody#update}. The bump map is used once the
         * image is loaded and {@link CentralBody#showBumps} is <code>true</code>.
         * <br /><br />
         * Example bump map:
         * <div align='center'>
         * <img src='../images/CentralBody.bumpMapSource.jpg' width='512' height='256' />
         * <a href='http://planetpixelemporium.com/earth.html'>Planet Texture Maps</a>
         * </div>
         *
         * @type {String}
         *
         * @see CentralBody#showBumps
         */
        this.bumpMapSource = undefined;
        this._bumpMapSource = undefined;
        this._bumpTexture = undefined;

        /**
         * When <code>true</code>, textures from the <code>dayTileProvider</code> are shown on the central body.
         * <br /><br />
         * <div align='center'>
         * <img src='../images/CentralBody.showDay.jpg' width='400' height='300' />
         * </div>
         *
         * @type {Boolean}
         *
         * @see CentralBody#dayTileProvider
         * @see CentralBody#showNight
         *
         * @default true
         */
        this.showDay = true;
        this._showDay = false;

        /**
         * When <code>true</code>, the night texture is shown on the side of the central body not illuminated by the sun.
         * The day and night textures are blended across the terminator using {@link CentralBody#dayNightBlendDelta}.
         * When <code>false</code>, the day textures are shown on the entire globe (if enabled).
         * <div align='center'>
         * <img src='../images/CentralBody.showNight.jpg' width='400' height='300' />
         * </div>
         *
         * @type {Boolean}
         *
         * @see CentralBody#nightImageSource
         * @see CentralBody#showDay
         * @see CentralBody#dayNightBlendDelta
         *
         * @default true
         *
         * @example
         * cb.showNight = true;
         * cb.nightImageSource = 'night.jpg';
         */
        this.showNight = true;
        this._showNight = false;

        /**
         * When <code>true</code>, diffuse-lit clouds are shown on the central body.  When {@link CentralBody#showNight}
         * is also true, clouds on the dark side of the globe will fully or partially occlude the night texture.
         * <div align='center'>
         * <img src='../images/CentralBody.showClouds.jpg' width='400' height='300' />
         * </div>
         *
         * @type {Boolean}
         *
         * @see CentralBody#cloudsMapSource
         * @see CentralBody#showCloudShadows
         * @see CentralBody#showNight
         *
         * @default true
         *
         * @example
         * cb.showClouds = true;
         * cb.cloudsMapSource = 'clouds.jpg';
         */
        this.showClouds = true;
        this._showClouds = false;

        /**
         * When <code>true</code>, clouds on the daytime side of the globe cast approximate shadows.  The
         * shadows can be shown with or without the clouds themselves, which are controlled with
         * {@link CentralBody#showClouds}.
         * <div align='center'>
         * <table border='0' cellpadding='5'><tr>
         * <td align='center'><code>true</code><br/><img src='../images/CentralBody.showCloudShadows.true.jpg' width='250' height='188' /></td>
         * <td align='center'><code>false</code><br/><img src='../images/CentralBody.showCloudShadows.false.jpg' width='250' height='188' /></td>
         * </tr></table>
         * </div>
         *
         * @type {Boolean}
         *
         * @see CentralBody#cloudsMapSource
         * @see CentralBody#showClouds
         *
         * @default true
         *
         * @example
         * cb.showClouds = true;
         * cb.showCloudShadows = true;
         * cb.cloudsMapSource = 'clouds.jpg';
         */
        this.showCloudShadows = true;
        this._showCloudShadows = false;

        /**
         * When <code>true</code>, a specular map (also called a gloss map) is used so only the ocean receives specular light.
         * <div align='center'>
         * <table border='0' cellpadding='5'><tr>
         * <td align='center'><code>true</code><br/><img src='../images/CentralBody.showSpecular.true.jpg' width='250' height='188' /></td>
         * <td align='center'><code>false</code><br/><img src='../images/CentralBody.showSpecular.false.jpg' width='250' height='188' /></td>
         * </tr></table>
         * </div>
         *
         * @type {Boolean}
         *
         * @see CentralBody#specularMapSource
         *
         * @default true
         *
         * @example
         * cb.showSpecular = true;
         * cb.specularMapSource = 'specular.jpg';
         */
        this.showSpecular = true;
        this._showSpecular = false;

        /**
         * When <code>true</code>, a bump map is used to add lighting detail to the mountainous areas of the central body.
         * This gives the appearance of extra geometric complexity even though the central body is still a smooth ellipsoid.
         * The apparent steepness of the mountains is controlled by {@link CentralBody#bumpMapNormalZ}.
         * <div align='center'>
         * <table border='0' cellpadding='5'><tr>
         * <td align='center'><code>true</code><br/><img src='../images/CentralBody.showBumps.true.jpg' width='250' height='188' /></td>
         * <td align='center'><code>false</code><br/><img src='../images/CentralBody.showBumps.false.jpg' width='250' height='188' /></td>
         * </tr></table>
         * </div>
         *
         * @type {Boolean}
         *
         * @see CentralBody#bumpMapSource
         * @see CentralBody#bumpMapNormalZ
         *
         * @default true
         *
         * @example
         * cb.showBumps = true;
         * cb.bumpMapSource = 'bump.jpg';
         */
        this.showBumps = true;
        this._showBumps = false;

        /**
         * When <code>true</code>, shows a line on the central body where day meets night.
         * <div align='center'>
         * <img src='../images/CentralBody.showTerminator.jpg' width='400' height='300' />
         * </div>
         *
         * @type {Boolean}
         *
         * @see CentralBody#showNight
         * @see CentralBody#dayNightBlendDelta
         *
         * @default false
         */
        this.showTerminator = false;
        this._showTerminator = false;

        /**
         * When {@link CentralBody#showBumps} is <code>true</code>, <code>bumpMapNormalZ</code> controls the
         * apparent steepness of the mountains.  A value less than one over-exaggerates the steepness; a value greater
         * than one under-exaggerates, making mountains less noticeable.
         * <div align='center'>
         * <table border='0' cellpadding='5'><tr>
         * <td align='center'><code>0.25</code><br/><img src='../images/Centralbody.bumpMapNormalZ.025.jpg' width='250' height='188' /></td>
         * <td align='center'><code>1.25</code><br/><img src='../images/Centralbody.bumpMapNormalZ.125.jpg' width='250' height='188' /></td>
         * </tr></table>
         * </div>
         *
         * @type {Number}
         *
         * @see CentralBody#showBumps
         *
         * @default 0.5
         *
         * @example
         * cb.showBumps = true;
         * cb.bumpMapSource = 'bump.jpg';
         * cb.bumpMapNormalZ = 1.0;
         */
        this.bumpMapNormalZ = 0.5;

        /**
         * When {@link CentralBody#showDay} and {@link CentralBody#showNight} are both <code>true</code>,
         * <code>dayNightBlendDelta</code> determines the size of the blend region surrounding the terminator (where day
         * meets night).  A value of zero indicates a sharp transition without blending; a larger value creates a linearly
         * blended region based on the diffuse lighting component:  <code>-dayNightBlendDelta &lt; diffuse &lt; dayNightBlendDelta</code>.
         * <div align='center'>
         * <table border='0' cellpadding='5'><tr>
         * <td align='center'><code>0.0</code><br/><img src='../images/Centralbody.dayNightBlendDelta.0.jpg' width='250' height='188' /></td>
         * <td align='center'><code>0.05</code><br/><img src='../images/Centralbody.dayNightBlendDelta.05.jpg' width='250' height='188' /></td>
         * </tr></table>
         * </div>
         *
         * @type {Number}
         *
         * @see CentralBody#showDay
         * @see CentralBody#showNight
         * @see CentralBody#showTerminator
         *
         * @default 0.05
         *
         * @example
         * cb.showDay = true;
         * cb.dayTileProvider = new Cesium.SingleTileProvider('day.jpg');
         * cb.showNight = true;
         * cb.nightImageSource = 'night.jpg';
         * cb.dayNightBlendDelta = 0.0;  // Sharp transition
         */
        this.dayNightBlendDelta = 0.05;

        /**
         * Changes the intensity of the night texture. A value of 1.0 is the same intensity as night texture.
         * A value less than 1.0 makes the night texture darker. A value greater than 1.0 makes the night texture
         * brighter. The default value is 2.0.
         *
         * @type {Number}
         *
         * @default 2.0
         */
        this.nightIntensity = 2.0;

        /**
         * The current morph transition time between 2D/Columbus View and 3D,
         * with 0.0 being 2D or Columbus View and 1.0 being 3D.
         *
         * @type Number
         *
         * @default 1.0
         */
        this.morphTime = 1.0;

        this._mode = SceneMode.SCENE3D;
        this._projection = undefined;

        this._fCameraHeight = undefined;
        this._fCameraHeight2 = undefined;
        this._outerRadius = ellipsoid.getRadii().multiplyByScalar(1.025).getMaximumComponent();

        // TODO: Do we want to expose any of these atmosphere constants?
        var Kr = 0.0025;
        var Kr4PI = Kr * 4.0 * Math.PI;
        var Km = 0.0015;
        var Km4PI = Km * 4.0 * Math.PI;
        var ESun = 15.0;
        var g = -0.95;
        var innerRadius = ellipsoid.getRadii().getMaximumComponent();
        var rayleighScaleDepth = 0.25;
        var inverseWaveLength = {
            x : 1.0 / Math.pow(0.650, 4.0), // Red
            y : 1.0 / Math.pow(0.570, 4.0), // Green
            z : 1.0 / Math.pow(0.475, 4.0) // Blue
        };

        this._minGroundFromAtmosphereHeight = 6378500.0; // from experimentation / where shader fails due to precision errors
        this._startFadeGroundFromAtmosphere = this._minGroundFromAtmosphereHeight + 1000;

        var that = this;

        var atmosphereUniforms = {
            v3InvWavelength : function() {
                return inverseWaveLength;
            },
            fCameraHeight : function() {
                return that._fCameraHeight;
            },
            fCameraHeight2 : function() {
                return that._fCameraHeight2;
            },
            fOuterRadius : function() {
                return that._outerRadius;
            },
            fOuterRadius2 : function() {
                return that._outerRadius * that._outerRadius;
            },
            fInnerRadius : function() {
                return innerRadius;
            },
            fInnerRadius2 : function() {
                return innerRadius * innerRadius;
            },
            fKrESun : function() {
                return Kr * ESun;
            },
            fKmESun : function() {
                return Km * ESun;
            },
            fKr4PI : function() {
                return Kr4PI;
            },
            fKm4PI : function() {
                return Km4PI;
            },
            fScale : function() {
                return 1.0 / (that._outerRadius - innerRadius);
            },
            fScaleDepth : function() {
                return rayleighScaleDepth;
            },
            fScaleOverScaleDepth : function() {
                return (1.0 / (that._outerRadius - innerRadius)) / rayleighScaleDepth;
            },
            g : function() {
                return g;
            },
            g2 : function() {
                return g * g;
            },
            fMinGroundFromAtmosphereHeight : function() {
                return that._minGroundFromAtmosphereHeight;
            },
            fstartFadeGroundFromAtmosphere : function() {
                return that._startFadeGroundFromAtmosphere;
            }
        };

        var uniforms = {
            u_nightTexture : function() {
                return that._nightTexture;
            },
            u_cloudMap : function() {
                return that._cloudsTexture;
            },
            u_specularMap : function() {
                return that._specularTexture;
            },
            u_bumpMap : function() {
                return that._bumpTexture;
            },
            u_bumpMapResoltuion : function() {
                return {
                    x : 1.0 / that._bumpTexture.getWidth(),
                    y : 1.0 / that._bumpTexture.getHeight()
                };
            },
            u_bumpMapNormalZ : function() {
                return that.bumpMapNormalZ;
            },
            u_dayNightBlendDelta : function() {
                return that.dayNightBlendDelta;
            },
            u_nightIntensity : function() {
                return that.nightIntensity;
            },
            u_morphTime : function() {
                return that.morphTime;
            }
        };

        // PERFORMANCE_IDEA:  Only combine these if showing the atmosphere.  Maybe this is too much of a micro-optimization.
        // http://jsperf.com/object-property-access-propcount
        this._drawUniforms = combine(uniforms, atmosphereUniforms);
    };

    /**
     * DOC_TBA
     *
     * @memberof CentralBody
     *
     * @return {Ellipsoid} DOC_TBA
     */
    CentralBody.prototype.getEllipsoid = function() {
        return this._ellipsoid;
    };

    CentralBody._isModeTransition = function(oldMode, newMode) {
        // SCENE2D, COLUMBUS_VIEW, and MORPHING use the same rendering path, so a
        // transition only occurs when switching from/to SCENE3D
        return ((oldMode !== newMode) &&
                ((oldMode === SceneMode.SCENE3D) ||
                 (newMode === SceneMode.SCENE3D)));
    };

    CentralBody.prototype._prefetchImages = function() {
        var limit = Math.max(Math.min(this._prefetchLimit, this._dayTileProvider.zoomMax), this._dayTileProvider.zoomMin);
        var stack = [this._rootTile];
        while (stack.length !== 0) {
            var tile = stack.pop();

            if (tile.zoom < limit) {
                this._processTile(tile);
                stack = stack.concat(tile.getChildren());
            } else if (tile.zoom === limit) {
                this._processTile(tile);
            }
        }
    };

    CentralBody.prototype._createTextureCache = function(context) {
        var pool = this._texturePool = new Texture2DPool(context);

        var fetch = function(tile) {
            var texture = pool.createTexture2D({
                width : tile.image.width,
                height : tile.image.height,
                pixelFormat : PixelFormat.RGB
            });
            return texture;
        };

        var remove = function(tile) {
            tile.texture = tile.texture && tile.texture.destroy();
            tile._extentVA = tile._extentVA && tile._extentVA.destroy();
            tile.projection = undefined;
            tile.state = TileState.READY;
        };

        var policy = new TileTextureCachePolicy({
            fetchFunc : fetch,
            removeFunc : remove,
            limit : this._textureCacheLimit
        });
        this._textureCache = new Cache(policy);
    };

    CentralBody.prototype._fetchImage = function(tile) {
        var that = this;
        var onload = function() {
            tile.state = TileState.IMAGE_LOADED;
        };
        var onerror = function() {
            tile._failCount = (tile._failCount) ? tile._failCount + 1 : 1;
            ++that._tileFailCount;
            that._lastFailedTime = new JulianDate();
            tile.state = TileState.IMAGE_FAILED;
        };
        var oninvalid = function() {
            tile.state = TileState.IMAGE_INVALID;
        };
        return this._dayTileProvider.loadTileImage(tile, onload, onerror, oninvalid);
    };

    CentralBody.prototype._getTileBoundingSphere = function(tile, sceneState) {
        if (sceneState.mode === SceneMode.SCENE3D) {
            return tile.get3DBoundingSphere();
        } else if (sceneState.mode === SceneMode.COLUMBUS_VIEW) {
            var boundingVolume = tile.get2DBoundingSphere(sceneState.scene2D.projection).clone();
            boundingVolume.center = new Cartesian3(0.0, boundingVolume.center.x, boundingVolume.center.y);
            return boundingVolume;
        } else {
            return tile.computeMorphBounds(this.morphTime, sceneState.scene2D.projection);
        }
    };

    CentralBody.prototype._cull = function(tile, sceneState) {
        if (sceneState.mode === SceneMode.SCENE2D) {
            var bRect = tile.get2DBoundingRectangle(sceneState.scene2D.projection);

            var frustum = sceneState.camera.frustum;
            var position = sceneState.camera.position;
            var up = sceneState.camera.up;
            var right = sceneState.camera.right;

            var width = frustum.right - frustum.left;
            var height = frustum.top - frustum.bottom;

            var lowerLeft = position.add(right.multiplyByScalar(frustum.left));
            lowerLeft = lowerLeft.add(up.multiplyByScalar(frustum.bottom));
            var upperLeft = lowerLeft.add(up.multiplyByScalar(height));
            var upperRight = upperLeft.add(right.multiplyByScalar(width));
            var lowerRight = upperRight.add(up.multiplyByScalar(-height));

            var x = Math.min(lowerLeft.x, lowerRight.x, upperLeft.x, upperRight.x);
            var y = Math.min(lowerLeft.y, lowerRight.y, upperLeft.y, upperRight.y);
            var w = Math.max(lowerLeft.x, lowerRight.x, upperLeft.x, upperRight.x) - x;
            var h = Math.max(lowerLeft.y, lowerRight.y, upperLeft.y, upperRight.y) - y;

            var fRect = new Rectangle(x, y, w, h);

            return !Rectangle.rectangleRectangleIntersect(bRect, fRect);
        }

        var boundingVolume = this._getTileBoundingSphere(tile, sceneState);
        if (sceneState.camera.getVisibility(boundingVolume, BoundingSphere.planeSphereIntersect) === Intersect.OUTSIDE) {
            return true;
        }

        if (sceneState.mode === SceneMode.SCENE3D) {
            var occludeePoint = tile.getOccludeePoint();
            var occluder = this._occluder;
            return (occludeePoint && !occluder.isVisible(new BoundingSphere(occludeePoint, 0.0))) || !occluder.isVisible(boundingVolume);
        }

        return false;
    };

    CentralBody.prototype._throttleImages = function(sceneState) {
        for ( var i = 0, len = this._imageQueue.length; i < len && i < this._imageThrottleLimit; ++i) {
            var tile = this._imageQueue.dequeue();

            if (this._cull(tile, sceneState)) {
                tile.state = TileState.READY;
                continue;
            }

            if (this._dayTileProvider.zoomMin !== 0 && tile.zoom === 0 && tile.x === 0 && tile.y === 0) {
                tile.image = this._createBaseTile();
                tile.projection = Projections.WGS84; // no need to re-project
                tile.state = TileState.IMAGE_LOADED;
            } else {
                tile.image = this._fetchImage(tile);
                if (!tile.projection) {
                    tile.projection = this._dayTileProvider.projection;
                }
            }
        }
    };

    CentralBody.prototype._createBaseTile = function() {
        // Some tile servers, like Bing, don't have a base image for the entire central body.
        // Create a 1x1 image that will never get rendered.
        var canvas = document.createElement('canvas');
        canvas.width = 1.0;
        canvas.height = 1.0;

        return canvas;
    };

    CentralBody.prototype._throttleReprojection = function(sceneState) {
        for ( var i = 0, len = this._reprojectQueue.length; i < len && i < this._reprojectThrottleLimit; ++i) {
            var tile = this._reprojectQueue.dequeue();

            if (this._cull(tile, sceneState)) {
                tile.image = undefined;
                tile.state = TileState.READY;
                continue;
            }

            tile.image = tile.projection.toWgs84(tile.extent, tile.image);
            tile.state = TileState.REPROJECTED;
            tile.projection = Projections.WGS84;
        }
    };

    CentralBody.prototype._throttleTextures = function(context, sceneState) {
        for ( var i = 0, len = this._textureQueue.length; i < len && i < this._textureThrottleLimit; ++i) {
            var tile = this._textureQueue.dequeue();

            if (this._cull(tile, sceneState) || !tile.image) {
                tile.image = undefined;
                tile.state = TileState.READY;
                continue;
            }

            tile.texture = this._textureCache.find(tile);
            tile.texture.copyFrom(tile.image);
            tile.texture.generateMipmap(MipmapHint.NICEST);
            tile.texture.setSampler({
                wrapS : TextureWrap.CLAMP,
                wrapT : TextureWrap.CLAMP,
                minificationFilter : TextureMinificationFilter.LINEAR_MIPMAP_LINEAR,
                magnificationFilter : TextureMagnificationFilter.LINEAR,
                maximumAnisotropy : context.getMaximumTextureFilterAnisotropy() || 8 // TODO: Remove Chrome work around
            });
            tile.state = TileState.TEXTURE_LOADED;
            tile.image = undefined;
        }
    };

    CentralBody.prototype._processTile = function(tile) {
        if (this._imageQueue.contains(tile) || this._reprojectQueue.contains(tile) || this._textureQueue.contains(tile)) {
            return;
        }

        var maxFailed = this._tileFailCount > this._maxTileFailCount;
        var requestFailed = tile.state === TileState.IMAGE_FAILED && tile._failCount < this._maxTileFailCount;
        var maxTimePassed = this._lastFailedTime && this._lastFailedTime.getSecondsDifference(new JulianDate()) >= this.failedTileRetryTime;
        var retry = maxTimePassed || (requestFailed && !maxFailed);

        // check if tile needs to load image
        if (!tile.state || tile.state === TileState.READY) {
            this._imageQueue.enqueue(tile);
            tile.state = TileState.IMAGE_LOADING;
        } else if (tile.state === TileState.IMAGE_LOADED) {
            // or re-project the image
            this._reprojectQueue.enqueue(tile);
            tile.state = TileState.REPROJECTING;
        } else if (tile.state === TileState.REPROJECTED) {
            // or copy to a texture
            this._textureQueue.enqueue(tile);
            tile.state = TileState.TEXTURE_LOADING;
        } else if (retry) {
            // or retry a failed image
            if (maxTimePassed) {
                tile._failCount = 0;
                this._tileFailCount = 0;
            }
            this._imageQueue.enqueue(tile);
            tile.state = TileState.IMAGE_LOADING;
        } else if (tile.state === TileState.IMAGE_INVALID && tile.image) {
            // or release invalid image if there is one
            tile.image = undefined;
        }
    };

    CentralBody.prototype._enqueueTile = function(tile, context, sceneState) {
        if (this._renderQueue.contains(tile)) {
            return;
        }

        var mode = sceneState.mode;
        var projection = sceneState.scene2D.projection;

        // create vertex array the first time it is needed or when morphing
        if (!tile._extentVA ||
            tile._extentVA.isDestroyed() ||
            CentralBody._isModeTransition(this._mode, mode) ||
            tile._mode !== mode ||
            this._projection !== projection) {
            tile._extentVA = tile._extentVA && tile._extentVA.destroy();

            var ellipsoid = this._ellipsoid;
            var rtc = tile.get3DBoundingSphere().center;
            var projectedRTC = tile.get2DBoundingSphere(projection).center.clone();

            var gran = (tile.zoom > 0) ? 0.05 * (1.0 / tile.zoom * 2.0) : 0.05; // seems like a good value after testing it for what looks good

            var typedArray;
            var buffer;
            var stride;
            var attributes;
            var indexBuffer;
            var datatype = ComponentDatatype.FLOAT;
            var usage = BufferUsage.STATIC_DRAW;

            if (mode === SceneMode.SCENE3D) {
                var buffers = ExtentTessellator.computeBuffers({
                    ellipsoid : ellipsoid,
                    extent : tile.extent,
                    granularity : gran,
                    generateTextureCoords : true,
                    interleave : true,
                    relativeToCenter : rtc
                });

                typedArray = datatype.toTypedArray(buffers.vertices);
                buffer = context.createVertexBuffer(typedArray, usage);
                stride = 5 * datatype.sizeInBytes;
                attributes = [{
                    index : attributeIndices.position3D,
                    vertexBuffer : buffer,
                    componentDatatype : datatype,
                    componentsPerAttribute : 3,
                    offsetInBytes : 0,
                    strideInBytes : stride
                }, {
                    index : attributeIndices.textureCoordinates,
                    vertexBuffer : buffer,
                    componentDatatype : datatype,
                    componentsPerAttribute : 2,
                    offsetInBytes : 3 * datatype.sizeInBytes,
                    strideInBytes : stride
                }, {
                    index : attributeIndices.position2D,
                    value : [0.0, 0.0]
                }];
                indexBuffer = context.createIndexBuffer(new Uint16Array(buffers.indices), usage, IndexDatatype.UNSIGNED_SHORT);
            } else {
                var vertices = [];
                var width = tile.extent.east - tile.extent.west;
                var height = tile.extent.north - tile.extent.south;
                var lonScalar = 1.0 / width;
                var latScalar = 1.0 / height;

                var mesh = PlaneTessellator.compute({
                    resolution : {
                        x : Math.max(Math.ceil(width / gran), 2.0),
                        y : Math.max(Math.ceil(height / gran), 2.0)
                    },
                    onInterpolation : function(time) {
                        var lonLat = new Cartographic(
                                CesiumMath.lerp(tile.extent.west, tile.extent.east, time.x),
                                CesiumMath.lerp(tile.extent.south, tile.extent.north, time.y));

                        var p = ellipsoid.cartographicToCartesian(lonLat).subtract(rtc);
                        vertices.push(p.x, p.y, p.z);

                        var u = (lonLat.longitude - tile.extent.west) * lonScalar;
                        var v = (lonLat.latitude - tile.extent.south) * latScalar;
                        vertices.push(u, v);

                        // TODO: This will not work if the projection's ellipsoid is different
                        // than the central body's ellipsoid.  Throw an exception?
                        var projectedLonLat = projection.project(lonLat).subtract(projectedRTC);
                        vertices.push(projectedLonLat.x, projectedLonLat.y);
                    }
                });

                typedArray = datatype.toTypedArray(vertices);
                buffer = context.createVertexBuffer(typedArray, usage);
                stride = 7 * datatype.sizeInBytes;
                attributes = [{
                    index : attributeIndices.position3D,
                    vertexBuffer : buffer,
                    componentDatatype : datatype,
                    componentsPerAttribute : 3,
                    offsetInBytes : 0,
                    strideInBytes : stride
                }, {
                    index : attributeIndices.textureCoordinates,
                    vertexBuffer : buffer,
                    componentDatatype : datatype,
                    componentsPerAttribute : 2,
                    offsetInBytes : 3 * datatype.sizeInBytes,
                    strideInBytes : stride
                }, {
                    index : attributeIndices.position2D,
                    vertexBuffer : buffer,
                    componentDatatype : datatype,
                    componentsPerAttribute : 2,
                    offsetInBytes : 5 * datatype.sizeInBytes,
                    strideInBytes : stride
                }];

                indexBuffer = context.createIndexBuffer(new Uint16Array(mesh.indexLists[0].values), usage, IndexDatatype.UNSIGNED_SHORT);
            }

            tile._extentVA = context.createVertexArray(attributes, indexBuffer);

            var intensity = (this._dayTileProvider && this._dayTileProvider.getIntensity && this._dayTileProvider.getIntensity(tile)) || 0.0;
            var drawUniforms = {
                u_dayTexture : function() {
                    return tile.texture;
                },
                u_center3D : function() {
                    return rtc;
                },
                u_center2D : function() {
                    return (projectedRTC) ? Cartesian2.fromCartesian3(projectedRTC) : Cartesian2.ZERO;
                },
                u_modifiedModelView : function() {
                    return tile.modelView;
                },
                u_dayIntensity : function() {
                    return intensity;
                },
                u_mode : function() {
                    return tile.mode;
                }
            };
            tile._drawUniforms = combine(drawUniforms, this._drawUniforms);

            tile._mode = mode;
        }
        this._renderQueue.enqueue(tile);
    };

    CentralBody.prototype._createTileDistanceFunction = function(sceneState, width, height) {
        var provider = this._dayTileProvider;
        if (typeof provider === 'undefined') {
            return undefined;
        }

        if (sceneState.mode === SceneMode.SCENE2D) {
            return undefined;
        }

        var frustum = sceneState.camera.frustum;
        var extent = provider.maxExtent;

        var pixelSizePerDistance = 2.0 * Math.tan(frustum.fovy * 0.5);
        if (height > width * frustum.aspectRatio) {
            pixelSizePerDistance /= height;
        } else {
            pixelSizePerDistance /= width;
        }

        var invPixelSizePerDistance = 1.0 / pixelSizePerDistance;
        var texelHeight = (extent.north - extent.south) / provider.tileHeight;
        var texelWidth = (extent.east - extent.west) / provider.tileWidth;
        var texelSize = (texelWidth > texelHeight) ? texelWidth : texelHeight;
        var dmin = texelSize * invPixelSizePerDistance;
        dmin *= this._ellipsoid.getMaximumRadius();

        return function(zoom, pixelError) {
            return (dmin / pixelError) * Math.exp(-0.693147181 * zoom);
        };
    };

    CentralBody.prototype._refine3D = function(tile, context, sceneState) {
        var provider = this._dayTileProvider;
        if (typeof provider === 'undefined') {
            return false;
        }

        if (tile.zoom < provider.zoomMin) {
            return true;
        }

        if (typeof this._minTileDistance === 'undefined') {
            return false;
        }

        var boundingVolume = this._getTileBoundingSphere(tile, sceneState);
        var cameraPosition = sceneState.camera.getPositionWC();
        var direction = sceneState.camera.getDirectionWC();

        var texturePixelError = (this.pixelError3D !== 'undefined' && this.pixelError3D > 0.0) ? this.pixelError3D : 1.0;
        var dmin = this._minTileDistance(tile.zoom, texturePixelError);

        var toCenter = boundingVolume.center.subtract(cameraPosition);
        var toSphere = toCenter.normalize().multiplyByScalar(toCenter.magnitude() - boundingVolume.radius);
        var distance = direction.multiplyByScalar(direction.dot(toSphere)).magnitude();

        if (distance > 0.0 && distance < dmin) {
            return true;
        }

        return false;
    };

    CentralBody.prototype._refine2D = function(tile, context, sceneState) {
        var camera = sceneState.camera;
        var frustum = camera.frustum;
        var pixelError = this.pixelError2D;
        var provider = this._dayTileProvider;

        var projection = sceneState.scene2D.projection;
        var viewport = context.getViewport();
        var viewportWidth = viewport.width;
        var viewportHeight = viewport.height;

        if (typeof provider === 'undefined') {
            return false;
        }

        if (tile.zoom < provider.zoomMin) {
            return true;
        }

        var texturePixelError = (pixelError > 0.0) ? pixelError : 1.0;

        var tileWidth, tileHeight;
        if (tile.texture && !tile.texture.isDestroyed()) {
            tileWidth = tile.texture.getWidth();
            tileHeight = tile.texture.getHeight();
        } else if (tile.image && typeof tile.image.width !== 'undefined') {
            tileWidth = tile.image.width;
            tileHeight = tile.image.height;
        } else {
            tileWidth = provider.tileWidth;
            tileHeight = provider.tileHeight;
        }

        var a = projection.project(new Cartographic(tile.extent.west, tile.extent.north));
        var b = projection.project(new Cartographic(tile.extent.east, tile.extent.south));
        var diagonal = a.subtract(b);
        var texelSize = Math.max(diagonal.x, diagonal.y) / Math.max(tileWidth, tileHeight);
        var pixelSize = Math.max(frustum.top - frustum.bottom, frustum.right - frustum.left) / Math.max(viewportWidth, viewportHeight);

        if (texelSize > pixelSize * texturePixelError) {
            return true;
        }

        return false;
    };

    CentralBody.prototype._refine = function(tile, context, sceneState) {
        if (sceneState.mode === SceneMode.SCENE2D) {
            return this._refine2D(tile, context, sceneState);
        }

        return this._refine3D(tile, context, sceneState);
    };

    CentralBody.prototype._createScissorRectangle = function(description) {
        var quad = description.quad;

        var upperLeft = new Cartesian3(quad[0], quad[1], quad[2]);
        var lowerLeft = new Cartesian3(quad[3], quad[4], quad[5]);
        var upperRight = new Cartesian3(quad[6], quad[7], quad[8]);
        var lowerRight = new Cartesian3(quad[9], quad[10], quad[11]);

        var mvp = description.modelViewProjection;
        var vt = description.viewportTransformation;

        var diag1 = upperRight.subtract(lowerLeft);
        var diag2 = upperLeft.subtract(lowerRight);

        var diag1Length = diag1.magnitude();
        var diag2Length = diag2.magnitude();

        var halfWidth = Math.max(diag1Length, diag2Length) * 0.5;
        var halfHeight = halfWidth;

        var center = lowerLeft.add(diag1.normalize().multiplyByScalar(diag1Length * 0.5));

        var camera = description.sceneState.camera;
        var nearCenter = camera.position.add(camera.direction.multiplyByScalar(camera.frustum.near));

        if (camera.direction.dot(center.subtract(nearCenter)) < 0) {
            center = center.subtract(nearCenter);
            var centerProjN = camera.direction.multiplyByScalar(camera.direction.dot(center));
            var centerRejN = center.subtract(centerProjN);
            center = nearCenter.add(centerRejN);
        }

        lowerLeft = center.add(camera.up.multiplyByScalar(-halfHeight)).add(camera.right.multiplyByScalar(-halfWidth));
        lowerLeft = Transforms.pointToWindowCoordinates(mvp, vt, lowerLeft);
        upperRight = center.add(camera.up.multiplyByScalar(halfHeight)).add(camera.right.multiplyByScalar(halfWidth));
        upperRight = Transforms.pointToWindowCoordinates(mvp, vt, upperRight);

        lowerLeft.x = Math.max(0.0, Math.min(lowerLeft.x, description.width));
        lowerLeft.y = Math.max(0.0, Math.min(lowerLeft.y, description.height));
        upperRight.x = Math.max(0.0, Math.min(upperRight.x, description.width));
        upperRight.y = Math.max(0.0, Math.min(upperRight.y, description.height));

        var x = Math.floor(lowerLeft.x);
        var y = Math.floor(lowerLeft.y);
        var width = Math.ceil(upperRight.x) - x;
        var height = Math.ceil(upperRight.y) - y;

        return new Rectangle(x, y, width, height);
    };

    CentralBody.prototype._computeDepthQuad = function(sceneState) {
        var radii = this._ellipsoid.getRadii();
        var p = sceneState.camera.getPositionWC();

        // Find the corresponding position in the scaled space of the ellipsoid.
        var q = this._ellipsoid.getOneOverRadii().multiplyComponents(p);

        var qMagnitude = q.magnitude();
        var qUnit = q.normalize();

        // Determine the east and north directions at q.
        var eUnit = Cartesian3.UNIT_Z.cross(q).normalize();
        var nUnit = qUnit.cross(eUnit).normalize();

        // Determine the radius of the 'limb' of the ellipsoid.
        var wMagnitude = Math.sqrt(q.magnitudeSquared() - 1.0);

        // Compute the center and offsets.
        var center = qUnit.multiplyByScalar(1.0 / qMagnitude);
        var scalar = wMagnitude / qMagnitude;
        var eastOffset = eUnit.multiplyByScalar(scalar);
        var northOffset = nUnit.multiplyByScalar(scalar);

        // A conservative measure for the longitudes would be to use the min/max longitudes of the bounding frustum.
        var upperLeft = radii.multiplyComponents(center.add(northOffset).subtract(eastOffset));
        var upperRight = radii.multiplyComponents(center.add(northOffset).add(eastOffset));
        var lowerLeft = radii.multiplyComponents(center.subtract(northOffset).subtract(eastOffset));
        var lowerRight = radii.multiplyComponents(center.subtract(northOffset).add(eastOffset));
        return [upperLeft.x, upperLeft.y, upperLeft.z, lowerLeft.x, lowerLeft.y, lowerLeft.z, upperRight.x, upperRight.y, upperRight.z, lowerRight.x, lowerRight.y, lowerRight.z];
    };

    CentralBody.prototype._computePoleQuad = function(sceneState, maxLat, maxGivenLat, viewProjMatrix, viewportTransformation) {
        var pt1 = this._ellipsoid.cartographicToCartesian(new Cartographic(0.0, maxGivenLat));
        var pt2 = this._ellipsoid.cartographicToCartesian(new Cartographic(Math.PI, maxGivenLat));
        var radius = pt1.subtract(pt2).magnitude() * 0.5;

        var center = this._ellipsoid.cartographicToCartesian(new Cartographic(0.0, maxLat));

        var right;
        var dir = sceneState.camera.direction;
        if (1.0 - Cartesian3.UNIT_Z.negate().dot(dir) < CesiumMath.EPSILON6) {
            right = Cartesian3.UNIT_X;
        } else {
            right = dir.cross(Cartesian3.UNIT_Z).normalize();
        }

        var screenRight = center.add(right.multiplyByScalar(radius));
        var screenUp = center.add(Cartesian3.UNIT_Z.cross(right).normalize().multiplyByScalar(radius));

        center = Transforms.pointToWindowCoordinates(viewProjMatrix, viewportTransformation, center);
        screenRight = Transforms.pointToWindowCoordinates(viewProjMatrix, viewportTransformation, screenRight);
        screenUp = Transforms.pointToWindowCoordinates(viewProjMatrix, viewportTransformation, screenUp);

        var halfWidth = Math.floor(Math.max(screenUp.subtract(center).magnitude(), screenRight.subtract(center).magnitude()));
        var halfHeight = halfWidth;

        return new Rectangle(
                Math.floor(center.x) - halfWidth,
                Math.floor(center.y) - halfHeight,
                halfWidth * 2.0,
                halfHeight * 2.0);
    };

    CentralBody.prototype._fillPoles = function(context, sceneState) {
        if (typeof this._dayTileProvider === 'undefined' || sceneState.mode !== SceneMode.SCENE3D) {
            return;
        }

        var viewProjMatrix = context.getUniformState().getViewProjection();
        var viewportTransformation = context.getUniformState().getViewportTransformation();
        var latitudeExtension = 0.05;

        var extent;
        var boundingVolume;
        var frustumCull;
        var occludeePoint;
        var occluded;
        var datatype;
        var mesh;
        var rect;
        var positions;
        var occluder = this._occluder;

        // handle north pole
        if (this._dayTileProvider.maxExtent.north < CesiumMath.PI_OVER_TWO) {
            extent = new Extent(
                -Math.PI,
                this._dayTileProvider.maxExtent.north,
                Math.PI,
                CesiumMath.PI_OVER_TWO
            );
            boundingVolume = Extent.compute3DBoundingSphere(extent, this._ellipsoid);
            frustumCull = sceneState.camera.getVisibility(boundingVolume, BoundingSphere.planeSphereIntersect) === Intersect.OUTSIDE;
            occludeePoint = Extent.computeOccludeePoint(extent, this._ellipsoid).occludeePoint;
            occluded = (occludeePoint && !occluder.isVisible(new BoundingSphere(occludeePoint, 0.0))) || !occluder.isVisible(boundingVolume);

            this._drawNorthPole = !frustumCull && !occluded;
            if (this._drawNorthPole) {
                rect = this._computePoleQuad(sceneState, extent.north, extent.south - latitudeExtension, viewProjMatrix, viewportTransformation);
                positions = [
                    rect.x, rect.y,
                    rect.x + rect.width, rect.y,
                    rect.x + rect.width, rect.y + rect.height,
                    rect.x, rect.y + rect.height
                ];

                if (typeof this._vaNorthPole === 'undefined') {
                    mesh = {
                        attributes : {
                            position : {
                                componentDatatype : ComponentDatatype.FLOAT,
                                componentsPerAttribute : 2,
                                values : positions
                            }
                        }
                    };
                    this._vaNorthPole = context.createVertexArrayFromMesh({
                        mesh : mesh,
                        attributeIndices : {
                            position : 0
                        },
                        bufferUsage : BufferUsage.STREAM_DRAW
                    });
                } else {
                    datatype = ComponentDatatype.FLOAT;
                    this._vaNorthPole.getAttribute(0).vertexBuffer.copyFromArrayView(datatype.toTypedArray(positions));
                }
            }
        }

        // handle south pole
        if (this._dayTileProvider.maxExtent.south > -CesiumMath.PI_OVER_TWO) {
            extent = new Extent(
                -Math.PI,
                -CesiumMath.PI_OVER_TWO,
                Math.PI,
                this._dayTileProvider.maxExtent.south
            );
            boundingVolume = Extent.compute3DBoundingSphere(extent, this._ellipsoid);
            frustumCull = sceneState.camera.getVisibility(boundingVolume, BoundingSphere.planeSphereIntersect) === Intersect.OUTSIDE;
            occludeePoint = Extent.computeOccludeePoint(extent, this._ellipsoid).occludeePoint;
            occluded = (occludeePoint && !occluder.isVisible(new BoundingSphere(occludeePoint, 0.0))) || !occluder.isVisible(boundingVolume);

            this._drawSouthPole = !frustumCull && !occluded;
            if (this._drawSouthPole) {
                rect = this._computePoleQuad(sceneState, extent.south, extent.north + latitudeExtension, viewProjMatrix, viewportTransformation);
                positions = [
                     rect.x, rect.y,
                     rect.x + rect.width, rect.y,
                     rect.x + rect.width, rect.y + rect.height,
                     rect.x, rect.y + rect.height
                 ];

                 if (typeof this._vaSouthPole === 'undefined') {
                     mesh = {
                         attributes : {
                             position : {
                                 componentDatatype : ComponentDatatype.FLOAT,
                                 componentsPerAttribute : 2,
                                 values : positions
                             }
                         }
                     };
                     this._vaSouthPole = context.createVertexArrayFromMesh({
                         mesh : mesh,
                         attributeIndices : {
                             position : 0
                         },
                         bufferUsage : BufferUsage.STREAM_DRAW
                     });
                 } else {
                     datatype = ComponentDatatype.FLOAT;
                     this._vaSouthPole.getAttribute(0).vertexBuffer.copyFromArrayView(datatype.toTypedArray(positions));
                 }
            }
        }

        var that = this;
        var drawUniforms = {
            u_fbTexture : function() {
                return that._fb.getColorTexture();
            },
            u_dayIntensity : function() {
                return (that._dayTileProvider && that._dayTileProvider.getPoleIntensity && that._dayTileProvider.getPoleIntensity()) || 0.0;
            }
        };

        if (typeof this._northPoleUniforms === 'undefined') {
            this._northPoleUniforms = combine(drawUniforms, {
                u_color : function() {
                    return that.northPoleColor;
                }
            });
            this._northPoleUniforms = combine(this._northPoleUniforms, this._drawUniforms);
        }

        if (typeof this._southPoleUniforms === 'undefined') {
            this._southPoleUniforms = combine(drawUniforms, {
                u_color : function() {
                    return that.southPoleColor;
                }
            });
            this._southPoleUniforms = combine(this._southPoleUniforms, this._drawUniforms);
        }
    };

    /**
     * @private
     */
    CentralBody.prototype.update = function(context, sceneState) {
        var width = context.getCanvas().clientWidth;
        var height = context.getCanvas().clientHeight;

        if (width === 0 || height === 0) {
            return;
        }

        var mode = sceneState.mode;
        var projection = sceneState.scene2D.projection;

        if (this._dayTileProvider !== this.dayTileProvider) {
            this._dayTileProvider = this.dayTileProvider;

            // destroy logo
            this._quadLogo = this._quadLogo && this._quadLogo.destroy();

            // stop loading everything
            this._imageQueue.clear();
            this._textureQueue.clear();
            this._reprojectQueue.clear();

            // destroy tiles
            this._destroyTileTree();

            // destroy resources
            this._texturePool = this._texturePool && this._texturePool.destroy();
            this._textureCache = this._textureCache && this._textureCache.destroy();

            // create new tile tree
            this._rootTile = new Tile({
                extent : this._dayTileProvider.maxExtent || this._maxExtent,
                zoom : 0,
                ellipsoid : this._ellipsoid
            });

            this._prefetchImages();
        }

        var hasLogo = this._dayTileProvider && this._dayTileProvider.getLogo;
        var imageLogo =  (hasLogo) ? this._dayTileProvider.getLogo() : undefined;
        var createLogo = !this._quadLogo || this._quadLogo.isDestroyed();
        var updateLogo = createLogo || this._imageLogo !== imageLogo;
        if (updateLogo) {
            if (typeof imageLogo === 'undefined') {
                this._quadLogo = this._quadLogo && this._quadLogo.destroy();
            }
            else {
                this._quadLogo = new ViewportQuad(new Rectangle(this.logoOffset.x, this.logoOffset.y, imageLogo.width, imageLogo.height));
                this._quadLogo.setTexture(context.createTexture2D({
                    source : imageLogo,
                    pixelFormat : PixelFormat.RGBA
                }));
                this._quadLogo.enableBlending = true;
            }
            this._imageLogo = imageLogo;
        } else if (this._quadLogo && this._imageLogo && !this.logoOffset.equals(this._logoOffset)) {
            this._quadLogo.setRectangle(new Rectangle(this.logoOffset.x, this.logoOffset.y, this._imageLogo.width, this._imageLogo.height));
            this._logoOffset = this.logoOffset;
        }

        if (!this._textureCache || this._textureCache.isDestroyed()) {
            this._createTextureCache(context);
        }

        var createFBO = !this._fb || this._fb.isDestroyed();
        var fboDimensionsChanged = this._fb && (this._fb.getColorTexture().getWidth() !== width || this._fb.getColorTexture().getHeight() !== height);

        if (createFBO || fboDimensionsChanged ||
            (!this._quadV || this._quadV.isDestroyed()) ||
            (!this._quadH || this._quadH.isDestroyed())) {

            this._minTileDistance = this._createTileDistanceFunction(sceneState, width, height);

            this._fb = this._fb && this._fb.destroy();
            this._quadV = this._quadV && this._quadV.destroy();
            this._quadH = this._quadH && this._quadH.destroy();

            // create FBO and texture render targets
            this._fb = context.createFramebuffer({
                colorTexture : context.createTexture2D({
                    width : width,
                    height : height,
                    pixelFormat : PixelFormat.RGBA
                })
            });

            // create viewport quad for vertical gaussian blur pass
            this._quadV = new ViewportQuad(new Rectangle(0.0, 0.0, width, height));
            this._quadV.vertexShader = '#define VERTICAL 1\n' + CentralBodyVSFilter;
            this._quadV.fragmentShader = CentralBodyFSFilter;
            this._quadV.uniforms.u_height = function() {
                return height;
            };
            this._quadV.setTexture(this._fb.getColorTexture());
            this._quadV.setDestroyTexture(false);
            this._quadV.setFramebuffer(context.createFramebuffer({
                colorTexture : context.createTexture2D({
                    width : width,
                    height : height,
                    pixelFormat : PixelFormat.RGBA
                })
            }));
            this._quadV.setDestroyFramebuffer(true);

            // create viewport quad for horizontal gaussian blur pass
            this._quadH = new ViewportQuad(new Rectangle(0.0, 0.0, width, height));
            this._quadH.vertexShader = CentralBodyVSFilter;
            this._quadH.fragmentShader = CentralBodyFSFilter;
            this._quadH.uniforms.u_width = function() {
                return width;
            };
            this._quadH.setTexture(this._quadV.getFramebuffer().getColorTexture());
            this._quadH.setDestroyTexture(false);
        }

        if ((mode !== SceneMode.SCENE2D && mode !== SceneMode.MORPHING) && typeof this._minTileDistance === 'undefined') {
            this._minTileDistance = this._createTileDistanceFunction(sceneState, width, height);
        }

        this._quadV.update(context, sceneState);
        this._quadH.update(context, sceneState);

        if (this._quadLogo && !this._quadLogo.isDestroyed()) {
            this._quadLogo.update(context, sceneState);
        }

        var vs, fs;

        if (this.showSkyAtmosphere && !this._vaSky) {
            // PERFORMANCE_IDEA:  Is 60 the right amount to tessellate?  I think scaling the original
            // geometry in a vertex is a bad idea; at least, because it introduces a draw call per tile.
            var skyMesh = CubeMapEllipsoidTessellator.compute(new Ellipsoid(this._ellipsoid.getRadii().multiplyByScalar(1.025)), 60);
            this._vaSky = context.createVertexArrayFromMesh({
                mesh : skyMesh,
                attributeIndices : MeshFilters.createAttributeIndices(skyMesh),
                bufferUsage : BufferUsage.STATIC_DRAW
            });

            vs = '#define SKY_FROM_SPACE \n' +
                 '#line 0 \n' +
                 SkyAtmosphereVS;

            fs = '#line 0\n' +
                 SkyAtmosphereFS;

            this._spSkyFromSpace = context.getShaderCache().getShaderProgram(vs, fs);

            vs = '#define SKY_FROM_ATMOSPHERE' +
                 '#line 0 \n' +
                 SkyAtmosphereVS;

            this._spSkyFromAtmosphere = context.getShaderCache().getShaderProgram(vs, fs);
            this._rsSky = context.createRenderState({
                cull : {
                    enabled : true,
                    face : CullFace.FRONT
                }
            // TODO: revisit when multi-frustum/depth test is ready
            /*depthTest : {
                enabled : true
            },
            depthMask : false*/
            });
        }

        if (CentralBody._isModeTransition(this._mode, mode) || this._projection !== projection) {
            if (mode === SceneMode.SCENE3D) {
                this._rsColor = context.createRenderState({ // Write color, not depth
                    cull : {
                        enabled : true
                    }
                });
                this._rsDepth = context.createRenderState({ // Write depth, not color
                    cull : {
                        enabled : true
                    },
                    depthTest : {
                        enabled : true,
                        func : DepthFunction.ALWAYS
                    },
                    colorMask : {
                        red : false,
                        green : false,
                        blue : false,
                        alpha : false
                    }
                });
            } else {
                this._rsColor = context.createRenderState();
                this._rsDepth = context.createRenderState();
            }
        }

        // TODO: Wait until multi-frustum
        //this._rsColor.depthTest.enabled = (mode === SceneMode.MORPHING);  // Depth test during morph
        var cull = (mode === SceneMode.SCENE3D) || (mode === SceneMode.MORPHING);
        this._rsColor.cull.enabled = cull;
        this._rsDepth.cull.enabled = cull;

        // update scisor/depth plane
        var depthQuad = this._computeDepthQuad(sceneState);

        // TODO: Re-enable scissor test.
        /*var scissorTest = { enabled : false };
        if (mode === SceneMode.SCENE3D) {
            var uniformState = context.getUniformState();
            var mvp = uniformState.getModelViewProjection();
            var rect = this._createScissorRectangle({
                sceneState : sceneState,
                width : width,
                height : height,
                quad : depthQuad,
                modelViewProjection : mvp,
                viewportTransformation : uniformState.getViewportTransformation()
            });

            if (rect.width !== 0 && rect.height !== 0) {
                scissorTest = {
                    enabled : true,
                    rectangle : rect
                };
            }
        }
        this._rsColor.scissorTest = scissorTest;
        this._rsDepth.scissorTest = scissorTest;
        this._quadV.renderState.scissorTest = scissorTest;
        this._quadH.renderState.scissorTest = scissorTest;*/

        // depth plane
        if (!this._vaDepth) {
            var mesh = {
                attributes : {
                    position : {
                        componentDatatype : ComponentDatatype.FLOAT,
                        componentsPerAttribute : 3,
                        values : depthQuad
                    }
                },
                indexLists : [{
                    primitiveType : PrimitiveType.TRIANGLES,
                    values : [0, 1, 2, 2, 1, 3]
                }]
            };
            this._vaDepth = context.createVertexArrayFromMesh({
                mesh : mesh,
                attributeIndices : {
                    position : 0
                },
                bufferUsage : BufferUsage.DYNAMIC_DRAW
            });
        } else {
            var datatype = ComponentDatatype.FLOAT;
            this._vaDepth.getAttribute(0).vertexBuffer.copyFromArrayView(datatype.toTypedArray(depthQuad));
        }

        if (!this._spDepth) {
            this._spDepth = context.getShaderCache().getShaderProgram(
                    CentralBodyVSDepth,
                    '#line 0\n' +
                    CentralBodyFSDepth, {
                        position : 0
                    });
        }

        var that = this;

        // Throw exception if there was a problem asynchronously loading an image.
        if (this._exception) {
            var message = this._exception;
            this._exception = undefined;
            throw new RuntimeError(message);
        }

        // PERFORMANCE_IDEA:  Once a texture is created, it is not destroyed if
        // the corresponding show flag is turned off.  This will waste memory
        // if a user loads every texture, then sets all the flags to false.

        if (this._nightImageSource !== this.nightImageSource) {
            this._nightImageSource = this.nightImageSource;

            var nightImage = new Image();
            nightImage.onload = function() {
                that._nightTexture = that._nightTexture && that._nightTexture.destroy();
                that._nightTexture = context.createTexture2D({
                    source : nightImage,
                    pixelFormat : PixelFormat.RGB
                });
            };
            nightImage.onerror = function() {
                that._exception = 'Could not load image: ' + this.src + '.';
            };
            nightImage.src = this.nightImageSource;
        }

        if (this._specularMapSource !== this.specularMapSource) {
            this._specularMapSource = this.specularMapSource;

            var specularImage = new Image();
            specularImage.onload = function() {
                that._specularTexture = that._specularTexture && that._specularTexture.destroy();
                that._specularTexture = context.createTexture2D({
                    source : specularImage,
                    pixelFormat : PixelFormat.LUMINANCE
                });
            };
            specularImage.onerror = function() {
                that._exception = 'Could not load image: ' + this.src + '.';
            };
            specularImage.src = this.specularMapSource;
        }

        if (this._cloudsMapSource !== this.cloudsMapSource) {
            this._cloudsMapSource = this.cloudsMapSource;

            var cloudsImage = new Image();
            cloudsImage.onload = function() {
                that._cloudsTexture = that._cloudsTexture && that._cloudsTexture.destroy();
                that._cloudsTexture = context.createTexture2D({
                    source : cloudsImage,
                    pixelFormat : PixelFormat.LUMINANCE
                });
            };
            cloudsImage.onerror = function() {
                that._exception = 'Could not load image: ' + this.src + '.';
            };
            cloudsImage.src = this.cloudsMapSource;
        }

        if (this._bumpMapSource !== this.bumpMapSource) {
            this._bumpMapSource = this.bumpMapSource;

            var bumpImage = new Image();
            bumpImage.onload = function() {
                that._bumpTexture = that._bumpTexture && that._bumpTexture.destroy();
                that._bumpTexture = context.createTexture2D({
                    source : bumpImage,
                    pixelFormat : PixelFormat.LUMINANCE
                });
            };
            bumpImage.onerror = function() {
                that._exception = 'Could not load image: ' + this.src + '.';
            };
            bumpImage.src = this.bumpMapSource;
        }

        // Initial compile or re-compile if uber-shader parameters changed
        var dayChanged = ((this._showDay !== this.showDay) && (!this.showDay || this._dayTileProvider));
        var nightChanged = ((this._showNight !== this.showNight) && (!this.showNight || this._nightTexture));
        var cloudsChanged = ((this._showClouds !== this.showClouds) && (!this.showClouds || this._cloudsTexture));
        var cloudShadowsChanged = ((this._showCloudShadows !== this.showCloudShadows) && (!this.showCloudShadows || this._cloudsTexture));
        var specularChanged = ((this._showSpecular !== this.showSpecular) && (!this.showSpecular || this._specularTexture));
        var bumpsChanged = ((this._showBumps !== this.showBumps) && (!this.showBumps || this._bumpTexture));

        if (typeof this._sp === 'undefined' || typeof this._spPoles === 'undefined' ||
            (dayChanged || nightChanged || cloudsChanged || cloudShadowsChanged || specularChanged || bumpsChanged) ||
            (this._showTerminator !== this.showTerminator) ||
            (this._affectedByLighting !== this.affectedByLighting)) {

            var fsPrepend = ((this.showDay && this._dayTileProvider) ? '#define SHOW_DAY 1\n' : '') +
                ((this.showNight && this._nightTexture) ? '#define SHOW_NIGHT 1\n' : '') +
                ((this.showClouds && this._cloudsTexture) ? '#define SHOW_CLOUDS 1\n' : '') +
                ((this.showCloudShadows && this._cloudsTexture) ? '#define SHOW_CLOUD_SHADOWS 1\n' : '') +
                ((this.showSpecular && this._specularTexture) ? '#define SHOW_SPECULAR 1\n' : '') +
                ((this.showBumps && this._bumpTexture) ? '#define SHOW_BUMPS 1\n' : '') +
                (this.showTerminator ? '#define SHOW_TERMINATOR 1\n' : '') +
                (this.affectedByLighting ? '#define AFFECTED_BY_LIGHTING 1\n' : '') +
                '#line 0\n' +
                CentralBodyFSCommon;
            var groundFromSpacePrepend = '#define SHOW_GROUND_ATMOSPHERE 1\n' +
                '#define SHOW_GROUND_ATMOSPHERE_FROM_SPACE 1\n';
            var groundFromAtmospherePrepend = '#define SHOW_GROUND_ATMOSPHERE 1\n' +
                '#define SHOW_GROUND_ATMOSPHERE_FROM_ATMOSPHERE 1\n';

            vs = '#line 0\n' +
                 GroundAtmosphere +
                 CentralBodyVS;

            fs = fsPrepend + CentralBodyFS;

            this._spWithoutAtmosphere = this._spWithoutAtmosphere && this._spWithoutAtmosphere.release();
            this._spGroundFromSpace = this._spGroundFromSpace && this._spGroundFromSpace.release();
            this._spGroundFromAtmosphere = this._spGroundFromAtmosphere && this._spGroundFromAtmosphere.release();

            this._spWithoutAtmosphere = context.getShaderCache().getShaderProgram(vs, fs, attributeIndices);
            this._spGroundFromSpace = context.getShaderCache().getShaderProgram(
                    groundFromSpacePrepend + vs,
                    groundFromSpacePrepend + fs,
                    attributeIndices);
            this._spGroundFromAtmosphere = context.getShaderCache().getShaderProgram(
                    groundFromAtmospherePrepend + vs,
                    groundFromAtmospherePrepend + fs,
                    attributeIndices);

            vs = CentralBodyVSPole;
            fs = fsPrepend + GroundAtmosphere + CentralBodyFSPole;

            this._spPolesWithoutAtmosphere = this._spPolesWithoutAtmosphere && this._spPolesWithoutAtmosphere.release();
            this._spPolesGroundFromSpace = this._spPolesGroundFromSpace && this._spPolesGroundFromSpace.release();
            this._spPolesGroundFromAtmosphere = this._spPolesGroundFromAtmosphere && this._spPolesGroundFromAtmosphere.release();

            this._spPolesWithoutAtmosphere = context.getShaderCache().getShaderProgram(vs, fs, attributeIndices);
            this._spPolesGroundFromSpace = context.getShaderCache().getShaderProgram(
                    vs,
                    groundFromSpacePrepend + fs,
                    attributeIndices);
            this._spPolesGroundFromAtmosphere = context.getShaderCache().getShaderProgram(
                    vs,
                    groundFromAtmospherePrepend + fs,
                    attributeIndices);

            // Sync to public state
            this._showDay = dayChanged ? this.showDay : this._showDay;
            this._showNight = nightChanged ? this.showNight : this._showNight;
            this._showClouds = cloudsChanged ? this.showClouds : this._showClouds;
            this._showCloudShadows = cloudShadowsChanged ? this.showCloudShadows : this._showCloudShadows;
            this._showSpecular = specularChanged ? this.showSpecular : this._showSpecular;
            this._showBumps = bumpsChanged ? this.showBumps : this._showBumps;
            this._showTerminator = this.showTerminator;
            this._affectedByLighting = this.affectedByLighting;
        }

        var camera = sceneState.camera;
        var cameraPosition = camera.getPositionWC();

        this._fCameraHeight2 = cameraPosition.magnitudeSquared();
        this._fCameraHeight = Math.sqrt(this._fCameraHeight2);

        if (this._fCameraHeight > this._outerRadius) {
            // Viewer in space
            this._spSky = this._spSkyFromSpace;
            if (this.showGroundAtmosphere) {
                this._sp = this._spGroundFromSpace;
                this._spPoles = this._spPolesGroundFromSpace;
            } else {
                this._sp = this._spWithoutAtmosphere;
                this._spPoles = this._spPolesWithoutAtmosphere;
            }
        } else {
            // after the camera passes the minimum height, there is no ground atmosphere effect
            var showAtmosphere = this._ellipsoid.cartesianToCartographic(cameraPosition).height >= this._minGroundFromAtmosphereHeight;
            if (this.showGroundAtmosphere && showAtmosphere) {
                this._sp = this._spGroundFromAtmosphere;
                this._spPoles = this._spPolesGroundFromAtmosphere;
            } else {
                this._sp = this._spWithoutAtmosphere;
                this._spPoles = this._spPolesWithoutAtmosphere;
            }
            this._spSky = this._spSkyFromAtmosphere;
        }

        this._occluder.setCameraPosition(cameraPosition);

        this._fillPoles(context, sceneState);

        this._throttleImages(sceneState);
        this._throttleReprojection(sceneState);
        this._throttleTextures(context, sceneState);

        var stack = [this._rootTile];
        while (stack.length !== 0) {
            var tile = stack.pop();

            if (this._cull(tile, sceneState)) {
                continue;
            }

            if (!this._dayTileProvider || (tile.state === TileState.TEXTURE_LOADED && tile.texture && !tile.texture.isDestroyed())) {
                if ((this._dayTileProvider && tile.zoom + 1 > this._dayTileProvider.zoomMax) || !this._refine(tile, context, sceneState)) {
                    this._enqueueTile(tile, context, sceneState);
                } else {
                    var children = tile.getChildren();
                    for (var i = 0; i < children.length; ++i) {
                        var child = children[i];
                        if ((child.state === TileState.TEXTURE_LOADED && child.texture && !child.texture.isDestroyed())) {
                            stack.push(child);
                        } else {
                            this._enqueueTile(tile, context, sceneState);
                            this._processTile(child);
                        }
                    }
                }
            } else {
                this._processTile(tile);
            }
        }

        this._mode = mode;
        this._projection = projection;
    };

    var clearState = {
        framebuffer : undefined,
        color : new Color(0.0, 0.0, 0.0, 0.0)
    };

    /**
     * DOC_TBA
     * @memberof CentralBody
     */
    CentralBody.prototype.render = function(context) {
        if (this.show) {
            // clear FBO
            clearState.framebuffer = this._fb;
            context.clear(context.createClearState(clearState));

            if (this.showSkyAtmosphere) {
                context.draw({
                    framebuffer : this._fb,
                    primitiveType : PrimitiveType.TRIANGLES,
                    shaderProgram : this._spSky,
                    uniformMap : this._drawUniforms,
                    vertexArray : this._vaSky,
                    renderState : this._rsSky
                });
            }

            if (this._renderQueue.length === 0) {
                return;
            }

            var uniformState = context.getUniformState();
            var mv = uniformState.getModelView();

            context.beginDraw({
                framebuffer : this._fb,
                shaderProgram : this._sp,
                renderState : this._rsColor
            });

            // TODO: remove once multi-frustum/depth testing is implemented
            this._renderQueue.sort(function(a, b) {
                return a.zoom - b.zoom;
            });

            // render tiles to FBO
            while (this._renderQueue.length > 0) {
                var tile = this._renderQueue.dequeue();

                var rtc;
                if (this.morphTime === 1.0) {
                    rtc = tile._drawUniforms.u_center3D();
                    tile.mode = 0;
                } else if (this.morphTime === 0.0) {
                    var center = tile._drawUniforms.u_center2D();
                    rtc = new Cartesian3(0.0, center.x, center.y);
                    tile.mode = 1;
                } else {
                    rtc = Cartesian3.ZERO;
                    tile.mode = 2;
                }
                var centerEye = mv.multiplyByVector(new Cartesian4(rtc.x, rtc.y, rtc.z, 1.0));
                tile.modelView = mv.setColumn(3, centerEye, tile.modelView);

                context.continueDraw({
                    primitiveType : PrimitiveType.TRIANGLES,
                    vertexArray : tile._extentVA,
                    uniformMap : tile._drawUniforms
                });
            }

            context.endDraw();

            // render quad with vertical gaussian blur with second-pass texture attached to FBO
            this._quadV.render(context);

            // render quad with horizontal gaussian blur
            this._quadH.render(context);

            // render quads to fill the poles
            if (this._mode === SceneMode.SCENE3D) {
                if (this._drawNorthPole) {
                    context.draw({
                        primitiveType : PrimitiveType.TRIANGLE_FAN,
                        shaderProgram : this._spPoles,
                        uniformMap : this._northPoleUniforms,
                        vertexArray : this._vaNorthPole,
                        renderState : this._rsColor
                    });
                }
                if (this._drawSouthPole) {
                    context.draw({
                        primitiveType : PrimitiveType.TRIANGLE_FAN,
                        shaderProgram : this._spPoles,
                        uniformMap : this._southPoleUniforms,
                        vertexArray : this._vaSouthPole,
                        renderState : this._rsColor
                    });
                }
            }

            // render depth plane
            if (this._mode === SceneMode.SCENE3D) {
                context.draw({
                    primitiveType : PrimitiveType.TRIANGLES,
                    shaderProgram : this._spDepth,
                    vertexArray : this._vaDepth,
                    renderState : this._rsDepth
                });
            }

            if (typeof this._quadLogo !== 'undefined' && !this._quadLogo.isDestroyed()) {
                this._quadLogo.render(context);
            }
        }
    };

    /**
     * DOC_TBA
     * @memberof CentralBody
     */
    CentralBody.prototype.renderForPick = function(context, framebuffer) {
        if (this.show) {
            if (this._mode === SceneMode.SCENE3D) {
                // Not actually pickable, but render depth-only so primitives on the backface
                // of the globe are not picked.
                context.draw({
                    primitiveType : PrimitiveType.TRIANGLES,
                    shaderProgram : this._spDepth,
                    vertexArray : this._vaDepth,
                    renderState : this._rsDepth,
                    framebuffer : framebuffer
                });
            }
        }
    };

    CentralBody.prototype._destroyTileTree = function() {
        var stack = [this._rootTile];
        while (stack.length !== 0) {
            var tile = stack.pop();

            // remove circular reference
            tile.parent = undefined;

            // destroy vertex array
            if (tile._extentVA) {
                tile._extentVA = tile._extentVA && tile._extentVA.destroy();
            }

            // destroy texture
            if (tile.texture) {
                tile.texture = tile.texture && tile.texture.destroy();
            }

            // process children
            if (tile.children) {
                stack = stack.concat(tile.children);
            }
        }

        this._rootTile = undefined;
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof CentralBody
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see CentralBody#destroy
     */
    CentralBody.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof CentralBody
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CentralBody#isDestroyed
     *
     * @example
     * centralBody = centralBody && centralBody.destroy();
     */
    CentralBody.prototype.destroy = function() {
        this._destroyTileTree();

        this._texturePool = this._texturePool && this._texturePool.destroy();
        this._textureCache = this._textureCache && this._textureCache.destroy();

        this._fb = this._fb && this._fb.destroy();
        this._quadV = this._quadV && this._quadV.destroy();
        this._quadH = this._quadH && this._quadH.destroy();

        this._vaNorthPole = this._vaNorthPole && this._vaNorthPole.destroy();
        this._vaSouthPole = this._vaSouthPole && this._vaSouthPole.destroy();

        this._spPolesWithoutAtmosphere = this._spPolesWithoutAtmosphere && this._spPolesWithoutAtmosphere.release();
        this._spPolesGroundFromSpace = this._spPolesGroundFromSpace && this._spPolesGroundFromSpace.release();
        this._spPolesGroundFromAtmosphere = this._spPolesGroundFromAtmosphere && this._spPolesGroundFromAtmosphere.release();

        this._spWithoutAtmosphere = this._spWithoutAtmosphere && this._spWithoutAtmosphere.release();
        this._spGroundFromSpace = this._spGroundFromSpace && this._spGroundFromSpace.release();
        this._spGroundFromAtmosphere = this._spGroundFromAtmosphere && this._spGroundFromAtmosphere.release();

        this._vaSky = this._vaSky && this._vaSky.destroy();
        this._spSkyFromSpace = this._spSkyFromSpace && this._spSkyFromSpace.release();
        this._spSkyFromAtmosphere = this._spSkyFromAtmosphere && this._spSkyFromAtmosphere.release();

        this._spDepth = this._spDepth && this._spDepth.release();
        this._vaDepth = this._vaDepth && this._vaDepth.destroy();

        this._nightTexture = this._nightTexture && this._nightTexture.destroy();
        this._specularTexture = this._specularTexture && this._specularTexture.destroy();
        this._cloudsTexture = this._cloudsTexture && this._cloudsTexture.destroy();
        this._bumpTexture = this._bumpTexture && this._bumpTexture.destroy();

        return destroyObject(this);
    };

    return CentralBody;
});

/*global define*/
define('Scene/PerformanceDisplay',[
        '../Core/destroyObject',
        '../Core/Rectangle',
        '../Renderer/PixelFormat',
        './ViewportQuad'
    ], function(
        destroyObject,
        Rectangle,
        PixelFormat,
        ViewportQuad) {
    

    /**
     * Draws a display in the top left corner of the scene displaying FPS (frames per second),
     * averaged over 1 second intervals, as well as unaveraged frame time.
     *
     * @alias PerformanceDisplay
     * @constructor
     *
     * @param {Color} [description.fpsColor] The color of the FPS graph.
     * @param {Color} [description.frameTimeColor] The color of the frame time graph.
     * @param {Color} [description.backgroundColor] The color of the background of the display.
     * @param {String} [description.font] The CSS font of the text in the display.
     * @param {Rectangle} [description.rectangle] The position and size of the display, relative to the top left corner.
     *
     * @example
     * scene.getPrimitives().add(new PerformanceDisplay());
     */
    var PerformanceDisplay = function(description) {
        if (typeof description === 'undefined') {
            description = {};
        }

        this._fpsColor = typeof description.fpsColor !== 'undefined' ? description.fpsColor.toCSSColor() : '#e52';
        this._frameTimeColor = typeof description.frameTimeColor !== 'undefined' ? description.frameTimeColor.toCSSColor() : '#de3';
        this._backgroundColor = typeof description.backgroundColor !== 'undefined' ? description.backgroundColor.toCSSColor() : 'rgba(0, 0, 30, 0.9)';
        this._font = typeof description.font !== 'undefined' ? description.font : 'bold 10px Helvetica,Arial,sans-serif';
        this._rectangle = typeof description.rectangle !== 'undefined' ? description.rectangle : new Rectangle(0, 0, 80, 40);

        this._canvas = document.createElement('canvas');
        this._canvas.width = this._rectangle.width;
        this._canvas.height = this._rectangle.height;

        this._canvasContext = this._canvas.getContext('2d');
        this._canvasContext.font = this._font;
        this._canvasContext.lineWidth = 1;

        this._bufferLength = this._rectangle.width;
        this._frameTimeSamples = new Array(this._bufferLength);
        this._fpsSamples = new Array(this._bufferLength);

        for ( var i = 0; i < this._bufferLength; i++) {
            this._frameTimeSamples[i] = this._fpsSamples[i] = 0;
        }

        this._frameTimeIndex = 0;
        this._fpsIndex = 0;
        this._lastFpsSampleTime = undefined;
        this._frameCount = 0;

        this._quad = new ViewportQuad(new Rectangle(0, 0, 0, 0));
        this._quad.enableBlending = true;

        this._time = undefined;
        this._texture = undefined;
        this._viewportHeight = 0;
    };

    /**
     * Update the display.  This function should only be called once per frame, because
     * each call records a frame in the internal buffer and redraws the display.
     */
    PerformanceDisplay.prototype.update = function(context, sceneState) {
        if (typeof this._time === 'undefined') {
            //first update
            this._lastFpsSampleTime = this._time = Date.now();
            return;
        }

        var previousTime = this._time;
        var time = this._time = Date.now();

        var frameTime = time - previousTime;
        this._frameTimeSamples[this._frameTimeIndex++] = frameTime;

        if (this._frameTimeIndex >= this._bufferLength) {
            this._frameTimeIndex = 0;
        }

        this._frameCount++;
        var fps = this._fps;
        var fpsElapsedTime = time - this._lastFpsSampleTime;
        if (fpsElapsedTime > 1000) {
            fps = this._fps = this._frameCount * 1000 / fpsElapsedTime | 0;
            this._fpsSamples[this._fpsIndex++] = fps;

            if (this._fpsIndex >= this._bufferLength) {
                this._fpsIndex = 0;
            }

            this._lastFpsSampleTime = time;
            this._frameCount = 0;
        }

        var ctx = this._canvasContext;
        var canvasWidth = this._rectangle.width;
        var canvasHeight = this._rectangle.height;
        ctx.clearRect(0, 0, canvasWidth, canvasHeight);
        ctx.fillStyle = this._backgroundColor;
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);

        if (typeof fps !== 'undefined') {
            ctx.fillStyle = this._fpsColor;
            ctx.textAlign = 'left';
            ctx.fillText(fps + ' FPS', 1, 10);
        }

        ctx.fillStyle = this._frameTimeColor;
        ctx.textAlign = 'right';
        ctx.fillText(frameTime + ' MS', canvasWidth - 1, 10);

        for ( var i = 0; i < this._bufferLength; i++) {
            fps = this._fpsSamples[(i + this._fpsIndex) % this._bufferLength];
            if (fps > 0) {
                this._drawLine(this._fpsColor, i, fps / 100);
            }

            frameTime = this._frameTimeSamples[(i + this._frameTimeIndex) % this._bufferLength];
            if (frameTime > 0) {
                this._drawLine(this._frameTimeColor, i, frameTime / 200);
            }
        }

        if (typeof this._texture === 'undefined') {
            this._texture = context.createTexture2D({
                source : this._canvas,
                pixelFormat : PixelFormat.RGBA
            });
            this._quad.setTexture(this._texture);
        } else {
            this._texture.copyFrom(this._canvas);
        }

        var viewportHeight = context.getViewport().height;
        if (viewportHeight !== this._viewportHeight) {
            this._viewportHeight = viewportHeight;
            this._quad.setRectangle(new Rectangle(this._rectangle.x, viewportHeight - canvasHeight - this._rectangle.y, canvasWidth, canvasHeight));
        }

        this._quad.update(context, sceneState);
    };

    PerformanceDisplay.prototype._drawLine = function(style, x, valuePercent) {
        var ctx = this._canvasContext;
        var canvasHeight = this._rectangle.height;
        var maxGraphHeight = canvasHeight - 10;

        x = 0.5 + x;
        ctx.beginPath();
        ctx.strokeStyle = style;
        ctx.moveTo(x, canvasHeight);

        var lineHeight = valuePercent * maxGraphHeight;
        if (lineHeight > maxGraphHeight) {
            lineHeight = maxGraphHeight;
        }

        var y = canvasHeight - lineHeight;
        ctx.lineTo(x, y);
        ctx.stroke();
    };

    /**
     * Renders the display.
     */
    PerformanceDisplay.prototype.render = function(context) {
        this._quad.render(context);
    };

    /**
     * Destroys the WebGL resources held by this object.
     */
    PerformanceDisplay.prototype.destroy = function() {
        this._quad = this._quad.destroy();
        return destroyObject(this);
    };

    return PerformanceDisplay;
});
;
define("Shaders/glslComments", function(){});

/**
 * @author sole / http://soledadpenades.com
 * @author mr.doob / http://mrdoob.com
 * @author Robert Eisele / http://www.xarg.org
 * @author Philippe / http://philippe.elsass.me
 * @author Robert Penner / http://www.robertpenner.com/easing_terms_of_use.html
 * @author Paul Lewis / http://www.aerotwist.com/
 * @author lechecacharro
 * @author Josh Faul / http://jocafa.com/
 * @author egraether / http://egraether.com/
 */

/*global define*/
define('ThirdParty/Tween',[],function() {

var TWEEN = TWEEN || ( function () {

	var _interval = null, _fps = 60, _autostart = false, _tweens = [];

	return {

		setFPS: function ( fps ) {

			_fps = fps || 60;

		},

		start: function ( fps ) {

			if ( fps ) {

				this.setFPS( fps );

			}

			if ( _interval === null ) {

				_interval = setInterval( this.update, 1000 / _fps );

			}

		},

		stop: function () {

			clearInterval( _interval );

			_interval = null;

		},

		setAutostart: function ( value ) {

			_autostart = value;

			if ( _autostart && _tweens.length ) {

				this.start();

			}

		},

		add: function ( tween ) {

			_tweens.push( tween );

			if ( _autostart ) {

				this.start();

			}

		},

		getAll: function () {

			return _tweens;

		},

		removeAll: function () {

			_tweens = [];

		},

		remove: function ( tween ) {

			var i = _tweens.indexOf( tween );

			if ( i !== -1 ) {

				_tweens.splice( i, 1 );

			}

		},

		update: function ( time ) {

			var i = 0, num_tweens = _tweens.length, time = time || Date.now();

			while ( i < num_tweens ) {

				if ( _tweens[ i ].update( time ) ) {

					i++;

				} else {

					_tweens.splice( i, 1 );
					num_tweens--;

				}

			}

			if ( num_tweens === 0 && _autostart ) {

				TWEEN.stop();

			}

		}

	};

} )();

TWEEN.Tween = function ( object ) {

	var _object = object,
	_valuesStart = {},
	_valuesDelta = {},
	_valuesEnd = {},
	_duration = 1000,
	_delayTime = 0,
	_startTime = null,
	_easingFunction = TWEEN.Easing.Linear.EaseNone,
	_chainedTween = null,
	_onUpdateCallback = null,
	_onCompleteCallback = null;

	this.to = function ( properties, duration ) {

		if( duration !== null ) {

			_duration = duration;

		}

		for ( var property in properties ) {

			// This prevents the engine from interpolating null values
			if ( _object[ property ] === null ) {

				continue;

			}

			// The current values are read when the tween starts;
			// here we only store the final desired values
			_valuesEnd[ property ] = properties[ property ];

		}

		return this;

	};

	this.start = function ( time ) {

		TWEEN.add( this );

		_startTime = time ? time + _delayTime : Date.now() + _delayTime;

		for ( var property in _valuesEnd ) {

			// Again, prevent dealing with null values
			if ( _object[ property ] === null ) {

				continue;

			}

			_valuesStart[ property ] = _object[ property ];
			_valuesDelta[ property ] = _valuesEnd[ property ] - _object[ property ];

		}

		return this;
	};

	this.stop = function () {

		TWEEN.remove( this );
		return this;

	};

	this.delay = function ( amount ) {

		_delayTime = amount;
		return this;

	};

	this.easing = function ( easing ) {

		_easingFunction = easing;
		return this;

	};

	this.chain = function ( chainedTween ) {

		_chainedTween = chainedTween;
		return this;

	};

	this.onUpdate = function ( onUpdateCallback ) {

		_onUpdateCallback = onUpdateCallback;
		return this;

	};

	this.onComplete = function ( onCompleteCallback ) {

		_onCompleteCallback = onCompleteCallback;
		return this;

	};

	this.update = function ( time ) {

		var property, elapsed, value;

		if ( time < _startTime ) {

			return true;

		}

		elapsed = ( time - _startTime ) / _duration;
		elapsed = elapsed > 1 ? 1 : elapsed;

		value = _easingFunction( elapsed );

		for ( property in _valuesDelta ) {

			_object[ property ] = _valuesStart[ property ] + _valuesDelta[ property ] * value;

		}

		if ( _onUpdateCallback !== null ) {

			_onUpdateCallback.call( _object, value );

		}

		if ( elapsed == 1 ) {

			if ( _onCompleteCallback !== null ) {

				_onCompleteCallback.call( _object );

			}

			if ( _chainedTween !== null ) {

				_chainedTween.start();

			}

			return false;

		}

		return true;

	};

	/*
	this.destroy = function () {

		TWEEN.remove( this );

	};
	*/
};

TWEEN.Easing = { Linear: {}, Quadratic: {}, Cubic: {}, Quartic: {}, Quintic: {}, Sinusoidal: {}, Exponential: {}, Circular: {}, Elastic: {}, Back: {}, Bounce: {} };


TWEEN.Easing.Linear.EaseNone = function ( k ) {

	return k;

};

//

TWEEN.Easing.Quadratic.EaseIn = function ( k ) {

	return k * k;

};

TWEEN.Easing.Quadratic.EaseOut = function ( k ) {

	return k * ( 2 - k );

};

TWEEN.Easing.Quadratic.EaseInOut = function ( k ) {

	if ( ( k *= 2 ) < 1 ) return 0.5 * k * k;
	return - 0.5 * ( --k * ( k - 2 ) - 1 );

};

//

TWEEN.Easing.Cubic.EaseIn = function ( k ) {

	return k * k * k;

};

TWEEN.Easing.Cubic.EaseOut = function ( k ) {

	return --k * k * k + 1;

};

TWEEN.Easing.Cubic.EaseInOut = function ( k ) {

	if ( ( k *= 2 ) < 1 ) return 0.5 * k * k * k;
	return 0.5 * ( ( k -= 2 ) * k * k + 2 );

};

//

TWEEN.Easing.Quartic.EaseIn = function ( k ) {

	return k * k * k * k;

};

TWEEN.Easing.Quartic.EaseOut = function ( k ) {

	return 1 - --k * k * k * k;

};

TWEEN.Easing.Quartic.EaseInOut = function ( k ) {

	if ( ( k *= 2 ) < 1) return 0.5 * k * k * k * k;
	return - 0.5 * ( ( k -= 2 ) * k * k * k - 2 );

};

//

TWEEN.Easing.Quintic.EaseIn = function ( k ) {

	return k * k * k * k * k;

};

TWEEN.Easing.Quintic.EaseOut = function ( k ) {

	return --k * k * k * k * k + 1;

};

TWEEN.Easing.Quintic.EaseInOut = function ( k ) {

	if ( ( k *= 2 ) < 1 ) return 0.5 * k * k * k * k * k;
	return 0.5 * ( ( k -= 2 ) * k * k * k * k + 2 );

};

//

TWEEN.Easing.Sinusoidal.EaseIn = function ( k ) {

	return 1 - Math.cos( k * Math.PI / 2 );

};

TWEEN.Easing.Sinusoidal.EaseOut = function ( k ) {

	return Math.sin( k * Math.PI / 2 );

};

TWEEN.Easing.Sinusoidal.EaseInOut = function ( k ) {

	return 0.5 * ( 1 - Math.cos( Math.PI * k ) );

};

//

TWEEN.Easing.Exponential.EaseIn = function ( k ) {

	return k === 0 ? 0 : Math.pow( 1024, k - 1 );

};

TWEEN.Easing.Exponential.EaseOut = function ( k ) {

	return k === 1 ? 1 : 1 - Math.pow( 2, - 10 * k );

};

TWEEN.Easing.Exponential.EaseInOut = function ( k ) {

	if ( k === 0 ) return 0;
	if ( k === 1 ) return 1;
	if ( ( k *= 2 ) < 1 ) return 0.5 * Math.pow( 1024, k - 1 );
	return 0.5 * ( - Math.pow( 2, - 10 * ( k - 1 ) ) + 2 );

};

//

TWEEN.Easing.Circular.EaseIn = function ( k ) {

	return 1 - Math.sqrt( 1 - k * k );

};

TWEEN.Easing.Circular.EaseOut = function ( k ) {

	return Math.sqrt( 1 - --k * k );

};

TWEEN.Easing.Circular.EaseInOut = function ( k ) {

	if ( ( k *= 2 ) < 1) return - 0.5 * ( Math.sqrt( 1 - k * k) - 1);
	return 0.5 * ( Math.sqrt( 1 - ( k -= 2) * k) + 1);

};

//

TWEEN.Easing.Elastic.EaseIn = function ( k ) {

	var s, a = 0.1, p = 0.4;
	if ( k === 0 ) return 0;
	if ( k === 1 ) return 1;
	if ( !a || a < 1 ) { a = 1; s = p / 4; }
	else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );
	return - ( a * Math.pow( 2, 10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) );

};

TWEEN.Easing.Elastic.EaseOut = function ( k ) {

	var s, a = 0.1, p = 0.4;
	if ( k === 0 ) return 0;
	if ( k === 1 ) return 1;
	if ( !a || a < 1 ) { a = 1; s = p / 4; }
	else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );
	return ( a * Math.pow( 2, - 10 * k) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) + 1 );

};

TWEEN.Easing.Elastic.EaseInOut = function ( k ) {

	var s, a = 0.1, p = 0.4;
	if ( k === 0 ) return 0;
	if ( k === 1 ) return 1;
	if ( !a || a < 1 ) { a = 1; s = p / 4; }
	else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );
	if ( ( k *= 2 ) < 1 ) return - 0.5 * ( a * Math.pow( 2, 10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) );
	return a * Math.pow( 2, -10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) * 0.5 + 1;

};

//

TWEEN.Easing.Back.EaseIn = function ( k ) {

	var s = 1.70158;
	return k * k * ( ( s + 1 ) * k - s );

};

TWEEN.Easing.Back.EaseOut = function ( k ) {

	var s = 1.70158;
	return --k * k * ( ( s + 1 ) * k + s ) + 1;

};

TWEEN.Easing.Back.EaseInOut = function ( k ) {

	var s = 1.70158 * 1.525;
	if ( ( k *= 2 ) < 1 ) return 0.5 * ( k * k * ( ( s + 1 ) * k - s ) );
	return 0.5 * ( ( k -= 2 ) * k * ( ( s + 1 ) * k + s ) + 2 );

};

//

TWEEN.Easing.Bounce.EaseIn = function ( k ) {

	return 1 - TWEEN.Easing.Bounce.EaseOut( 1 - k );

};

TWEEN.Easing.Bounce.EaseOut = function ( k ) {

	if ( k < ( 1 / 2.75 ) ) {

		return 7.5625 * k * k;

	} else if ( k < ( 2 / 2.75 ) ) {

		return 7.5625 * ( k -= ( 1.5 / 2.75 ) ) * k + 0.75;

	} else if ( k < ( 2.5 / 2.75 ) ) {

		return 7.5625 * ( k -= ( 2.25 / 2.75 ) ) * k + 0.9375;

	} else {

		return 7.5625 * ( k -= ( 2.625 / 2.75 ) ) * k + 0.984375;

	}

};

TWEEN.Easing.Bounce.EaseInOut = function ( k ) {

	if ( k < 0.5 ) return TWEEN.Easing.Bounce.EaseIn( k * 2 ) * 0.5;
	return TWEEN.Easing.Bounce.EaseOut( k * 2 - 1 ) * 0.5 + 0.5;

};

return TWEEN;
});

/*global define*/
define('Scene/AnimationCollection',[
        '../Core/DeveloperError',
        '../Core/clone',
        '../ThirdParty/Tween'
    ], function(
        DeveloperError,
        clone,
        Tween) {
    

    /**
     * DOC_TBA
     *
     * @alias AnimationCollection
     * @constructor
     */
    var AnimationCollection = function() {
    };

    /**
     * DOC_TBA
     * @memberof AnimationCollection
     */
    AnimationCollection.prototype.add = function(template) {
        var t = template || {};
        t.duration = (typeof t.duration === 'undefined') ? 3000 : t.duration;
        t.delayDuration = (typeof t.delayDuration === 'undefined') ? 0 : t.delayDuration;
        t.easingFunction = (typeof t.easingFunction === 'undefined') ? Tween.Easing.Linear.EaseNone : t.easingFunction;

        var value = clone(t.startValue);
        var tween = new Tween.Tween(value);
        tween.to(t.stopValue, t.duration);
        tween.delay(t.delayDuration);
        tween.easing(t.easingFunction);
        if (t.onUpdate) {
            tween.onUpdate(function() {
                t.onUpdate(value);
            });
        }
        tween.onComplete(t.onComplete || null);
        tween.start();

        return {
            _tween : tween
        };
    };

    /**
     * DOC_TBA
     * @memberof AnimationCollection
     *
     * @exception {DeveloperError} material is required.
     * @exception {DeveloperError} material has no properties with alpha components.
     */
    AnimationCollection.prototype.addAlpha = function(material, start, stop, template) {
        if (typeof material === 'undefined') {
            throw new DeveloperError('material is required.');
        }

        var properties = [];

        for ( var property in material) {
            if (material.hasOwnProperty(property) &&
                typeof material[property] !== 'undefined' &&
                typeof material[property].alpha !== 'undefined') {
                properties.push(property);
            }
        }

        if (properties.length === 0) {
            throw new DeveloperError('material has no properties with alpha components.');
        }

        // Default to fade in
        start = (typeof start === 'undefined') ? 0.0 : start;
        stop = (typeof stop === 'undefined') ? 1.0 : stop;

        var t = template || {};
        t.duration = (typeof t.duration === 'undefined') ? 3000 : t.duration;
        t.delayDuration = (typeof t.delayDuration === 'undefined') ? 0 : t.delayDuration;
        t.easingFunction = (typeof t.easingFunction === 'undefined') ? Tween.Easing.Linear.EaseNone : t.easingFunction;

        var value = {
            alpha : start
        };
        var tween = new Tween.Tween(value);
        tween.to({
            alpha : stop
        }, t.duration);
        tween.delay(t.delayDuration);
        tween.easing(t.easingFunction);
        tween.onUpdate(function() {
            var length = properties.length;
            for ( var i = 0; i < length; ++i) {
                material[properties[i]].alpha = value.alpha;
            }
        });
        tween.onComplete(t.onComplete || null);
        tween.start();

        return {
            _tween : tween
        };
    };

    /**
     * DOC_TBA
     * @memberof AnimationCollection
     */
    AnimationCollection.prototype.addProperty = function(object, property, start, stop, template) {
        if (typeof object === 'undefined') {
            throw new DeveloperError('object is required.');
        }

        if (typeof property === 'undefined') {
            throw new DeveloperError('property is required.');
        }

        if (typeof object[property] === 'undefined') {
            throw new DeveloperError('object must have the specified property.');
        }

        var t = template || {};
        t.duration = (typeof t.duration === 'undefined') ? 3000 : t.duration;
        t.delayDuration = (typeof t.delayDuration === 'undefined') ? 0 : t.delayDuration;
        t.easingFunction = (typeof t.easingFunction === 'undefined') ? Tween.Easing.Linear.EaseNone : t.easingFunction;

        var value = {
            value : start
        };
        var tween = new Tween.Tween(value);
        tween.to({
            value : stop
        }, t.duration);
        tween.delay(t.delayDuration);
        tween.easing(t.easingFunction);
        tween.onUpdate(function() {
            object[property] = value.value;
        });
        tween.onComplete(t.onComplete || null);
        tween.start();

        return {
            _tween : tween
        };
    };

    /**
     * DOC_TBA
     * @memberof AnimationCollection
     *
     * @exception {DeveloperError} material is required.
     * @exception {DeveloperError} material must have an offset property.
     */
    AnimationCollection.prototype.addOffsetIncrement = function(material, template) {
        if (typeof material === 'undefined') {
            throw new DeveloperError('material is required.');
        }

        if (typeof material.offset === 'undefined') {
            throw new DeveloperError('material must have an offset property.');
        }

        var t = template || {};
        t.duration = (typeof t.duration === 'undefined') ? 3000 : t.duration;
        t.delayDuration = (typeof t.delayDuration === 'undefined') ? 0 : t.delayDuration;
        t.easingFunction = (typeof t.easingFunction === 'undefined') ? Tween.Easing.Linear.EaseNone : t.easingFunction;

        var value = {
            offset : material.offset
        };
        var tween = new Tween.Tween(value);
        tween.to({
            offset : material.offset + 1.0
        }, t.duration);
        tween.delay(t.delayDuration);
        tween.easing(t.easingFunction);
        tween.onUpdate(function() {
            material.offset = value.offset;
        });
        // t.onComplete is ignored.
        tween.onComplete(function() {
            tween.to({
                offset : material.offset + 1.0
            }, t.duration);
            tween.start();
        });
        tween.start();

        return {
            _tween : tween
        };
    };

    /**
     * DOC_TBA
     * @memberof AnimationCollection
     */
    AnimationCollection.prototype.remove = function(animation) {
        if (typeof animation !== 'undefined') {
            var count = Tween.getAll().length;
            Tween.remove(animation._tween);

            return Tween.getAll().length === (count - 1);
        }

        return false;
    };

    /**
     * DOC_TBA
     * @memberof AnimationCollection
     */
    AnimationCollection.prototype.removeAll = function() {
        Tween.removeAll();
    };

    /**
     * DOC_TBA
     * @memberof Animationcollection
     */
    AnimationCollection.prototype.contains = function(animation) {
        if (typeof animation !== 'undefined') {
            return Tween.getAll().indexOf(animation) !== -1;
        }
        return false;
    };

    /**
     * DOC_TBA
     * @memberof AnimationCollection
     */
    AnimationCollection.prototype.update = function() {
        Tween.update();
    };

    return AnimationCollection;
});
/*global define*/
define('Scene/Camera2DController',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/FAR',
        '../Core/Math',
        '../Core/Quaternion',
        '../Core/Matrix3',
        '../Core/Cartesian2',
        '../Core/Cartographic',
        './CameraEventHandler',
        './CameraEventType',
        './CameraHelpers',
        './AnimationCollection',
        '../ThirdParty/Tween'
    ], function(
        DeveloperError,
        destroyObject,
        FAR,
        CesiumMath,
        Quaternion,
        Matrix3,
        Cartesian2,
        Cartographic,
        CameraEventHandler,
        CameraEventType,
        CameraHelpers,
        AnimationCollection,
        Tween) {
    

    var move = CameraHelpers.move;
    var maintainInertia = CameraHelpers.maintainInertia;
    var handleZoom = CameraHelpers.handleZoom;

    /**
     * A type that defines camera behavior: movement of the position in the direction
     * of the camera's axes and manipulating a camera's orthographic frustum for a zooming effect.
     *
     * @alias Camera2DController
     *
     * @param {HTMLCanvasElement} canvas An HTML canvas element used for its dimensions
     * and for listening on user events.
     * @param {Camera} camera The camera to use.
     * @param {DOC_TBA} projection The projection of the map the camera is moving around..
     *
     * @exception {DeveloperError} canvas is required.
     * @exception {DeveloperError} camera is required.
     * @exception {DeveloperError} projection is required.
     *
     * @internalConstructor
     */
    var Camera2DController = function(canvas, camera, projection) {
        if (typeof canvas === 'undefined') {
            throw new DeveloperError('canvas is required.');
        }

        if (typeof camera === 'undefined') {
            throw new DeveloperError('camera is required.');
        }

        if (typeof projection === 'undefined') {
            throw new DeveloperError('projection is required.');
        }

        this._canvas = canvas;
        this._camera = camera;
        this._projection = projection;
        this._zoomRate = 100000.0;
        this._moveRate = 100000.0;

        /**
         * A parameter in the range <code>[0, 1)</code> used to determine how long
         * the camera will continue to translate because of inertia.
         * With value of zero, the camera will have no inertia.
         *
         * @type Number
         */
        this.inertiaTranslate = 0.9;

        /**
         * A parameter in the range <code>[0, 1)</code> used to determine how long
         * the camera will continue to zoom because of inertia.
         * With value of zero, the camera will have no inertia.
         *
         * @type Number
         */
        this.inertiaZoom = 0.8;

        this._zoomFactor = 1.5;
        this._translateFactor = 1.0;
        this._minimumZoomRate = 20.0;
        this._maximumZoomRate = FAR;

        this._translateHandler = new CameraEventHandler(canvas, CameraEventType.LEFT_DRAG);
        this._zoomHandler = new CameraEventHandler(canvas, CameraEventType.RIGHT_DRAG);
        this._zoomWheel = new CameraEventHandler(canvas, CameraEventType.WHEEL);
        this._twistHandler = new CameraEventHandler(canvas, CameraEventType.MIDDLE_DRAG);

        this._lastInertiaZoomMovement = undefined;
        this._lastInertiaTranslateMovement = undefined;
        this._lastInertiaWheelZoomMovement = undefined;

        this._frustum = this._camera.frustum.clone();
        this._animationCollection = new AnimationCollection();
        this._zoomAnimation = undefined;
        this._translateAnimation = undefined;

        var maxZoomOut = 2.0;
        this._frustum.right *= maxZoomOut;
        this._frustum.left *= maxZoomOut;
        this._frustum.top *= maxZoomOut;
        this._frustum.bottom *= maxZoomOut;

        this._maxCoord = projection.project(new Cartographic(Math.PI, CesiumMath.PI_OVER_TWO, 0.0));

        this._maxZoomFactor = 2.5;
        this._maxTranslateFactor = 1.5;
    };

    /**
     * Returns the projection of the map that the camera is moving around.
     *
     * @memberof Camera2DController
     *
     * @returns {DOC_TBA} The projection of the map that the camera is moving around.
     *
     * @see Camera2DController#setProjection
     */
    Camera2DController.prototype.getProjection = function() {
        return this._projection;
    };

    /**
     * Sets the projection of the map that the camera is moving around.
     *
     * @memberof Camera2DController
     *
     * @param {DOC_TBA} projection The projection of the map that the camera is moving around.
     *
     * @exception {DeveloperError} projection is required.
     *
     * @see Camera2DController#getProjection
     */
    Camera2DController.prototype.setProjection = function(projection) {
        if (typeof projection === 'undefined') {
            throw new DeveloperError('projection is required.');
        }

        this._projection = projection;
        this._maxCoord = projection.project(new Cartographic(Math.PI, CesiumMath.toRadians(85.05112878)));
    };

    /**
     * Translates the camera's position by <code>rate</code> along the camera's up vector.
     *
     * @memberof Camera2DController
     *
     * @param {Number} rate The rate to move.
     *
     * @see Camera2DController#moveDown
     */
    Camera2DController.prototype.moveUp = function(rate) {
        move(this._camera, this._camera.up, rate || this._moveRate);
    };

    /**
     * Translates the camera's position by <code>rate</code> along the opposite direction
     * of the camera's up vector.
     *
     * @memberof Camera2DController
     *
     * @param {Number} rate The rate to move.
     *
     * @see Camera2DController#moveUp
     */
    Camera2DController.prototype.moveDown = function(rate) {
        move(this._camera, this._camera.up, -rate || -this._moveRate);
    };

    /**
     * Translates the camera's position by <code>rate</code> along the camera's right vector.
     *
     * @memberof Camera2DController
     *
     * @param {Number} rate The rate to move.
     *
     * @see Camera2DController#moveLeft
     */
    Camera2DController.prototype.moveRight = function(rate) {
        move(this._camera, this._camera.right, rate || this._moveRate);
    };

    /**
     * Translates the camera's position by <code>rate</code> along the opposite direction
     * of the camera's right vector.
     *
     * @memberof Camera2DController
     *
     * @param {Number} rate The rate to move.
     *
     * @see Camera2DController#moveRight
     */
    Camera2DController.prototype.moveLeft = function(rate) {
        move(this._camera, this._camera.right, -rate || -this._moveRate);
    };

    /**
     * DOC_TBA
     *
     * @memberof Camera2DController
     *
     * @param {Number} rate The rate to move.
     *
     * @see Camera2DController#zoomOut
     */
    Camera2DController.prototype.zoomIn = function(rate) {
        var moveRate = rate || this._zoomRate;
        var frustum = this._camera.frustum;

        if (frustum.left === null || frustum.right === null ||
            frustum.top === null || frustum.bottom === null) {
                throw new DeveloperError('The camera frustum is expected to be orthographic for 2D camera control.');
        }

        var newRight = frustum.right - moveRate;
        var newLeft = frustum.left + moveRate;

        var maxRight = this._maxCoord.x * this._maxZoomFactor;
        if (newRight > maxRight) {
            newRight = maxRight;
            newLeft = -newRight;
        }

        if (newRight > newLeft) {
            var ratio = frustum.top / frustum.right;
            frustum.right = newRight;
            frustum.left = newLeft;
            frustum.top = frustum.right * ratio;
            frustum.bottom = -frustum.top;
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof Camera2DController
     *
     * @param {Number} rate The rate to move.
     *
     * @see Camera2DController#zoomIn
     */
    Camera2DController.prototype.zoomOut = function(rate) {
        this.zoomIn(-rate || -this._zoomRate);
    };

    Camera2DController.prototype._addCorrectZoomAnimation = function() {
        var camera = this._camera;
        var frustum = camera.frustum;
        var top = frustum.top;
        var bottom = frustum.bottom;
        var right = frustum.right;
        var left = frustum.left;

        var startFrustum = this._frustum;

        var update2D = function(value) {
            camera.frustum.top = CesiumMath.lerp(top, startFrustum.top, value.time);
            camera.frustum.bottom = CesiumMath.lerp(bottom, startFrustum.bottom, value.time);
            camera.frustum.right = CesiumMath.lerp(right, startFrustum.right, value.time);
            camera.frustum.left = CesiumMath.lerp(left, startFrustum.left, value.time);
        };

        this._zoomAnimation = this._animationCollection.add({
            easingFunction : Tween.Easing.Exponential.EaseOut,
            startValue : {
                time : 0.0
            },
            stopValue : {
                time : 1.0
            },
            onUpdate : update2D
        });
    };

    Camera2DController.prototype._addCorrectTranslateAnimation = function() {
        var camera = this._camera;
        var currentPosition = camera.position;
        var translatedPosition = currentPosition.clone();

        if (translatedPosition.x > this._maxCoord.x) {
            translatedPosition.x = this._maxCoord.x;
        } else if (translatedPosition.x < -this._maxCoord.x) {
            translatedPosition.x = -this._maxCoord.x;
        }

        if (translatedPosition.y > this._maxCoord.y) {
            translatedPosition.y = this._maxCoord.y;
        } else if (translatedPosition.y < -this._maxCoord.y) {
            translatedPosition.y = -this._maxCoord.y;
        }

        var update2D = function(value) {
            camera.position = currentPosition.lerp(translatedPosition, value.time);
        };

        this._translateAnimation = this._animationCollection.add({
            easingFunction : Tween.Easing.Exponential.EaseOut,
            startValue : {
                time : 0.0
            },
            stopValue : {
                time : 1.0
            },
            onUpdate : update2D
        });
    };

    /**
     * @private
     */
    Camera2DController.prototype.update = function() {
        var translate = this._translateHandler;
        var rightZoom = this._zoomHandler;
        var wheelZoom = this._zoomWheel;
        var translating = translate.isMoving() && translate.getMovement();
        var rightZooming = rightZoom.isMoving();
        var wheelZooming = wheelZoom.isMoving();

        if (translate.isButtonDown() || rightZoom.isButtonDown() || wheelZooming) {
            this._animationCollection.removeAll();
        }

        if (translating) {
            this._translate(translate.getMovement());
        }

        if (!translating && this.inertiaTranslate < 1.0) {
            maintainInertia(translate, this.inertiaTranslate, this._translate, this, '_lastInertiaTranslateMovement');
        }

        if (rightZooming) {
            this._zoom(rightZoom.getMovement());
        } else if (wheelZooming) {
            this._zoom(wheelZoom.getMovement());
        }

        if (!rightZooming && this.inertiaZoom < 1.0) {
            maintainInertia(rightZoom, this.inertiaZoom, this._zoom, this, '_lastInertiaZoomMovement');
        }

        if (!wheelZooming && this.inertiaZoom < 1.0) {
            maintainInertia(wheelZoom, this.inertiaZoom, this._zoom, this, '_lastInertiaWheelZoomMovement');
        }

        if (this._twistHandler.isMoving()) {
            this._twist(this._twistHandler.getMovement());
        }

        if (!translate.isButtonDown() && !rightZoom.isButtonDown()) {
            if (this._camera.frustum.right > this._frustum.right &&
                !this._lastInertiaZoomMovement && !this._animationCollection.contains(this._zoomAnimation)) {
                this._addCorrectZoomAnimation();
            }

            var position = this._camera.position;
            var translateX = position.x < -this._maxCoord.x || position.x > this._maxCoord.x;
            var translateY = position.y < -this._maxCoord.y || position.y > this._maxCoord.y;
            if ((translateX || translateY) && !this._lastInertiaTranslateMovement &&
                    !this._animationCollection.contains(this._translateAnimation)) {
                this._addCorrectTranslateAnimation();
            }
        }

        this._animationCollection.update();

        return true;
    };

    Camera2DController.prototype._translate = function(movement) {
       var frustum = this._camera.frustum;

       if (frustum.left === null || frustum.right === null ||
           frustum.top === null || frustum.bottom === null) {
               throw new DeveloperError('The camera frustum is expected to be orthographic for 2D camera control.');
       }

       var width = this._canvas.clientWidth;
       var height = this._canvas.clientHeight;

       var start = new Cartesian2();
       start.x = (movement.startPosition.x / width) * (frustum.right - frustum.left) + frustum.left;
       start.y = ((height - movement.startPosition.y) / height) * (frustum.top - frustum.bottom) + frustum.bottom;

       var end = new Cartesian2();
       end.x = (movement.endPosition.x / width) * (frustum.right - frustum.left) + frustum.left;
       end.y = ((height - movement.endPosition.y) / height) * (frustum.top - frustum.bottom) + frustum.bottom;

       var camera = this._camera;
       var right = camera.right;
       var up = camera.up;
       var position;
       var newPosition;

       var distance = start.subtract(end);
       if (distance.x !== 0) {
           position = camera.position;
           newPosition = position.add(right.multiplyByScalar(distance.x));

           var maxX = this._maxCoord.x * this._maxTranslateFactor;
           if (newPosition.x > maxX) {
               newPosition.x = maxX;
           }
           if (newPosition.x < -maxX) {
               newPosition.x = -maxX;
           }

           camera.position = newPosition;
       }
       if (distance.y !== 0) {
           position = camera.position;
           newPosition = position.add(up.multiplyByScalar(distance.y));

           var maxY = this._maxCoord.y * this._maxTranslateFactor;
           if (newPosition.y > maxY) {
               newPosition.y = maxY;
           }
           if (newPosition.y < -maxY) {
               newPosition.y = -maxY;
           }

           camera.position = newPosition;
       }
   };

   Camera2DController.prototype._zoom = function(movement) {
       var camera = this._camera;
       var mag = Math.max(camera.frustum.right - camera.frustum.left, camera.frustum.top - camera.frustum.bottom);
       handleZoom(this, movement, mag);
   };

   Camera2DController.prototype._twist = function(movement) {
       var width = this._canvas.clientWidth;
       var height = this._canvas.clientHeight;

       var start = new Cartesian2();
       start.x = (2.0 / width) * movement.startPosition.x - 1.0;
       start.y = (2.0 / height) * (height - movement.startPosition.y) - 1.0;
       start = start.normalize();

       var end = new Cartesian2();
       end.x = (2.0 / width) * movement.endPosition.x - 1.0;
       end.y = (2.0 / height) * (height - movement.endPosition.y) - 1.0;
       end = end.normalize();

       var startTheta = Math.acos(start.x);
       if (start.y < 0) {
           startTheta = CesiumMath.TWO_PI - startTheta;
       }
       var endTheta = Math.acos(end.x);
       if (end.y < 0) {
           endTheta = CesiumMath.TWO_PI - endTheta;
       }
       var theta = endTheta - startTheta;

       var camera = this._camera;
       var rotation = Matrix3.fromQuaternion(Quaternion.fromAxisAngle(camera.direction, theta));
       camera.up = rotation.multiplyByVector(camera.up);
       camera.right = camera.direction.cross(camera.up);
   };

   /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof Camera2DController
     *
     * @return {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     *
     * @see Camera2DController#destroy
     */
    Camera2DController.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Removes mouse listeners held by this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof Camera2DController
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see Camera2DController#isDestroyed
     *
     * @example
     * controller = controller && controller.destroy();
     */
    Camera2DController.prototype.destroy = function() {
        this._translateHandler = this._translateHandler && this._translateHandler.destroy();
        this._zoomHandler = this._zoomHandler && this._zoomHandler.destroy();
        this._zoomWheel = this._zoomWheel && this._zoomWheel.destroy();
        this._twistHandler = this._twistHandler && this._twistHandler.destroy();
        return destroyObject(this);
    };

    return Camera2DController;
});
/*global define*/
define('Scene/CameraColumbusViewController',[
        '../Core/destroyObject',
        '../Core/Ellipsoid',
        '../Core/Cartesian3',
        '../Core/Cartesian4',
        '../Core/Math',
        '../Core/Matrix4',
        './CameraEventHandler',
        './CameraEventType',
        './CameraSpindleController',
        './CameraFreeLookController',
        './CameraHelpers',
        './AnimationCollection',
        '../ThirdParty/Tween'
    ], function(
        destroyObject,
        Ellipsoid,
        Cartesian3,
        Cartesian4,
        CesiumMath,
        Matrix4,
        CameraEventHandler,
        CameraEventType,
        CameraSpindleController,
        CameraFreeLookController,
        CameraHelpers,
        AnimationCollection,
        Tween) {
    

    var maintainInertia = CameraHelpers.maintainInertia;

    /**
     * DOC_TBD
     * @alias CameraColumbusViewController
     * @constructor
     */
    var CameraColumbusViewController = function(canvas, camera, ellipsoid) {
        this._canvas = canvas;
        this._camera = camera;
        this._ellipsoid = ellipsoid || Ellipsoid.WGS84;

        /**
         * A parameter in the range <code>[0, 1]</code> used to determine how long
         * the camera will continue to translate because of inertia.
         * With a value of zero, the camera will have no inertia.
         *
         * @type Number
         */
        this.inertiaTranslate = 0.9;

        this._translateHandler = new CameraEventHandler(canvas, CameraEventType.LEFT_DRAG);

        this._spindleController = new CameraSpindleController(canvas, camera, Ellipsoid.UNIT_SPHERE);

        // TODO: Shouldn't change private variables like this, need to be able to change event modifiers
        //       on controllers.
        this._spindleController._spinHandler = this._spindleController._spinHandler && this._spindleController._spinHandler.destroy();
        this._spindleController._spinHandler = new CameraEventHandler(canvas, CameraEventType.MIDDLE_DRAG);
        this._spindleController.constrainedAxis = Cartesian3.UNIT_Z;

        this._freeLookController = new CameraFreeLookController(canvas, camera);
        this._freeLookController.horizontalRotationAxis = Cartesian3.UNIT_Z;

        this._transform = this._camera.transform.clone();
        this._lastInertiaTranslateMovement = undefined;

        this._animationCollection = new AnimationCollection();
        this._translateAnimation = undefined;

        this._mapWidth = this._ellipsoid.getRadii().x * Math.PI;
        this._mapHeight = this._ellipsoid.getRadii().y * CesiumMath.PI_OVER_TWO;
    };

    /**
     * @private
     */
    CameraColumbusViewController.prototype.update = function() {
        var translate = this._translateHandler;
        var translating = translate.isMoving() && translate.getMovement();

        if (translate.isButtonDown() || this._spindleController._zoomHandler.isButtonDown() ||
                this._spindleController._spinHandler.isButtonDown() || this._freeLookController._handler.isButtonDown()) {
            this._animationCollection.removeAll();
        }

        if (translating) {
            this._translate(translate.getMovement());
        }

        if (!translating && this.inertiaTranslate < 1.0) {
            maintainInertia(translate, this.inertiaTranslate, this._translate, this, '_lastInertiaTranslateMovement');
        }

        this._spindleController.update();
        this._freeLookController.update();

        this._correctPosition();
        this._animationCollection.update();

        return true;
    };

    CameraColumbusViewController.prototype._addCorrectTranslateAnimation = function(position, center, maxX, maxY) {
        var newPosition = position.clone();

        if (center.y > maxX) {
            newPosition.y -= center.y - maxX;
        } else if (center.y < -maxX) {
            newPosition.y += -maxX - center.y;
        }

        if (center.z > maxY) {
            newPosition.z -= center.z - maxY;
        } else if (center.z < -maxY) {
            newPosition.z += -maxY - center.z;
        }

        var camera = this._camera;
        var updateCV = function(value) {
            var interp = position.lerp(newPosition, value.time);
            var pos = new Cartesian4(interp.x, interp.y, interp.z, 1.0);
            camera.position = Cartesian3.fromCartesian4(camera.getInverseTransform().multiplyByVector(pos));
        };

        this._translateAnimation = this._animationCollection.add({
            easingFunction : Tween.Easing.Exponential.EaseOut,
            startValue : {
                time : 0.0
            },
            stopValue : {
                time : 1.0
            },
            onUpdate : updateCV
        });
    };

    CameraColumbusViewController.prototype._translate = function(movement) {
        var camera = this._camera;
        var sign = (camera.direction.dot(Cartesian3.UNIT_Z) >= 0) ? 1.0 : -1.0;

        var startRay = camera.getPickRay(movement.startPosition);
        var endRay = camera.getPickRay(movement.endPosition);

        var position = new Cartesian4(startRay.origin.x, startRay.origin.y, startRay.origin.z, 1.0);
        position = Cartesian3.fromCartesian4(camera.getInverseTransform().multiplyByVector(position));
        var direction = new Cartesian4(startRay.direction.x, startRay.direction.y, startRay.direction.z, 0.0);
        direction = Cartesian3.fromCartesian4(camera.getInverseTransform().multiplyByVector(direction));
        var scalar = sign * position.z / direction.z;
        var startPlanePos = position.add(direction.multiplyByScalar(scalar));

        position = new Cartesian4(endRay.origin.x, endRay.origin.y, endRay.origin.z, 1.0);
        position = Cartesian3.fromCartesian4(camera.getInverseTransform().multiplyByVector(position));
        direction = new Cartesian4(endRay.direction.x, endRay.direction.y, endRay.direction.z, 0.0);
        direction = Cartesian3.fromCartesian4(camera.getInverseTransform().multiplyByVector(direction));
        scalar = sign * position.z / direction.z;
        var endPlanePos = position.add(direction.multiplyByScalar(scalar));

        var diff = startPlanePos.subtract(endPlanePos);
        camera.position = camera.position.add(diff);
    };

    CameraColumbusViewController.prototype._correctPosition = function()
    {
        var camera = this._camera;
        var position = camera.position;
        var direction = camera.direction;
        var cameraPosition;

        var centerWC;
        var positionWC;

        if (direction.dot(Cartesian3.UNIT_Z) >= 0) {
            centerWC = Cartesian4.UNIT_W;
            this._transform.setColumn(3, centerWC, this._transform);

            cameraPosition = new Cartesian4(camera.position.x, camera.position.y, camera.position.z, 1.0);
            positionWC = camera.transform.multiplyByVector(cameraPosition);

            camera.transform = this._transform.clone();
        } else {
            var scalar = -position.z / direction.z;
            var center = position.add(direction.multiplyByScalar(scalar));
            center = new Cartesian4(center.x, center.y, center.z, 1.0);
            centerWC = camera.transform.multiplyByVector(center);
            this._transform.setColumn(3, centerWC, this._transform);

            cameraPosition = new Cartesian4(camera.position.x, camera.position.y, camera.position.z, 1.0);
            positionWC = camera.transform.multiplyByVector(cameraPosition);
            camera.transform = this._transform.clone();
        }

        var tanPhi = Math.tan(this._camera.frustum.fovy * 0.5);
        var tanTheta = this._camera.frustum.aspectRatio * tanPhi;
        var distToC = positionWC.subtract(centerWC).magnitude();
        var dWidth = tanTheta * distToC;
        var dHeight = tanPhi * distToC;

        var maxX = Math.max(dWidth - this._mapWidth, this._mapWidth);
        var maxY = Math.max(dHeight - this._mapHeight, this._mapHeight);

        if (positionWC.x < -maxX || positionWC.x > maxX || positionWC.y < -maxY || positionWC.y > maxY) {
            if (!this._translateHandler.isButtonDown()) {
                var translateX = centerWC.y < -maxX || centerWC.y > maxX;
                var translateY = centerWC.z < -maxY || centerWC.z > maxY;
                if ((translateX || translateY) && !this._lastInertiaTranslateMovement &&
                        !this._animationCollection.contains(this._translateAnimation)) {
                    this._addCorrectTranslateAnimation(Cartesian3.fromCartesian4(positionWC), Cartesian3.fromCartesian4(centerWC), maxX, maxY);
                }
            }

            maxX = maxX + this._mapWidth * 0.5;
            if (centerWC.y > maxX) {
                positionWC.y -= centerWC.y - maxX;
            } else if (centerWC.y < -maxX) {
                positionWC.y += -maxX - centerWC.y;
            }

            maxY = maxY + this._mapHeight * 0.5;
            if (centerWC.z > maxY) {
                positionWC.z -= centerWC.z - maxY;
            } else if (centerWC.z < -maxY) {
                positionWC.z += -maxY - centerWC.z;
            }
        }

        camera.position = Cartesian3.fromCartesian4(camera.getInverseTransform().multiplyByVector(positionWC));
    };

    /**
      * Returns true if this object was destroyed; otherwise, false.
      * <br /><br />
      * If this object was destroyed, it should not be used; calling any function other than
      * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
      *
      * @memberof CameraColumbusViewController
      *
      * @return {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
      *
      * @see CameraSpindleController#destroy
      */
    CameraColumbusViewController.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Removes mouse listeners held by this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof CameraColumbusViewController
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see CameraColumbusViewController#isDestroyed
     *
     * @example
     * controller = controller && controller.destroy();
     */
    CameraColumbusViewController.prototype.destroy = function() {
        this._translateHandler = this._translateHandler && this._translateHandler.destroy();
        this._spindleController = this._spindleController && this._spindleController.destroy();
        this._freeLookController = this._freeLookController && this._freeLookController.destroy();
        return destroyObject(this);
    };

    return CameraColumbusViewController;
});
/*global define*/
define('Scene/CameraControllerCollection',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/Ellipsoid',
        '../Core/Cartographic',
        './Camera2DController',
        './CameraFlightController',
        './CameraSpindleController',
        './CameraFreeLookController',
        './CameraColumbusViewController',
        './CameraCentralBodyController'
    ], function(
        DeveloperError,
        destroyObject,
        Ellipsoid,
        Cartographic,
        Camera2DController,
        CameraFlightController,
        CameraSpindleController,
        CameraFreeLookController,
        CameraColumbusViewController,
        CameraCentralBodyController) {
    

    /**
     * DOC_TBA
     *
     * @alias CameraControllerCollection
     * @internalConstructor
     *
     * @see Camera#getControllers
     */
    var CameraControllerCollection = function(camera, canvas) {
        this._controllers = [];
        this._canvas = canvas;
        this._camera = camera;
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraControllerCollection
     *
     * @see CameraControllerCollection#addFreeLook
     * @see CameraControllerCollection#addFlight
     * @see CameraControllerCollection#addSpindle
     * @see CameraControllerCollection#addColumbusView
     */
    CameraControllerCollection.prototype.add2D = function(projection) {
        var twoD = new Camera2DController(this._canvas, this._camera, projection);
        this._controllers.push(twoD);
        return twoD;
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraControllerCollection
     *
     * @see CameraControllerCollection#addFreeLook
     * @see CameraControllerCollection#addFlight
     * @see CameraControllerCollection#add2D
     * @see CameraControllerCollection#addColumbusView
     */
    CameraControllerCollection.prototype.addSpindle = function(ellipsoid) {
        var spindle = new CameraSpindleController(this._canvas, this._camera, ellipsoid);
        this._controllers.push(spindle);
        return spindle;
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraControllerCollection
     *
     * @see CameraControllerCollection#addSpindle
     * @see CameraControllerCollection#addFlight
     * @see CameraControllerCollection#add2D
     * @see CameraControllerCollection#addColumbusView
     */
    CameraControllerCollection.prototype.addFreeLook = function(ellipsoid) {
        var freeLook = new CameraFreeLookController(this._canvas, this._camera);
        this._controllers.push(freeLook);
        return freeLook;
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraControllerCollection
     *
     * @see CameraControllerCollection#addSpindle
     * @see CameraControllerCollection#addFlight
     * @see CameraControllerCollection#add2D
     * @see CameraControllerCollection#addFreeLook
     */
    CameraControllerCollection.prototype.addColumbusView = function() {
        var cv = new CameraColumbusViewController(this._canvas, this._camera);
        this._controllers.push(cv);
        return cv;
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraControllerCollection
     *
     * @see CameraControllerCollection#addSpindle
     * @see CameraControllerCollection#addFreeLook
     * @see CameraControllerCollection#add2D
     * @see CameraControllerCollection#addColumbusView
     */
    CameraControllerCollection.prototype.addFlight = function(template) {
        var t = template || {};
        var ellipsoid = t.ellipsoid || Ellipsoid.WGS84;
        var destination = t.destination || ellipsoid.cartographicToCartesian(new Cartographic(0.0, 0.0, 0.0));
        var duration = t.duration || 4.0;
        var complete = template.complete;
		var flightController = new CameraFlightController(this._canvas, this._camera, ellipsoid, destination, duration, complete);
		this._controllers.push(flightController);
		return flightController;
    };

    CameraControllerCollection.prototype.addCentralBody = function() {
        var cb = new CameraCentralBodyController(this._canvas, this._camera);
        this._controllers.push(cb);
        return cb;
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraControllerCollection
     *
     * @see CameraControllerCollection#removeAll
     */
    CameraControllerCollection.prototype.remove = function(controller) {
        if (controller) {
            var controllers = this._controllers;
            var i = controllers.indexOf(controller);
            if (i !== -1) {
                controllers[i].destroy();
                controllers.splice(i, 1);
                return true;
            }
        }

        return false;
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraControllerCollection
     *
     * @see CameraControllerCollection#remove
     */
    CameraControllerCollection.prototype.removeAll = function() {
        var controllers = this._controllers;
        var length = controllers.length;
        for ( var i = 0; i < length; ++i) {
            controllers[i].destroy();
        }

        this._controllers = [];
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraControllerCollection
     */
    CameraControllerCollection.prototype.contains = function(controller) {
        if (controller) {
            return (this._controllers.indexOf(controller) !== -1);
        }

        return false;
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraControllerCollection
     *
     * @see CameraControllerCollection#getLength
     */
    CameraControllerCollection.prototype.get = function(index) {
        if (typeof index === 'undefined') {
            throw new DeveloperError('index is required.');
        }

        return this._controllers[index];
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraControllerCollection
     *
     * @see CameraControllerCollection#get
     */
    CameraControllerCollection.prototype.getLength = function() {
        return this._controllers.length;
    };

    /**
     * @private
     */
    CameraControllerCollection.prototype.update = function() {
        var toRemove = [];

        var controllers = this._controllers;
        var length = controllers.length;
        for ( var i = 0; i < length; ++i) {
            if (!controllers[i].update()) {
                toRemove.push(i);
            }
        }

        // Automatically remove expired controllers
        for ( var j = 0; j < toRemove.length; ++j) {
            var index = toRemove[j];
            controllers[index].destroy();
            controllers.splice(index, 1);
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraControllerCollection
     */
    CameraControllerCollection.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * DOC_TBA
     *
     * @memberof CameraControllerCollection
     */
    CameraControllerCollection.prototype.destroy = function() {
        this.removeAll();
        return destroyObject(this);
    };

    return CameraControllerCollection;
});

/*global define*/
define('Scene/Camera',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/Math',
        '../Core/Intersect',
        '../Core/Ellipsoid',
        '../Core/IntersectionTests',
        '../Core/Cartesian3',
        '../Core/Cartesian4',
        '../Core/Cartographic',
        '../Core/Matrix4',
        '../Core/Ray',
        './CameraControllerCollection',
        './PerspectiveFrustum'
    ], function(
        DeveloperError,
        destroyObject,
        CesiumMath,
        Intersect,
        Ellipsoid,
        IntersectionTests,
        Cartesian3,
        Cartesian4,
        Cartographic,
        Matrix4,
        Ray,
        CameraControllerCollection,
        PerspectiveFrustum) {
    

    /**
     * The camera is defined by a position, orientation, and view frustum.
     * <br /><br />
     * The orientation forms an orthonormal basis with a view, up and right = view x up unit vectors.
     * <br /><br />
     * The viewing frustum is defined by 6 planes.
     * Each plane is represented by a {Cartesian4} object, where the x, y, and z components
     * define the unit vector normal to the plane, and the w component is the distance of the
     * plane from the origin/camera position.
     *
     * @alias Camera
     *
     * @exception {DeveloperError} canvas is required.
     *
     * @constructor
     *
     * @example
     * // Create a camera looking down the negative z-axis, positioned at the origin,
     * // with a field of view of 60 degrees, and 1:1 aspect ratio.
     * var camera = new Camera(canvas);
     * camera.position = new Cartesian3();
     * camera.direction = Cartesian3.UNIT_Z.negate();
     * camera.up = Cartesian3.UNIT_Y;
     * camera.fovy = CesiumMath.PI_OVER_THREE;
     * camera.near = 1.0;
     * camera.far = 2.0;
     */
    var Camera = function(canvas) {
        if (!canvas) {
            throw new DeveloperError('canvas is required.');
        }

        /**
         * DOC_TBA
         *
         * @type {Matrix4}
         */
        this.transform = Matrix4.IDENTITY;
        this._transform = this.transform.clone();
        this._invTransform = Matrix4.IDENTITY;

        var maxRadii = Ellipsoid.WGS84.getRadii().getMaximumComponent();
        var position = new Cartesian3(0.0, -2.0, 1.0).normalize().multiplyByScalar(2.0 * maxRadii);

        /**
         * The position of the camera.
         *
         * @type {Cartesian3}
         */
        this.position = position.clone();
        this._position = position;
        this._positionWC = position;

        var direction = Cartesian3.ZERO.subtract(position).normalize();

        /**
         * The view direction of the camera.
         *
         * @type {Cartesian3}
         */
        this.direction = direction.clone();
        this._direction = direction;
        this._directionWC = direction;

        var right = direction.cross(Cartesian3.UNIT_Z).normalize();

        /**
         * The right direction of the camera.
         *
         * @type {Cartesian3}
         */
        this.right = right.clone();
        this._right = right;
        this._rightWC = right;

        var up = right.cross(direction);

        /**
         * The up direction of the camera.
         *
         * @type {Cartesian3}
         */
        this.up = up.clone();
        this._up = up;
        this._upWC = up;

        /**
         * DOC_TBA
         *
         * @type {Frustum}
         */
        this.frustum = new PerspectiveFrustum();
        this.frustum.fovy = CesiumMath.toRadians(60.0);
        this.frustum.aspectRatio = canvas.clientWidth / canvas.clientHeight;
        this.frustum.near = 0.01 * maxRadii;
        this.frustum.far = 20.0 * maxRadii;

        this._viewMatrix = undefined;
        this._invViewMatrix = undefined;
        this._updateViewMatrix();

        this._planes = this.frustum.getPlanes(this._positionWC, this._directionWC, this._upWC);

        this._canvas = canvas;
        this._controllers = new CameraControllerCollection(this, canvas);
    };

    /**
     * DOC_TBA
     * @memberof Camera
     */
    Camera.prototype.getControllers = function() {
        return this._controllers;
    };

    /**
     * DOC_TBA
     * @memberof Camera
     */
    Camera.prototype.update = function() {
        this._controllers.update();
    };

    /**
     * Sets the camera position and orientation with an eye position, target, and up vector.
     *
     * @memberof Camera
     *
     * @param {Array} arguments If one parameter is passed to this function, it must have three
     * properties with the names eye, target, and up; otherwise three arguments are expected which
     * the same as the properties of one object and given in the order given above.
     *
     */
    Camera.prototype.lookAt = function() {
        var eye, target, up;
        if (arguments.length === 1) {
            var param = arguments[0];
            if (param.eye && param.target && param.up) {
                eye = param.eye;
                target = param.target;
                up = param.up;
            } else {
                return;
            }
        } else if (arguments.length === 3) {
            eye = arguments[0];
            target = arguments[1];
            up = arguments[2];
        } else {
            return;
        }

        this.position = eye;
        this.direction = target.subtract(eye).normalize();
        this.up = up.normalize();
        this.right = this.direction.cross(this.up);
    };

    /**
     * Zooms to a cartographic extent on the central body. The camera will be looking straight down at the extent,
     * with the up vector pointing toward local north.
     *
     * @memberof Camera
     * @param {Ellipsoid} ellipsoid The ellipsoid to view.
     * @param {Extent} extent The extent to view.
     *
     * @exception {DeveloperError} extent is required.
     */
    Camera.prototype.viewExtent = function(extent, ellipsoid) {
        if (typeof extent === 'undefined') {
            throw new DeveloperError('extent is required.');
        }

        ellipsoid = (typeof ellipsoid === 'undefined') ? Ellipsoid.WGS84 : ellipsoid;

        var north = extent.north;
        var south = extent.south;
        var east = extent.east;
        var west = extent.west;

        // If we go across the International Date Line
        if (west > east) {
            east += CesiumMath.TWO_PI;
        }

        var northEast = ellipsoid.cartographicToCartesian(new Cartographic(east, north));
        var southWest = ellipsoid.cartographicToCartesian(new Cartographic(west, south));
        var diagonal = northEast.subtract(southWest);
        var center = southWest.add(diagonal.normalize().multiplyByScalar(diagonal.magnitude() * 0.5));

        var northWest = ellipsoid.cartographicToCartesian(new Cartographic(west, north)).subtract(center);
        var southEast = ellipsoid.cartographicToCartesian(new Cartographic(east, south)).subtract(center);
        northEast = northEast.subtract(center);
        southWest = southWest.subtract(center);

        this.direction = center.negate().normalize();
        this.right = this.direction.cross(Cartesian3.UNIT_Z).normalize();
        this.up = this.right.cross(this.direction);

        var height = Math.max(Math.abs(this.up.dot(northWest)), Math.abs(this.up.dot(southEast)), Math.abs(this.up.dot(northEast)), Math.abs(this.up.dot(southWest)));
        var width = Math.max(Math.abs(this.right.dot(northWest)), Math.abs(this.right.dot(southEast)), Math.abs(this.right.dot(northEast)), Math.abs(this.right.dot(southWest)));

        var tanPhi = Math.tan(this.frustum.fovy * 0.5);
        var tanTheta = this.frustum.aspectRatio * tanPhi;
        var d = Math.max(width / tanTheta, height / tanPhi);

        this.position = center.normalize().multiplyByScalar(center.magnitude() + d);
    };

    /**
     * Zooms to a cartographic extent on the Columbus view map. The camera will be looking straight down at the extent,
     * with the up vector pointing toward local north.
     *
     * @memberof Camera
     * @param {Ellipsoid} ellipsoid The ellipsoid to view.
     * @param {Extent} extent The extent to view.
     *
     * @exception {DeveloperError} extent is required.
     * @exception {DeveloperError} projection is required.
     */
    Camera.prototype.viewExtentColumbusView = function(extent, projection) {
        if (typeof extent === 'undefined') {
            throw new DeveloperError('extent is required.');
        }

        if (typeof projection === 'undefined') {
            throw new DeveloperError('projection is required.');
        }

        var north = extent.north;
        var south = extent.south;
        var east = extent.east;
        var west = extent.west;

        var transform = this.transform.setColumn(3, Cartesian4.UNIT_W);

        var northEast = projection.project(new Cartographic(east, north));
        northEast = transform.multiplyByVector(new Cartesian4(northEast.x, northEast.y, northEast.z, 1.0));
        northEast = Cartesian3.fromCartesian4(this.getInverseTransform().multiplyByVector(northEast));

        var southWest = projection.project(new Cartographic(west, south));
        southWest = transform.multiplyByVector(new Cartesian4(southWest.x, southWest.y, southWest.z, 1.0));
        southWest = Cartesian3.fromCartesian4(this.getInverseTransform().multiplyByVector(southWest));

        var tanPhi = Math.tan(this.frustum.fovy * 0.5);
        var tanTheta = this.frustum.aspectRatio * tanPhi;
        var d = Math.max((northEast.x - southWest.x) / tanTheta, (northEast.y - southWest.y) / tanPhi) * 0.5;

        var position = projection.project(new Cartographic(0.5 * (west + east), 0.5 * (north + south), d));
        position = transform.multiplyByVector(new Cartesian4(position.x, position.y, position.z, 1.0));
        this.position = Cartesian3.fromCartesian4(this.getInverseTransform().multiplyByVector(position));

        // Not exactly -z direction because that would lock the camera in place with a constrained z axis.
        this.direction = new Cartesian3(0.0, 0.0001, -0.999);
        this.right = Cartesian3.UNIT_X;
        this.up = this.right.cross(this.direction);
    };

    /**
     * Zooms to a cartographic extent on the 2D map. The camera will be looking straight down at the extent,
     * with the up vector pointing toward local north.
     *
     * @memberof Camera
     * @param {Ellipsoid} ellipsoid The ellipsoid to view.
     * @param {Extent} extent The extent to view.
     *
     * @exception {DeveloperError} extent is required.
     * @exception {DeveloperError} projection is required.
     */
    Camera.prototype.viewExtent2D = function(extent, projection) {
        if (typeof extent === 'undefined') {
            throw new DeveloperError('extent is required.');
        }

        if (typeof projection === 'undefined') {
            throw new DeveloperError('projection is required.');
        }

        var north = extent.north;
        var south = extent.south;
        var east = extent.east;
        var west = extent.west;
        var lla = new Cartographic(0.5 * (west + east), 0.5 * (north + south));

        var northEast = projection.project(new Cartographic(east, north));
        var southWest = projection.project(new Cartographic(west, south));

        var width = Math.abs(northEast.x - southWest.x) * 0.5;
        var height = Math.abs(northEast.y - southWest.y) * 0.5;

        var position = projection.project(lla);
        this.position.x = position.x;
        this.position.y = position.y;

        var right, top;
        var ratio = this.frustum.right / this.frustum.top;
        var heightRatio = height * ratio;
        if (width > heightRatio) {
            right = width;
            top = right / ratio;
        } else {
            top = height;
            right = heightRatio;
        }

        this.frustum.right = right;
        this.frustum.left = -right;
        this.frustum.top = top;
        this.frustum.bottom = -top;
    };

    Camera.prototype._updateViewMatrix = function() {
        var r = this._right;
        var u = this._up;
        var d = this._direction;
        var e = this._position;

        var viewMatrix = new Matrix4( r.x,  r.y,  r.z, -r.dot(e),
                                      u.x,  u.y,  u.z, -u.dot(e),
                                     -d.x, -d.y, -d.z,  d.dot(e),
                                      0.0,  0.0,  0.0,      1.0);
        this._viewMatrix = viewMatrix.multiply(this._invTransform);

        this._invViewMatrix = this._viewMatrix.inverseTransformation();
    };

    Camera.prototype._update = function() {
        var position = this._position;
        var positionChanged = !position.equals(this.position);
        if (positionChanged) {
            position = this._position = this.position.clone();
        }

        var direction = this._direction;
        var directionChanged = !direction.equals(this.direction);
        if (directionChanged) {
            direction = this._direction = this.direction.clone();
        }

        var up = this._up;
        var upChanged = !up.equals(this.up);
        if (upChanged) {
            up = this._up = this.up.clone();
        }

        var right = this._right;
        var rightChanged = !right.equals(this.right);
        if (rightChanged) {
            right = this._right = this.right.clone();
        }

        var transform = this._transform;
        var transformChanged = !transform.equals(this.transform);
        if (transformChanged) {
            transform = this._transform = this.transform.clone();

            this._invTransform = this._transform.inverseTransformation();
        }

        if (positionChanged || transformChanged) {
            this._positionWC = Cartesian3.fromCartesian4(transform.multiplyByVector(new Cartesian4(position.x, position.y, position.z, 1.0)));
        }

        if (directionChanged || transformChanged) {
            this._directionWC = Cartesian3.fromCartesian4(transform.multiplyByVector(new Cartesian4(direction.x, direction.y, direction.z, 0.0)));
        }

        if (upChanged || transformChanged) {
            this._upWC = Cartesian3.fromCartesian4(transform.multiplyByVector(new Cartesian4(up.x, up.y, up.z, 0.0)));
        }

        if (rightChanged || transformChanged) {
            this._rightWC = Cartesian3.fromCartesian4(transform.multiplyByVector(new Cartesian4(right.x, right.y, right.z, 0.0)));
        }

        if (positionChanged || directionChanged || upChanged || transformChanged) {
            this._planes = this.frustum.getPlanes(this._positionWC, this._directionWC, this._upWC);
        }

        if (directionChanged || upChanged || rightChanged) {
            var det = direction.dot(up.cross(right));
            if (Math.abs(1.0 - det) > CesiumMath.EPSILON2) {
                //orthonormalize axes
                direction = this._direction = direction.normalize();
                this.direction = direction.clone();

                var invUpMag = 1.0 / up.magnitudeSquared();
                var scalar = up.dot(direction) * invUpMag;
                var w0 = direction.multiplyByScalar(scalar);
                up = this._up = up.subtract(w0).normalize();
                this.up = up.clone();

                right = this._right = direction.cross(up);
                this.right = right.clone();
            }
        }

        if (positionChanged || directionChanged || upChanged || rightChanged || transformChanged) {
            this._updateViewMatrix();
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof Camera
     *
     * @return {Matrix4} DOC_TBA
     */
    Camera.prototype.getInverseTransform = function() {
        this._update();
        return this._invTransform;
    };

    /**
     * Returns the view matrix.
     *
     * @memberof Camera
     *
     * @return {Matrix4} The view matrix.
     *
     * @see UniformState#getView
     * @see UniformState#setView
     * @see agi_view
     */
    Camera.prototype.getViewMatrix = function() {
        this._update();
        return this._viewMatrix;
    };

    /**
     * DOC_TBA
     * @memberof Camera
     */
    Camera.prototype.getInverseViewMatrix = function() {
        this._update();
        return this._invViewMatrix;
    };

    /**
     * The position of the camera in world coordinates.
     *
     * @type {Cartesian3}
     */
    Camera.prototype.getPositionWC = function() {
        this._update();
        return this._positionWC;
    };

    /**
     * The view direction of the camera in world coordinates.
     *
     * @type {Cartesian3}
     */
    Camera.prototype.getDirectionWC = function() {
        this._update();
        return this._directionWC;
    };

    /**
     * The up direction of the camera in world coordinates.
     *
     * @type {Cartesian3}
     */
    Camera.prototype.getUpWC = function() {
        this._update();
        return this._upWC;
    };

    /**
     * The right direction of the camera in world coordinates.
     *
     * @type {Cartesian3}
     */
    Camera.prototype.getRightWC = function() {
        this._update();
        return this._rightWC;
    };

    Camera.prototype._getPickRayPerspective = function(windowPosition) {
        var width = this._canvas.clientWidth;
        var height = this._canvas.clientHeight;

        var tanPhi = Math.tan(this.frustum.fovy * 0.5);
        var tanTheta = this.frustum.aspectRatio * tanPhi;
        var near = this.frustum.near;

        var x = (2.0 / width) * windowPosition.x - 1.0;
        var y = (2.0 / height) * (height - windowPosition.y) - 1.0;

        var position = this.getPositionWC();
        var nearCenter = position.add(this.getDirectionWC().multiplyByScalar(near));
        var xDir = this.getRightWC().multiplyByScalar(x * near * tanTheta);
        var yDir = this.getUpWC().multiplyByScalar(y * near * tanPhi);
        var direction = nearCenter.add(xDir).add(yDir).subtract(position).normalize();

        return new Ray(position.clone(), direction);
    };

    Camera.prototype._getPickRayOrthographic = function(windowPosition) {
        var width = this._canvas.clientWidth;
        var height = this._canvas.clientHeight;

        var x = (2.0 / width) * windowPosition.x - 1.0;
        x *= (this.frustum.right - this.frustum.left) * 0.5;
        var y = (2.0 / height) * (height - windowPosition.y) - 1.0;
        y *= (this.frustum.top - this.frustum.bottom) * 0.5;

        var position = this.position.clone();
        position.x += x;
        position.y += y;

        return new Ray(position, this.getDirectionWC());
    };

    /**
     * Create a ray from the camera position through the pixel at <code>windowPosition</code>
     * in world coordinates.
     *
     * @memberof Camera
     *
     * @param {Cartesian2} windowPosition The x and y coordinates of a pixel.
     *
     * @exception {DeveloperError} windowPosition is required.
     *
     * @return {Object} Returns the {@link Cartesian3} position and direction of the ray.
     */
    Camera.prototype.getPickRay = function(windowPosition) {
        if (typeof windowPosition === 'undefined') {
            throw new DeveloperError('windowPosition is required.');
        }

        var frustum = this.frustum;
        if (typeof frustum.aspectRatio !== 'undefined' && typeof frustum.fovy !== 'undefined' && typeof frustum.near !== 'undefined') {
            return this._getPickRayPerspective(windowPosition);
        }

        return this._getPickRayOrthographic(windowPosition);
    };

    /**
     * Pick an ellipsoid in 3D mode.
     *
     * @memberof Camera
     *
     * @param {Cartesian2} windowPosition The x and y coordinates of a pixel.
     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid to pick.
     *
     * @exception {DeveloperError} windowPosition is required.
     *
     * @return {Cartesian3} If the ellipsoid was picked, returns the point on the surface of the ellipsoid.
     * If the ellipsoid was not picked, returns undefined.
     */
    Camera.prototype.pickEllipsoid = function(windowPosition, ellipsoid) {
        if (typeof windowPosition === 'undefined') {
            throw new DeveloperError('windowPosition is required.');
        }

        ellipsoid = ellipsoid || Ellipsoid.WGS84;
        var ray = this._getPickRayPerspective(windowPosition);
        var intersection = IntersectionTests.rayEllipsoid(ray, ellipsoid);
        if (!intersection) {
            return undefined;
        }

        var iPt = ray.getPoint(intersection.start);
        return iPt;
    };

    /**
     * Pick the map in 2D mode.
     *
     * @param {Cartesian2} windowPosition The x and y coordinates of a pixel.
     * @param {DOC_TBA} projection DOC_TBA
     *
     * @exception {DeveloperError} windowPosition is required.
     * @exception {DeveloperError} projection is required.
     *
     * @return {Cartesian3} If the map was picked, returns the point on the surface of the map.
     * If the map was not picked, returns undefined.
     */
    Camera.prototype.pickMap2D = function(windowPosition, projection) {
        if (typeof windowPosition === 'undefined') {
            throw new DeveloperError('windowPosition is required.');
        }

        if (typeof projection === 'undefined') {
            throw new DeveloperError('projection is required.');
        }

        var ray = this._getPickRayOrthographic(windowPosition);
        var position = ray.origin;
        position.z = 0.0;
        var cart = projection.unproject(position);

        if (cart.latitude < -CesiumMath.PI_OVER_TWO || cart.latitude > CesiumMath.PI_OVER_TWO ||
                cart.longitude < - Math.PI || cart.longitude > Math.PI) {
            return undefined;
        }

        return projection.getEllipsoid().cartographicToCartesian(cart);
    };

    /**
     * Pick the map in Columbus View mode.
     *
     * @param {Cartesian2} windowPosition The x and y coordinates of a pixel.
     * @param {DOC_TBA} projection DOC_TBA
     *
     * @exception {DeveloperError} windowPosition is required.
     * @exception {DeveloperError} projection is required.
     *
     * @return {Cartesian3} If the map was picked, returns the point on the surface of the map.
     * If the map was not picked, returns undefined.
     */
    Camera.prototype.pickMapColumbusView = function(windowPosition, projection) {
        if (typeof windowPosition === 'undefined') {
            throw new DeveloperError('windowPosition is required.');
        }

        if (typeof projection === 'undefined') {
            throw new DeveloperError('projection is required.');
        }

        var ray = this._getPickRayPerspective(windowPosition);
        var scalar = -ray.origin.x / ray.direction.x;
        var position = ray.getPoint(scalar);

        var cart = projection.unproject(new Cartesian3(position.y, position.z, 0.0));

        if (cart.latitude < -CesiumMath.PI_OVER_TWO || cart.latitude > CesiumMath.PI_OVER_TWO ||
                cart.longitude < - Math.PI || cart.longitude > Math.PI) {
            return undefined;
        }

        position = projection.getEllipsoid().cartographicToCartesian(cart);
        return position;
    };

    /**
     * Determines whether a bounding volume intersects with the frustum or not.
     *
     * @memberof Camera
     *
     * @param {Object} object The bounding volume whose intersection with the frustum is to be tested.
     * @param {Function} planeIntersectTest The function that tests for intersections between a plane
     * and the bounding volume type of object
     *
     * @return {Enumeration}  Intersect.OUTSIDE,
     *                                 Intersect.INTERSECTING, or
     *                                 Intersect.INSIDE.
     */
    Camera.prototype.getVisibility = function(object, planeIntersectTest) {
        this._update();
        var planes = this._planes;
        var intersecting = false;
        for ( var k = 0; k < planes.length; k++) {
            var result = planeIntersectTest(object, planes[k]);
            if (result === Intersect.OUTSIDE) {
                return Intersect.OUTSIDE;
            } else if (result === Intersect.INTERSECTING) {
                intersecting = true;
            }
        }

        return intersecting ? Intersect.INTERSECTING : Intersect.INSIDE;
    };

    /**
     * Returns a duplicate of a Camera instance.
     *
     * @memberof Camera
     *
     * @return {Camera} A new copy of the Camera instance.
     */
    Camera.prototype.clone = function() {
        var camera = new Camera(this._canvas);
        camera.position = this.position.clone();
        camera.direction = this.direction.clone();
        camera.up = this.up.clone();
        camera.right = this.right.clone();
        camera.transform = this.transform.clone();
        camera.frustum = this.frustum.clone();
        return camera;
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof Camera
     *
     * @return {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     *
     * @see Camera#destroy
     */
    Camera.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Removes keyboard listeners held by this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof Camera
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see Camera#isDestroyed
     *
     * @example
     * camera = camera && camera.destroy();
     */
    Camera.prototype.destroy = function() {
        this._controllers.destroy();
        return destroyObject(this);
    };

    return Camera;
});

/*global define*/
define('Scene/Scene',[
        '../Core/Color',
        '../Core/destroyObject',
        '../Core/EquidistantCylindricalProjection',
        '../Core/Ellipsoid',
        '../Core/DeveloperError',
        '../Renderer/Context',
        './Camera',
        './CompositePrimitive',
        './AnimationCollection',
        './SceneMode',
        './SceneState'
    ], function(
        Color,
        destroyObject,
        EquidistantCylindricalProjection,
        Ellipsoid,
        DeveloperError,
        Context,
        Camera,
        CompositePrimitive,
        AnimationCollection,
        SceneMode,
        SceneState) {
    

    /**
     * DOC_TBA
     *
     * @alias Scene
     * @constructor
     */
    var Scene = function(canvas) {
        var context = new Context(canvas);

        this._sceneState = new SceneState();
        this._canvas = canvas;
        this._context = context;
        this._primitives = new CompositePrimitive();
        this._pickFramebuffer = undefined;
        this._camera = new Camera(canvas);
        this._clearState = context.createClearState({
            color : Color.BLACK,
            depth : 1.0
        });

        this._animate = undefined; // Animation callback
        this._animations = new AnimationCollection();

        this._shaderFrameCount = 0;

        /**
         * The current mode of the scene.
         *
         * @type SceneMode
         */
        this.mode = SceneMode.SCENE3D;

        /**
         * DOC_TBA
         */
        this.scene2D = {
            /**
             * The projection to use in 2D mode.
             */
            projection : new EquidistantCylindricalProjection(Ellipsoid.WGS84)
        };

        /**
         * The current morph transition time between 2D/Columbus View and 3D,
         * with 0.0 being 2D or Columbus View and 1.0 being 3D.
         *
         * @type Number
         */
        this.morphTime = 1.0;
    };

    /**
     * DOC_TBA
     * @memberof Scene
     */
    Scene.prototype.getCanvas = function() {
        return this._canvas;
    };

    /**
     * DOC_TBA
     * @memberof Scene
     */
    Scene.prototype.getContext = function() {
        return this._context;
    };

    /**
     * DOC_TBA
     * @memberof Scene
     */
    Scene.prototype.getPrimitives = function() {
        return this._primitives;
    };

    /**
     * DOC_TBA
     * @memberof Scene
     */
    Scene.prototype.getCamera = function() {
        return this._camera;
    };
    // TODO: setCamera

    /**
     * DOC_TBA
     * @memberof Scene
     */
    Scene.prototype.getUniformState = function() {
        return this._context.getUniformState();
    };

    /**
     * DOC_TBA
     * @memberof Scene
     */
    Scene.prototype.getAnimations = function() {
        return this._animations;
    };

    /**
     * DOC_TBA
     * @memberof Scene
     */
    Scene.prototype.setSunPosition = function(sunPosition) {
        this.getUniformState().setSunPosition(sunPosition);
    };

    /**
     * DOC_TBA
     * @memberof Scene
     */
    Scene.prototype.getSunPosition = function() {
        return this.getUniformState().getSunPosition();
    };

    /**
     * DOC_TBA
     * @memberof Scene
     */
    Scene.prototype.setAnimation = function(animationCallback) {
        this._animate = animationCallback;
    };

    /**
     * DOC_TBA
     * @memberof Scene
     */
    Scene.prototype.getAnimation = function() {
        return this._animate;
    };

    Scene.prototype._update = function() {
        var us = this.getUniformState();
        var camera = this._camera;

        // Destroy released shaders once every 120 frames to avoid thrashing the cache
        if (this._shaderFrameCount++ === 120) {
            this._shaderFrameCount = 0;
            this._context.getShaderCache().destroyReleasedShaderPrograms();
        }

        this._animations.update();
        camera.update();
        us.setProjection(camera.frustum.getProjectionMatrix());
        if (camera.frustum.getInfiniteProjectionMatrix) {
            us.setInfiniteProjection(camera.frustum.getInfiniteProjectionMatrix());
        }
        us.setView(camera.getViewMatrix());

        if (this._animate) {
            this._animate();
        }

        var sceneState = this._sceneState;
        sceneState.mode = this.mode;
        sceneState.scene2D = this.scene2D;
        sceneState.camera = camera;

        this._primitives.update(this._context, sceneState);
    };

    /**
     * DOC_TBA
     * @memberof Scene
     */
    Scene.prototype.render = function() {
        this._update();

        this._context.clear(this._clearState);
        this._primitives.render(this._context);
    };

    /**
     * DOC_TBA
     * @memberof Scene
     */
    Scene.prototype.pick = function(windowPosition) {
        var context = this._context;
        var primitives = this._primitives;

        this._pickFramebuffer = this._pickFramebuffer || context.createPickFramebuffer();
        var fb = this._pickFramebuffer.begin();

        // TODO: Should we also do a regular update?
        primitives.updateForPick(context);
        primitives.renderForPick(context, fb);

        return this._pickFramebuffer.end({
            x : windowPosition.x,
            y : (this._canvas.clientHeight - windowPosition.y)
        });
    };

    /**
     * Pick an ellipsoid or map.
     *
     * @memberof Scene
     *
     * @param {Cartesian2} windowPosition The x and y coordinates of a pixel.
     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid to pick.
     *
     * @exception {DeveloperError} windowPosition is required.
     *
     * @return {Cartesian3} If the ellipsoid or map was picked, returns the point on the surface of the ellipsoid or map
     * in world coordinates. If the ellipsoid or map was not picked, returns undefined.
     */
    Scene.prototype.pickEllipsoid = function(windowPosition, ellipsoid) {
        if (typeof windowPosition === 'undefined') {
            throw new DeveloperError('windowPosition is required.');
        }

        ellipsoid = ellipsoid || Ellipsoid.WGS84;

        var p;
        if (this.mode === SceneMode.SCENE3D) {
            p = this._camera.pickEllipsoid(windowPosition, ellipsoid);
        } else if (this.mode === SceneMode.SCENE2D) {
            p = this._camera.pickMap2D(windowPosition, this.scene2D.projection);
        } else if (this.mode === SceneMode.COLUMBUS_VIEW) {
            p = this._camera.pickMapColumbusView(windowPosition, this.scene2D.projection);
        }

        return p;
    };

    /**
     * View an extent on an ellipsoid or map.
     *
     * @memberof Scene
     *
     * @param {Extent} extent The extent to view.
     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid to view.
     *
     * @exception {DeveloperError} extent is required.
     */
    Scene.prototype.viewExtent = function(extent, ellipsoid) {
        if (typeof extent === 'undefined') {
            throw new DeveloperError('extent is required.');
        }

        ellipsoid = ellipsoid || Ellipsoid.WGS84;

        if (this.mode === SceneMode.SCENE3D) {
            this._camera.viewExtent(extent, ellipsoid);
        } else if (this.mode === SceneMode.SCENE2D) {
            this._camera.viewExtent2D(extent, this.scene2D.projection);
        } else if (this.mode === SceneMode.COLUMBUS_VIEW) {
            this._camera.viewExtentColumbusView(extent, this.scene2D.projection);
        }
    };

    /**
     * DOC_TBA
     * @memberof Scene
     */
    Scene.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * DOC_TBA
     * @memberof Scene
     */
    Scene.prototype.destroy = function() {
        this._camera = this._camera && this._camera.destroy();
        this._pickFramebuffer = this._pickFramebuffer && this._pickFramebuffer.destroy();
        this._primitives = this._primitives && this._primitives.destroy();
        this._context = this._context && this._context.destroy();
        return destroyObject(this);
    };

    return Scene;
});
/*global define*/
define('Scene/SceneTransitioner',[
        '../Core/destroyObject',
        '../Core/Math',
        '../Core/EventHandler',
        '../Core/MouseEventType',
        '../Core/Ellipsoid',
        '../Core/Cartesian2',
        '../Core/Cartesian3',
        '../Core/Cartesian4',
        '../Core/Cartographic',
        '../Core/Matrix4',
        '../ThirdParty/Tween',
        './OrthographicFrustum',
        './PerspectiveFrustum',
        './SceneMode'
    ], function(
        destroyObject,
        CesiumMath,
        EventHandler,
        MouseEventType,
        Ellipsoid,
        Cartesian2,
        Cartesian3,
        Cartesian4,
        Cartographic,
        Matrix4,
        Tween,
        OrthographicFrustum,
        PerspectiveFrustum,
        SceneMode) {
    

    /**
     * DOC_TBA
     *
     * @alias SceneTransitioner
     * @constructor
     */
    var SceneTransitioner = function(scene, ellipsoid) {
        this._scene = scene;
        this._ellipsoid = ellipsoid || Ellipsoid.WGS84;
        var canvas = scene.getCanvas();

        // Position camera and size frustum so the entire 2D map is visible
        var maxRadii = this._ellipsoid.getMaximumRadius();
        var position = new Cartesian3(0.0, 0.0, 2.0 * maxRadii);
        var direction = position.negate().normalize();
        var up = Cartesian3.UNIT_Y;

        var frustum = new OrthographicFrustum();
        frustum.right = maxRadii * Math.PI;
        frustum.left = -frustum.right;
        frustum.top = frustum.right * (canvas.clientHeight / canvas.clientWidth);
        frustum.bottom = -frustum.top;
        frustum.near = 0.01 * maxRadii;
        frustum.far = 60.0 * maxRadii;

        var transform = new Matrix4(0.0, 0.0, 1.0, 0.0,
                                    1.0, 0.0, 0.0, 0.0,
                                    0.0, 1.0, 0.0, 0.0,
                                    0.0, 0.0, 0.0, 1.0);

        this._camera2D = {
            position : position,
            direction : direction,
            up : up,
            frustum : frustum,
            transform : transform
        };

        position = new Cartesian3(0.0, -1.0, 1.0).normalize().multiplyByScalar(5.0 * maxRadii);
        direction = Cartesian3.ZERO.subtract(position).normalize();
        var right = direction.cross(Cartesian3.UNIT_Z).normalize();
        up = right.cross(direction);

        frustum = new PerspectiveFrustum();
        frustum.fovy = CesiumMath.toRadians(60.0);
        frustum.aspectRatio = canvas.clientWidth / canvas.clientHeight;
        frustum.near = 0.01 * maxRadii;
        frustum.far = 60.0 * maxRadii;

        this._cameraCV = {
            position : position,
            direction : direction,
            up : up,
            frustum : frustum,
            transform : transform
        };

        position = new Cartesian3(0.0, -2.0, 1.0).normalize().multiplyByScalar(2.0 * maxRadii);
        direction = Cartesian3.ZERO.subtract(position).normalize();
        right = direction.cross(Cartesian3.UNIT_Z).normalize();
        up = right.cross(direction);

        this._camera3D = {
            position : position,
            direction : direction,
            up : up,
            frustum : frustum
        };

        this._currentAnimations = [];
        this._morphHandler = undefined;
        this._morphCancelled = false;

        /**
         * DOC_TBA
         * @type {Number}
         */
        this.morphDuration2D = 3000;

        /**
         * DOC_TBA
         * @type {Number}
         */
        this.morphDuration3D = 3000;

        /**
         * DOC_TBA
         * @type {Number}
         */
        this.morphDurationColumbusView = 3000;

        /**
         * DOC_TBA
         * @type {Boolean}
         */
        this.endMorphOnMouseInput = true;
    };

    //immediately set the morph time of all objects in the scene
    function setMorphTime(scene, morphTime) {
        scene.morphTime = morphTime;

        var primitives = scene.getPrimitives();
        for ( var i = 0, len = primitives.getLength(); i < len; i++) {
            var primitive = primitives.get(i);
            if (typeof primitive.morphTime !== 'undefined') {
                primitive.morphTime = morphTime;
            }
        }

        var centralBody = primitives.getCentralBody();
        centralBody.morphTime = morphTime;
    }

    //in the future the animations will be more complicated
    function addMorphTimeAnimations(transitioner, scene, start, stop, duration, onComplete) {
        //for now, all objects morph at the same rate
        var template = {
            duration : duration,
            easingFunction : Tween.Easing.Quartic.EaseOut
        };

        var primitives = scene.getPrimitives();
        var sceneAnimations = scene.getAnimations();
        var animation;
        for ( var i = 0, len = primitives.getLength(); i < len; i++) {
            var primitive = primitives.get(i);
            if (typeof primitive.morphTime !== 'undefined') {
                animation = sceneAnimations.addProperty(primitive, 'morphTime', start, stop, template);
                transitioner._currentAnimations.push(animation);
            }
        }

        var centralBody = primitives.getCentralBody();
        animation = sceneAnimations.addProperty(centralBody, 'morphTime', start, stop, template);
        transitioner._currentAnimations.push(animation);

        if (typeof onComplete !== 'undefined') {
            template.onComplete = function() {
                onComplete.call(transitioner);
            };
        }

        animation = sceneAnimations.addProperty(scene, 'morphTime', start, stop, template);
        transitioner._currentAnimations.push(animation);
    }

    /**
     * DOC_TBA
     * @memberof SceneTransitioner
     */
    SceneTransitioner.prototype.to2D = function() {
        var scene = this._scene;

        if (scene.mode !== SceneMode.SCENE2D) {
            scene.mode = SceneMode.SCENE2D;
            setMorphTime(scene, 0.0);

            this._destroyMorphHandler();

            var camera = scene.getCamera();
            camera.frustum = this._camera2D.frustum.clone();
            camera.transform = this._camera2D.transform.clone();

            var controllers = camera.getControllers();
            controllers.removeAll();
            controllers.add2D(scene.scene2D.projection);

            // TODO: Match incoming columbus-view or 3D position
            camera.position = this._camera2D.position.clone();
            camera.direction = this._camera2D.direction.clone();
            camera.up = this._camera2D.up.clone();
        }
    };

    /**
     * DOC_TBA
     * @memberof SceneTransitioner
     */
    SceneTransitioner.prototype.toColumbusView = function() {
        var scene = this._scene;
        var previousMode = scene.mode;

        if (scene.mode !== SceneMode.COLUMBUS_VIEW) {
            scene.mode = SceneMode.COLUMBUS_VIEW;
            setMorphTime(scene, 0.0);

            this._destroyMorphHandler();

            var camera = scene.getCamera();
            camera.frustum = this._cameraCV.frustum.clone();
            camera.transform = this._cameraCV.transform.clone();

            var controllers = camera.getControllers();
            controllers.removeAll();
            controllers.addColumbusView();

            if (previousMode !== SceneMode.MORPHING || this._morphCancelled) {
                this._morphCancelled = false;

                // TODO: Match incoming 2D or 3D position
                camera.position = this._cameraCV.position.clone();
                camera.direction = this._cameraCV.direction.clone();
                camera.up = this._cameraCV.up.clone();
            }
        }
    };

    /**
     * DOC_TBA
     * @memberof SceneTransitioner
     */
    SceneTransitioner.prototype.to3D = function() {
        var scene = this._scene;
        var previousMode = scene.mode;

        if (scene.mode !== SceneMode.SCENE3D) {
            scene.mode = SceneMode.SCENE3D;
            setMorphTime(scene, 1.0);

            this._destroyMorphHandler();

            var camera = scene.getCamera();
            var controllers = camera.getControllers();
            controllers.removeAll();
            controllers.addCentralBody();

            camera.frustum = this._camera3D.frustum.clone();
            camera.transform = Matrix4.IDENTITY;

            if (previousMode !== SceneMode.MORPHING || this._morphCancelled) {
                this._morphCancelled = false;

                // TODO: Match incoming columbus-view or 2D position
                camera.position = this._camera3D.position.clone();
                camera.direction = this._camera3D.direction.clone();
                camera.up = this._camera3D.up.clone();
            }
        }
    };

    SceneTransitioner.prototype._createMorphHandler = function(endMorphFunction) {
        var that = this;

        var controllers = this._scene.getCamera().getControllers();
        controllers.removeAll();

        if (this.endMorphOnMouseInput) {
            this._morphHandler = new EventHandler(this._scene.getCanvas());

            var cancelMorph = function() {
                that._morphCancelled = true;
                endMorphFunction.call(that);
            };
            this._morphHandler.setMouseAction(cancelMorph, MouseEventType.LEFT_DOWN);
            this._morphHandler.setMouseAction(cancelMorph, MouseEventType.MIDDLE_DOWN);
            this._morphHandler.setMouseAction(cancelMorph, MouseEventType.RIGHT_DOWN);
            this._morphHandler.setMouseAction(cancelMorph, MouseEventType.WHEEL);
        }
    };

    SceneTransitioner.prototype._destroyMorphHandler = function() {
        var animations = this._scene.getAnimations();
        for ( var i = 0; i < this._currentAnimations.length; ++i) {
            animations.remove(this._currentAnimations[i]);
        }
        this._currentAnimations.length = 0;
        this._morphHandler = this._morphHandler && this._morphHandler.destroy();
    };

    SceneTransitioner.prototype._changeCameraTransform = function(camera, transform) {
        var pos = new Cartesian4(camera.position.x, camera.position.y, camera.position.z, 1.0);
        var dir = new Cartesian4(camera.direction.x, camera.direction.y, camera.direction.z, 0.0);
        var up = new Cartesian4(camera.up.x, camera.up.y, camera.up.z, 0.0);

        var frame = transform.inverseTransformation().multiply(camera.transform);
        camera.transform = transform.clone();

        camera.position = Cartesian3.fromCartesian4(frame.multiplyByVector(pos));
        camera.direction = Cartesian3.fromCartesian4(frame.multiplyByVector(dir));
        camera.up = Cartesian3.fromCartesian4(frame.multiplyByVector(up));
        camera.right = camera.direction.cross(camera.up);
    };

    SceneTransitioner.prototype._columbusViewMorph = function(startPosition, endPosition, time) {
        // Just linear for now.
        return startPosition.lerp(endPosition, time);
    };

    SceneTransitioner.prototype._scenePerspectiveToOrthographic = function(duration, onComplete) {
        var that = this;

        var scene = this._scene;
        var camera = scene.getCamera();

        var startPos = camera.position;
        var startFOVy = camera.frustum.fovy;
        var endFOVy = CesiumMath.RADIANS_PER_DEGREE * 0.5;
        var d = startPos.magnitude() * Math.tan(startFOVy * 0.5);

        // TODO: remove this when multi-frustum is implemented.
        camera.frustum.far = d / Math.tan(endFOVy * 0.5) + 10000000.0;

        var update = function(value) {
            camera.frustum.fovy = CesiumMath.lerp(startFOVy, endFOVy, value.time);

            var distance = d / Math.tan(camera.frustum.fovy * 0.5);
            camera.position = camera.position.normalize().multiplyByScalar(distance);
        };

        var animation = scene.getAnimations().add({
            duration : duration,
            easingFunction : Tween.Easing.Quartic.EaseOut,
            startValue : {
                time : 0.0
            },
            stopValue : {
                time : 1.0
            },
            onUpdate : update,
            onComplete : function() {
                camera.frustum = that._camera2D.frustum.clone();
                onComplete.call(that);
            }
        });
        this._currentAnimations.push(animation);
    };

    SceneTransitioner.prototype._sceneCVTo2D = function(duration, onComplete) {
        var that = this;

        var scene = this._scene;
        var camera = scene.getCamera();
        var maxRadii = this._ellipsoid.getMaximumRadius();

        this._changeCameraTransform(camera, this._cameraCV.transform);

        var startPos = camera.position.clone();
        var startDir = camera.direction.clone();
        var startUp = camera.up.clone();

        var tanPhi = Math.tan(this._cameraCV.frustum.fovy * 0.5);
        var tanTheta = this._cameraCV.frustum.aspectRatio * tanPhi;
        var d = (maxRadii * Math.PI) / tanTheta;

        var endPos = this._camera2D.position.normalize().multiplyByScalar(d);
        var endDir = that._camera2D.direction.clone();
        var endUp = that._camera2D.up.clone();

        var updateCV = function(value) {
            camera.position = that._columbusViewMorph(startPos, endPos, value.time);
            camera.direction = that._columbusViewMorph(startDir, endDir, value.time);
            camera.up = that._columbusViewMorph(startUp, endUp, value.time);
            camera.right = camera.direction.cross(camera.up);
        };

        duration = duration * 0.5;
        var animation = scene.getAnimations().add({
            duration : duration,
            easingFunction : Tween.Easing.Quartic.EaseOut,
            startValue : {
                time : 0.0
            },
            stopValue : {
                time : 1.0
            },
            onUpdate : updateCV,
            onComplete : function() {
                that._scenePerspectiveToOrthographic(duration, onComplete);
            }
        });
        this._currentAnimations.push(animation);
    };

    SceneTransitioner.prototype._scene3DTo2D = function(duration, onComplete) {
        duration = duration * 0.5;

        var maxRadii = this._ellipsoid.getMaximumRadius();

        var tanPhi = Math.tan(this._camera3D.frustum.fovy * 0.5);
        var tanTheta = this._camera3D.frustum.aspectRatio * tanPhi;
        var d = (maxRadii * Math.PI) / tanTheta;

        var camera3DTo2D = {};
        camera3DTo2D.position = this._camera2D.position.normalize().multiplyByScalar(d);
        camera3DTo2D.direction = this._camera2D.direction.clone();
        camera3DTo2D.up = this._camera2D.up.clone();

        var complete = function() {
            this._scenePerspectiveToOrthographic(duration, onComplete);
        };
        this._scene3DToCV(duration, camera3DTo2D, complete);
    };

    SceneTransitioner.prototype._sceneOrthographicToPerspective = function(duration, onComplete) {
        var that = this;

        var scene = this._scene;
        var camera = scene.getCamera();
        var maxRadii = this._ellipsoid.getMaximumRadius();

        var tanPhi = Math.tan(this._cameraCV.frustum.fovy * 0.5);
        var tanTheta = this._cameraCV.frustum.aspectRatio * tanPhi;
        var d = (maxRadii * Math.PI) / tanTheta;
        var endPos2D = this._camera2D.position.normalize().multiplyByScalar(d);

        var top = camera.frustum.top;
        var bottom = camera.frustum.bottom;
        var right = camera.frustum.right;
        var left = camera.frustum.left;

        var frustum2D = this._camera2D.frustum;
        var frustumCV = this._cameraCV.frustum;

        var startPos = camera.position.clone();

        var update2D = function(value) {
            camera.position = that._columbusViewMorph(startPos, endPos2D, value.time);
            camera.frustum.top = CesiumMath.lerp(top, frustum2D.top, value.time);
            camera.frustum.bottom = CesiumMath.lerp(bottom, frustum2D.bottom, value.time);
            camera.frustum.right = CesiumMath.lerp(right, frustum2D.right, value.time);
            camera.frustum.left = CesiumMath.lerp(left, frustum2D.left, value.time);
        };

        var startTime = (right - left) / (2.0 * maxRadii * Math.PI);
        var endTime = 1.0;
        if (startTime > endTime) {
            startTime = 0.0;
        }

        var partialDuration = (endTime - startTime) * duration;
        if (partialDuration === 0 && Cartesian2.magnitude(Cartesian2.subtract(startPos, endPos2D, startPos)) !== 0) {
            partialDuration = duration;
            startTime = 0.0;
            endTime = 1.0;
        }

        var animation = scene.getAnimations().add({
            easingFunction : Tween.Easing.Quartic.EaseOut,
            duration : partialDuration,
            startValue : {
                time : startTime
            },
            stopValue : {
                time : endTime
            },
            onUpdate : update2D,
            onComplete : function() {
                camera.frustum = frustumCV.clone();
                onComplete.call(that);
            }
        });
        this._currentAnimations.push(animation);
    };

    SceneTransitioner.prototype._scene2DToCV = function(duration, onComplete) {
        var that = this;

        var scene = this._scene;
        var camera = scene.getCamera();

        duration = duration * 0.5;

        var completeFrustumChange = function() {
            var startPos = camera.position.clone();
            var startDir = camera.direction.clone();
            var startUp = camera.up.clone();

            var endPos = that._cameraCV.position.clone();
            var endDir = that._cameraCV.direction.clone();
            var endUp = that._cameraCV.up.clone();

            var updateCV = function(value) {
                camera.position = that._columbusViewMorph(startPos, endPos, value.time);
                camera.direction = that._columbusViewMorph(startDir, endDir, value.time);
                camera.up = that._columbusViewMorph(startUp, endUp, value.time);
                camera.right = camera.direction.cross(camera.up);
            };

            var animation = scene.getAnimations().add({
                duration : duration,
                easingFunction : Tween.Easing.Quartic.EaseOut,
                startValue : {
                    time : 0.0
                },
                stopValue : {
                    time : 1.0
                },
                onUpdate : updateCV,
                onComplete : function() {
                    onComplete.call(that);
                }
            });

            that._currentAnimations.push(animation);
        };

        this._sceneOrthographicToPerspective(duration, completeFrustumChange);
    };

    SceneTransitioner.prototype._scene3DToCV = function(duration, endCamera, onComplete) {
        var that = this;

        var scene = this._scene;

        var camera = scene.getCamera();
        this._changeCameraTransform(camera, this._cameraCV.transform);

        var startPos = camera.position.clone();
        var startDir = camera.direction.clone();
        var startUp = camera.up.clone();

        var endPos = endCamera.position.clone();
        var endDir = endCamera.direction.clone();
        var endUp = endCamera.up.clone();

        var update = function(value) {
            camera.position = that._columbusViewMorph(startPos, endPos, value.time);
            camera.direction = that._columbusViewMorph(startDir, endDir, value.time);
            camera.up = that._columbusViewMorph(startUp, endUp, value.time);
            camera.right = camera.direction.cross(camera.up);
        };

        var animation = scene.getAnimations().add({
            duration : duration,
            easingFunction : Tween.Easing.Quartic.EaseOut,
            startValue : {
                time : 0.0
            },
            stopValue : {
                time : 1.0
            },
            onUpdate : update,
            onComplete : function() {
                camera.position = endPos;
                camera.direction = endDir;
                camera.up = endUp;
            }
        });
        this._currentAnimations.push(animation);

        addMorphTimeAnimations(this, scene, 1.0, 0.0, duration, onComplete);
    };

    SceneTransitioner.prototype._scene2DTo3D = function(duration, onComplete) {
        duration = duration * 0.5;

        var camera = this._scene.getCamera();

        this._sceneOrthographicToPerspective(duration, function() {
            camera.frustum = this._cameraCV.frustum.clone();
            camera.transform = this._cameraCV.transform.clone();
            this._sceneCVTo3D(duration, onComplete);
        });
    };

    SceneTransitioner.prototype._sceneCVTo3D = function(duration, onComplete) {
        var scene = this._scene;

        var that = this;

        var camera = scene.getCamera();
        this._changeCameraTransform(camera, Matrix4.IDENTITY);

        var startPos = camera.position;
        var startDir = camera.direction;
        var startUp = camera.up;

        var maxRadii = this._ellipsoid.getMaximumRadius();
        var endPos = this._ellipsoid.cartographicToCartesian(new Cartographic(0.0, 0.0, 10.0));
        endPos = endPos.normalize().multiplyByScalar(2.0 * maxRadii);
        var endDir = Cartesian3.ZERO.subtract(endPos).normalize();
        var endRight = endDir.cross(Cartesian3.UNIT_Z).normalize();
        var endUp = endRight.cross(endDir);

        var update = function(value) {
            camera.position = that._columbusViewMorph(startPos, endPos, value.time);
            camera.direction = that._columbusViewMorph(startDir, endDir, value.time);
            camera.up = that._columbusViewMorph(startUp, endUp, value.time);
            camera.right = camera.direction.cross(camera.up);
        };

        var animation = scene.getAnimations().add({
            duration : duration,
            easingFunction : Tween.Easing.Quartic.EaseOut,
            startValue : {
                time : 0.0
            },
            stopValue : {
                time : 1.0
            },
            onUpdate : update
        });
        this._currentAnimations.push(animation);

        addMorphTimeAnimations(this, scene, 0.0, 1.0, duration, onComplete);
    };

    /**
     * DOC_TBA
     * @memberof SceneTransitioner
     */
    SceneTransitioner.prototype.morphTo2D = function() {
        var previousMode = this._scene.mode;

        if (previousMode === SceneMode.SCENE2D || previousMode === SceneMode.MORPHING) {
            return;
        }

        this._scene.mode = SceneMode.MORPHING;
        this._createMorphHandler(this.to2D);

        if (previousMode === SceneMode.COLUMBUS_VIEW) {
            this._sceneCVTo2D(this.morphDuration2D, this.to2D);
        } else {
            this._scene3DTo2D(this.morphDuration2D, this.to2D);
        }
    };

    /**
     * DOC_TBA
     * @memberof SceneTransitioner
     */
    SceneTransitioner.prototype.morphToColumbusView = function() {
        var previousMode = this._scene.mode;

        if (previousMode === SceneMode.COLUMBUS_VIEW || previousMode === SceneMode.MORPHING) {
            return;
        }

        this._scene.mode = SceneMode.MORPHING;
        this._createMorphHandler(this.toColumbusView);

        if (previousMode === SceneMode.SCENE2D) {
            this._scene2DToCV(this.morphDurationColumbusView, this.toColumbusView);
        } else {
            this._scene3DToCV(this.morphDurationColumbusView, this._cameraCV, this.toColumbusView);
        }
    };

    /**
     * DOC_TBA
     * @memberof SceneTransitioner
     */
    SceneTransitioner.prototype.morphTo3D = function() {
        var scene = this._scene;
        var previousMode = scene.mode;

        if (previousMode === SceneMode.SCENE3D || previousMode === SceneMode.MORPHING) {
            return;
        }

        scene.mode = SceneMode.MORPHING;
        this._createMorphHandler(this.to3D);

        if (previousMode === SceneMode.SCENE2D) {
            this._scene2DTo3D(this.morphDuration3D, this.to3D);
        } else {
            this._sceneCVTo3D(this.morphDuration3D, this.to3D);
        }
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof SceneTransitioner
     *
     * @return {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     *
     * @see SceneTransitioner#destroy
     */
    SceneTransitioner.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof SceneTransitioner
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see SceneTransitioner#isDestroyed
     *
     * @example
     * transitioner = transitioner && transitioner.destroy();
     */
    SceneTransitioner.prototype.destroy = function() {
        this._destroyMorphHandler();
        return destroyObject(this);
    };

    return SceneTransitioner;
});
/**
 * @fileOverview
 *
 * Grauw Uri utilities
 *
 * See: http://hg.grauw.nl/grauw-lib/file/tip/src/uri.js
 *
 * @author Laurens Holst (http://www.grauw.nl/)
 *
 *   Copyright 2012 Laurens Holst
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 *   Modifications made by Cesium to fit into our build system as well as fix warnings.
 */
/*global define*/
define('ThirdParty/Uri',[],function() {
    
    /*global unescape*/

    // Regular expression from RFC 3986 appendix B
    var parseRegex = new RegExp('^(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\\?([^#]*))?(?:#(.*))?$');

    var caseRegex = /%[0-9a-z]{2}/gi;
    var percentRegex = /[a-zA-Z0-9\-\._~]/;
    var authorityRegex = /(.*@)?([^@:]*)(:.*)?/;

    /**
     * Constructs a Uri object.
     * @constructor
     * @class Implementation of Uri parsing and base Uri resolving algorithm in RFC 3986.
     * @param {string|Uri} uri A string or Uri object to create the object from.
     */
    function Uri(uri) {
        if (uri instanceof Uri) { // copy constructor
            this.scheme = uri.scheme;
            this.authority = uri.authority;
            this.path = uri.path;
            this.query = uri.query;
            this.fragment = uri.fragment;
        } else if (uri) { // uri is Uri string or cast to string
            var c = parseRegex.exec(uri);
            this.scheme = c[1];
            this.authority = c[2];
            this.path = c[3];
            this.query = c[4];
            this.fragment = c[5];
        }
    }

    // Initial values on the prototype
    Uri.prototype.scheme = null;
    Uri.prototype.authority = null;
    Uri.prototype.path = '';
    Uri.prototype.query = null;
    Uri.prototype.fragment = null;

    /**
     * Returns the scheme part of the Uri.
     * In "http://example.com:80/a/b?x#y" this is "http".
     */
    Uri.prototype.getScheme = function() {
        return this.scheme;
    };

    /**
     * Returns the authority part of the Uri.
     * In "http://example.com:80/a/b?x#y" this is "example.com:80".
     */
    Uri.prototype.getAuthority = function() {
        return this.authority;
    };

    /**
     * Returns the path part of the Uri.
     * In "http://example.com:80/a/b?x#y" this is "/a/b".
     * In "mailto:mike@example.com" this is "mike@example.com".
     */
    Uri.prototype.getPath = function() {
        return this.path;
    };

    /**
     * Returns the query part of the Uri.
     * In "http://example.com:80/a/b?x#y" this is "x".
     */
    Uri.prototype.getQuery = function() {
        return this.query;
    };

    /**
     * Returns the fragment part of the Uri.
     * In "http://example.com:80/a/b?x#y" this is "y".
     */
    Uri.prototype.getFragment = function() {
        return this.fragment;
    };

    /**
     * Tests whether the Uri is an absolute Uri.
     * See RFC 3986 section 4.3.
     */
    Uri.prototype.isAbsolute = function() {
        return !!this.scheme && !this.fragment;
    };

    /**
     * Tests whether the Uri is a same-document reference.
     * See RFC 3986 section 4.4.
     *
     * To perform more thorough comparison, you can normalise the Uri objects.
     */
    Uri.prototype.isSameDocumentAs = function(uri) {
        return uri.scheme === this.scheme && uri.authority === this.authority && uri.path === this.path && uri.query === this.query;
    };

    /**
     * Simple String Comparison of two Uris.
     * See RFC 3986 section 6.2.1.
     *
     * To perform more thorough comparison, you can normalise the Uri objects.
     */
    Uri.prototype.equals = function(uri) {
        return this.isSameDocumentAs(uri) && uri.fragment === this.fragment;
    };

    /**
     * Normalizes the Uri using syntax-based normalization.
     * This includes case normalization, percent-encoding normalization and path segment normalization.
     * XXX: Percent-encoding normalization does not escape characters that need to be escaped.
     *      (Although that would not be a valid Uri in the first place.)
     * See RFC 3986 section 6.2.2.
     */
    Uri.prototype.normalize = function() {
        this.removeDotSegments();
        if (this.scheme) {
            this.scheme = this.scheme.toLowerCase();
        }
        if (this.authority) {
            this.authority = this.authority.replace(authorityRegex, replaceAuthority).replace(caseRegex, replaceCase);
        }
        if (this.path) {
            this.path = this.path.replace(caseRegex, replaceCase);
        }
        if (this.query) {
            this.query = this.query.replace(caseRegex, replaceCase);
        }
        if (this.fragment) {
            this.fragment = this.fragment.replace(caseRegex, replaceCase);
        }
    };

    function replaceCase(str) {
        var dec = unescape(str);
        return percentRegex.test(dec) ? dec : str.toUpperCase();
    }

    function replaceAuthority(str, p1, p2, p3) {
        return (p1 || '') + p2.toLowerCase() + (p3 || '');
    }

    /**
     * Resolve a relative Uri (this) against a base Uri.
     * The base Uri must be an absolute Uri.
     * See RFC 3986 section 5.2
     */
    Uri.prototype.resolve = function(baseUri) {
        var uri = new Uri();
        if (this.scheme) {
            uri.scheme = this.scheme;
            uri.authority = this.authority;
            uri.path = this.path;
            uri.query = this.query;
        } else {
            uri.scheme = baseUri.scheme;
            if (this.authority) {
                uri.authority = this.authority;
                uri.path = this.path;
                uri.query = this.query;
            } else {
                uri.authority = baseUri.authority;
                if (this.path === '') {
                    uri.path = baseUri.path;
                    uri.query = this.query || baseUri.query;
                } else {
                    if (this.path.charAt(0) === '/') {
                        uri.path = this.path;
                        uri.removeDotSegments();
                    } else {
                        if (baseUri.authority && baseUri.path === '') {
                            uri.path = '/' + this.path;
                        } else {
                            uri.path = baseUri.path.substring(0, baseUri.path.lastIndexOf('/') + 1) + this.path;
                        }
                        uri.removeDotSegments();
                    }
                    uri.query = this.query;
                }
            }
        }
        uri.fragment = this.fragment;
        return uri;
    };

    /**
     * Remove dot segments from path.
     * See RFC 3986 section 5.2.4
     * @private
     */
    Uri.prototype.removeDotSegments = function() {
        var input = this.path.split('/'), output = [], segment, absPath = input[0] === '';
        if (absPath) {
            input.shift();
        }
        if (input[0] === '') {
            input.shift();
        }
        while (input.length) {
            segment = input.shift();
            if (segment === '..') {
                output.pop();
            } else if (segment !== '.') {
                output.push(segment);
            }
        }
        if (segment === '.' || segment === '..') {
            output.push('');
        }
        if (absPath) {
            output.unshift('');
        }
        this.path = output.join('/');
    };

    var cache = {};

    /**
     * Resolves a relative Uri against an absolute base Uri.
     * Convenience method.
     * @param {String} uri the relative Uri to resolve
     * @param {String} baseUri the base Uri (must be absolute) to resolve against
     */
    Uri.resolve = function(sUri, sBaseUri) {
        var uri = cache[sUri];
        if (typeof uri === 'undefined') {
            cache[sUri] = new Uri(sUri);
        }
        var baseUri = cache[sBaseUri] || (cache[sBaseUri] = new Uri(sBaseUri));
        return uri.resolve(baseUri).toString();
    };

    /**
     * Serializes the Uri to a string.
     */
    Uri.prototype.toString = function() {
        var result = '';
        if (this.scheme) {
            result += this.scheme + ':';
        }
        if (this.authority) {
            result += '//' + this.authority;
        }
        result += this.path;
        if (this.query) {
            result += '?' + this.query;
        }
        if (this.fragment) {
            result += '#' + this.fragment;
        }
        return result;
    };

    return Uri;
});

/*global define*/
define('DynamicScene/CzmlImage',['../ThirdParty/Uri'], function(Uri) {
    

    /**
     * Provides methods for working with a image defined in CZML.
     *
     * @exports CzmlImage
     *
     * @see DynamicProperty
     * @see CzmlCartesian2
     * @see CzmlCartesian3
     * @see CzmlCartographic
     * @see CzmlColor
     * @see CzmlHorizontalOrigin
     * @see CzmlLabelStyle
     * @see CzmlNumber
     * @see CzmlImage
     * @see CzmlUnitCartesian3
     * @see CzmlUnitQuaternion
     * @see CzmlUnitSpherical
     * @see CzmlVerticalOrigin
     */
    var CzmlImage = {
        /**
         * Returns the packed image representation contained within the provided CZML interval
         * or undefined if the interval does not contain image data.
         *
         * @param {Object} czmlInterval The CZML interval to unwrap.
         */
        unwrapInterval : function(czmlInterval, sourceUri) {
            var result = typeof czmlInterval.image === 'undefined' ? czmlInterval : czmlInterval.image;
            if (typeof sourceUri !== 'undefined') {
                var baseUri = new Uri(document.location.href);
                sourceUri = new Uri(sourceUri);
                result = new Uri(result).resolve(sourceUri.resolve(baseUri)).toString();
            }
            return result;
        },

        /**
         * Since CZML images can not be sampled, this method always returns false.
         */
        isSampled : function() {
            return false;
        },

        /**
         * Returns the image value contained within the unwrappedInterval.  For images
         * this is the unwrappedInterval itself.
         *
         * @param {Object} unwrappedInterval The result of CzmlImage.unwrapInterval.
         * @returns The image value.
         */
        getValue : function(unwrappedInterval) {
            return unwrappedInterval;
        }
    };

    return CzmlImage;
});
/*global define*/
define('DynamicScene/DynamicBillboard',[
        '../Core/TimeInterval',
        './CzmlBoolean',
        './CzmlCartesian2',
        './CzmlCartesian3',
        './CzmlNumber',
        './CzmlImage',
        './CzmlHorizontalOrigin',
        './CzmlVerticalOrigin',
        './CzmlColor',
        './DynamicProperty'
    ], function(
        TimeInterval,
        CzmlBoolean,
        CzmlCartesian2,
        CzmlCartesian3,
        CzmlNumber,
        CzmlImage,
        CzmlHorizontalOrigin,
        CzmlVerticalOrigin,
        CzmlColor,
        DynamicProperty) {
    

    /**
     * Represents a time-dynamic billboard, typically used in conjunction with DynamicBillboardVisualizer and
     * DynamicObjectCollection to visualize CZML.
     *
     * @alias DynamicBillboard
     * @constructor
     *
     * @see DynamicObject
     * @see DynamicProperty
     * @see DynamicObjectCollection
     * @see DynamicBillboardVisualizer
     * @see VisualizerCollection
     * @see Billboard
     * @see BillboardCollection
     * @see CzmlDefaults
     */
    var DynamicBillboard = function() {
        /**
         * A DynamicProperty of type CzmlImage which determines the billboard's texture.
         */
        this.image = undefined;
        /**
         * A DynamicProperty of type CzmlNumber which determines the billboard's scale.
         */
        this.scale = undefined;
        /**
         * A DynamicProperty of type CzmlHorizontalOrigin which determines the billboard's horizontal origin.
         */
        this.horizontalOrigin = undefined;
        /**
         * A DynamicProperty of type CzmlVerticalHorigin which determines the billboard's vertical origin.
         */
        this.verticalOrigin = undefined;
        /**
         * A DynamicProperty of type CzmlColor which determines the billboard's color.
         */
        this.color = undefined;
        /**
         * A DynamicProperty of type CzmlCartesian3 which determines the billboard's eye offset.
         */
        this.eyeOffset = undefined;
        /**
         * A DynamicProperty of type CzmlCartesian2 which determines the billboard's pixel offset.
         */
        this.pixelOffset = undefined;
        /**
         * A DynamicProperty of type CzmlBoolean which determines the billboard's visibility.
         */
        this.show = undefined;
    };

    /**
     * Processes a single CZML packet and merges its data into the provided DynamicObject's billboard.
     * If the DynamicObject does not have a billboard, one is created.  This method is not
     * normally called directly, but is part of the array of CZML processing functions that is
     * passed into the DynamicObjectCollection constructor.
     * @memberof DynamicBillboard
     *
     * @param {DynamicObject} dynamicObject The DynamicObject which will contain the billboard data.
     * @param {Object} packet The CZML packet to process.
     * @param {DynamicObjectCollection} [dynamicObjectCollection] The collection into which objects are being loaded.
     * @param {String} [sourceUri] The originating url of the CZML being processed.
     * @returns {Boolean} true if any new properties were created while processing the packet, false otherwise.
     *
     * @see DynamicObject
     * @see DynamicProperty
     * @see DynamicObjectCollection
     * @see CzmlDefaults#updaters
     */
    DynamicBillboard.processCzmlPacket = function(dynamicObject, packet, dynamicObjectCollection, sourceUri) {
        var billboardData = packet.billboard;
        if (typeof billboardData === 'undefined') {
            return false;
        }

        var billboardUpdated = false;
        var billboard = dynamicObject.billboard;
        billboardUpdated = typeof billboard === 'undefined';
        if (billboardUpdated) {
            dynamicObject.billboard = billboard = new DynamicBillboard();
        }

        var interval = billboardData.interval;
        if (typeof interval !== 'undefined') {
            interval = TimeInterval.fromIso8601(interval);
        }

        if (typeof billboardData.color !== 'undefined') {
            var color = billboard.color;
            if (typeof color === 'undefined') {
                billboard.color = color = new DynamicProperty(CzmlColor);
                billboardUpdated = true;
            }
            color.processCzmlIntervals(billboardData.color, interval);
        }

        if (typeof billboardData.eyeOffset !== 'undefined') {
            var eyeOffset = billboard.eyeOffset;
            if (typeof eyeOffset === 'undefined') {
                billboard.eyeOffset = eyeOffset = new DynamicProperty(CzmlCartesian3);
                billboardUpdated = true;
            }
            eyeOffset.processCzmlIntervals(billboardData.eyeOffset, interval);
        }

        if (typeof billboardData.horizontalOrigin !== 'undefined') {
            var horizontalOrigin = billboard.horizontalOrigin;
            if (typeof horizontalOrigin === 'undefined') {
                billboard.horizontalOrigin = horizontalOrigin = new DynamicProperty(CzmlHorizontalOrigin);
                billboardUpdated = true;
            }
            horizontalOrigin.processCzmlIntervals(billboardData.horizontalOrigin, interval);
        }

        if (typeof billboardData.image !== 'undefined') {
            var image = billboard.image;
            if (typeof image === 'undefined') {
                billboard.image = image = new DynamicProperty(CzmlImage);
                billboardUpdated = true;
            }
            image.processCzmlIntervals(billboardData.image, interval, sourceUri);
        }

        if (typeof billboardData.pixelOffset !== 'undefined') {
            var pixelOffset = billboard.pixelOffset;
            if (typeof pixelOffset === 'undefined') {
                billboard.pixelOffset = pixelOffset = new DynamicProperty(CzmlCartesian2);
                billboardUpdated = true;
            }
            pixelOffset.processCzmlIntervals(billboardData.pixelOffset, interval);
        }

        if (typeof billboardData.scale !== 'undefined') {
            var scale = billboard.scale;
            if (typeof scale === 'undefined') {
                billboard.scale = scale = new DynamicProperty(CzmlNumber);
                billboardUpdated = true;
            }
            scale.processCzmlIntervals(billboardData.scale, interval);
        }

        if (typeof billboardData.show !== 'undefined') {
            var show = billboard.show;
            if (typeof show === 'undefined') {
                billboard.show = show = new DynamicProperty(CzmlBoolean);
                billboardUpdated = true;
            }
            show.processCzmlIntervals(billboardData.show, interval);
        }

        if (typeof billboardData.verticalOrigin !== 'undefined') {
            var verticalOrigin = billboard.verticalOrigin;
            if (typeof verticalOrigin === 'undefined') {
                billboard.verticalOrigin = verticalOrigin = new DynamicProperty(CzmlVerticalOrigin);
                billboardUpdated = true;
            }
            verticalOrigin.processCzmlIntervals(billboardData.verticalOrigin, interval);
        }

        return billboardUpdated;
    };

    /**
     * Given two DynamicObjects, takes the billboard properties from the second
     * and assigns them to the first, assuming such a property did not already exist.
     * This method is not normally called directly, but is part of the array of CZML processing
     * functions that is passed into the CompositeDynamicObjectCollection constructor.
     * @memberof DynamicBillboard
     *
     * @param {DynamicObject} targetObject The DynamicObject which will have properties merged onto it.
     * @param {DynamicObject} objectToMerge The DynamicObject containing properties to be merged.
     *
     * @see CzmlDefaults
     */
    DynamicBillboard.mergeProperties = function(targetObject, objectToMerge) {
        var billboardToMerge = objectToMerge.billboard;
        if (typeof billboardToMerge !== 'undefined') {

            var targetBillboard = targetObject.billboard;
            if (typeof targetBillboard === 'undefined') {
                targetObject.billboard = targetBillboard = new DynamicBillboard();
            }

            targetBillboard.color = targetBillboard.color || billboardToMerge.color;
            targetBillboard.eyeOffset = targetBillboard.eyeOffset || billboardToMerge.eyeOffset;
            targetBillboard.horizontalOrigin = targetBillboard.horizontalOrigin || billboardToMerge.horizontalOrigin;
            targetBillboard.image = targetBillboard.image || billboardToMerge.image;
            targetBillboard.pixelOffset = targetBillboard.pixelOffset || billboardToMerge.pixelOffset;
            targetBillboard.scale = targetBillboard.scale || billboardToMerge.scale;
            targetBillboard.show = targetBillboard.show || billboardToMerge.show;
            targetBillboard.verticalOrigin = targetBillboard.verticalOrigin || billboardToMerge.verticalOrigin;
        }
    };

    /**
     * Given a DynamicObject, undefines the billboard associated with it.
     * This method is not normally called directly, but is part of the array of CZML processing
     * functions that is passed into the CompositeDynamicObjectCollection constructor.
     * @memberof DynamicBillboard
     *
     * @param {DynamicObject} dynamicObject The DynamicObject to remove the billboard from.
     *
     * @see CzmlDefaults
     */
    DynamicBillboard.undefineProperties = function(dynamicObject) {
        dynamicObject.billboard = undefined;
    };

    return DynamicBillboard;
});
/*global define*/
define('DynamicScene/DynamicImageMaterial',[
        './DynamicProperty',
        './CzmlImage',
        './CzmlNumber',
        '../Scene/DiffuseMapMaterial',
        '../Renderer/PixelFormat'
    ], function(
         DynamicProperty,
         CzmlImage,
         CzmlNumber,
         DiffuseMapMaterial,
         PixelFormat) {
    

    //CZML_TODO Cesium doesn't currently provide any sort of 'default' texture or image
    //when you default construct something with a texture.  This means that as soon as we create
    //our image material, we have to assign a texture to it or else we will crash
    //on the next draw.  Once we change Cesium to have built in texture defaults,
    //this code can be removed.  If we decide Cesium shouldn't have built in defaults,
    //this code should be changes so at least all CZML visualization has defaults.
    function createDefaultTexture() {
        var canvas = document.createElement('canvas');
        canvas.height = '64';
        canvas.width = '64';

        var context = canvas.getContext('2d');
        context.fillStyle = '#FFFFFF';
        context.font = '64px sans-serif';
        context.textBaseline = 'top';
        context.fillText('?', 16, 0);
        context.font = '64px sans-serif';
        context.strokeStyle = '#000000';
        context.strokeText('?', 16, 0);
        return canvas;
    }

    var defaultTexture = createDefaultTexture();

    /**
     * A utility class for processing CZML image materials.
     * @alias DynamicImageMaterial
     * @constructor
     */
    var DynamicImageMaterial = function() {
        this.image = undefined;
        this.verticalRepeat = undefined;
        this.horizontalRepeat = undefined;
    };

    /**
     * Returns true if the provided CZML interval contains image material data.
     * @param czmlInterval The CZML interval to check.
     * @returns {Boolean} true if the interval contains CZML image material data, false otherwise.
     */
    DynamicImageMaterial.isMaterial = function(czmlInterval) {
        return typeof czmlInterval.image !== 'undefined';
    };

    /**
     * Provided a CZML interval containing image material data, processes the
     * interval into a new or existing instance of this class.
     *
     * @param {Object} czmlInterval The interval to process.
     * @param {String} [sourceUri] The originating url of the CZML being processed.
     * @returns The modified existingMaterial parameter or a new DynamicImageMaterial instance if existingMaterial was undefined or not a DynamicImageMaterial.
     */
    DynamicImageMaterial.prototype.processCzmlIntervals = function(czmlInterval, sourceUri) {
        var materialData = czmlInterval.image;
        if (typeof materialData === 'undefined') {
            return;
        }

        if (typeof materialData.image !== 'undefined') {
            var image = this.image;
            if (typeof image === 'undefined') {
                this.image = image = new DynamicProperty(CzmlImage);
            }
            image.processCzmlIntervals(materialData.image, undefined, sourceUri);
        }

        if (typeof materialData.verticalRepeat !== 'undefined') {
            var verticalRepeat = this.verticalRepeat;
            if (typeof verticalRepeat === 'undefined') {
                this.verticalRepeat = verticalRepeat = new DynamicProperty(CzmlNumber);
            }
            verticalRepeat.processCzmlIntervals(materialData.verticalRepeat);
        }

        if (typeof materialData.horizontalRepeat !== 'undefined') {
            var horizontalRepeat = this.horizontalRepeat;
            if (typeof horizontalRepeat === 'undefined') {
                this.horizontalRepeat = horizontalRepeat = new DynamicProperty(CzmlNumber);
            }
            horizontalRepeat.processCzmlIntervals(materialData.horizontalRepeat);
        }
    };

    /**
     * Get's a DiffuseMapMaterial that represents this dynamic material at the provided time.
     *
     * @param {JulianDate} time The desired time.
     * @param {Context} context The context in which this material exists.
     * @param {DiffuseMapMaterial} [existingMaterial] An existing material to be modified.  If the material is undefined or not a DiffuseMapMaterial, a new instance is created.
     * @returns The modified existingMaterial parameter or a new DiffuseMapMaterial instance if existingMaterial was undefined or not a DiffuseMapMaterial.
     */
    DynamicImageMaterial.prototype.getValue = function(time, context, existingMaterial) {
        if (typeof existingMaterial === 'undefined' || !(existingMaterial instanceof DiffuseMapMaterial)) {
            existingMaterial = new DiffuseMapMaterial();
        }

        var tRepeat;
        var property = this.verticalRepeat;
        if (typeof property !== 'undefined') {
            tRepeat = property.getValue(time);
            if (typeof tRepeat !== 'undefined') {
                existingMaterial.tRepeat = tRepeat;
            }
        }

        var sRepeat;
        property = this.horizontalRepeat;
        if (typeof property !== 'undefined') {
            sRepeat = property.getValue(time);
            if (typeof value !== 'undefined') {
                existingMaterial.sRepeat = sRepeat;
            }
        }

        property = this.image;
        if (typeof property !== 'undefined') {
            var url = this.image.getValue(time);
            if (typeof url !== 'undefined' && existingMaterial.currentUrl !== url) {
                existingMaterial.currentUrl = url;
                var image = new Image();
                image.onload = function() {
                    if (existingMaterial.currentUrl === url) {
                        existingMaterial.texture = context.createTexture2D({
                            source : image
                        });
                    }
                };
                image.src = url;
            }
        }
        if (!existingMaterial.texture) {
            existingMaterial.texture = context.createTexture2D({
                source : defaultTexture
            });
        }
        return existingMaterial;
    };

    return DynamicImageMaterial;
});
/*global define*/
define('DynamicScene/DynamicMaterialProperty',[
        '../Core/JulianDate',
        '../Core/TimeInterval',
        '../Core/TimeIntervalCollection',
        '../Core/Iso8601',
        './DynamicColorMaterial',
        './DynamicImageMaterial'
    ], function(
        JulianDate,
        TimeInterval,
        TimeIntervalCollection,
        Iso8601,
        DynamicColorMaterial,
        DynamicImageMaterial) {
    

    var potentialMaterials = [DynamicColorMaterial, DynamicImageMaterial];

    /**
     * A dynamic property which stores data for multiple types of materials
     * associated with the same property over time. Rather than creating instances
     * of this object directly, it's typically created and managed via loading CZML
     * data into a DynamicObjectCollection.
     *
     * @alias DynamicMaterialProperty
     * @internalconstructor
     *
     * @see DynamicObject
     * @see DynamicProperty
     * @see ReferenceProperty
     * @see DynamicPositionProperty
     * @see DynamicDirectionsProperty
     * @see DynamicVertexPositionsProperty
     */
    var DynamicMaterialProperty = function() {
        this._intervals = new TimeIntervalCollection();
    };


    /**
     * Processes the provided CZML interval or intervals into this property.
     * @memberof DynamicMaterialProperty
     *
     * @param {Object} czmlIntervals The CZML data to process.
     * @param {TimeInterval} [constrainedInterval] Constrains the processing so that any times outside of this interval are ignored.
     * @param {String} [sourceUri] The originating url of the CZML being processed.
     */
    DynamicMaterialProperty.prototype.processCzmlIntervals = function(czmlIntervals, constrainedInterval, sourceUri) {
        if (Array.isArray(czmlIntervals)) {
            for ( var i = 0, len = czmlIntervals.length; i < len; i++) {
                this._addCzmlInterval(czmlIntervals[i], constrainedInterval, sourceUri);
            }
        } else {
            this._addCzmlInterval(czmlIntervals, constrainedInterval, sourceUri);
        }
    };

    /**
     * Returns the value of the property at the specified time.
     * @memberof DynamicMaterialProperty
     *
     * @param {JulianDate} time The time for which to retrieve the value.
     * @param {Context} [context] The context in which the material exists.
     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
     * @returns The modified result parameter or a new instance if the result parameter was not supplied.
     */
    DynamicMaterialProperty.prototype.getValue = function(time, context, existingMaterial) {
        var value = this._intervals.findIntervalContainingDate(time);
        var material = typeof value !== 'undefined' ? value.data : undefined;
        if (typeof material !== 'undefined') {
            return material.getValue(time, context, existingMaterial);
        }
        return existingMaterial;
    };

    DynamicMaterialProperty.prototype._addCzmlInterval = function(czmlInterval, constrainedInterval, sourceUri) {
        var iso8601Interval = czmlInterval.interval;
        if (typeof iso8601Interval === 'undefined') {
            iso8601Interval = Iso8601.MAXIMUM_INTERVAL.clone();
        } else {
            iso8601Interval = TimeInterval.fromIso8601(iso8601Interval);
        }

        if (typeof constrainedInterval !== 'undefined') {
            iso8601Interval = iso8601Interval.intersect(constrainedInterval);
        }

        //See if we already have data at that interval.
        var thisIntervals = this._intervals;
        var existingInterval = thisIntervals.findInterval(iso8601Interval.start, iso8601Interval.stop);
        var foundMaterial = false;
        var existingMaterial;

        if (typeof existingInterval !== 'undefined') {
            //We have an interval, but we need to make sure the
            //new data is the same type of material as the old data.
            existingMaterial = existingInterval.data;
            foundMaterial = existingMaterial.isMaterial(czmlInterval);
        } else {
            //If not, create it.
            existingInterval = iso8601Interval;
            thisIntervals.addInterval(existingInterval);
        }

        //If the new data was a different type, look for a handler for this type.
        if (foundMaterial === false) {
            for ( var i = 0, len = potentialMaterials.length; i < len; i++) {
                var Material = potentialMaterials[i];
                foundMaterial = Material.isMaterial(czmlInterval);
                if (foundMaterial) {
                    existingInterval.data = existingMaterial = new Material();
                    break;
                }
            }
        }

        //We could handle the data, prcess it.
        if (foundMaterial) {
            existingMaterial.processCzmlIntervals(czmlInterval, sourceUri);
        }
    };

    return DynamicMaterialProperty;
});
/*global define*/
define('DynamicScene/DynamicCone',[
        '../Core/TimeInterval',
        './CzmlBoolean',
        './CzmlNumber',
        './CzmlColor',
        './DynamicProperty',
        './DynamicMaterialProperty'
       ], function(
         TimeInterval,
         CzmlBoolean,
         CzmlNumber,
         CzmlColor,
         DynamicProperty,
         DynamicMaterialProperty) {
    

    /**
     * Represents a time-dynamic cone, typically used in conjunction with DynamicConeVisualizer and
     * DynamicObjectCollection to visualize CZML.
     *
     * @alias DynamicCone
     * @constructor
     *
     * @see DynamicObject
     * @see DynamicProperty
     * @see DynamicObjectCollection
     * @see DynamicConeVisualizer
     * @see VisualizerCollection
     * @see ComplexConicSensor
     * @see CzmlDefaults
     */
    var DynamicCone = function() {
        /**
         * A DynamicProperty of type CzmlNumber which determines the cone's minimum clock-angle.
         */
        this.minimumClockAngle = undefined;
        /**
         * A DynamicProperty of type CzmlNumber which determines the cone's maximum clock-angle.
         */
        this.maximumClockAngle = undefined;
        /**
         * A DynamicProperty of type CzmlNumber which determines the cone's inner half-angle.
         */
        this.innerHalfAngle = undefined;
        /**
         * A DynamicProperty of type CzmlNumber which determines the cone's outer half-angle.
         */
        this.outerHalfAngle = undefined;
        /**
         * A DynamicMaterialProperty which determines the cone's cap material.
         */
        this.capMaterial = undefined;
        /**
         * A DynamicMaterialProperty which determines the cone's inner material.
         */
        this.innerMaterial = undefined;
        /**
         * A DynamicMaterialProperty which determines the cone's outer material.
         */
        this.outerMaterial = undefined;
        /**
         * A DynamicMaterialProperty which determines the cone's silhouette material.
         */
        this.silhouetteMaterial = undefined;
        /**
         * A DynamicProperty of type CzmlColor which determines the color of the line formed by the intersection of the cone and other central bodies.
         */
        this.intersectionColor = undefined;
        /**
         * A DynamicProperty of type CzmlBoolean which determines the cone's intersection visibility
         */
        this.showIntersection = undefined;
        /**
         * A DynamicProperty of type CzmlNumber which determines the cone's radius.
         */
        this.radius = undefined;
        /**
         * A DynamicProperty of type CzmlBoolean which determines the cone's visibility
         */
        this.show = undefined;
    };

    /**
     * Processes a single CZML packet and merges its data into the provided DynamicObject's cone.
     * If the DynamicObject does not have a cone, one is created.  This method is not
     * normally called directly, but is part of the array of CZML processing functions that is
     * passed into the DynamicObjectCollection constructor.
     *
     * @param {DynamicObject} dynamicObject The DynamicObject which will contain the cone data.
     * @param {Object} packet The CZML packet to process.
     * @returns {Boolean} true if any new properties were created while processing the packet, false otherwise.
     *
     * @see DynamicObject
     * @see DynamicProperty
     * @see DynamicObjectCollection
     * @see CzmlDefaults#updaters
     */
    DynamicCone.processCzmlPacket = function(dynamicObject, packet) {
        var coneData = packet.cone;
        if (typeof coneData === 'undefined') {
            return false;
        }

        var coneUpdated = false;
        var cone = dynamicObject.cone;
        coneUpdated = typeof cone === 'undefined';
        if (coneUpdated) {
            dynamicObject.cone = cone = new DynamicCone();
        }

        var interval = coneData.interval;
        if (typeof interval !== 'undefined') {
            interval = TimeInterval.fromIso8601(interval);
        }

        if (typeof coneData.show !== 'undefined') {
            var show = cone.show;
            if (typeof show === 'undefined') {
                cone.show = show = new DynamicProperty(CzmlBoolean);
                coneUpdated = true;
            }
            show.processCzmlIntervals(coneData.show, interval);
        }

        if (typeof coneData.innerHalfAngle !== 'undefined') {
            var innerHalfAngle = cone.innerHalfAngle;
            if (typeof innerHalfAngle === 'undefined') {
                cone.innerHalfAngle = innerHalfAngle = new DynamicProperty(CzmlNumber);
                coneUpdated = true;
            }
            innerHalfAngle.processCzmlIntervals(coneData.innerHalfAngle, interval);
        }

        if (typeof coneData.outerHalfAngle !== 'undefined') {
            var outerHalfAngle = cone.outerHalfAngle;
            if (typeof outerHalfAngle === 'undefined') {
                cone.outerHalfAngle = outerHalfAngle = new DynamicProperty(CzmlNumber);
                coneUpdated = true;
            }
            outerHalfAngle.processCzmlIntervals(coneData.outerHalfAngle, interval);
        }

        if (typeof coneData.minimumClockAngle !== 'undefined') {
            var minimumClockAngle = cone.minimumClockAngle;
            if (typeof minimumClockAngle === 'undefined') {
                cone.minimumClockAngle = minimumClockAngle = new DynamicProperty(CzmlNumber);
                coneUpdated = true;
            }
            minimumClockAngle.processCzmlIntervals(coneData.minimumClockAngle, interval);
        }

        if (typeof coneData.maximumClockAngle !== 'undefined') {
            var maximumClockAngle = cone.maximumClockAngle;
            if (typeof maximumClockAngle === 'undefined') {
                cone.maximumClockAngle = maximumClockAngle = new DynamicProperty(CzmlNumber);
                coneUpdated = true;
            }
            maximumClockAngle.processCzmlIntervals(coneData.maximumClockAngle, interval);
        }

        if (typeof coneData.radius !== 'undefined') {
            var radius = cone.radius;
            if (typeof radius === 'undefined') {
                cone.radius = radius = new DynamicProperty(CzmlNumber);
                coneUpdated = true;
            }
            radius.processCzmlIntervals(coneData.radius, interval);
        }

        if (typeof coneData.showIntersection !== 'undefined') {
            var showIntersection = cone.showIntersection;
            if (typeof showIntersection === 'undefined') {
                cone.showIntersection = showIntersection = new DynamicProperty(CzmlBoolean);
                coneUpdated = true;
            }
            showIntersection.processCzmlIntervals(coneData.showIntersection, interval);
        }

        if (typeof coneData.intersectionColor !== 'undefined') {
            var intersectionColor = cone.intersectionColor;
            if (typeof intersectionColor === 'undefined') {
                cone.intersectionColor = intersectionColor = new DynamicProperty(CzmlColor);
                coneUpdated = true;
            }
            intersectionColor.processCzmlIntervals(coneData.intersectionColor, interval);
        }

        if (typeof coneData.capMaterial !== 'undefined') {
            var capMaterial = cone.capMaterial;
            if (typeof capMaterial === 'undefined') {
                cone.capMaterial = capMaterial = new DynamicMaterialProperty();
                coneUpdated = true;
            }
            capMaterial.processCzmlIntervals(coneData.capMaterial, interval);
        }

        if (typeof coneData.innerMaterial !== 'undefined') {
            var innerMaterial = cone.innerMaterial;
            if (typeof innerMaterial === 'undefined') {
                cone.innerMaterial = innerMaterial = new DynamicMaterialProperty();
                coneUpdated = true;
            }
            innerMaterial.processCzmlIntervals(coneData.innerMaterial, interval);
        }

        if (typeof coneData.outerMaterial !== 'undefined') {
            var outerMaterial = cone.outerMaterial;
            if (typeof outerMaterial === 'undefined') {
                cone.outerMaterial = outerMaterial = new DynamicMaterialProperty();
                coneUpdated = true;
            }
            outerMaterial.processCzmlIntervals(coneData.outerMaterial, interval);
        }

        if (typeof coneData.silhouetteMaterial !== 'undefined') {
            var silhouetteMaterial = cone.silhouetteMaterial;
            if (typeof silhouetteMaterial === 'undefined') {
                cone.silhouetteMaterial = silhouetteMaterial = new DynamicMaterialProperty();
                coneUpdated = true;
            }
            silhouetteMaterial.processCzmlIntervals(coneData.silhouetteMaterial, interval);
        }

        return coneUpdated;
    };

    /**
     * Given two DynamicObjects, takes the cone properties from the second
     * and assigns them to the first, assuming such a property did not already exist.
     * This method is not normally called directly, but is part of the array of CZML processing
     * functions that is passed into the CompositeDynamicObjectCollection constructor.
     *
     * @param {DynamicObject} targetObject The DynamicObject which will have properties merged onto it.
     * @param {DynamicObject} objectToMerge The DynamicObject containing properties to be merged.
     *
     * @see CzmlDefaults
     */
    DynamicCone.mergeProperties = function(targetObject, objectToMerge) {
        var coneToMerge = objectToMerge.cone;
        if (typeof coneToMerge !== 'undefined') {

            var targetCone = targetObject.cone;
            if (typeof targetCone === 'undefined') {
                targetObject.cone = targetCone = new DynamicCone();
            }

            targetCone.show = targetCone.show || coneToMerge.show;
            targetCone.innerHalfAngle = targetCone.innerHalfAngle || coneToMerge.innerHalfAngle;
            targetCone.outerHalfAngle = targetCone.outerHalfAngle || coneToMerge.outerHalfAngle;
            targetCone.minimumClockAngle = targetCone.minimumClockAngle || coneToMerge.minimumClockAngle;
            targetCone.maximumClockAngle = targetCone.maximumClockAngle || coneToMerge.maximumClockAngle;
            targetCone.radius = targetCone.radius || coneToMerge.radius;
            targetCone.showIntersection = targetCone.showIntersection || coneToMerge.showIntersection;
            targetCone.intersectionColor = targetCone.intersectionColor || coneToMerge.intersectionColor;
            targetCone.capMaterial = targetCone.capMaterial || coneToMerge.capMaterial;
            targetCone.innerMaterial = targetCone.innerMaterial || coneToMerge.innerMaterial;
            targetCone.outerMaterial = targetCone.outerMaterial || coneToMerge.outerMaterial;
            targetCone.silhouetteMaterial = targetCone.silhouetteMaterial || coneToMerge.silhouetteMaterial;
        }
    };

    /**
     * Given a DynamicObject, undefines the cone associated with it.
     * This method is not normally called directly, but is part of the array of CZML processing
     * functions that is passed into the CompositeDynamicObjectCollection constructor.
     *
     * @param {DynamicObject} dynamicObject The DynamicObject to remove the cone from.
     *
     * @see CzmlDefaults
     */
    DynamicCone.undefineProperties = function(dynamicObject) {
        dynamicObject.cone = undefined;
    };

    return DynamicCone;
});
/*global define*/
define('DynamicScene/DynamicPolygon',[
        '../Core/TimeInterval',
        './CzmlBoolean',
        './DynamicProperty',
        './DynamicMaterialProperty'
    ], function(
         TimeInterval,
         CzmlBoolean,
         DynamicProperty,
         DynamicMaterialProperty) {
    

    /**
     * Represents a time-dynamic polygon, typically used in conjunction with DynamicPolygonVisualizer and
     * DynamicObjectCollection to visualize CZML.
     *
     * @alias DynamicPolygon
     * @constructor
     *
     * @see DynamicObject
     * @see DynamicProperty
     * @see DynamicObjectCollection
     * @see DynamicPolygonVisualizer
     * @see VisualizerCollection
     * @see Polygon
     * @see CzmlDefaults
     */
    var DynamicPolygon = function() {
        /**
         * A DynamicProperty of type CzmlBoolean which determines the polygon's visibility.
         */
        this.show = undefined;
        /**
         * A DynamicMaterialProperty which determines the polygon's material.
         */
        this.material = undefined;
    };

    /**
     * Processes a single CZML packet and merges its data into the provided DynamicObject's polygon.
     * If the DynamicObject does not have a polygon, one is created.  This method is not
     * normally called directly, but is part of the array of CZML processing functions that is
     * passed into the DynamicObjectCollection constructor.
     *
     * @param {DynamicObject} dynamicObject The DynamicObject which will contain the polygon data.
     * @param {Object} packet The CZML packet to process.
     * @param {DynamicObjectCollection} [dynamicObjectCollection] The collection into which objects are being loaded.
     * @param {String} [sourceUri] The originating url of the CZML being processed.
     * @returns {Boolean} true if any new properties were created while processing the packet, false otherwise.
     *
     * @see DynamicObject
     * @see DynamicProperty
     * @see DynamicObjectCollection
     * @see CzmlDefaults#updaters
     */
    DynamicPolygon.processCzmlPacket = function(dynamicObject, packet, dynamicObjectCollection, sourceUri) {
        var polygonData = packet.polygon;
        if (typeof polygonData === 'undefined') {
            return false;
        }

        var polygonUpdated = false;
        var polygon = dynamicObject.polygon;
        polygonUpdated = typeof polygon === 'undefined';
        if (polygonUpdated) {
            dynamicObject.polygon = polygon = new DynamicPolygon();
        }

        var interval = polygonData.interval;
        if (typeof interval !== 'undefined') {
            interval = TimeInterval.fromIso8601(interval);
        }

        if (typeof polygonData.show !== 'undefined') {
            var show = polygon.show;
            if (typeof show === 'undefined') {
                polygon.show = show = new DynamicProperty(CzmlBoolean);
                polygonUpdated = true;
            }
            show.processCzmlIntervals(polygonData.show, interval);
        }

        if (typeof polygonData.material !== 'undefined') {
            var material = polygon.material;
            if (typeof material === 'undefined') {
                polygon.material = material = new DynamicMaterialProperty();
                polygonUpdated = true;
            }
            material.processCzmlIntervals(polygonData.material, interval, sourceUri);
        }
        return polygonUpdated;
    };

    /**
     * Given two DynamicObjects, takes the polygon properties from the second
     * and assigns them to the first, assuming such a property did not already exist.
     * This method is not normally called directly, but is part of the array of CZML processing
     * functions that is passed into the CompositeDynamicObjectCollection constructor.
     *
     * @param {DynamicObject} targetObject The DynamicObject which will have properties merged onto it.
     * @param {DynamicObject} objectToMerge The DynamicObject containing properties to be merged.
     *
     * @see CzmlDefaults
     */
    DynamicPolygon.mergeProperties = function(targetObject, objectToMerge) {
        var polygonToMerge = objectToMerge.polygon;
        if (typeof polygonToMerge !== 'undefined') {

            var targetPolygon = targetObject.polygon;
            if (typeof targetPolygon === 'undefined') {
                targetObject.polygon = targetPolygon = new DynamicPolygon();
            }

            targetPolygon.show = targetPolygon.show || polygonToMerge.show;
            targetPolygon.material = targetPolygon.material || polygonToMerge.material;
        }
    };

    /**
     * Given a DynamicObject, undefines the polygon associated with it.
     * This method is not normally called directly, but is part of the array of CZML processing
     * functions that is passed into the CompositeDynamicObjectCollection constructor.
     *
     * @param {DynamicObject} dynamicObject The DynamicObject to remove the polygon from.
     *
     * @see CzmlDefaults
     */
    DynamicPolygon.undefineProperties = function(dynamicObject) {
        dynamicObject.polygon = undefined;
    };

    return DynamicPolygon;
});
/*global define*/
define('DynamicScene/DynamicPyramid',[
        '../Core/TimeInterval',
        './CzmlBoolean',
        './CzmlNumber',
        './CzmlColor',
        './DynamicProperty',
        './DynamicDirectionsProperty',
        './DynamicMaterialProperty'
    ], function(
        TimeInterval,
        CzmlBoolean,
        CzmlNumber,
        CzmlColor,
        DynamicProperty,
        DynamicDirectionsProperty,
        DynamicMaterialProperty) {
    

    /**
     * Represents a time-dynamic pyramid, typically used in conjunction with DynamicPyramidVisualizer and
     * DynamicObjectCollection to visualize CZML.
     *
     * @alias DynamicPyramid
     * @constructor
     *
     * @see DynamicObject
     * @see DynamicProperty
     * @see DynamicObjectCollection
     * @see DynamicPyramidVisualizer
     * @see VisualizerCollection
     * @see CustomSensor
     * @see CzmlDefaults
     */
    var DynamicPyramid = function() {
        this.show = undefined;
        this.directions = undefined;
        this.radius = undefined;
        this.showIntersection = undefined;
        this.intersectionColor = undefined;
        this.material = undefined;
    };

    /**
     * Processes a single CZML packet and merges its data into the provided DynamicObject's pyramid.
     * If the DynamicObject does not have a pyramid, one is created.  This method is not
     * normally called directly, but is part of the array of CZML processing functions that is
     * passed into the DynamicObjectCollection constructor.
     *
     * @param {DynamicObject} dynamicObject The DynamicObject which will contain the pyramid data.
     * @param {Object} packet The CZML packet to process.
     * @param {DynamicObject} dynamicObjectCollection The DynamicObjectCollection to which the DynamicObject belongs.
     *
     * @returns {Boolean} true if any new properties were created while processing the packet, false otherwise.
     *
     * @see DynamicObject
     * @see DynamicProperty
     * @see DynamicObjectCollection
     * @see CzmlDefaults#updaters
     */
    DynamicPyramid.processCzmlPacket = function(dynamicObject, packet, dynamicObjectCollection) {
        var pyramidData = packet.pyramid;
        if (typeof pyramidData === 'undefined') {
            return false;
        }

        var pyramidUpdated = false;
        var pyramid = dynamicObject.pyramid;
        pyramidUpdated = typeof pyramid === 'undefined';
        if (pyramidUpdated) {
            dynamicObject.pyramid = pyramid = new DynamicPyramid();
        }

        var interval = pyramidData.interval;
        if (typeof interval !== 'undefined') {
            interval = TimeInterval.fromIso8601(interval);
        }

        if (typeof pyramidData.show !== 'undefined') {
            var show = pyramid.show;
            if (typeof show === 'undefined') {
                pyramid.show = show = new DynamicProperty(CzmlBoolean);
                pyramidUpdated = true;
            }
            show.processCzmlIntervals(pyramidData.show, interval);
        }

        if (typeof pyramidData.radius !== 'undefined') {
            var radius = pyramid.radius;
            if (typeof radius === 'undefined') {
                pyramid.radius = radius = new DynamicProperty(CzmlNumber);
                pyramidUpdated = true;
            }
            radius.processCzmlIntervals(pyramidData.radius, interval);
        }

        if (typeof pyramidData.showIntersection !== 'undefined') {
            var showIntersection = pyramid.showIntersection;
            if (typeof showIntersection === 'undefined') {
                pyramid.showIntersection = showIntersection = new DynamicProperty(CzmlBoolean);
                pyramidUpdated = true;
            }
            showIntersection.processCzmlIntervals(pyramidData.showIntersection, interval);
        }

        if (typeof pyramidData.intersectionColor !== 'undefined') {
            var intersectionColor = pyramid.intersectionColor;
            if (typeof intersectionColor === 'undefined') {
                pyramid.intersectionColor = intersectionColor = new DynamicProperty(CzmlColor);
                pyramidUpdated = true;
            }
            intersectionColor.processCzmlIntervals(pyramidData.intersectionColor, interval);
        }

        if (typeof pyramidData.material !== 'undefined') {
            var material = pyramid.material;
            if (typeof material === 'undefined') {
                pyramid.material = material = new DynamicMaterialProperty();
                pyramidUpdated = true;
            }
            material.processCzmlIntervals(pyramidData.material, interval);
        }

        if (typeof pyramidData.directions !== 'undefined') {
            var directions = pyramid.directions;
            if (typeof directions === 'undefined') {
                pyramid.directions = directions = new DynamicDirectionsProperty();
                pyramidUpdated = true;
            }
            directions.processCzmlIntervals(pyramidData.directions, interval);
        }
        return pyramidUpdated;
    };

    /**
     * Given two DynamicObjects, takes the pyramid properties from the second
     * and assigns them to the first, assuming such a property did not already exist.
     * This method is not normally called directly, but is part of the array of CZML processing
     * functions that is passed into the CompositeDynamicObjectCollection constructor.
     *
     * @param {DynamicObject} targetObject The DynamicObject which will have properties merged onto it.
     * @param {DynamicObject} objectToMerge The DynamicObject containing properties to be merged.
     *
     * @see CzmlDefaults
     */
    DynamicPyramid.mergeProperties = function(targetObject, objectToMerge) {
        var pyramidToMerge = objectToMerge.pyramid;
        if (typeof pyramidToMerge !== 'undefined') {

            var targetPyramid = targetObject.pyramid;
            if (typeof targetPyramid === 'undefined') {
                targetObject.pyramid = targetPyramid = new DynamicPyramid();
            }

            targetPyramid.show = targetPyramid.show || pyramidToMerge.show;
            targetPyramid.directions = targetPyramid.directions || pyramidToMerge.directions;
            targetPyramid.radius = targetPyramid.radius || pyramidToMerge.radius;
            targetPyramid.showIntersection = targetPyramid.showIntersection || pyramidToMerge.showIntersection;
            targetPyramid.intersectionColor = targetPyramid.intersectionColor || pyramidToMerge.intersectionColor;
            targetPyramid.material = targetPyramid.material || pyramidToMerge.material;
        }
    };

    /**
     * Given a DynamicObject, undefines the pyramid associated with it.
     * This method is not normally called directly, but is part of the array of CZML processing
     * functions that is passed into the CompositeDynamicObjectCollection constructor.
     *
     * @param {DynamicObject} dynamicObject The DynamicObject to remove the pyramid from.
     *
     * @see CzmlDefaults
     */
    DynamicPyramid.undefineProperties = function(dynamicObject) {
        dynamicObject.pyramid = undefined;
    };

    return DynamicPyramid;
});

/*!
  This library rewrites the Canvas2D "measureText" function
  so that it returns a more complete metrics object.
  This library is licensed under the MIT (Expat) license,
  the text for which is included below.

   -----------------------------------------------------------------------------

  CHANGELOG:

    2012-01-21 - Whitespace handling added by Joe Turner
                 (https://github.com/oampo)

   -----------------------------------------------------------------------------

  Copyright (C) 2011 by Mike "Pomax" Kamermans

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.
*/
/*global define*/
define('ThirdParty/measureText',[],function() {
    
//  var NAME = "FontMetrics Library";
//  var VERSION = "1-2012.0121.1300";

  // if there is no getComputedStyle, this library won't work.
//  if(!document.defaultView.getComputedStyle) {
//    throw("ERROR: 'document.defaultView.getComputedStyle' not found. This library only works in browsers that can report computed CSS values.");
//  }

  // store the old text metrics function on the Canvas2D prototype
  //CanvasRenderingContext2D.prototype.measureTextWidth = CanvasRenderingContext2D.prototype.measureText;

  /**
   *  shortcut function for getting computed CSS values
   */
  var getCSSValue = function(element, property) {
    return document.defaultView.getComputedStyle(element,null).getPropertyValue(property);
  };

  // debug function
//  var show = function(canvas, ctx, xstart, w, h, metrics)
//  {
//    document.body.appendChild(canvas);
//    ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
//
//    ctx.beginPath();
//    ctx.moveTo(xstart,0);
//    ctx.lineTo(xstart,h);
//    ctx.closePath();
//    ctx.stroke();
//
//    ctx.beginPath();
//    ctx.moveTo(xstart+metrics.bounds.maxx,0);
//    ctx.lineTo(xstart+metrics.bounds.maxx,h);
//    ctx.closePath();
//    ctx.stroke();
//
//    ctx.beginPath();
//    ctx.moveTo(0,h/2-metrics.ascent);
//    ctx.lineTo(w,h/2-metrics.ascent);
//    ctx.closePath();
//    ctx.stroke();
//
//    ctx.beginPath();
//    ctx.moveTo(0,h/2+metrics.descent);
//    ctx.lineTo(w,h/2+metrics.descent);
//    ctx.closePath();
//    ctx.stroke();
//  }

  /**
   * The new text metrics function
   */
  return function(context2D, textstring) {
    var metrics = context2D.measureText(textstring),
        fontFamily = getCSSValue(context2D.canvas,"font-family"),
        fontSize = getCSSValue(context2D.canvas,"font-size").replace("px",""),
        isSpace = !(/\S/.test(textstring));
        metrics.fontsize = fontSize;

    // for text lead values, we meaure a multiline text container.
    var leadDiv = document.createElement("div");
    leadDiv.style.position = "absolute";
    leadDiv.style.opacity = 0;
    leadDiv.style.font = fontSize + "px " + fontFamily;
    leadDiv.innerHTML = textstring + "<br/>" + textstring;
    document.body.appendChild(leadDiv);

    // make some initial guess at the text leading (using the standard TeX ratio)
    metrics.leading = 1.2 * fontSize;

    // then we try to get the real value from the browser
    var leadDivHeight = getCSSValue(leadDiv,"height");
    leadDivHeight = leadDivHeight.replace("px","");
    if (leadDivHeight >= fontSize * 2) { metrics.leading = (leadDivHeight/2) | 0; }
    document.body.removeChild(leadDiv);

    // if we're not dealing with white space, we can compute metrics
    if (!isSpace) {
        // Have characters, so measure the text
        var canvas = document.createElement("canvas");
        var padding = 100;
        canvas.width = metrics.width + padding;
        canvas.height = 3*fontSize;
        canvas.style.opacity = 1;
        canvas.style.fontFamily = fontFamily;
        canvas.style.fontSize = fontSize;
        var ctx = canvas.getContext("2d");
        ctx.font = fontSize + "px " + fontFamily;

        var w = canvas.width,
            h = canvas.height,
            baseline = h/2;

        // Set all canvas pixeldata values to 255, with all the content
        // data being 0. This lets us scan for data[i] != 255.
        ctx.fillStyle = "white";
        ctx.fillRect(-1, -1, w+2, h+2);
        ctx.fillStyle = "black";
        ctx.fillText(textstring, padding/2, baseline);
        var pixelData = ctx.getImageData(0, 0, w, h).data;

        // canvas pixel data is w*4 by h*4, because R, G, B and A are separate,
        // consecutive values in the array, rather than stored as 32 bit ints.
        var i = 0,
            w4 = w * 4,
            len = pixelData.length;

        // Finding the ascent uses a normal, forward scanline
        while (++i < len && pixelData[i] === 255) {}
        var ascent = (i/w4)|0;

        // Finding the descent uses a reverse scanline
        i = len - 1;
        while (--i > 0 && pixelData[i] === 255) {}
        var descent = (i/w4)|0;

        // find the min-x coordinate
        for(i = 0; i<len && pixelData[i] === 255; ) {
          i += w4;
          if(i>=len) { i = (i-len) + 4; }}
        var minx = ((i%w4)/4) | 0;

        // find the max-x coordinate
        var step = 1;
        for(i = len-3; i>=0 && pixelData[i] === 255; ) {
          i -= w4;
          if(i<0) { i = (len - 3) - (step++)*4; }}
        var maxx = ((i%w4)/4) + 1 | 0;

        // set font metrics
        metrics.ascent = (baseline - ascent);
        metrics.descent = (descent - baseline);
        metrics.bounds = { minx: minx - (padding/2),
                           maxx: maxx - (padding/2),
                           miny: 0,
                           maxy: descent-ascent };
        metrics.height = 1+(descent - ascent);
    }

    // if we ARE dealing with whitespace, most values will just be zero.
    else {
        // Only whitespace, so we can't measure the text
        metrics.ascent = 0;
        metrics.descent = 0;
        metrics.bounds = { minx: 0,
                           maxx: metrics.width, // Best guess
                           miny: 0,
                           maxy: 0 };
        metrics.height = 0;
    }
    return metrics;
  };
});
/*global define*/
define('Scene/Label',[
        '../Core/Color',
        '../Core/shallowEquals',
        '../Core/Cartesian2',
        '../Core/Cartesian3',
        '../ThirdParty/measureText',
        './Billboard',
        './LabelStyle',
        './HorizontalOrigin',
        './VerticalOrigin'
    ], function(
        Color,
        shallowEquals,
        Cartesian2,
        Cartesian3,
        measureText,
        Billboard,
        LabelStyle,
        HorizontalOrigin,
        VerticalOrigin) {
    

    /**
     * DOC_TBA
     *
     * @alias Label
     * @internalConstructor
     *
     * @see LabelCollection
     * @see LabelCollection#add
     * @see Billboard
     *
     * @see <a href='http://www.whatwg.org/specs/web-apps/current-work/#2dcontext'>HTML canvas 2D context</a>
     */
    var Label = function(labelTemplate, labelCollection) {
        var l = labelTemplate || {};
        var show = (typeof l.show === 'undefined') ? true : l.show;
        var billboardCollection = labelCollection._getCollection();

        this._text = l.text || '';
        this._font = l.font || '30px sans-serif';
        this._fillColor = (typeof l.fillColor !== 'undefined') ? Color.clone(l.fillColor) : new Color(1.0, 1.0, 1.0, 1.0);
        this._outlineColor = (typeof l.outlineColor !== 'undefined') ? Color.clone(l.outlineColor) : new Color(0.0, 0.0, 0.0, 1.0);
        this._style = l.style || LabelStyle.FILL;
        this._verticalOrigin = l.verticalOrigin || VerticalOrigin.BOTTOM;
        this._horizontalOrigin = l.horizontalOrigin || HorizontalOrigin.LEFT;
        this._pixelOffset = l.pixelOffset ? new Cartesian2(l.pixelOffset.x, l.pixelOffset.y) : Cartesian2.ZERO.clone();
        this._eyeOffset = l.eyeOffset ? new Cartesian3(l.eyeOffset.x, l.eyeOffset.y, l.eyeOffset.z) : Cartesian3.ZERO.clone();

        this._position = l.position ? new Cartesian3(l.position.x, l.position.y, l.position.z) : Cartesian3.ZERO.clone();
        this._scale = (typeof l.scale === 'undefined') ? 1.0 : l.scale;
        this._show = show;

        this._billboardCollection = billboardCollection;
        this._labelCollection = labelCollection;
        this._billboards = undefined;

        this._createBillboards();
    };

    /**
     * Returns true if this label will be shown.  Call {@link Label#setShow}
     * to hide or show a label, instead of removing it and re-adding it to the collection.
     *
     * @memberof Label
     *
     * @return {Boolean} <code>true</code> if this label will be shown; otherwise, <code>false</code>.
     *
     * @see Label#setShow
     */
    Label.prototype.getShow = function() {
        return this._show;
    };

    /**
     * Determines if this label will be shown.  Call this to hide or show a label, instead
     * of removing it and re-adding it to the collection.
     *
     * @memberof Label
     *
     * @param {Boolean} value Indicates if this label will be shown.
     *
     * @see Label#getShow
     */
    Label.prototype.setShow = function(value) {
        if ((typeof value !== 'undefined') && (value !== this._show)) {
            this._show = value;

            var billboards = this._billboards;
            var length = this._billboards ? this._billboards.length : 0;
            for ( var i = 0; i < length; i++) {
                billboards[i].setShow(value);
            }
        }
    };

    /**
     * Returns the Cartesian position of this label.
     *
     * @memberof Label
     *
     * @return {Cartesian3} The Cartesian position of this label.
     *
     * @see Label#setPosition
     */
    Label.prototype.getPosition = function() {
        return this._position;
    };

    /**
     * Sets the Cartesian position of this label.
     * <br /><br />
     * As shown in the examples, <code>value</code> can be either a {@link Cartesian3}
     * or an object literal with <code>x</code>, <code>y</code>, and <code>z</code> properties.
     * A copy of <code>value</code> is made, so changing it after calling <code>setPosition</code>
     * does not affect the label's position; an explicit call to <code>setPosition</code> is required.
     *
     * @memberof Label
     *
     * @param {Cartesian3} value The Cartesian position.
     *
     * @see Label#getPosition
     *
     * @example
     * // Example 1. Set a label's position using a Cartesian3.
     * l.setPosition(new Cartesian3(1.0, 2.0, 3.0));
     *
     * //////////////////////////////////////////////////////////////////
     *
     * // Example 2. Set a label's position using an object literal.
     * l.setPosition({
     *   x : 1.0,
     *   y : 2.0,
     *   z : 3.0});
     */
    Label.prototype.setPosition = function(value) {
        var p = this._position;

        if ((typeof value !== 'undefined') &&
            ((p.x !== value.x) || (p.y !== value.y) || (p.z !== value.z))) {

            p.x = value.x;
            p.y = value.y;
            p.z = value.z;

            var billboards = this._billboards;
            var length = this._billboards ? this._billboards.length : 0;
            for ( var i = 0; i < length; i++) {
                billboards[i].setPosition(value);
            }
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof Label
     *
     * @see Label#setText
     */
    Label.prototype.getText = function() {
        return this._text;
    };

    /**
     * DOC_TBA
     *
     * @memberof Label
     *
     * @see Label#getText
     */
    Label.prototype.setText = function(value) {
        if ((typeof value !== 'undefined') && (value !== this._text)) {
            this._text = value;
            this._createBillboards();
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof Label
     *
     * @see Label#setFont
     */
    Label.prototype.getFont = function() {
        return this._font;
    };

    /**
     * DOC_TBA
     * CSS font-family
     *
     * @memberof Label
     *
     * @see Label#getFont
     * @see Label#setFillColor
     * @see Label#setOutlineColor
     * @see <a href='http://www.whatwg.org/specs/web-apps/current-work/#dom-context-2d-font'>HTML canvas 2D context font</a>
     */
    Label.prototype.setFont = function(value) {
        if ((typeof value !== 'undefined') && (this._font !== value)) {
            this._font = value;
            this._createBillboards();
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof Label
     *
     * @see Label#setFillColor
     */
    Label.prototype.getFillColor = function() {
        return this._fillColor;
    };

    /**
     * DOC_TBA
     *
     * CSS <color> values
     *
     * @memberof Label
     *
     * @see Label#getFillColor
     * @see Label#setOutlineColor
     * @see Label#setFont
     */
    Label.prototype.setFillColor = function(value) {
        var c = this._fillColor;
        if ((typeof value !== 'undefined') && !Color.equals(c, value)) {
            Color.clone(value, this._fillColor);
            this._createBillboards();
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof Label
     *
     * @see Label#setOutlineColor
     */
    Label.prototype.getOutlineColor = function() {
        return this._outlineColor;
    };

    /**
     * DOC_TBA
     *
     * CSS <color> values
     *
     * @memberof Label
     *
     * @see Label#getOutlineColor
     * @see Label#setFillColor
     * @see Label#setFont
     */
    Label.prototype.setOutlineColor = function(value) {
        var c = this._outlineColor;
        if ((typeof value !== 'undefined') && !Color.equals(c, value)) {
            Color.clone(value, this._outlineColor);
            this._createBillboards();
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof Label
     *
     * @see Label#setStyle
     */
    Label.prototype.getStyle = function() {
        return this._style;
    };

    /**
     * DOC_TBA
     *
     * @memberof Label
     *
     * @param {LabelStyle} value DOC_TBA
     *
     * @see Label#getStyle
     * @see Label#setOutlineColor
     * @see Label#setFillColor
     */
    Label.prototype.setStyle = function(value) {
        if ((typeof value !== 'undefined') && (this._style !== value)) {
            this._style = value;
            this._createBillboards();
        }
    };

    /**
     * Returns the pixel offset from the origin of this label.
     *
     * @memberof Label
     *
     * @return {Cartesian2} The pixel offset of this label.
     *
     * @see Label#setPixelOffset
     */
    Label.prototype.getPixelOffset = function() {
        return this._pixelOffset;
    };

    /**
     * Sets the pixel offset in screen space from the origin of this label.  This is commonly used
     * to align multiple labels and billboards at the same position, e.g., an image and text.  The
     * screen space origin is the bottom, left corner of the canvas; <code>x</code> increases from
     * left to right, and <code>y</code> increases from bottom to top.
     * <br /><br />
     * <code>value</code> can be either a {@link Cartesian2}  or an object literal with
     * <code>x</code> and <code>y</code> properties.  A copy of <code>value</code> is made, so
     * changing it after calling <code>setPixelOffset</code> does not affect the label's pixel
     * offset; an explicit call to <code>setPixelOffset</code> is required.
     * <br /><br />
     * <div align='center'>
     * <table border='0' cellpadding='5'><tr>
     * <td align='center'><code>default</code><br/><img src='images/Label.setPixelOffset.default.png' width='250' height='188' /></td>
     * <td align='center'><code>l.setPixelOffset({ x : 25, y : -75 });</code><br/><img src='images/Label.setPixelOffset.x50y-25.png' width='250' height='188' /></td>
     * </tr></table>
     * The label's origin is indicated by the yellow point.
     * </div>
     *
     * @memberof Label
     *
     * @param {Cartesian2} value The 2D Cartesian pixel offset.
     *
     * @see Label#getPixelOffset
     * @see Billboard#setPixelOffset
     */
    Label.prototype.setPixelOffset = function(value) {
        var p = this._pixelOffset;
        if ((typeof value !== 'undefined') && ((p.x !== value.x) || (p.y !== value.y))) {
            p.x = value.x;
            p.y = value.y;
            this._setPixelOffsets();
        }
    };

    /**
     * Returns the 3D Cartesian offset applied to this label in eye coordinates.
     *
     * @memberof Label
     *
     * @return {Cartesian3} The 3D Cartesian offset applied to this label in eye coordinates.
     *
     * @see Label#setEyeOffset
     */
    Label.prototype.getEyeOffset = function() {
        return this._eyeOffset;
    };

    /**
     * Sets the 3D Cartesian offset applied to this label in eye coordinates.  Eye coordinates is a left-handed
     * coordinate system, where <code>x</code> points towards the viewer's right, <code>y</code> points up, and
     * <code>z</code> points into the screen.  Eye coordinates use the same scale as world and model coordinates,
     * which is typically meters.
     * <br /><br />
     * An eye offset is commonly used to arrange multiple label or objects at the same position, e.g., to
     * arrange a label above its corresponding 3D model.
     * <br /><br />
     * <code>value</code> can be either a {@link Cartesian3} or an object literal with <code>x</code>,
     * <code>y</code>, and <code>z</code> properties.  A copy of <code>value</code> is made, so changing it after
     * calling <code>setEyeOffset</code> does not affect the label's eye offset; an explicit call to
     * <code>setEyeOffset</code> is required.
     * <br /><br />
     * Below, the label is positioned at the center of the Earth but an eye offset makes it always
     * appear on top of the Earth regardless of the viewer's or Earth's orientation.
     * <br /><br />
     * <div align='center'>
     * <table border='0' cellpadding='5'><tr>
     * <td align='center'><img src='images/Billboard.setEyeOffset.one.png' width='250' height='188' /></td>
     * <td align='center'><img src='images/Billboard.setEyeOffset.two.png' width='250' height='188' /></td>
     * </tr></table>
     * <code>l.setEyeOffset({ x : 0.0, y : 8000000.0, z : 0.0 });</code><br /><br />
     * </div>
     *
     * @memberof Label
     *
     * @param {Cartesian3} value The 3D Cartesian offset in eye coordinates.
     *
     * @see Label#getEyeOffset
     */
    Label.prototype.setEyeOffset = function(value) {
        var e = this._eyeOffset;

        if ((typeof value !== 'undefined') &&
            ((e.x !== value.x) || (e.y !== value.y) || (e.z !== value.z))) {
            e.x = value.x;
            e.y = value.y;
            e.z = value.z;
            var billboards = this._billboards;
            var length = this._billboards ? this._billboards.length : 0;
            for ( var i = 0; i < length; i++) {
                var b = billboards[i];
                var eyeOffset = b.getEyeOffset();
                b.setEyeOffset({
                    x : this._eyeOffset.x + eyeOffset.x,
                    y : this._eyeOffset.y + eyeOffset.y,
                    z : this._eyeOffset.z + eyeOffset.z
                });
            }
        }
    };

    /**
     * Returns the horizontal origin of this label.
     *
     * @memberof Label
     *
     * @return {HorizontalOrigin} The horizontal origin of this label.
     *
     * @see Label#setHorizontalOrigin
     */
    Label.prototype.getHorizontalOrigin = function() {
        return this._horizontalOrigin;
    };

    /**
     * Sets the horizontal origin of this label, which determines if the label is
     * to the left, center, or right of its position.
     * <br /><br />
     * <div align='center'>
     * <img src='images/Billboard.setHorizontalOrigin.png' width='400' height='300' /><br />
     * </div>
     *
     * @memberof Label
     *
     * @param {HorizontalOrigin} value The horizontal origin.
     *
     * @see Label#getHorizontalOrigin
     * @see Label#setVerticalOrigin
     *
     * @example
     * // Use a top, right origin
     * l.setHorizontalOrigin(HorizontalOrigin.RIGHT);
     * l.setVerticalOrigin(VerticalOrigin.TOP);
     */
    Label.prototype.setHorizontalOrigin = function(value) {
        if ((typeof value !== 'undefined') && (this._horizontalOrigin !== value)) {
            this._horizontalOrigin = value;
            this._createBillboards();
        }
    };

    /**
     * Returns the vertical origin of this label.
     *
     * @memberof Label
     *
     * @return {VerticalOrigin} The vertical origin of this label.
     *
     * @see Label#setVerticalOrigin
     */
    Label.prototype.getVerticalOrigin = function() {
        return this._verticalOrigin;
    };

    /**
     * Sets the vertical origin of this label, which determines if the label is
     * to the above, below, or at the center of its position.
     * <br /><br />
     * <div align='center'>
     * <img src='images/Billboard.setVerticalOrigin.png' width='400' height='300' /><br />
     * </div>
     *
     * @memberof Label
     *
     * @param {VerticalOrigin} value The vertical origin.
     *
     * @see Label#getVerticalOrigin
     * @see Label#setHorizontalOrigin
     *
     * @example
     * // Use a top, right origin
     * l.setHorizontalOrigin(HorizontalOrigin.RIGHT);
     * l.setVerticalOrigin(VerticalOrigin.TOP);
     */
    Label.prototype.setVerticalOrigin = function(value) {
        if ((typeof value !== 'undefined') && (this._verticalOrigin !== value)) {
            this._verticalOrigin = value;
            this._createBillboards();
        }
    };

    /**
     * Returns the uniform scale that is multiplied with the label's size in pixels.
     *
     * @memberof Label
     *
     * @return {Number} The scale used to size the label.
     *
     * @see Label#setScale
     */
    Label.prototype.getScale = function() {
        return this._scale;
    };

    /**
     * Sets the uniform scale that is multiplied with the label's size in pixels.
     * A scale of <code>1.0</code> does not change the size of the label; a scale greater than
     * <code>1.0</code> enlarges the label; a positive scale less than <code>1.0</code> shrinks
     * the label.
     * <br /><br />
     * Applying a large scale value may pixelate the label.  To make text larger without pixelation,
     * use a larger font size when calling {@link Label#setFont} instead.
     * <br /><br />
     * <div align='center'>
     * <img src='images/Label.setScale.png' width='400' height='300' /><br/>
     * From left to right in the above image, the scales are <code>0.5</code>, <code>1.0</code>,
     * and <code>2.0</code>.
     * </div>
     *
     * @memberof Label
     *
     * @param {Number} value The scale used to size the label.
     *
     * @see Label#getScale
     * @see Label#setFont
     */
    Label.prototype.setScale = function(value) {
        if ((typeof value !== 'undefined') && (this._scale !== value)) {
            this._scale = value;
            var billboards = this._billboards;
            var length = this._billboards ? this._billboards.length : 0;
            for ( var i = 0; i < length; i++) {
                billboards[i].setScale(value);
            }
            this._setPixelOffsets();
        }
    };

    /**
     * Computes the screen-space position of the label's origin, taking into account eye and pixel offsets.
     * The screen space origin is the bottom, left corner of the canvas; <code>x</code> increases from
     * left to right, and <code>y</code> increases from bottom to top.
     *
     * @memberof Label
     *
     * @param {UniformState} uniformState The same state object passed to {@link LabelCollection#render}.
     *
     * @return {Cartesian2} The screen-space position of the label.
     *
     * @exception {DeveloperError} Label must be in a collection.
     * @exception {DeveloperError} uniformState is required.
     *
     * @see Label#setEyeOffset
     * @see Label#setPixelOffset
     * @see LabelCollection#render
     *
     * @example
     * console.log(l.computeScreenSpacePosition(scene.getUniformState()).toString());
     */
    Label.prototype.computeScreenSpacePosition = function(uniformState) {
        // This function is basically a stripped-down JavaScript version of BillboardCollectionVS.glsl

        var billboards = this._billboards;
        var position = (this._billboards.length !== 0) ? billboards[0]._getActualPosition() : this._position;

        return Billboard._computeScreenSpacePosition(this._labelCollection.modelMatrix, position, this._eyeOffset, this._pixelOffset, uniformState);
    };

    /**
     * Determines if this label equals another label.  Labels are equal if all their properties
     * are equal.  Labels in different collections can be equal.
     *
     * @memberof Label
     *
     * @param {Label} other The label to compare for equality.
     *
     * @return {Boolean} <code>true</code> if the labels are equal; otherwise, <code>false</code>.
     */
    Label.prototype.equals = function(other) {
        return other &&
               (this.getShow() === other.getShow()) &&
               (this.getPosition().equals(other.getPosition())) &&
               (this.getPixelOffset().equals(other.getPixelOffset())) &&
               (this.getEyeOffset().equals(other.getEyeOffset())) &&
               (this.getHorizontalOrigin().value === other.getHorizontalOrigin().value) &&
               (this.getVerticalOrigin().value === other.getVerticalOrigin().value) &&
               (this.getScale() === other.getScale()) &&
               (this._text === other._text) &&
               (this._font === other._font) &&
               (shallowEquals(this._fillColor, other._fillColor)) &&
               (shallowEquals(this._outlineColor, other._outlineColor)) &&
               (this._style === other._style);
    };

    Label.prototype._destroy = function() {
        var billboardCollection = this._billboardCollection;
        var billboards = this._billboards;
        var length = this._billboards ? this._billboards.length : 0;
        for ( var i = 0; i < length; i++) {
            billboardCollection.remove(billboards[i]);
        }
        this._billboards = null;
        this._billboardCollection = null;
        this._labelCollection = null;
    };

    Label.prototype._getCollection = function() {
        return this._labelCollection;
    };

    Label.prototype._getBillboards = function() {
        return this._billboards;
    };

    Label.prototype._createBillboards = function() {
        var i;
        var length = this._billboards ? this._billboards.length : 0;
        for (i = 0; i < length; i++) {
            this._billboardCollection.remove(this._billboards[i]);
        }

        this._billboards = [];
        var text = this._text;
        length = text.length;
        var self = this;

        var onCanvasCreated = function() {
            self._setUpdateTextureAtlas(true);
        };

        for (i = 0; i < length; i++) {
            var charValue = text.charAt(i);
            var billboard = this._billboardCollection.add({
                show : this._show,
                position : this._position,
                eyeOffset : this._eyeOffset,
                horizontalOrigin : HorizontalOrigin.LEFT,
                verticalOrigin : this._verticalOrigin,
                scale : this._scale,
                _pickIdThis : this
            });

            var canvasContainer = this._labelCollection._canvasContainer;
            var index = canvasContainer.add(charValue, this, onCanvasCreated);
            billboard.setImageIndex(index);
            billboard._labelDimension = canvasContainer.getItem(index)._dimension;
            this._billboards.push(billboard);
        }
        this._setPixelOffsets();
    };

    Label.prototype._createId = function(charValue) {
        return JSON.stringify({
            fillColor : this._fillColor.red.toString() + ',' + this._fillColor.green.toString() + ',' + this._fillColor.blue.toString() + ',' + this._fillColor.alpha.toString(),
            font : this._font,
            outlineColor : this._outlineColor.red.toString() + ',' + this._outlineColor.green.toString() + ',' + this._outlineColor.blue.toString() + ',' + this._outlineColor.alpha.toString(),
            style : this._style,
            verticalOrigin : this._verticalOrigin,
            value : charValue
        });
    };

    Label.prototype._createCanvas = function(charValue) {
        var font = this._font;

        var canvas = document.createElement('canvas');
        canvas.width = canvas.height = 1;
        canvas.style.font = font;
        canvas.style.display = 'hidden';

        var context2D = canvas.getContext('2d');
        context2D.font = font;


        //the vertical origin needs to be set before the measureText call. It won't work otherwise.
        //It's magic.
        var verticalOrigin = this._verticalOrigin;
        if (verticalOrigin === VerticalOrigin.BOTTOM) {
            context2D.textBaseline = 'bottom';
        } else if (verticalOrigin === VerticalOrigin.TOP) {
            context2D.textBaseline = 'top';
        } else {// VerticalOrigin.CENTER
            context2D.textBaseline = 'middle';
        }

        //in order for measureText to calculate style, the canvas has to be
        //(temporarily) added to the DOM.
        document.body.appendChild(canvas);
        var dimensions = measureText(context2D, charValue);
        document.body.removeChild(canvas);
        var baseline = dimensions.height - dimensions.ascent;
        canvas.width = dimensions.width;
        canvas.height = dimensions.height;
        context2D.font = font;
        // font must be explicitly set again after changing width and height
        context2D.fillStyle = 'rgba(' + this._fillColor.red * 255 + ', ' + this._fillColor.green * 255 + ', ' + this._fillColor.blue * 255 + ', ' + this._fillColor.alpha + ')';
        context2D.strokeStyle = 'rgba(' + this._outlineColor.red * 255 + ', ' + this._outlineColor.green * 255 + ', ' + this._outlineColor.blue * 255 + ', ' + this._outlineColor.alpha + ')';

        var y = canvas.height - baseline;
        var style = this._style;

        canvas._dimension = {
            width : canvas.width,
            height : canvas.height,
            descent : dimensions.descent
        };

        if (style === LabelStyle.FILL) {
            context2D.fillText(charValue, 0, y);
        } else if (style === LabelStyle.OUTLINE) {
            context2D.strokeText(charValue, 0, y);
        } else {// LabelStyle.FILL_AND_OUTLINE
            context2D.fillText(charValue, 0, y);
            context2D.strokeText(charValue, 0, y);
        }
        return canvas;
    };

    Label.prototype._getMaxHeight = function() {
        var i;
        var billboards = this._billboards;
        var length = billboards.length;
        var maxHeight = 0;
        for (i = 0; i < length; i++) {
            var billboard = billboards[i];
            maxHeight = Math.max(maxHeight, billboard._labelDimension.height);
        }
        return maxHeight;
    };

    Label.prototype._getWidth = function(){
        var i;
        var billboards = this._billboards;
        var length = billboards.length;
        var width = 0;
        for (i = 0; i < length; i++) {
            var billboard = billboards[i];
            width += billboard._labelDimension.width;
        }
        return width;
    };

    Label.prototype._setPixelOffsets = function() {
        var billboards = this._billboards;
        var maxHeight = 0;
        var i;
        var length = billboards.length;
        var thisPixelOffset = this._pixelOffset;
        var thisVerticalOrigin = this._verticalOrigin;
        var thisHorizontalOrigin = this._horizontalOrigin;
        var totalWidth = this._getWidth();
        var widthOffset = 0;
        var scale = this._scale;
        var dimension;
        var billboard;
        if(thisHorizontalOrigin === HorizontalOrigin.CENTER){
            widthOffset -= totalWidth / 2 * scale;
        }
        else if(thisHorizontalOrigin === HorizontalOrigin.RIGHT){
            widthOffset -= totalWidth * scale;
        }
        if (thisVerticalOrigin === VerticalOrigin.TOP) {
            maxHeight = this._getMaxHeight();
            for (i = 0; i < length; i++) {
                billboard = billboards[i];
                dimension = billboard._labelDimension;
                if (dimension.height < maxHeight) {
                    billboard.setPixelOffset({
                        x : thisPixelOffset.x + widthOffset,
                        y : thisPixelOffset.y - ((maxHeight - dimension.height) * scale) - (dimension.descent * scale)
                    });
                } else {
                    billboard.setPixelOffset({
                        x : thisPixelOffset.x + widthOffset,
                        y : thisPixelOffset.y - (dimension.descent * scale)
                    });
                }
                widthOffset += dimension.width * scale;
            }
        } else if (thisVerticalOrigin === VerticalOrigin.CENTER) {
            maxHeight = this._getMaxHeight();
            for (i = 0; i < length; i++) {
                billboard = billboards[i];
                dimension = billboard._labelDimension;
                if (dimension.height < maxHeight) {
                    billboard.setPixelOffset({
                        x : thisPixelOffset.x + widthOffset,
                        y : thisPixelOffset.y - (((maxHeight - billboard._labelDimension.height) / 2) * scale) - dimension.descent * scale
                    });
                } else {
                    billboard.setPixelOffset({
                        x : thisPixelOffset.x + widthOffset,
                        y : thisPixelOffset.y - billboard._labelDimension.descent * scale
                    });
                }
                widthOffset += dimension.width * scale;
            }
        } else if (thisVerticalOrigin === VerticalOrigin.BOTTOM) {
            for (i = 0; i < length; i++) {
                billboard = billboards[i];
                billboard.setPixelOffset({
                    x : thisPixelOffset.x + widthOffset,
                    y : thisPixelOffset.y - billboard._labelDimension.descent * scale
                });
                widthOffset += billboard._labelDimension.width * scale;
            }
        }
    };

    Label.prototype._setUpdateTextureAtlas = function(value) {
        this._labelCollection._setUpdateTextureAtlas(value);
    };

    return Label;
});
/*global define*/
define('Scene/LabelCollection',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/Matrix4',
        '../Renderer/BufferUsage',
        '../Renderer/PixelFormat',
        '../Renderer/TextureAtlas',
        './BillboardCollection',
        './Label'
    ], function(
        DeveloperError,
        destroyObject,
        Matrix4,
        BufferUsage,
        PixelFormat,
        TextureAtlas,
        BillboardCollection,
        Label) {
    

    function CanvasContainer() {
        this._sources = {};
        this._sourcesArray = [];
    }

    CanvasContainer.prototype.add = function(charValue, label, canvasCreated) {
        var id = label._createId(charValue);
        if (this._contains(id)) {
            return this._getCanvas(id).index;
        }

        var canvas = label._createCanvas(charValue);
        this._sources[id] = canvas;
        canvas.index = this._sourcesArray.push(canvas) - 1;
        if (typeof canvasCreated !== 'undefined') {
            canvasCreated();
        }
        return canvas.index;
    };

    CanvasContainer.prototype.getItems = function() {
        return this._sourcesArray;
    };

    CanvasContainer.prototype.getItem = function(index) {
        return this._sourcesArray[index];
    };

    CanvasContainer.prototype._contains = function(id) {
        return typeof this._sources[id] !== 'undefined';
    };

    CanvasContainer.prototype._getCanvas = function(id) {
        return this._sources[id];
    };

    /**
     * A renderable collection of labels.  Labels are viewport-aligned text positioned in the 3D scene.
     * Each label can have a different font, color, scale, etc.
     * <br /><br />
     * <div align='center'>
     * <img src='images/Label.png' width='400' height='300' /><br />
     * Example labels
     * </div>
     * <br /><br />
     * Labels are added and removed from the collection using {@link LabelCollection#add}
     * and {@link LabelCollection#remove}.
     *
     * @alias LabelCollection
     * @constructor
     *
     * @performance For best performance, prefer a few collections, each with many labels, to
     * many collections with only a few labels each.  Also set the buffer usage via
     * {@link LabelCollection#bufferUsage} based on your expected update pattern.
     * Avoid having collections where some labels change every frame and others do not; instead,
     * create one or more collections for static labels, and one or more collections for dynamic labels.
     *
     * @see LabelCollection#add
     * @see LabelCollection#remove
     * @see LabelCollection#bufferUsage
     * @see Label
     * @see BillboardCollection
     *
     * @example
     * // Create a label collection with two labels
     * var labels = new LabelCollection();
     * labels.add({
     *   position : { x : 1.0, y : 2.0, z : 3.0 },
     *   text : 'A label'
     * });
     * labels.add({
     *   position : { x : 4.0, y : 5.0, z : 6.0 },
     *   text : 'Another label'
     * });
     */
    var LabelCollection = function() {
        this._billboardCollection = new BillboardCollection();
        this._labels = [];
        this._labelsRemoved = false;
        this._updateTextureAtlas = false;
        this._canvasContainer = new CanvasContainer();

        /**
         * The 4x4 transformation matrix that transforms each label in this collection from model to world coordinates.
         * When this is the identity matrix, the labels are drawn in world coordinates, i.e., Earth's WGS84 coordinates.
         * Local reference frames can be used by providing a different transformation matrix, like that returned
         * by {@link Transforms.eastNorthUpToFixedFrame}.  This matrix is available to GLSL vertex and fragment
         * shaders via {@link agi_model} and derived uniforms.
         *
         * @type Matrix4
         *
         * @see Transforms.eastNorthUpToFixedFrame
         * @see agi_model
         *
         * @example
         * var center = ellipsoid.cartographicToCartesian(Cartographic.fromDegrees(-75.59777, 40.03883));
         * labels.modelMatrix = Transforms.eastNorthUpToFixedFrame(center);
         * labels.add({
         *   position : new Cartesian3(0.0, 0.0, 0.0),
         *   text     : 'Center'
         * });
         * labels.add({
         *   position : new Cartesian3(1000000.0, 0.0, 0.0),
         *   text     : 'East'
         * });
         * labels.add({
         *   position : new Cartesian3(0.0, 1000000.0, 0.0),
         *   text     : 'North'
         * });
         * labels.add({
         *   position : new Cartesian3(0.0, 0.0, 1000000.0),
         *   text     : 'Up'
         * });
         */
        this.modelMatrix = Matrix4.IDENTITY;

        /**
         * The current morph transition time between 2D/Columbus View and 3D,
         * with 0.0 being 2D or Columbus View and 1.0 being 3D.
         *
         * @type Number
         */
        this.morphTime = 1.0;

        /**
         * The usage hint for the collection's vertex buffer.
         *
         * @performance If <code>bufferUsage</code> changes, the next time
         * {@link LabelCollection#update} is called, the collection's vertex buffer
         * is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.
         * For best performance, it is important to provide the proper usage hint.  If the collection
         * and labels will not change over several frames, use <code>BufferUsage.STATIC_DRAW</code>.
         * If all labels will change every frame or labels are added/removed every frame, use
         * <code>BufferUsage.STREAM_DRAW</code>.  If a subset of labels change every frame, use
         * <code>BufferUsage.DYNAMIC_DRAW</code>.
         */
        this.bufferUsage = BufferUsage.STATIC_DRAW;
    };

    LabelCollection.prototype._getCollection = function() {
        return this._billboardCollection;
    };

    LabelCollection.prototype._setUpdateTextureAtlas = function(value) {
        this._updateTextureAtlas = value;
    };

    /**
     * Creates and adds a label with the specified initial properties to the collection.
     * The added label is returned so it can be modified or removed from the collection later.
     *
     * @memberof LabelCollection
     *
     * @param {Object}[label=undefined] A template describing the label's properties as shown in Example 1.
     *
     * @return {Label} The label that was added to the collection.
     *
     * @performance Calling <code>add</code> is expected constant time.  However, when
     * {@link LabelCollection#update} is called, the collection's vertex buffer
     * is rewritten; this operations is <code>O(n)</code> and also incurs
     * CPU to GPU overhead.  For best performance, add as many billboards as possible before
     * calling <code>update</code>.
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see LabelCollection#remove
     * @see LabelCollection#removeAll
     * @see LabelCollection#update
     *
     * @example
     * // Example 1:  Add a label, specifying all the default values.
     * var l = labels.add({
     *   show : true,
     *   position : Cartesian3.ZERO,
     *   text : '',
     *   font : '30px sans-serif',
     *   fillColor : 'white',
     *   outlineColor : 'white',
     *   style : LabelStyle.FILL,
     *   pixelOffset : Cartesian2.ZERO,
     *   eyeOffset : Cartesian3.ZERO,
     *   horizontalOrigin : HorizontalOrigin.LEFT,
     *   verticalOrigin : VerticalOrigin.BOTTOM,
     *   scale : 1.0,
     * });
     *
     * // Example 2:  Specify only the label's cartographic position,
     * // text, and font.
     * var l = labels.add({
     *   position : ellipsoid.cartographicToCartesian(new Cartographic(longitude, latitude, height)),
     *   text : 'Hello World',
     *   font : '24px Helvetica',
     * });
     */
    LabelCollection.prototype.add = function(label) {
        var l = new Label(label, this);
        l._index = this._labels.length;

        this._labels.push(l);

        return l;
    };

    /**
     * Removes a label from the collection.
     *
     * @memberof LabelCollection
     *
     * @param {Label} label The label to remove.
     *
     * @return {Boolean} <code>true</code> if the label was removed; <code>false</code> if the label was not found in the collection.
     *
     * @performance Calling <code>remove</code> is expected constant time.  However, when
     * {@link LabelCollection#update} is called, the collection's vertex buffer
     * is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.  For
     * best performance, remove as many labels as possible before calling <code>update</code>.
     * If you intend to temporarily hide a label, it is usually more efficient to call
     * {@link Label#setShow} instead of removing and re-adding the label.
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see LabelCollection#add
     * @see LabelCollection#removeAll
     * @see LabelCollection#update
     * @see Label#setShow
     *
     * @example
     * var l = labels.add(...);
     * labels.remove(l);  // Returns true
     */
    LabelCollection.prototype.remove = function(label) {
        if (label && (label._getCollection() === this)) {
            this._labels[label._index] = null;
            // Removed later
            this._labelsRemoved = true;
            label._destroy();

            return true;
        }

        return false;
    };

    /**
     * Removes all labels from the collection.
     *
     * @memberof LabelCollection
     *
     * @performance <code>O(n)</code>.  It is more efficient to remove all the labels
     * from a collection and then add new ones than to create a new collection entirely.
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see LabelCollection#add
     * @see LabelCollection#remove
     * @see LabelCollection#update
     *
     * @example
     * labels.add(...);
     * labels.add(...);
     * labels.removeAll();
     */
    LabelCollection.prototype.removeAll = function() {
        this._destroyLabels();
        this._labels = [];
        this._labelsRemoved = false;
        this._updateTextureAtlas = true;
    };

    LabelCollection.prototype._removeLabels = function() {
        if (this._labelsRemoved) {
            this._labelsRemoved = false;

            var labels = [];
            var length = this._labels.length;
            for ( var i = 0, j = 0; i < length; ++i) {
                var label = this._labels[i];
                if (label) {
                    label._index = j++;
                    labels.push(label);
                }
            }
            this._labels = labels;
        }
    };

    /**
     * DOC_TBA
     *
     * @memberof LabelCollection
     *
     * @param {Object} label DOC_TBA
     *
     * @see LabelCollection#get
     */
    LabelCollection.prototype.contains = function(label) {
        if (label) {
            var labels = this._labels;
            var length = labels.length;
            for ( var i = 0; i < length; i++) {
                if (labels[i] === label) {
                    return true;
                }
            }
        }

        return false;
    };

    /**
     * Returns the label in the collection at the specified index.  Indices are zero-based
     * and increase as labels are added.  Removing a label shifts all labels after
     * it to the left, changing their indices.  This function is commonly used with
     * {@link LabelCollection#getLength} to iterate over all the labels
     * in the collection.
     *
     * @memberof LabelCollection
     *
     * @param {Number} index The zero-based index of the billboard.
     *
     * @return {Label} The label at the specified index.
     *
     * @performance Expected constant time.  If labels were removed from the collection and
     * {@link LabelCollection#update} was not called, an implicit <code>O(n)</code>
     * operation is performed.
     *
     * @exception {DeveloperError} index is required.
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see LabelCollection#getLength
     *
     * @example
     * // Toggle the show property of every label in the collection
     * var len = labels.getLength();
     * for (var i = 0; i < len; ++i) {
     *   var l = billboards.get(i);
     *   l.setShow(!l.getShow());
     * }
     */
    LabelCollection.prototype.get = function(index) {
        if (typeof index === 'undefined') {
            throw new DeveloperError('index is required.');
        }

        this._removeLabels();
        return this._labels[index];
    };

    /**
     * Returns the number of labels in this collection.  This is commonly used with
     * {@link LabelCollection#get} to iterate over all the labels
     * in the collection.
     *
     * @memberof LabelCollection
     *
     * @return {Number} The number of labels in this collection.
     *
     * @performance Expected constant time.  If labels were removed from the collection and
     * {@link LabelCollection#update} was not called, an implicit <code>O(n)</code>
     * operation is performed.
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see LabelCollection#get
     *
     * @example
     * // Toggle the show property of every label in the collection
     * var len = labels.getLength();
     * for (var i = 0; i < len; ++i) {
     *   var l = billboards.get(i);
     *   l.setShow(!l.getShow());
     * }
     */
    LabelCollection.prototype.getLength = function() {
        this._removeLabels();
        return this._labels.length;
    };

    /**
     * @private
     */
    LabelCollection.prototype.update = function(context, sceneState) {
        this._billboardCollection.modelMatrix = this.modelMatrix;
        this._billboardCollection.morphTime = this.morphTime;
        this._billboardCollection.bufferUsage = this.bufferUsage;
        this._removeLabels();

        if (this._updateTextureAtlas) {
            this._updateTextureAtlas = false;

            //Determines which subset of images are new to the texture atlas.
            var textureAtlas = this._billboardCollection.getTextureAtlas();
            var images = this._canvasContainer.getItems();
            var numImagesOld = (typeof textureAtlas !== 'undefined') ? textureAtlas.getNumberOfImages() : 0;
            var numImagesNew = images.length;
            var newImages = images.slice(numImagesOld);
            var difference = numImagesNew - numImagesOld;

            // First time creating texture atlas or removing images from the texture atlas.
            if ((numImagesOld === 0 && numImagesNew > 0) || difference < 0) {
                textureAtlas = textureAtlas && textureAtlas.destroy();
                textureAtlas = context.createTextureAtlas({images : images});
                this._billboardCollection.setTextureAtlas(textureAtlas);
            }
            // Adding one new image to the texture atlas.
            else if (difference === 1) {
                textureAtlas.addImage(newImages[0]);
            }
            // Adding multiple new images to the texture atlas.
            else if (difference > 1) {
                textureAtlas.addImages(newImages);
            }
        }

        this._billboardCollection.update(context, sceneState);
    };

    /**
     * Renders the labels.  In order for changes to properties to be realized,
     * {@link LabelCollection#update} must be called before <code>render</code>.
     * <br /><br />
     * Labels are rendered in a single pass using an uber-shader with a texture atlas, where
     * each image in the atlas corresponds to one label.
     *
     * @memberof LabelCollection
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see LabelCollection#update
     */
    LabelCollection.prototype.render = function(context) {
        this._billboardCollection.render(context);
    };

    /**
     * @private
     */
    LabelCollection.prototype.updateForPick = function(context) {
        this._billboardCollection.updateForPick(context);
    };

    /**
     * DOC_TBA
     * @memberof LabelCollection
     */
    LabelCollection.prototype.renderForPick = function(context, framebuffer) {
        this._billboardCollection.renderForPick(context, framebuffer);
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof LabelCollection
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see LabelCollection#destroy
     */
    LabelCollection.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof LabelCollection
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see LabelCollection#isDestroyed
     *
     * @example
     * labels = labels && labels.destroy();
     */
    LabelCollection.prototype.destroy = function() {
        this._destroyLabels();

        this._billboardCollection = this._billboardCollection && this._billboardCollection.destroy();

        return destroyObject(this);
    };

    LabelCollection.prototype._destroyLabels = function() {
        var labels = this._labels;
        var length = labels.length;
        for ( var i = 0; i < length; ++i) {
            if (labels[i]) {
                labels[i]._destroy();
            }
        }
    };

    return LabelCollection;
});
/*global define*/
define('DynamicScene/DynamicLabelVisualizer',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/Color',
        '../Core/Cartesian2',
        '../Core/Cartesian3',
        '../Scene/LabelCollection',
        '../Scene/LabelStyle',
        '../Scene/HorizontalOrigin',
        '../Scene/VerticalOrigin'
    ], function(
        DeveloperError,
        destroyObject,
        Color,
        Cartesian2,
        Cartesian3,
        LabelCollection,
        LabelStyle,
        HorizontalOrigin,
        VerticalOrigin) {
    

    /**
     * A DynamicObject visualizer which maps the DynamicLabel instance
     * in DynamicObject.label to a Label primitive.
     * @alias DynamicLabelVisualizer
     * @constructor
     *
     * @param {Scene} scene The scene the primitives will be rendered in.
     * @param {DynamicObjectCollection} [dynamicObjectCollection] The dynamicObjectCollection to visualize.
     *
     * @exception {DeveloperError} scene is required.
     *
     * @see DynamicLabel
     * @see Scene
     * @see DynamicObject
     * @see DynamicObjectCollection
     * @see CompositeDynamicObjectCollection
     * @see VisualizerCollection
     * @see DynamicBillboardVisualizer
     * @see DynamicConeVisualizer
     * @see DynamicConeVisualizerUsingCustomSensorr
     * @see DynamicPointVisualizer
     * @see DynamicPolygonVisualizer
     * @see DynamicPolylineVisualizer
     * @see DynamicPyramidVisualizer
     *
     */
    var DynamicLabelVisualizer = function(scene, dynamicObjectCollection) {
        if (typeof scene === 'undefined') {
            throw new DeveloperError('scene is required.');
        }
        this._scene = scene;
        this._unusedIndexes = [];
        this._dynamicObjectCollection = undefined;

        var labelCollection = this._labelCollection = new LabelCollection();
        scene.getPrimitives().add(labelCollection);
        this.setDynamicObjectCollection(dynamicObjectCollection);
    };

    /**
     * Returns the scene being used by this visualizer.
     *
     * @returns {Scene} The scene being used by this visualizer.
     */
    DynamicLabelVisualizer.prototype.getScene = function() {
        return this._scene;
    };

    /**
     * Gets the DynamicObjectCollection being visualized.
     *
     * @returns {DynamicObjectCollection} The DynamicObjectCollection being visualized.
     */
    DynamicLabelVisualizer.prototype.getDynamicObjectCollection = function() {
        return this._dynamicObjectCollection;
    };

    /**
     * Sets the DynamicObjectCollection to visualize.
     *
     * @param dynamicObjectCollection The DynamicObjectCollection to visualizer.
     */
    DynamicLabelVisualizer.prototype.setDynamicObjectCollection = function(dynamicObjectCollection) {
        var oldCollection = this._dynamicObjectCollection;
        if (oldCollection !== dynamicObjectCollection) {
            if (typeof oldCollection !== 'undefined') {
                oldCollection.objectsRemoved.removeEventListener(DynamicLabelVisualizer.prototype._onObjectsRemoved);
                this.removeAllPrimitives();
            }
            this._dynamicObjectCollection = dynamicObjectCollection;
            if (typeof dynamicObjectCollection !== 'undefined') {
                dynamicObjectCollection.objectsRemoved.addEventListener(DynamicLabelVisualizer.prototype._onObjectsRemoved, this);
            }
        }
    };

    /**
     * Updates all of the primitives created by this visualizer to match their
     * DynamicObject counterpart at the given time.
     *
     * @param {JulianDate} time The time to update to.
     *
     * @exception {DeveloperError} time is required.
     */
    DynamicLabelVisualizer.prototype.update = function(time) {
        if (typeof time === 'undefined') {
            throw new DeveloperError('time is requied.');
        }
        if (typeof this._dynamicObjectCollection !== 'undefined') {
            var dynamicObjects = this._dynamicObjectCollection.getObjects();
            for ( var i = 0, len = dynamicObjects.length; i < len; i++) {
                this._updateObject(time, dynamicObjects[i]);
            }
        }
    };

    /**
     * Removes all primitives from the scene.
     */
    DynamicLabelVisualizer.prototype.removeAllPrimitives = function() {
        this._unusedIndexes = [];
        this._labelCollection.removeAll();
        if (typeof this._dynamicObjectCollection !== 'undefined') {
            var dynamicObjects = this._dynamicObjectCollection.getObjects();
            for ( var i = dynamicObjects.length - 1; i > -1; i--) {
                dynamicObjects[i]._labelVisualizerIndex = undefined;
            }
        }
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof DynamicLabelVisualizer
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see DynamicLabelVisualizer#destroy
     */
    DynamicLabelVisualizer.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof DynamicLabelVisualizer
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see DynamicLabelVisualizer#isDestroyed
     *
     * @example
     * visualizer = visualizer && visualizer.destroy();
     */
    DynamicLabelVisualizer.prototype.destroy = function() {
        this.removeAllPrimitives();
        this._scene.getPrimitives().remove(this._labelCollection);
        return destroyObject(this);
    };

    var position;
    var fillColor;
    var outlineColor;
    var eyeOffset;
    var pixelOffset;
    DynamicLabelVisualizer.prototype._updateObject = function(time, dynamicObject) {
        var dynamicLabel = dynamicObject.label;
        if (typeof dynamicLabel === 'undefined') {
            return;
        }

        var textProperty = dynamicLabel.text;
        if (typeof textProperty === 'undefined') {
            return;
        }

        var positionProperty = dynamicObject.position;
        if (typeof positionProperty === 'undefined') {
            return;
        }

        var label;
        var showProperty = dynamicLabel.show;
        var labelVisualizerIndex = dynamicObject._labelVisualizerIndex;
        var show = dynamicObject.isAvailable(time) && (typeof showProperty === 'undefined' || showProperty.getValue(time));

        if (!show) {
            //don't bother creating or updating anything else
            if (typeof labelVisualizerIndex !== 'undefined') {
                label = this._labelCollection.get(labelVisualizerIndex);
                label.setShow(false);
                this._unusedIndexes.push(labelVisualizerIndex);
                dynamicObject._labelVisualizerIndex = undefined;
            }
            return;
        }

        if (typeof labelVisualizerIndex === 'undefined') {
            var unusedIndexes = this._unusedIndexes;
            var length = unusedIndexes.length;
            if (length > 0) {
                labelVisualizerIndex = unusedIndexes.pop();
                label = this._labelCollection.get(labelVisualizerIndex);
            } else {
                labelVisualizerIndex = this._labelCollection.getLength();
                label = this._labelCollection.add();
            }
            dynamicObject._labelVisualizerIndex = labelVisualizerIndex;
            label.dynamicObject = dynamicObject;

            // CZML_TODO Determine official defaults
            label.setText('');
            label.setScale(1.0);
            label.setFont('30px sans-serif');
            label.setFillColor(Color.WHITE);
            label.setOutlineColor(Color.BLACK);
            label.setStyle(LabelStyle.FILL);
            label.setPixelOffset(Cartesian2.ZERO);
            label.setEyeOffset(Cartesian3.ZERO);
            label.setHorizontalOrigin(HorizontalOrigin.CENTER);
            label.setVerticalOrigin(VerticalOrigin.CENTER);
        } else {
            label = this._labelCollection.get(labelVisualizerIndex);
        }

        label.setShow(show);

        var text = textProperty.getValue(time);
        if (typeof text !== 'undefined') {
            label.setText(text);
        }

        position = positionProperty.getValueCartesian(time, position);
        if (typeof position !== 'undefined') {
            label.setPosition(position);
        }

        var property = dynamicLabel.scale;
        if (typeof property !== 'undefined') {
            var scale = property.getValue(time);
            if (typeof scale !== 'undefined') {
                label.setScale(scale);
            }
        }

        property = dynamicLabel.font;
        if (typeof property !== 'undefined') {
            var font = property.getValue(time);
            if (typeof font !== 'undefined') {
                label.setFont(font);
            }
        }

        property = dynamicLabel.fillColor;
        if (typeof property !== 'undefined') {
            fillColor = property.getValue(time, fillColor);
            if (typeof fillColor !== 'undefined') {
                label.setFillColor(fillColor);
            }
        }

        property = dynamicLabel.outlineColor;
        if (typeof property !== 'undefined') {
            outlineColor = property.getValue(time, outlineColor);
            if (typeof outlineColor !== 'undefined') {
                label.setOutlineColor(outlineColor);
            }
        }

        property = dynamicLabel.style;
        if (typeof property !== 'undefined') {
            var style = property.getValue(time);
            if (typeof style !== 'undefined') {
                label.setStyle(style);
            }
        }

        property = dynamicLabel.pixelOffset;
        if (typeof property !== 'undefined') {
            pixelOffset = property.getValue(time, pixelOffset);
            if (typeof pixelOffset !== 'undefined') {
                label.setPixelOffset(pixelOffset);
            }
        }

        property = dynamicLabel.eyeOffset;
        if (typeof property !== 'undefined') {
            eyeOffset = property.getValue(time, eyeOffset);
            if (typeof eyeOffset !== 'undefined') {
                label.setEyeOffset(eyeOffset);
            }
        }

        property = dynamicLabel.horizontalOrigin;
        if (typeof property !== 'undefined') {
            var horizontalOrigin = property.getValue(time);
            if (typeof horizontalOrigin !== 'undefined') {
                label.setHorizontalOrigin(horizontalOrigin);
            }
        }

        property = dynamicLabel.verticalOrigin;
        if (typeof property !== 'undefined') {
            var verticalOrigin = property.getValue(time);
            if (typeof verticalOrigin !== 'undefined') {
                label.setVerticalOrigin(verticalOrigin);
            }
        }
    };

    DynamicLabelVisualizer.prototype._onObjectsRemoved = function(dynamicObjectCollection, dynamicObjects) {
        var thisLabelCollection = this._labelCollection;
        var thisUnusedIndexes = this._unusedIndexes;
        for ( var i = dynamicObjects.length - 1; i > -1; i--) {
            var dynamicObject = dynamicObjects[i];
            var labelVisualizerIndex = dynamicObject._labelVisualizerIndex;
            if (typeof labelVisualizerIndex !== 'undefined') {
                var label = thisLabelCollection.get(labelVisualizerIndex);
                label.setShow(false);
                thisUnusedIndexes.push(labelVisualizerIndex);
                dynamicObject._labelVisualizerIndex = undefined;
            }
        }
    };

    return DynamicLabelVisualizer;
});
/** @license MIT License (c) copyright B Cavalier & J Hann */

/**
 * when
 * A lightweight CommonJS Promises/A and when() implementation
 *
 * when is part of the cujo.js family of libraries (http://cujojs.com/)
 *
 * Licensed under the MIT License at:
 * http://www.opensource.org/licenses/mit-license.php
 *
 * @version 1.3.0
 */

(function(define) {
define('ThirdParty/when',[],function() {
	var freeze, reduceArray, slice, undef;

	//
	// Public API
	//

	when.defer     = defer;
	when.reject    = reject;
	when.isPromise = isPromise;

	when.all       = all;
	when.some      = some;
	when.any       = any;

	when.map       = map;
	when.reduce    = reduce;

	when.chain     = chain;

	/** Object.freeze */
	freeze = Object.freeze || function(o) { return o; };

	/**
	 * Trusted Promise constructor.  A Promise created from this constructor is
	 * a trusted when.js promise.  Any other duck-typed promise is considered
	 * untrusted.
	 *
	 * @constructor
	 */
	function Promise() {}

	Promise.prototype = freeze({
		always: function(alwaysback, progback) {
			return this.then(alwaysback, alwaysback, progback);
		},

		otherwise: function(errback) {
			return this.then(undef, errback);
		}
	});

	/**
	 * Create an already-resolved promise for the supplied value
	 * @private
	 *
	 * @param value anything
	 * @return {Promise}
	 */
	function resolved(value) {

		var p = new Promise();

		p.then = function(callback) {
			try {
				return promise(callback ? callback(value) : value);
			} catch(e) {
				return rejected(e);
			}
		};

		return freeze(p);
	}

	/**
	 * Create an already-rejected {@link Promise} with the supplied
	 * rejection reason.
	 * @private
	 *
	 * @param reason rejection reason
	 * @return {Promise}
	 */
	function rejected(reason) {

		var p = new Promise();

		p.then = function(callback, errback) {
			try {
				return errback ? promise(errback(reason)) : rejected(reason);
			} catch(e) {
				return rejected(e);
			}
		};

		return freeze(p);
	}

	/**
	 * Returns a rejected promise for the supplied promiseOrValue. If
	 * promiseOrValue is a value, it will be the rejection value of the
	 * returned promise.  If promiseOrValue is a promise, its
	 * completion value will be the rejected value of the returned promise
	 *
	 * @param promiseOrValue {*} the rejected value of the returned {@link Promise}
	 *
	 * @return {Promise} rejected {@link Promise}
	 */
	function reject(promiseOrValue) {
		return when(promiseOrValue, function(value) {
			return rejected(value);
		});
	}

	/**
	 * Creates a new, CommonJS compliant, Deferred with fully isolated
	 * resolver and promise parts, either or both of which may be given out
	 * safely to consumers.
	 * The Deferred itself has the full API: resolve, reject, progress, and
	 * then. The resolver has resolve, reject, and progress.  The promise
	 * only has then.
	 *
	 * @memberOf when
	 * @function
	 *
	 * @returns {Deferred}
	 */
	function defer() {
		var deferred, promise, listeners, progressHandlers, _then, _progress, complete;

		listeners = [];
		progressHandlers = [];

		/**
		 * Pre-resolution then() that adds the supplied callback, errback, and progback
		 * functions to the registered listeners
		 *
		 * @private
		 *
		 * @param [callback] {Function} resolution handler
		 * @param [errback] {Function} rejection handler
		 * @param [progback] {Function} progress handler
		 *
		 * @throws {Error} if any argument is not null, undefined, or a Function
		 */
		_then = function unresolvedThen(callback, errback, progback) {
			var deferred = defer();

			listeners.push(function(promise) {
				promise.then(callback, errback)
					.then(deferred.resolve, deferred.reject, deferred.progress);
			});

			progback && progressHandlers.push(progback);

			return deferred.promise;
		};

		/**
		 * Registers a handler for this {@link Deferred}'s {@link Promise}.  Even though all arguments
		 * are optional, each argument that *is* supplied must be null, undefined, or a Function.
		 * Any other value will cause an Error to be thrown.
		 *
		 * @memberOf Promise
		 *
		 * @param [callback] {Function} resolution handler
		 * @param [errback] {Function} rejection handler
		 * @param [progback] {Function} progress handler
		 *
		 * @throws {Error} if any argument is not null, undefined, or a Function
		 */
		function then(callback, errback, progback) {
			return _then(callback, errback, progback);
		}

		/**
		 * Resolves this {@link Deferred}'s {@link Promise} with val as the
		 * resolution value.
		 *
		 * @memberOf Resolver
		 *
		 * @param val anything
		 */
		function resolve(val) {
			complete(resolved(val));
		}

		/**
		 * Rejects this {@link Deferred}'s {@link Promise} with err as the
		 * reason.
		 *
		 * @memberOf Resolver
		 *
		 * @param err anything
		 */
		function reject(err) {
			complete(rejected(err));
		}

		/**
		 * @private
		 * @param update
		 */
		_progress = function(update) {
			var progress, i = 0;
			while (progress = progressHandlers[i++]) progress(update);
		};

		/**
		 * Emits a progress update to all progress observers registered with
		 * this {@link Deferred}'s {@link Promise}
		 *
		 * @memberOf Resolver
		 *
		 * @param update anything
		 */
		function progress(update) {
			_progress(update);
		}

		/**
		 * Transition from pre-resolution state to post-resolution state, notifying
		 * all listeners of the resolution or rejection
		 *
		 * @private
		 *
		 * @param completed {Promise} the completed value of this deferred
		 */
		complete = function(completed) {
			var listener, i = 0;

			// Replace _then with one that directly notifies with the result.
			_then = completed.then;

			// Replace complete so that this Deferred can only be completed
			// once. Also Replace _progress, so that subsequent attempts to issue
			// progress throw.
			complete = _progress = function alreadyCompleted() {
				// TODO: Consider silently returning here so that parties who
				// have a reference to the resolver cannot tell that the promise
				// has been resolved using try/catch
				throw new Error("already completed");
			};

			// Free progressHandlers array since we'll never issue progress events
			// for this promise again now that it's completed
			progressHandlers = undef;

			// Notify listeners
			// Traverse all listeners registered directly with this Deferred

			while (listener = listeners[i++]) {
				listener(completed);
			}

			listeners = [];
		};

		/**
		 * The full Deferred object, with both {@link Promise} and {@link Resolver}
		 * parts
		 * @class Deferred
		 * @name Deferred
		 */
		deferred = {};

		// Promise and Resolver parts
		// Freeze Promise and Resolver APIs

		promise = new Promise();
		promise.then = deferred.then = then;

		/**
		 * The {@link Promise} for this {@link Deferred}
		 * @memberOf Deferred
		 * @name promise
		 * @type {Promise}
		 */
		deferred.promise = freeze(promise);

		/**
		 * The {@link Resolver} for this {@link Deferred}
		 * @memberOf Deferred
		 * @name resolver
		 * @class Resolver
		 */
		deferred.resolver = freeze({
			resolve:  (deferred.resolve  = resolve),
			reject:   (deferred.reject   = reject),
			progress: (deferred.progress = progress)
		});

		return deferred;
	}

	/**
	 * Determines if promiseOrValue is a promise or not.  Uses the feature
	 * test from http://wiki.commonjs.org/wiki/Promises/A to determine if
	 * promiseOrValue is a promise.
	 *
	 * @param promiseOrValue anything
	 *
	 * @returns {Boolean} true if promiseOrValue is a {@link Promise}
	 */
	function isPromise(promiseOrValue) {
		return promiseOrValue && typeof promiseOrValue.then === 'function';
	}

	/**
	 * Register an observer for a promise or immediate value.
	 *
	 * @function
	 * @name when
	 * @namespace
	 *
	 * @param promiseOrValue anything
	 * @param {Function} [callback] callback to be called when promiseOrValue is
	 *   successfully resolved.  If promiseOrValue is an immediate value, callback
	 *   will be invoked immediately.
	 * @param {Function} [errback] callback to be called when promiseOrValue is
	 *   rejected.
	 * @param {Function} [progressHandler] callback to be called when progress updates
	 *   are issued for promiseOrValue.
	 *
	 * @returns {Promise} a new {@link Promise} that will complete with the return
	 *   value of callback or errback or the completion value of promiseOrValue if
	 *   callback and/or errback is not supplied.
	 */
	function when(promiseOrValue, callback, errback, progressHandler) {
		// Get a promise for the input promiseOrValue
		// See promise()
		var trustedPromise = promise(promiseOrValue);

		// Register promise handlers
		return trustedPromise.then(callback, errback, progressHandler);
	}

	/**
	 * Returns promiseOrValue if promiseOrValue is a {@link Promise}, a new Promise if
	 * promiseOrValue is a foreign promise, or a new, already-resolved {@link Promise}
	 * whose resolution value is promiseOrValue if promiseOrValue is an immediate value.
	 *
	 * Note that this function is not safe to export since it will return its
	 * input when promiseOrValue is a {@link Promise}
	 *
	 * @private
	 *
	 * @param promiseOrValue anything
	 *
	 * @returns Guaranteed to return a trusted Promise.  If promiseOrValue is a when.js {@link Promise}
	 *   returns promiseOrValue, otherwise, returns a new, already-resolved, when.js {@link Promise}
	 *   whose resolution value is:
	 *   * the resolution value of promiseOrValue if it's a foreign promise, or
	 *   * promiseOrValue if it's a value
	 */
	function promise(promiseOrValue) {
		var promise, deferred;

		if(promiseOrValue instanceof Promise) {
			// It's a when.js promise, so we trust it
			promise = promiseOrValue;

		} else {
			// It's not a when.js promise.  Check to see if it's a foreign promise
			// or a value.

			deferred = defer();
			if(isPromise(promiseOrValue)) {
				// It's a compliant promise, but we don't know where it came from,
				// so we don't trust its implementation entirely.  Introduce a trusted
				// middleman when.js promise

				// IMPORTANT: This is the only place when.js should ever call .then() on
				// an untrusted promise.
				promiseOrValue.then(deferred.resolve, deferred.reject, deferred.progress);
				promise = deferred.promise;

			} else {
				// It's a value, not a promise.  Create an already-resolved promise
				// for it.
				deferred.resolve(promiseOrValue);
				promise = deferred.promise;
			}
		}

		return promise;
	}

	/**
	 * Return a promise that will resolve when howMany of the supplied promisesOrValues
	 * have resolved. The resolution value of the returned promise will be an array of
	 * length howMany containing the resolutions values of the triggering promisesOrValues.
	 *
	 * @memberOf when
	 *
	 * @param promisesOrValues {Array} array of anything, may contain a mix
	 *      of {@link Promise}s and values
	 * @param howMany
	 * @param [callback]
	 * @param [errback]
	 * @param [progressHandler]
	 *
	 * @returns {Promise}
	 */
	function some(promisesOrValues, howMany, callback, errback, progressHandler) {

		checkCallbacks(2, arguments);

		return when(promisesOrValues, function(promisesOrValues) {

			var toResolve, results, ret, deferred, resolver, rejecter, handleProgress, len, i;

			len = promisesOrValues.length >>> 0;

			toResolve = Math.max(0, Math.min(howMany, len));
			results = [];
			deferred = defer();
			ret = when(deferred, callback, errback, progressHandler);

			// Wrapper so that resolver can be replaced
			function resolve(val) {
				resolver(val);
			}

			// Wrapper so that rejecter can be replaced
			function reject(err) {
				rejecter(err);
			}

			// Wrapper so that progress can be replaced
			function progress(update) {
				handleProgress(update);
			}

			function complete() {
				resolver = rejecter = handleProgress = noop;
			}

			// No items in the input, resolve immediately
			if (!toResolve) {
				deferred.resolve(results);

			} else {
				// Resolver for promises.  Captures the value and resolves
				// the returned promise when toResolve reaches zero.
				// Overwrites resolver var with a noop once promise has
				// be resolved to cover case where n < promises.length
				resolver = function(val) {
					// This orders the values based on promise resolution order
					// Another strategy would be to use the original position of
					// the corresponding promise.
					results.push(val);

					if (!--toResolve) {
						complete();
						deferred.resolve(results);
					}
				};

				// Rejecter for promises.  Rejects returned promise
				// immediately, and overwrites rejecter var with a noop
				// once promise to cover case where n < promises.length.
				// TODO: Consider rejecting only when N (or promises.length - N?)
				// promises have been rejected instead of only one?
				rejecter = function(err) {
					complete();
					deferred.reject(err);
				};

				handleProgress = deferred.progress;

				// TODO: Replace while with forEach
				for(i = 0; i < len; ++i) {
					if(i in promisesOrValues) {
						when(promisesOrValues[i], resolve, reject, progress);
					}
				}
			}

			return ret;
		});
	}

	/**
	 * Return a promise that will resolve only once all the supplied promisesOrValues
	 * have resolved. The resolution value of the returned promise will be an array
	 * containing the resolution values of each of the promisesOrValues.
	 *
	 * @memberOf when
	 *
	 * @param promisesOrValues {Array|Promise} array of anything, may contain a mix
	 *      of {@link Promise}s and values
	 * @param [callback] {Function}
	 * @param [errback] {Function}
	 * @param [progressHandler] {Function}
	 *
	 * @returns {Promise}
	 */
	function all(promisesOrValues, callback, errback, progressHandler) {

		checkCallbacks(1, arguments);

		return when(promisesOrValues, function(promisesOrValues) {
			return _reduce(promisesOrValues, reduceIntoArray, []);
		}).then(callback, errback, progressHandler);
	}

	function reduceIntoArray(current, val, i) {
		current[i] = val;
		return current;
	}

	/**
	 * Return a promise that will resolve when any one of the supplied promisesOrValues
	 * has resolved. The resolution value of the returned promise will be the resolution
	 * value of the triggering promiseOrValue.
	 *
	 * @memberOf when
	 *
	 * @param promisesOrValues {Array|Promise} array of anything, may contain a mix
	 *      of {@link Promise}s and values
	 * @param [callback] {Function}
	 * @param [errback] {Function}
	 * @param [progressHandler] {Function}
	 *
	 * @returns {Promise}
	 */
	function any(promisesOrValues, callback, errback, progressHandler) {

		function unwrapSingleResult(val) {
			return callback ? callback(val[0]) : val[0];
		}

		return some(promisesOrValues, 1, unwrapSingleResult, errback, progressHandler);
	}

	/**
	 * Traditional map function, similar to `Array.prototype.map()`, but allows
	 * input to contain {@link Promise}s and/or values, and mapFunc may return
	 * either a value or a {@link Promise}
	 *
	 * @memberOf when
	 *
	 * @param promise {Array|Promise} array of anything, may contain a mix
	 *      of {@link Promise}s and values
	 * @param mapFunc {Function} mapping function mapFunc(value) which may return
	 *      either a {@link Promise} or value
	 *
	 * @returns {Promise} a {@link Promise} that will resolve to an array containing
	 *      the mapped output values.
	 */
	function map(promise, mapFunc) {
		return when(promise, function(array) {
			return _map(array, mapFunc);
		});
	}

	/**
	 * Private map helper to map an array of promises
	 * @private
	 *
	 * @param promisesOrValues {Array}
	 * @param mapFunc {Function}
	 * @return {Promise}
	 */
	function _map(promisesOrValues, mapFunc) {

		var results, len, i;

		// Since we know the resulting length, we can preallocate the results
		// array to avoid array expansions.
		len = promisesOrValues.length >>> 0;
		results = new Array(len);

		// Since mapFunc may be async, get all invocations of it into flight
		// asap, and then use reduce() to collect all the results
		for(i = 0; i < len; i++) {
			if(i in promisesOrValues)
				results[i] = when(promisesOrValues[i], mapFunc);
		}

		// Could use all() here, but that would result in another array
		// being allocated, i.e. map() would end up allocating 2 arrays
		// of size len instead of just 1.  Since all() uses reduce()
		// anyway, avoid the additional allocation by calling reduce
		// directly.
		return _reduce(results, reduceIntoArray, results);
	}

	/**
	 * Traditional reduce function, similar to `Array.prototype.reduce()`, but
	 * input may contain {@link Promise}s and/or values, and reduceFunc
	 * may return either a value or a {@link Promise}, *and* initialValue may
	 * be a {@link Promise} for the starting value.
	 *
	 * @memberOf when
	 *
	 * @param promise {Array|Promise} array of anything, may contain a mix
	 *      of {@link Promise}s and values.  May also be a {@link Promise} for
	 *      an array.
	 * @param reduceFunc {Function} reduce function reduce(currentValue, nextValue, index, total),
	 *      where total is the total number of items being reduced, and will be the same
	 *      in each call to reduceFunc.
	 * @param initialValue starting value, or a {@link Promise} for the starting value
	 *
	 * @returns {Promise} that will resolve to the final reduced value
	 */
	function reduce(promise, reduceFunc, initialValue) {
		var args = slice.call(arguments, 1);
		return when(promise, function(array) {
			return _reduce.apply(undef, [array].concat(args));
		});
	}

	/**
	 * Private reduce to reduce an array of promises
	 * @private
	 *
	 * @param promisesOrValues {Array}
	 * @param reduceFunc {Function}
	 * @param initialValue {*}
	 * @return {Promise}
	 */
	function _reduce(promisesOrValues, reduceFunc, initialValue) {

		var total, args;

		total = promisesOrValues.length;

		// Skip promisesOrValues, since it will be used as 'this' in the call
		// to the actual reduce engine below.

		// Wrap the supplied reduceFunc with one that handles promises and then
		// delegates to the supplied.

		args = [
			function (current, val, i) {
				return when(current, function (c) {
					return when(val, function (value) {
						return reduceFunc(c, value, i, total);
					});
				});
			}
		];

		if (arguments.length > 2) args.push(initialValue);

		return reduceArray.apply(promisesOrValues, args);
	}

	/**
	 * Ensure that resolution of promiseOrValue will complete resolver with the completion
	 * value of promiseOrValue, or instead with resolveValue if it is provided.
	 *
	 * @memberOf when
	 *
	 * @param promiseOrValue
	 * @param resolver {Resolver}
	 * @param [resolveValue] anything
	 *
	 * @returns {Promise}
	 */
	function chain(promiseOrValue, resolver, resolveValue) {
		var useResolveValue = arguments.length > 2;

		return when(promiseOrValue,
			function(val) {
				if(useResolveValue) val = resolveValue;
				resolver.resolve(val);
				return val;
			},
			function(e) {
				resolver.reject(e);
				return rejected(e);
			},
			resolver.progress
		);
	}

	//
	// Utility functions
	//

	/**
	 * Helper that checks arrayOfCallbacks to ensure that each element is either
	 * a function, or null or undefined.
	 *
	 * @private
	 *
	 * @param arrayOfCallbacks {Array} array to check
	 * @throws {Error} if any element of arrayOfCallbacks is something other than
	 * a Functions, null, or undefined.
	 */
	function checkCallbacks(start, arrayOfCallbacks) {
		var arg, i = arrayOfCallbacks.length;
		while(i > start) {
			arg = arrayOfCallbacks[--i];
			if (arg != null && typeof arg != 'function') throw new Error('callback is not a function');
		}
	}

	/**
	 * No-Op function used in method replacement
	 * @private
	 */
	function noop() {}

	slice = [].slice;

	// ES5 reduce implementation if native not available
	// See: http://es5.github.com/#x15.4.4.21 as there are many
	// specifics and edge cases.
	reduceArray = [].reduce ||
		function(reduceFunc /*, initialValue */) {
			// ES5 dictates that reduce.length === 1

			// This implementation deviates from ES5 spec in the following ways:
			// 1. It does not check if reduceFunc is a Callable

			var arr, args, reduced, len, i;

			i = 0;
			arr = Object(this);
			len = arr.length >>> 0;
			args = arguments;

			// If no initialValue, use first item of array (we know length !== 0 here)
			// and adjust i to start at second item
			if(args.length <= 1) {
				// Skip to the first real element in the array
				for(;;) {
					if(i in arr) {
						reduced = arr[i++];
						break;
					}

					// If we reached the end of the array without finding any real
					// elements, it's a TypeError
					if(++i >= len) {
						throw new TypeError();
					}
				}
			} else {
				// If initialValue provided, use it
				reduced = args[1];
			}

			// Do the actual reduce
			for(;i < len; ++i) {
				// Skip holes
				if(i in arr)
					reduced = reduceFunc(reduced, arr[i], i, arr);
			}

			return reduced;
		};

	return when;
});
})(typeof define == 'function'
	? define
	: function (factory) { typeof module != 'undefined'
		? (module.exports = factory())
		: (this.when      = factory());
	}
	// Boilerplate for AMD, Node, and browser global
);
/*global define*/
define('Core/jsonp',[
        './defaultValue',
        './DeveloperError',
        '../ThirdParty/when'
    ], function(
        defaultValue,
        DeveloperError,
        when) {
    

    function pushQueryParameter(array, name, value) {
        array.push(encodeURIComponent(name) + '=' + encodeURIComponent(value));
    }

    /**
     * Requests a resource using JSONP.
     *
     * @exports jsonp
     *
     * @param {String} url The URL to request.
     * @param {Object} [options.parameters] Any extra query parameters to append to the URL.
     * @param {String} [options.callbackParameterName='callback'] The callback parameter name that the server expects.
     * @param {Object} [options.proxy] A proxy to use for the request. This object is expected to have a getURL function which returns the proxied URL, if needed.
     *
     * @returns {Object} a promise that will resolve to the requested data when loaded.
     *
     * @see <a href='http://wiki.commonjs.org/wiki/Promises/A'>CommonJS Promises/A</a>
     *
     * @example
     * // load a data asynchronously
     * jsonp('some/webservice').then(function(data) {
     *     // use the loaded data
     * }, function() {
     *     // an error occurred
     * });
     */
    var jsonp = function(url, options) {
        if (typeof url === 'undefined') {
            throw new DeveloperError('url is required.');
        }

        options = defaultValue(options, {});

        var deferred = when.defer();

        //generate a unique function name
        var functionName;
        do {
            functionName = 'jsonp' + Math.random().toString().substring(2, 8);
        } while (typeof window[functionName] !== 'undefined');

        //assign a function with that name in the global scope
        window[functionName] = function(data) {
            deferred.resolve(data);

            try {
                delete window[functionName];
            } catch (e) {
                window[functionName] = undefined;
            }
        };

        var callbackParameterName = defaultValue(options.callbackParameterName, 'callback');
        var queryParts = [];
        pushQueryParameter(queryParts, callbackParameterName, functionName);

        var parameters = defaultValue(options.parameters, {});
        for ( var name in parameters) {
            if (parameters.hasOwnProperty(name)) {
                pushQueryParameter(queryParts, name, parameters[name]);
            }
        }

        if (queryParts.length > 0) {
            if (url.indexOf('?') === -1) {
                url += '?';
            } else {
                url += '&';
            }

            url += queryParts.join('&');
        }

        var proxy = options.proxy;
        if (typeof proxy !== 'undefined') {
            url = proxy.getURL(url);
        }

        var script = document.createElement('script');
        script.async = true;
        script.src = url;

        var head = document.getElementsByTagName('head')[0];
        script.onload = function() {
            script.onload = undefined;
            head.removeChild(script);
        };

        head.appendChild(script);

        return deferred.promise;
    };

    return jsonp;
});
/*global define*/
define('Scene/ArcGISTileProvider',[
        '../Core/DeveloperError',
        '../Core/Extent',
        '../Core/Math',
        '../Core/jsonp',
        './Projections'
    ], function(
        DeveloperError,
        Extent,
        CesiumMath,
        jsonp,
        Projections) {
    

    /**
     * Provides tile images hosted by an ArcGIS Server.
     *
     * @alias ArcGISTileProvider
     * @constructor
     *
     * @param {String} description.host The ArcGIS Server host name.
     * @param {String} [description.instance='/arcgis/rest'] The instance name.
     * @param {String} [description.folder=undefined] The folder where the service is located.
     * @param {String} description.service The service name.
     * @param {Object} [description.proxy=undefined] A proxy to use for requests. This object is expected to have a getURL function which returns the proxied URL, if needed.
     *
     * @exception {DeveloperError} <code>description.host</code> is required.
     * @exception {DeveloperError} <code>description.service</code> is required.
     *
     * @see SingleTileProvider
     * @see BingMapsTileProvider
     * @see OpenStreetMapTileProvider
     * @see CompositeTileProvider
     *
     * @see <a href='http://resources.esri.com/help/9.3/arcgisserver/apis/rest/'>ArcGIS Server REST API</a>
     * @see <a href='http://www.w3.org/TR/cors/'>Cross-Origin Resource Sharing</a>
     *
     * @example
     * // ArcGIS World Street Maps tile provider
     * var esri = new ArcGISTileProvider({
     *     host : 'server.arcgisonline.com',
     *     service : 'World_Street_Map'
     * });
     */
    var ArcGISTileProvider = function(description) {
        var desc = description || {};
        var instance = desc.instance || 'arcgis/rest';

        if (!desc.host) {
            throw new DeveloperError('description.host is required.');
        }

        if (!desc.service) {
            throw new DeveloperError('description.service is required.');
        }

        this._url = 'http://' + desc.host + '/' + instance + '/services/';

        if (desc.folder) {
            this._url += desc.folder + '/';
        }

        this._url += desc.service + '/MapServer';

        /**
         * The ArcGIS Server host name.
         * @type {String}
         */
        this.host = desc.host;

        /**
         * The instance name. The default value is '/arcgis/rest'.
         * @type {String}
         */
        this.instance = instance;

        /**
         * The folder where the service is located.
         * @type {String}
         */
        this.folder = desc.folder;

        /**
         * The service name.
         * @type {String}
         */
        this.service = desc.service;

        this._proxy = desc.proxy;

        // TODO: Get this information from the server

        /**
         * The cartographic extent of the base tile, with north, south, east and
         * west properties in radians.
         *
         * @type {Extent}
         */
        this.maxExtent = new Extent(
            -CesiumMath.PI,
            CesiumMath.toRadians(-85.05112878),
            CesiumMath.PI,
            CesiumMath.toRadians(85.05112878)
        );

        /**
         * The width of every image loaded.
         *
         * @type {Number}
         */
        this.tileWidth = 256;

        /**
         * The height of every image loaded.
         *
         * @type {Number}
         */
        this.tileHeight = 256;

        /**
         * The maximum zoom level that can be requested.
         *
         * @type {Number}
         */
        this.zoomMax = 19;

        /**
         * The minimum zoom level that can be requested.
         *
         * @type {Number}
         */
        this.zoomMin = 0;

        /**
         * The map projection of the image.
         *
         * @type {Enumeration}
         * @see Projections
         */
        this.projection = Projections.MERCATOR;

        this._logo = undefined;
        this._logoLoaded = false;

        var that = this;
        jsonp(this._url, {
            parameters : {
                f : 'json'
            },
            proxy : this._proxy
        }).then(function(data) {
            var credit = data.copyrightText;

            var canvas = document.createElement('canvas');
            canvas.width = 800.0;
            canvas.height = 20.0;

            var context = canvas.getContext('2d');
            context.fillStyle = '#fff';
            context.font = '12px sans-serif';
            context.textBaseline = 'top';
            context.fillText(credit, 0, 0);

            that._logo = canvas;
            that._logoLoaded = true;
        });
    };

    /**
     * Loads the image for <code>tile</code>.
     *
     * @memberof ArcGISTileProvider
     *
     * @param {Tile} tile The tile to load the image for.
     * @param {Function} onload A function that will be called when the image is finished loading.
     * @param {Function} onerror A function that will be called if there is an error loading the image.
     *
     * @exception {DeveloperError} <code>tile.zoom</code> is less than <code>zoomMin</code>
     * or greater than <code>zoomMax</code>.
     */
    ArcGISTileProvider.prototype.loadTileImage = function(tile, onload, onerror) {
        if (tile.zoom < this.zoomMin || tile.zoom > this.zoomMax) {
            throw new DeveloperError('tile.zoom must be between in [zoomMin, zoomMax].');
        }

        var image = new Image();
        image.onload = onload;
        image.onerror = onerror;
        image.crossOrigin = '';

        var url = this._url + '/tile/' + tile.zoom + '/' + tile.y + '/' + tile.x;
        if (typeof this._proxy !== 'undefined') {
            url = this._proxy.getURL(url);
        }

        image.src = url;

        return image;
    };

    /**
     * DOC_TBA
     * @memberof ArcGISTileProvider
     */
    ArcGISTileProvider.prototype.getLogo = function() {
        return (this._logoLoaded) ? this._logo : undefined;
    };

    return ArcGISTileProvider;
});
/*!
   Portions Copyright (c) 2006-2009 Microsoft Corporation.  All rights reserved.

   http://msdn.microsoft.com/en-us/library/bb259689.aspx
   http://msdn.microsoft.com/en-us/cc300389.aspx#O

   MICROSOFT LIMITED PUBLIC LICENSE

   This license governs use of code marked as 'sample' or 'example' available on
   this web site without a license agreement, as provided under the section above
   titled 'NOTICE SPECIFIC TO SOFTWARE AVAILABLE ON THIS WEB SITE.' If you use
   such code (the 'software'), you accept this license. If you do not accept the
   license, do not use the software.

   1. Definitions

   The terms 'reproduce,' 'reproduction,' 'derivative works,' and 'distribution'
   have the same meaning here as under U.S. copyright law.

   A 'contribution' is the original software, or any additions or changes to the software.

   A 'contributor' is any person that distributes its contribution under this license.

   'Licensed patents' are a contributor's patent claims that read directly on its contribution.

   2. Grant of Rights

   (A) Copyright Grant - Subject to the terms of this license, including the license
   conditions and limitations in section 3, each contributor grants you a non-exclusive,
   worldwide, royalty-free copyright license to reproduce its contribution, prepare
   derivative works of its contribution, and distribute its contribution or any
   derivative works that you create.

   (B) Patent Grant - Subject to the terms of this license, including the license
   conditions and limitations in section 3, each contributor grants you a
   non-exclusive, worldwide, royalty-free license under its licensed patents to
   make, have made, use, sell, offer for sale, import, and/or otherwise dispose
   of its contribution in the software or derivative works of the contribution
   in the software.

   3. Conditions and Limitations

   (A) No Trademark License- This license does not grant you rights to use any
   contributors' name, logo, or trademarks.

   (B) If you bring a patent claim against any contributor over patents that
   you claim are infringed by the software, your patent license from such
   contributor to the software ends automatically.

   (C) If you distribute any portion of the software, you must retain all
   copyright, patent, trademark, and attribution notices that are present in
   the software.

   (D) If you distribute any portion of the software in source code form, you
   may do so only under this license by including a complete copy of this license
   with your distribution. If you distribute any portion of the software in
   compiled or object code form, you may only do so under a license that
   complies with this license.

   (E) The software is licensed 'as-is.' You bear the risk of using it. The
   contributors give no express warranties, guarantees or conditions. You may
   have additional consumer rights under your local laws which this license
   cannot change. To the extent permitted under your local laws, the contributors
   exclude the implied warranties of merchantability, fitness for a particular
   purpose and non-infringement.

   (F) Platform Limitation - The licenses granted in sections 2(A) and 2(B)
   extend only to the software or derivative works that you create that run
   on a Microsoft Windows operating system product.
 */
/*global define*/
define('Scene/BingMapsTileProvider',[
        '../Core/DeveloperError',
        '../Core/Extent',
        '../Core/Math',
        '../Core/jsonp',
        './BingMapsStyle',
        './Projections'
    ], function(
        DeveloperError,
        Extent,
        CesiumMath,
        jsonp,
        BingMapsStyle,
        Projections) {
    

    /**
     * Uses the Bing Map imagery API to load images for tiles.
     *
     * @alias BingMapsTileProvider
     * @constructor
     *
     * @param {String} description.server The name of the Bing Maps server hosting the imagery.
     * @param {String} [description.key] An optional Bing Maps key, which can be created at <a href='https://www.bingmapsportal.com/'>https://www.bingmapsportal.com/</a>.
     * @param {Enumeration} [description.mapStyle=BingMapsStyle.AERIAL] The type of Bing Maps imagery to load.
     * @param {Object} [description.proxy=undefined] A proxy to use for requests. This object is expected to have a getURL function which returns the proxied URL, if needed.
     *
     * @exception {DeveloperError} <code>description.server</code> is required.
     *
     * @see SingleTileProvider
     * @see ArcGISTileProvider
     * @see OpenStreetMapTileProvider
     * @see CompositeTileProvider
     *
     * @see <a href='http://msdn.microsoft.com/en-us/library/ff701713.aspx'>Bing Maps REST Services</a>
     * @see <a href='http://www.w3.org/TR/cors/'>Cross-Origin Resource Sharing</a>
     *
     * @example
     * // Bing Maps tile provider
     * var bing = new BingMapsTileProvider({
     *     server : 'dev.virtualearth.net',
     *     mapStyle : BingMapsStyle.AERIAL
     * });
     */
    var BingMapsTileProvider = function(description) {
        var desc = description || {};
        var key = desc.key || 'AquXz3981-1ND5jGs8qQn7R7YUP8qkWi77yZSVM7o3nIvzb-Mg0W2Ta57xuUyywX';
        var mapStyle = desc.mapStyle || BingMapsStyle.AERIAL;

        if (typeof desc.server === 'undefined') {
            throw new DeveloperError('description.server is required.');
        }

        /**
         * The name of the Bing Maps server hosting the imagery.
         * @type {String}
         */
        this.server = desc.server;
        this._server = desc.server;

        /**
         * The Bing Maps key.
         * @type {String}
         */
        this.key = key;
        this._key = key;

        /**
         * The type of Bing Maps imagery to load.
         * @type {Enumeration}
         */
        this.mapStyle = mapStyle;
        this._mapStyle = mapStyle;

        this._proxy = desc.proxy;

        // TODO: The following 5 properties should be set in _requestTemplate.
        //       The may be needed before the response so for now set the default values.

        /**
         * The cartographic extent of the base tile, with north, south, east and
         * west properties in radians.
         *
         * @type {Extent}
         */
        this.maxExtent = new Extent(
            -CesiumMath.PI,
            CesiumMath.toRadians(-85.05112878),
            CesiumMath.PI,
            CesiumMath.toRadians(85.05112878)
        );

        /**
         * The width of every image loaded.
         *
         * @type {Number}
         */
        this.tileWidth = 256;

        /**
         * The height of every image loaded.
         *
         * @type {Number}
         */
        this.tileHeight = 256;

        /**
         * The maximum zoom level that can be requested.
         *
         * @type {Number}
         */
        this.zoomMax = 23;

        /**
         * The minimum zoom level that can be requested.
         *
         * @type {Number}
         */
        this.zoomMin = 1;

        /**
         * The map projection of the image.
         *
         * @type {Enumeration}
         * @see Projections
         */
        this.projection = Projections.MERCATOR;

        this._url = undefined;
        this._deferredQueue = [];
        this._requestTemplate();
    };

    //for a given tile, if we have an element with the same tile in the queue, return the element.
    function findInDeferredQueue(deferredQueue, tile) {
        for ( var i = 0, len = deferredQueue.length; i < len; ++i) {
            var element = deferredQueue[i];
            var t = element.tile;
            if (t.zoom === tile.zoom && t.x === tile.x && t.y === tile.y) {
                return element;
            }
        }
        return undefined;
    }

    /**
     * Converts a tiles (x, y, zoom) position into a quadkey used to request an image
     * from a Bing Maps server.
     *
     * @memberof BingMapsTileProvider
     *
     * @param {Number} x The tile's x coordinate.
     * @param {Number} y The tile's y coordinate.
     * @param {Number} zoom The tile's zoom level.
     *
     * @see <a href='http://msdn.microsoft.com/en-us/library/bb259689.aspx'>Bing Maps Tile System</a>
     * @see BingMapsTileProvider#quadKeyToTileXY
     */
    BingMapsTileProvider.tileXYToQuadKey = function(x, y, zoom) {
        var quadkey = '';
        for ( var i = zoom; i > 0; --i) {
            var digit = '0'.charCodeAt(0);
            var mask = 1 << (i - 1);
            if ((x & mask) !== 0) {
                digit++;
            }
            if ((y & mask) !== 0) {
                digit += 2;
            }
            quadkey += String.fromCharCode(digit);
        }
        return quadkey;
    };

    /**
     * Converts a tile's quadkey used to request an image from a Bing Maps server into the
     * (x, y, zoom) position.
     *
     * @memberof BingMapsTileProvider
     *
     * @param {String} quadkey The tile's quad key
     *
     * @see <a href='http://msdn.microsoft.com/en-us/library/bb259689.aspx'>Bing Maps Tile System</a>
     * @see BingMapsTileProvider#tileXYToQuadKey
     */
    BingMapsTileProvider.quadKeyToTileXY = function(quadkey) {
        var result = {
            x : 0,
            y : 0,
            zoom : quadkey.length
        };

        for ( var i = result.zoom; i > 0; --i) {
            var mask = 1 << (i - 1);
            var c = quadkey[result.lod - i];
            if (c === '1') {
                result.x |= mask;
            } else if (c === '2') {
                result.y |= mask;
            } else if (c === '3') {
                result.x |= mask;
                result.y |= mask;
            }
        }

        return result;
    };

    BingMapsTileProvider.prototype._getMetadataUrl = function() {
        return 'http://' + this.server + '/REST/v1/Imagery/Metadata/' + this.mapStyle.imagerySetName + '?key=' + this.key;
    };

    BingMapsTileProvider.prototype._requestTemplate = function() {
        var that = this;
        jsonp(this._getMetadataUrl(), {
            callbackParameterName : 'jsonp',
            proxy: this._proxy
        }).then(function(data) {
            var resource = data.resourceSets[0].resources[0];

            var url = resource.imageUrl;
            url = url.replace('{subdomain}', resource.imageUrlSubdomains[0]);
            url = url.replace('{culture}', '');
            that._url = url;

            that.tileWidth = resource.imageWidth;
            that.tileHeight = resource.imageHeight;
            that.zoomMin = resource.zoomMin;
            that.zoomMax = resource.zoomMax;

            that._deferredQueue.forEach(function(element) {
                that._loadImage(element);
            });
            that._deferredQueue = [];
        });
    };

    /**
     * Loads the image for <code>tile</code>.
     *
     * @memberof BingMapsTileProvider
     *
     * @param {Tile} tile The tile to load the image for.
     * @param {Function} onload A function that will be called when the image is finished loading.
     * @param {Function} onerror A function that will be called if there is an error loading the image.
     * @param {Function} oninvalid A function that will be called if the image loaded is not valid.
     *
     * @exception {DeveloperError} <code>tile.zoom</code> is less than <code>zoomMin</code>
     * or greater than <code>zoomMax</code>.
     */
    BingMapsTileProvider.prototype.loadTileImage = function(tile, onload, onerror, oninvalid) {
        if (this.server !== this._server || this.key !== this._key || this.mapStyle !== this._mapStyle) {
            this._server = this.server;
            this._key = this.key;
            this._mapStyle = this.mapStyle;

            this._url = undefined;
            this._requestTemplate();
        }

        if (tile.zoom < this.zoomMin || tile.zoom > this.zoomMax) {
            throw new DeveloperError('tile.zoom must be between in [zoomMin, zoomMax].');
        }

        var image = new Image();
        var element = {
            tile : tile,
            onload : onload,
            onerror : onerror,
            oninvalid : oninvalid,
            image : image
        };

        if (typeof this._url === 'undefined') {
            var existingElement = findInDeferredQueue(this._deferredQueue, tile);
            if (typeof existingElement === 'undefined') {
                this._deferredQueue.push(element);
                return image;
            }

            //add the callbacks to the existing element so both are called
            existingElement.onload = combineFunctions(existingElement.onload, onload);
            existingElement.onerror = combineFunctions(existingElement.onerror, onerror);
            existingElement.oninvalid = combineFunctions(existingElement.oninvalid, oninvalid);
            return existingElement.image;
        }

        this._loadImage(element);
        return image;
    };

    function combineFunctions(a, b) {
        if (typeof a !== 'function' && typeof b !== 'function') {
            return undefined;
        }
        if (typeof a !== 'function' && typeof b === 'function') {
            return b;
        }
        if (typeof a === 'function' && typeof b !== 'function') {
            return a;
        }
        return function() {
            a();
            b();
        };
    }

    BingMapsTileProvider.prototype._loadImage = function(element) {
        var tile = element.tile;
        var lat = CesiumMath.toDegrees((tile.extent.north + tile.extent.south) * 0.5);
        var lon = CesiumMath.toDegrees((tile.extent.east + tile.extent.west) * 0.5);
        var zoomResponse = false;
        var validZoom = false;
        var loaded = false;

        jsonp(this._getMetadataUrl(), {
            parameters : {
                centerPoint : lat + ',' + lon,
                zoomLevel : tile.zoom
            },
            callbackParameterName : 'jsonp',
            proxy : this._proxy
        }).then(function(data) {
            if (typeof data.resourceSets[0] === 'undefined') {
                if (typeof element.onerror === 'function') {
                    element.onerror();
                }
                return;
            }

            var resource = data.resourceSets[0].resources[0];
            if (resource.vintageStart && resource.vintageEnd) {
                validZoom = true;
                if (loaded && typeof element.onload === 'function') {
                    element.onload();
                }
            } else if (typeof element.oninvalid === 'function') {
                element.oninvalid();
            }

            zoomResponse = true;
        });

        var image = element.image;
        image.onload = function() {
            if (zoomResponse && validZoom && typeof element.onload === 'function') {
                element.onload();
            }
            loaded = true;
        };
        image.onerror = element.onerror;
        image.crossOrigin = '';

        var quadkey = BingMapsTileProvider.tileXYToQuadKey(tile.x, tile.y, tile.zoom);
        var url = this._url.replace('{quadkey}', quadkey);
        if (typeof this._proxy !== 'undefined') {
            url = this._proxy.getURL(url);
        }

        image.src = url;
    };

    /**
     * DOC_TBA
     * @memberof BingMapsTileProvider
     */
    BingMapsTileProvider.prototype.getIntensity = function(tile) {
        if ((this.mapStyle === BingMapsStyle.AERIAL || this.mapStyle === BingMapsStyle.AERIAL_WITH_LABELS) && tile.zoom <= 8.0) {
            return 1.0;
        }
        return 0.1;
    };

    /**
     * DOC_TBA
     * @memberof BingMapsTileProvider
     */
    BingMapsTileProvider.prototype.getPoleIntensity = function() {
        return 1.0;
    };

    /**
     * DOC_TBA
     * @memberof BingMapsTileProvider
     */
    BingMapsTileProvider.prototype.getLogo = function() {
        if (typeof BingMapsTileProvider._logo === 'undefined') {
            var image = new Image();
            image.loaded = false;
            image.onload = function() {
                BingMapsTileProvider._logo.loaded = true;
            };
            image.src = BingMapsTileProvider._logoData;
            BingMapsTileProvider._logo = image;
        }

        var logo = BingMapsTileProvider._logo;
        return (logo && logo.loaded) ? logo : undefined;
    };

    BingMapsTileProvider._logo = undefined;
    BingMapsTileProvider._logoLoaded = false;
    BingMapsTileProvider._logoData = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAF0AAAAdCAYAAADIKWCvAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAABBZSURBVHja1FoJdFTVGZ6ZzJZlskMgsrcEoqAQrBhBliKBiBDAgFUL5RQkgIDaKCoqGEBAFkGSgEYrCKgoYtWICLIZBBEOFkX0YEKoDSQo2SczmX36fS/3xscUBAKxp/ecl5eZd99/7/3+/37/cker0Wi0moami4qKCvJ6vVqj0RjEL4KCgvwul8vLe3l5uRdf+cXV2CZPnqwJbHl5eZSpjY2NDcL7Oj2a3+9XxtFqtX632+3FV76qqirK9Ak5fs3/oGGu11Qe1nnJPlpx6cLDw4mNPiQkxARggggSLi8AcuOzG8rwqIC/pFwoUA9lEWyj2Ww28X8+8Hg8EOV1QawTz9xq4C/VrkQxQvHN0fzXAnRauB7AGiIiIsJCQ0PDAFIIPusAjKO+vt5WU1Njs1qtDpvN5v4VgORoioXjboAcc3BwsAWKDA8LCwuFTK3D4aiHrBorBeJ/nU7nUilTeyULlkq4CMDaS6xbGofuUiBxp2P3+7Ecf3FxsXq3+5sCurQ+WroZ4FhGpI1Mur1vvyGYltZaa/156dLF7wDscxhUoR3SDYBsXBCU4gdwftIGJwfL9TudziD00ZtMpuCYmJjY8SmdUgYl1N3H/ierwg4/t+nHPEzOh34eXARcg8VrSW3cYT6fT6seA318Kvk+SXMqalCDGHQhOZynAEX5zLXwOebeCDrH4Fr4v8FgUPrxM+T5eIcRemBQPmDlA/i+pm4Vgq7FAJyoEXdLn9v6pg4dOngCH1ZX19SsXLn8MwzoxoI5OTeA9NJipQB89omJeXH3RUZGerkYNDPkhfXvGX/jA4mfL9D765XFJcRoulnTUirmr69Zh/5OLhSL8IvF6zAOwdCpx4AcjuEDYB6A6qHiAZpXKEDBy2KxBHEdMCCK0As5FKOMC4PSYIp+QZuKAZFG0bRgVfbhQ2UN7AdZjSDxO/QlL7oxVzd2qFso2t9k0LlINAJv9njcRtVW0eFZFC4bJmbARN0EGBcthO9xEfyDf31eLNhJ7heWacD35vjIoNaBg7o9XgPHQp9gAgXZ3ML410DuV/wJ72IX+gQQ0he48MjFBgV4OZYA0IDvjbBsI+4mvEPK1EnQOVeuVewCOncDqNQEZbA/n9F/2bGr6+h3VIATXBqaC3fg7eCO83Xq1IlU0yTg9WJCnAwtg8DrfyFQRV4wJhaHxUTDmrSwbJ2YiFSMH5NUQLDb7XW1tbV15GkuDhM0rt1WeKzOcfPKkTc5h7H/8Z9Cvl35XlEBFmfAQsIgz4/FG8n5bADDjIuAy22vKBTi3fQvGMNah4Y+9QDcRZ6FsvQY04h5QkyYBWIskGumIiX1kGsBqg9yaCF6KMr88COZw264PrGb0Iv/ZHHxwdlPPv7qoUOHsiXdQHarwsLCtR07dhzaq1evUfjswfserE17NfSiyBccGET6UrstbKew4cNH3DBq9OjU1q1axUdGRoQHCqmrs9kBdtWJEyeOZmU9uw7bHr63xsGtDpCCvNFJnvdLg3aUlZbWdu9+YyuH40U9xgphpAQ6CoHFRi5YsCijffu2v4+Ojm6BYMeolk9rr6ioqjx16tR3mzZtevfgwQNFGKOSSqBPYHQEgwiHnJhHH52V3qtX0gD6kkA5DofTda68vMLpcDrbtLkuPvB5YWHREe6YpKSkBwoKCp4aMGDAc9u2bZvSoUOHVKLBXSMM9KoiI73ao0sno+JS/VtvbZofHR1lCQC5HkCQ1zQwUBppCK/4+NbXJSdvH1yw7/PdT81+YmNlZWU9I6H0u9NHJCZ26cr+lVVV1ry8l/bh+1iAZH755Vce6t79hh6CVxtBxhh1Uj6fxcW1iMXV7+abk/oWFRWfyM5elbdnz+4f6BdgGKGPPPLonaNGpd2rNopAOQS5bZvrWl8MjBUrln0MC3Zx82JH/Iw7Zcfl5+cvSklJGQPQvcLR0qleE9D/q1ksYcFqKzly5KvD72x++71vvv66hE5FOCLj+PETBtwx+I67YDyK9aQMHjQ0MfH9m+4ZO2YOF+5Xh2/4wFCSBP7O5nfnqUEoOX2mbNfOXfnr16/bS/4W4ZoxNXVYj3vvu/fPlE8FdO2akPj8888vzMzMXHD48KHTU6ZO6z9u3H0TpOJoFPsPfLHv+cUL3wA49cKAgqdOm56WOnRIKhTQuK4jR/75bfGpUyfhpRwwkiqAbsOcbQMHDlxCeklOTn6YQM+dO/cgeR2WztTFR1prKugEQ09LgRDs7Oj28+cvfDA9fVS6utPp06Vl999/79zq6uoyTKoaW9pOXuN2w2KM4M8wyIjNzJx1z8iRw0fKxZeUnCmbMGH8wuzs3BnXX981QbH0yiprevrds5ctWz4xKalnD2mRa9et3/BK3ks7QNc/Q75Vgk6HxyiI8tPSRiXPmDk9wxLWYAxU0qSJf13ywQcfLKEe+R0Iv37WY7OeO3Bg/3HIqpSgQ3nB4PoorDFu87tbFsa1bBEjx54586GsgoLPjsHPnMbY5RjbjnG9MoIh+HQs+I6Ri4evlZaW+i6Us1x2nC77U3hgh59+Plcxdmz6M+fOnSthvI4J0bs7pNfGO0xk7Viga8GCrLf5HZQ2mve2ba9rnTF12h2BtAUlGTt37txFfj745eGDq3Ozd8LSSrGoSsi3cmFCPsMaDG1zvPXWG/sTEhLapaePVuS3bhUXN2lSxiAJOFv2qpy8vXv3FCL3qgSAVcDKLuSYIZvRjiHr2axVq1fnZAml6tLSRvYBVR2ilTMe4Dt03gwdIZu0qyiHpQsCLQBvsqXr1IBfCPQPP8j/EBljJRwlF1FNS8cEajGpGt7xuRYOrRqgwLdVVSxfvmQrt7d8P6lnz56BuSHjaDV1lZWVnYWMGsqHZXInUXYNxqgGCByzis8IZHb2i582WgwAg5zz/M2OHZ+cgCwH3qMjd9L3MLrizuFnfO88duzrsyLWVlqbtm3aITojXyulCVInI1vMk1SihKkA340QkRZ+wRrUFXO6zChxIUXTnrdl3nxzw2EsuB4AKBN3NjSX2FrM+FgQ08sYGs/cJSUl/05M7KpYcjS85Vm08zStCjkFx1GWA2PUQw4VVg8lS1AArIVxI+N+ZR7qd9u1axuv/pySMrTLhg2vVwBgM/qbmE0KYzJBSSb6kzvvvCtRvTvKSs+eJI+jP52oG8r14LqYNV91YU4nrZzZGBdktdZWqDsMHjwkgXQgkg2m9ibwK4tYRoR7TCyMMjFRshuTydAKoaV832az2y6rQqZVlO3morFrZBGMFyuSHkYUzAoZQajf++77738gj8vP4PzJAwYOTEC6Hot5RoHHoxGaxkRERMQijIzD3KKnTMmYqA4QsrLmbCB/cVcwEQuwZH/ApbkmoDOtFlZsf+3vr+7iRGSH8ePH3wNjjcLEI5FQ8GI5Mhygh2OCESwd4ArH4qCDyGg402EIuy2/8PWXhy89VcXwvSqKO2+R8nsqRoCidlwehLWbyblKxAUnu+KFFc/k5q75G+Lrjrg6tG/fviOuTstfWJmxdevHK+T8+M6GjRs3IECoRj5BSvKw7PxrBa1r0fSCY5nK0zMz2Svfv//Ap4MGDVQyyDZt4luvWfPywzNmPLgCCY+B3EsFMXqhgwQIBlYS0WInT56Syuil0Qn/dK5izeqcHTk5q7v8quZ1SqHJJ6w9cLGyoOaTV8Bm98JQCuDoy6dNnfoAAWXY2qdPcp9du3b1qa6uqWW3wKSOUdSWLe/9Izc3ey+ozEYeF/WdZq/rE3Q/BvUilKLDIZeWP/307NXBwSvCb7vt1tsVZ5jUo8dHH23N2bNn7yc5Oavy2Y90JONocGTP4SOGp4HGu0rBVVXV1jlz57xAC9IEOGgoLIBaFMCVYlOgJasrgKQXPPcGPsOc7Rs3rD/wUf6HRzIypvXr379fSgvkUkzYLpRBs4WHW0LbtWsXH9TQdDLCCoy0ms3SiYOnodVjYdWMvzMzH1n4+BOzxw3o3+8uTpwWNHr0yDEjRtx1t8zyZBytTja4ZQuLTv6A+HlRRUWFjY5Lq9UEgu49P/PVuyCHTsyroheNurSL3cSdRWt0BERCbkY5rNGzGLV06eKSl17KfZ++hzmEKOixiGaGf7px4qSJ4xijM/IZMmTwHUing6dPn7YI1GJiSRp37dVUEC/b0oW1eFjQohfHAgiM59m5z6yBA9qcmfnYGHU9I9B6Amsj+/fvKwRN1jEsY2JTW2M9g23OzFOLHVDBwhjutaJ660eEV8pKpgjTAi3dz/hYJGMMAatramqrpUXa7Ha+a8X3dSyKQbYGY1eyeikiJRbyGAQEr1v3WvnWrfnH33578zzSJp/37v2H5D59b+/86Y7tZ0ExDAR08KnNaunawGM7AM8JMjoJxmKDydes3PH0h4cSDLvG/2VCHzjNKK1G69+9e/fho0e/KmNZVFYB0eyMK0WtPBh9w3lAwrMD+AzWpVnt4skSlWtn7I9Wjjifcb9ThIuNloZAhKgbMbewli1bxsBpx0A5oQDZR2qBr7G7GqIB7gaWmLljqCifTOAAfigunmDFDRkytNvq1blZUv6BL74smDY14ynszB9FvsHd5G2KtV9JRip7+gAYC/Us6JByXOLIrhZgl7N8SjpZvGhhMbcna9T0+FwwLRGLpiU6leIEKISgQ56NoMLyzKzbs5bNgQCUErEAPNaxmcg4eBaL6MgnKsYyctEiOeNpDUuq9XSYAIWOz4guPKwwsTQMhZg4H44N4OqZHPkaGg8naPFOzIF+y33s2DdKciRjdeQSsSwnywOO34rT1cD7haV5eUqCuxJKMkrhVmW8ztMWeczla6gA0cEpFMBLfJagBeF9ngjZ1YvicZg8oBDveHkqJc5LA5sPFuqFopysibDwRLDFcWDIcwsXTxTJkKaosLDw9dfXHmDxCruOPsotDkXMrKFjh5lT7xx2XnJ05kxpMRO7i/mU5gQ9MFTzAnxanUecO9KCdeQ8eQYpowrubIJM7gVNBGZybtCD8o66Do3/Gw99eTEDxOVXW7k8JKG1y/SbZ5SsofPwg6VngKi/tXfvsRERlsiGZOePSPfdKzZvfucg5s+SglOciYaw4NW7d3LXmTNmZKjPAubNm7sWu6PW03DW52tuS9dewXPtr7xzzZKJi8XJ6jNT6grg87QpLA5t0KDBt8ye/eSLoaEhodKxFxWdPJGfn//h9u2fHBflgW7Dhw8f0bnz7xJkFZRJYE5O7pKNG9dvA22dYc2HVUmVT2kWTtdeQwVpLiexUIPXlEREvK8F9RkY7oHLI3G17D9gYM/pD06f1aFDu06XIweUUrps2bLFe/fuOQra+glUxGKbDbTkbKoTbQ7QmzzINd2aAnT+toYRDaMsUAcjrCgoosUtvXt3uWfsn+7u2LHj9SaT0cgTI0EjdU6ny3X27Nl/7dy1c9t7W94l/TB8rQS11LCkS/8FJ+25mjrLbwL6hX5W19xN/mxP/kiK1USEtiHgeQuPB3lAzViXzl8cciu/LGMkg6iFoW0dwGbtnGesdvgXhwBcFtr8zWmE/5egq4GnxQNERlT8iYjy8wv5cw6Gp+L3OhpR4vXJErQ4mXLhXZf4DY36533NCvp/BBgAjIr8TQiNmVwAAAAASUVORK5CYII=';

    return BingMapsTileProvider;
});
/*global define*/
define('Core/loadImage',[
        './defaultValue',
        './DeveloperError',
        '../ThirdParty/when'
    ], function(
        defaultValue,
        DeveloperError,
        when) {
    

    var dataUriRegex = /^data:/;

    /**
     * Asynchronously loads the given image URL.  Returns a promise that will resolve to
     * an {@link Image} once loaded, or reject if the image failed to load.
     *
     * @exports loadImage
     *
     * @param {String} url The source of the image.
     * @param {Boolean} [crossOrigin=true] Whether to request the image using Cross-Origin
     * Resource Sharing (CORS).  Data URIs are never requested using CORS.
     *
     * @returns {Object} a promise that will resolve to the requested data when loaded.
     *
     * @see <a href='http://www.w3.org/TR/cors/'>Cross-Origin Resource Sharing</a>
     * @see <a href='http://wiki.commonjs.org/wiki/Promises/A'>CommonJS Promises/A</a>
     *
     * @example
     * // load a single image asynchronously
     * loadImage('some/image/url.png').then(function(image) {
     *     // use the loaded image
     * }, function() {
     *     // an error occurred
     * });
     *
     * // load several images in parallel
     * when.all([loadImage('image1.png'), loadImage('image2.png')]).then(function(images) {
     *     // images is an array containing all the loaded images
     * });
     */
    var loadImage = function(url, crossOrigin) {
        if (typeof url === 'undefined') {
            throw new DeveloperError('url is required.');
        }

        crossOrigin = defaultValue(crossOrigin, true);

        // data URIs can't have crossOrigin set.
        if (dataUriRegex.test(url)) {
            crossOrigin = false;
        }

        var deferred = when.defer();
        var image = new Image();

        if (crossOrigin) {
            image.crossOrigin = '';
        }

        image.onload = function(e) {
            deferred.resolve(image);
        };

        image.onerror = function(e) {
            deferred.reject();
        };

        image.src = url;

        return deferred.promise;
    };

    return loadImage;
});

/*global define*/
define('Renderer/TextureAtlasBuilder',[
        '../Core/Event',
        '../Core/DeveloperError',
        '../Core/loadImage'
       ], function(
         Event,
         DeveloperError,
         loadImage) {
    

    function SourceHolder() {
        this.imageLoaded = new Event();
        this.index = -1;
        this.loaded = false;
    }

    /**
     * A utility class which dynamically builds a TextureAtlas by associating
     * a unique identifier with each texture as it is added.  If a texture with
     * the same id is needed later, the existing index is returned, rather than
     * adding multiple copies of the same texture.
     *
     * @alias TextureAtlasBuilder
     * @constructor
     *
     * @see TextureAtlas
     */
    var TextureAtlasBuilder  = function(textureAtlas) {
        if (typeof textureAtlas === 'undefined') {
            throw new DeveloperError('textureAtlas is required.');
        }
        this.textureAtlas = textureAtlas;
        this._idHash = {};
    };

    /**
     * Retrieves the image from the specified url and adds it to the atlas.
     * The supplied callback is triggered with the index of the texture.
     * If the url is already in the atlas, the atlas is unchanged and the callback
     * is triggered immediately with the existing index.
     *
     * @memberof TextureAtlasBuilder
     *
     * @param {String} url The url of the image to add to the atlas.
     * @param {Function} textureAvailableCallback A function taking the image index as it's only parameter.
     *
     * @exception {DeveloperError} url is required.
     * @exception {DeveloperError} textureAvailableCallback is required.
     */
    TextureAtlasBuilder.prototype.addTextureFromUrl = function(url, textureAvailableCallback) {
        if (typeof url === 'undefined') {
            throw new DeveloperError('url is required.');
        }

        if (typeof textureAvailableCallback === 'undefined') {
            throw new DeveloperError('textureAvailableCallback is required.');
        }

        this.addTextureFromFunction(url, function(id, callback) {
            loadImage(id).then(callback);
        }, textureAvailableCallback);
    };

    /**
     * <p>
     * Checks the atlas for a texture with the supplied id, if the id does not
     * exist, the supplied callback is triggered to create it.  In either case,
     * once the image is in the atlas, the second supplied callback is triggered
     * with its index.
     * </p>
     *
     * <p>
     * This function is useful for dynamically generated textures that are shared
     * across many billboards.  Only the first billboard will actually create the texture
     * while subsequent billboards will re-use the existing one.
     * </p>
     *
     * @memberof TextureAtlasBuilder
     *
     * @param {String} id The id of the image to add to the atlas.
     * @param {Function} getImageCallback A function which takes two parameters; first the id of the image to
     * retrieve and second, a function to call when the image is ready.  The function takes the image as its
     * only parameter.
     * @param {Function} textureAvailableCallback A function taking the image index as it's only parameter.
     *
     * @exception {DeveloperError} id is required.
     * @exception {DeveloperError} getImageCallback is required.
     * @exception {DeveloperError} textureAvailableCallback is required.
     */
    TextureAtlasBuilder.prototype.addTextureFromFunction = function(id, getImageCallback, textureAvailableCallback) {
        if (typeof id === 'undefined') {
            throw new DeveloperError('id is required.');
        }

        if (typeof getImageCallback === 'undefined') {
            throw new DeveloperError('getImageCallback is required.');
        }

        if (typeof textureAvailableCallback === 'undefined') {
            throw new DeveloperError('textureAvailableCallback is required.');
        }

        var sourceHolder = this._idHash[id];
        if (typeof sourceHolder !== 'undefined') {
            //we're already aware of this source
            if (sourceHolder.loaded) {
                //and it's already loaded, tell the callback what index to use
                textureAvailableCallback(sourceHolder.index);
            } else {
                //add the callback to be notified once it loads
                sourceHolder.imageLoaded.addEventListener(textureAvailableCallback);
            }
            return;
        }

        //not in atlas, create the source, which may be async
        this._idHash[id] = sourceHolder = new SourceHolder();
        sourceHolder.imageLoaded.addEventListener(textureAvailableCallback);

        var that = this;
        getImageCallback(id, function(newImage) {
            if (!that.textureAtlas.isDestroyed()) {
                var index = sourceHolder.index = that.textureAtlas.addImage(newImage);
                sourceHolder.loaded = true;
                sourceHolder.imageLoaded.raiseEvent(index, id);
                sourceHolder.imageLoaded = undefined;
            }
        });
    };

    return TextureAtlasBuilder;
});
/*global define*/
define('DynamicScene/DynamicBillboardVisualizer',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/Color',
        '../Core/Cartesian2',
        '../Core/Cartesian3',
        '../Scene/BillboardCollection',
        '../Scene/HorizontalOrigin',
        '../Scene/VerticalOrigin',
        '../Renderer/TextureAtlasBuilder'
    ], function(
        DeveloperError,
        destroyObject,
        Color,
        Cartesian2,
        Cartesian3,
        BillboardCollection,
        HorizontalOrigin,
        VerticalOrigin,
        TextureAtlasBuilder) {
    

    //Callback to create a callback so that we close over all of the proper values.
    function textureReady(dynamicObject, billboardCollection, textureValue) {
        return function(imageIndex) {
            //By the time the texture was loaded, the billboard might already be
            //gone or have been assigned a different texture.  Look it up again
            //and check.
            var currentIndex = dynamicObject._billboardVisualizerIndex;
            if (typeof currentIndex !== 'undefined') {
                var cbBillboard = billboardCollection.get(currentIndex);
                if (cbBillboard._visualizerUrl === textureValue) {
                    cbBillboard._visualizerTextureAvailable = true;
                    cbBillboard.setImageIndex(imageIndex);
                }
            }
        };
    }

    /**
     * A DynamicObject visualizer which maps the DynamicBillboard instance
     * in DynamicObject.billboard to a Billboard primitive.
     * @alias DynamicBillboardVisualizer
     * @constructor
     *
     * @param {Scene} scene The scene the primitives will be rendered in.
     * @param {DynamicObjectCollection} [dynamicObjectCollection] The dynamicObjectCollection to visualize.
     *
     * @exception {DeveloperError} scene is required.
     *
     * @see DynamicBillboard
     * @see Scene
     * @see DynamicObject
     * @see DynamicObjectCollection
     * @see CompositeDynamicObjectCollection
     * @see VisualizerCollection
     * @see DynamicConeVisualizer
     * @see DynamicConeVisualizerUsingCustomSensor
     * @see DynamicLabelVisualizer
     * @see DynamicPointVisualizer
     * @see DynamicPolygonVisualizer
     * @see DynamicPolylineVisualizer
     * @see DynamicPyramidVisualizer
     *
     */
    var DynamicBillboardVisualizer = function(scene, dynamicObjectCollection) {
        if (typeof scene === 'undefined') {
            throw new DeveloperError('scene is required.');
        }

        this._scene = scene;
        this._unusedIndexes = [];
        this._dynamicObjectCollection = undefined;

        var billboardCollection = this._billboardCollection = new BillboardCollection();
        var atlas = this._textureAtlas = scene.getContext().createTextureAtlas();
        this._textureAtlasBuilder = new TextureAtlasBuilder(atlas);
        billboardCollection.setTextureAtlas(atlas);
        scene.getPrimitives().add(billboardCollection);
        this.setDynamicObjectCollection(dynamicObjectCollection);
    };

    /**
     * Returns the scene being used by this visualizer.
     *
     * @returns {Scene} The scene being used by this visualizer.
     */
    DynamicBillboardVisualizer.prototype.getScene = function() {
        return this._scene;
    };

    /**
     * Gets the DynamicObjectCollection being visualized.
     *
     * @returns {DynamicObjectCollection} The DynamicObjectCollection being visualized.
     */
    DynamicBillboardVisualizer.prototype.getDynamicObjectCollection = function() {
        return this._dynamicObjectCollection;
    };

    /**
     * Sets the DynamicObjectCollection to visualize.
     *
     * @param dynamicObjectCollection The DynamicObjectCollection to visualizer.
     */
    DynamicBillboardVisualizer.prototype.setDynamicObjectCollection = function(dynamicObjectCollection) {
        var oldCollection = this._dynamicObjectCollection;
        if (oldCollection !== dynamicObjectCollection) {
            if (typeof oldCollection !== 'undefined') {
                oldCollection.objectsRemoved.removeEventListener(DynamicBillboardVisualizer.prototype._onObjectsRemoved);
                this.removeAllPrimitives();
            }
            this._dynamicObjectCollection = dynamicObjectCollection;
            if (typeof dynamicObjectCollection !== 'undefined') {
                dynamicObjectCollection.objectsRemoved.addEventListener(DynamicBillboardVisualizer.prototype._onObjectsRemoved, this);
            }
        }
    };

    /**
     * Updates all of the primitives created by this visualizer to match their
     * DynamicObject counterpart at the given time.
     *
     * @param {JulianDate} time The time to update to.
     *
     * @exception {DeveloperError} time is required.
     */
    DynamicBillboardVisualizer.prototype.update = function(time) {
        if (typeof time === 'undefined') {
            throw new DeveloperError('time is requied.');
        }
        if (typeof this._dynamicObjectCollection !== 'undefined') {
            var dynamicObjects = this._dynamicObjectCollection.getObjects();
            for ( var i = 0, len = dynamicObjects.length; i < len; i++) {
                this._updateObject(time, dynamicObjects[i]);
            }
        }
    };

    /**
     * Removes all primitives from the scene.
     */
    DynamicBillboardVisualizer.prototype.removeAllPrimitives = function() {
        if (typeof this._dynamicObjectCollection !== 'undefined') {
            this._unusedIndexes = [];
            this._billboardCollection.removeAll();
            var dynamicObjects = this._dynamicObjectCollection.getObjects();
            for ( var i = dynamicObjects.length - 1; i > -1; i--) {
                dynamicObjects[i]._billboardVisualizerIndex = undefined;
            }
        }
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof DynamicBillboardVisualizer
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see DynamicBillboardVisualizer#destroy
     */
    DynamicBillboardVisualizer.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof DynamicBillboardVisualizer
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see DynamicBillboardVisualizer#isDestroyed
     *
     * @example
     * visualizer = visualizer && visualizer.destroy();
     */
    DynamicBillboardVisualizer.prototype.destroy = function() {
        this.removeAllPrimitives();
        this._scene.getPrimitives().remove(this._billboardCollection);
        return destroyObject(this);
    };

    var position;
    var color;
    var eyeOffset;
    var pixelOffset;
    DynamicBillboardVisualizer.prototype._updateObject = function(time, dynamicObject) {
        var dynamicBillboard = dynamicObject.billboard;
        if (typeof dynamicBillboard === 'undefined') {
            return;
        }

        var positionProperty = dynamicObject.position;
        if (typeof positionProperty === 'undefined') {
            return;
        }

        var textureProperty = dynamicBillboard.image;
        if (typeof textureProperty === 'undefined') {
            return;
        }

        var billboard;
        var showProperty = dynamicBillboard.show;
        var billboardVisualizerIndex = dynamicObject._billboardVisualizerIndex;
        var show = dynamicObject.isAvailable(time) && (typeof showProperty === 'undefined' || showProperty.getValue(time));

        if (!show) {
            //don't bother creating or updating anything else
            if (typeof billboardVisualizerIndex !== 'undefined') {
                billboard = this._billboardCollection.get(billboardVisualizerIndex);
                billboard.setShow(false);
                billboard._visualizerUrl = undefined;
                billboard._visualizerTextureAvailable = false;
                dynamicObject._billboardVisualizerIndex = undefined;
                this._unusedIndexes.push(billboardVisualizerIndex);
            }
            return;
        }

        if (typeof billboardVisualizerIndex === 'undefined') {
            var unusedIndexes = this._unusedIndexes;
            var length = unusedIndexes.length;
            if (length > 0) {
                billboardVisualizerIndex = unusedIndexes.pop();
                billboard = this._billboardCollection.get(billboardVisualizerIndex);
            } else {
                billboardVisualizerIndex = this._billboardCollection.getLength();
                billboard = this._billboardCollection.add();
            }
            dynamicObject._billboardVisualizerIndex = billboardVisualizerIndex;
            billboard.dynamicObject = dynamicObject;
            billboard._visualizerUrl = undefined;
            billboard._visualizerTextureAvailable = false;

            // CZML_TODO Determine official defaults
            billboard.setColor(Color.WHITE);
            billboard.setEyeOffset(Cartesian3.ZERO);
            billboard.setPixelOffset(Cartesian2.ZERO);
            billboard.setScale(1.0);
            billboard.setHorizontalOrigin(HorizontalOrigin.CENTER);
            billboard.setVerticalOrigin(VerticalOrigin.CENTER);
        } else {
            billboard = this._billboardCollection.get(billboardVisualizerIndex);
        }

        var textureValue = textureProperty.getValue(time);
        if (textureValue !== billboard._visualizerUrl) {
            billboard._visualizerUrl = textureValue;
            billboard._visualizerTextureAvailable = false;
            this._textureAtlasBuilder.addTextureFromUrl(textureValue, textureReady(dynamicObject, this._billboardCollection, textureValue));
        }

        billboard.setShow(billboard._visualizerTextureAvailable);
        if (!billboard._visualizerTextureAvailable) {
            return;
        }

        position = positionProperty.getValueCartesian(time, position);
        if (position !== 'undefined') {
            billboard.setPosition(position);
        }

        var property = dynamicBillboard.color;

        if (typeof property !== 'undefined') {
            color = property.getValue(time, color);
            if (typeof color !== 'undefined') {
                billboard.setColor(color);
            }
        }

        property = dynamicBillboard.eyeOffset;
        if (typeof property !== 'undefined') {
            eyeOffset = property.getValue(time, eyeOffset);
            if (typeof eyeOffset !== 'undefined') {
                billboard.setEyeOffset(eyeOffset);
            }
        }

        property = dynamicBillboard.pixelOffset;
        if (typeof property !== 'undefined') {
            pixelOffset = property.getValue(time, pixelOffset);
            if (typeof pixelOffset !== 'undefined') {
                billboard.setPixelOffset(pixelOffset);
            }
        }

        property = dynamicBillboard.scale;
        if (typeof property !== 'undefined') {
            var scale = property.getValue(time);
            if (typeof scale !== 'undefined') {
                billboard.setScale(scale);
            }
        }

        property = dynamicBillboard.horizontalOrigin;
        if (typeof property !== 'undefined') {
            var horizontalOrigin = property.getValue(time);
            if (typeof horizontalOrigin !== 'undefined') {
                billboard.setHorizontalOrigin(horizontalOrigin);
            }
        }

        property = dynamicBillboard.verticalOrigin;
        if (typeof property !== 'undefined') {
            var verticalOrigin = property.getValue(time);
            if (typeof verticalOrigin !== 'undefined') {
                billboard.setVerticalOrigin(verticalOrigin);
            }
        }
    };

    DynamicBillboardVisualizer.prototype._onObjectsRemoved = function(dynamicObjectCollection, dynamicObjects) {
        var thisBillboardCollection = this._billboardCollection;
        var thisUnusedIndexes = this._unusedIndexes;
        for ( var i = dynamicObjects.length - 1; i > -1; i--) {
            var dynamicObject = dynamicObjects[i];
            var billboardVisualizerIndex = dynamicObject._billboardVisualizerIndex;
            if (typeof billboardVisualizerIndex !== 'undefined') {
                var billboard = thisBillboardCollection.get(billboardVisualizerIndex);
                billboard.setShow(false);
                billboard._visualizerUrl = undefined;
                billboard._visualizerTextureAvailable = false;
                dynamicObject._billboardVisualizerIndex = undefined;
                thisUnusedIndexes.push(billboardVisualizerIndex);
            }
        }
    };

    return DynamicBillboardVisualizer;
});
/*global define*/
define('DynamicScene/DynamicPointVisualizer',[
        '../Core/Event',
        '../Core/DeveloperError',
        '../Core/destroyObject',
        '../Core/Color',
        '../Scene/BillboardCollection',
        '../Renderer/TextureAtlasBuilder'
       ], function(
         Event,
         DeveloperError,
         destroyObject,
         Color,
         BillboardCollection,
         TextureAtlasBuilder) {
    

    /**
     * A DynamicObject visualizer which maps the DynamicPoint instance
     * in DynamicObject.point to a Billboard primitive with a point texture.
     * @alias DynamicPointVisualizer
     * @constructor
     *
     * @param {Scene} scene The scene the primitives will be rendered in.
     * @param {DynamicObjectCollection} [dynamicObjectCollection] The dynamicObjectCollection to visualize.
     *
     * @exception {DeveloperError} scene is required.
     *
     * @see DynamicPoint
     * @see Scene
     * @see DynamicObject
     * @see DynamicObjectCollection
     * @see CompositeDynamicObjectCollection
     * @see VisualizerCollection
     * @see DynamicBillboardVisualizer
     * @see DynamicConeVisualizer
     * @see DynamicConeVisualizerUsingCustomSensorr
     * @see DynamicLabelVisualizer
     * @see DynamicPolygonVisualizer
     * @see DynamicPolylineVisualizer
     * @see DynamicPyramidVisualizer
     *
     */
    var DynamicPointVisualizer = function(scene, dynamicObjectCollection) {
        if (typeof scene === 'undefined') {
            throw new DeveloperError('scene is required.');
        }
        this._scene = scene;
        this._unusedIndexes = [];
        this._dynamicObjectCollection = undefined;
        var billboardCollection = this._billboardCollection = new BillboardCollection();
        var atlas = this._textureAtlas = scene.getContext().createTextureAtlas();
        this._textureAtlasBuilder = new TextureAtlasBuilder(atlas);
        billboardCollection.setTextureAtlas(atlas);
        scene.getPrimitives().add(billboardCollection);
        this.setDynamicObjectCollection(dynamicObjectCollection);
    };

    /**
     * Returns the scene being used by this visualizer.
     *
     * @returns {Scene} The scene being used by this visualizer.
     */
    DynamicPointVisualizer.prototype.getScene = function() {
        return this._scene;
    };

    /**
     * Gets the DynamicObjectCollection being visualized.
     *
     * @returns {DynamicObjectCollection} The DynamicObjectCollection being visualized.
     */
    DynamicPointVisualizer.prototype.getDynamicObjectCollection = function() {
        return this._dynamicObjectCollection;
    };

    /**
     * Sets the DynamicObjectCollection to visualize.
     *
     * @param dynamicObjectCollection The DynamicObjectCollection to visualizer.
     */
    DynamicPointVisualizer.prototype.setDynamicObjectCollection = function(dynamicObjectCollection) {
        var oldCollection = this._dynamicObjectCollection;
        if (oldCollection !== dynamicObjectCollection) {
            if (typeof oldCollection !== 'undefined') {
                oldCollection.objectsRemoved.removeEventListener(DynamicPointVisualizer.prototype._onObjectsRemoved);
                this.removeAllPrimitives();
            }
            this._dynamicObjectCollection = dynamicObjectCollection;
            if (typeof dynamicObjectCollection !== 'undefined') {
                dynamicObjectCollection.objectsRemoved.addEventListener(DynamicPointVisualizer.prototype._onObjectsRemoved, this);
            }
        }
    };

    /**
     * Updates all of the primitives created by this visualizer to match their
     * DynamicObject counterpart at the given time.
     *
     * @param {JulianDate} time The time to update to.
     *
     * @exception {DeveloperError} time is required.
     */
    DynamicPointVisualizer.prototype.update = function(time) {
        if (typeof time === 'undefined') {
            throw new DeveloperError('time is requied.');
        }
        if (typeof this._dynamicObjectCollection !== 'undefined') {
            var dynamicObjects = this._dynamicObjectCollection.getObjects();
            for ( var i = 0, len = dynamicObjects.length; i < len; i++) {
                this._updateObject(time, dynamicObjects[i]);
            }
        }
    };

    /**
     * Removes all primitives from the scene.
     */
    DynamicPointVisualizer.prototype.removeAllPrimitives = function() {
        this._unusedIndexes = [];
        this._billboardCollection.removeAll();
        if (typeof this._dynamicObjectCollection !== 'undefined') {
            var dynamicObjects = this._dynamicObjectCollection.getObjects();
            for ( var i = dynamicObjects.length - 1; i > -1; i--) {
                dynamicObjects[i]._pointVisualizerIndex = undefined;
            }
        }
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof DynamicPointVisualizer
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see DynamicPointVisualizer#destroy
     */
    DynamicPointVisualizer.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof DynamicPointVisualizer
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see DynamicPointVisualizer#isDestroyed
     *
     * @example
     * visualizer = visualizer && visualizer.destroy();
     */
    DynamicPointVisualizer.prototype.destroy = function() {
        this.removeAllPrimitives();
        this._scene.getPrimitives().remove(this._billboardCollection);
        return destroyObject(this);
    };

    var color;
    var position;
    var outlineColor;
    DynamicPointVisualizer.prototype._updateObject = function(time, dynamicObject) {
        var dynamicPoint = dynamicObject.point;
        if (typeof dynamicPoint === 'undefined') {
            return;
        }

        var positionProperty = dynamicObject.position;
        if (typeof positionProperty === 'undefined') {
            return;
        }

        var billboard;
        var showProperty = dynamicPoint.show;
        var pointVisualizerIndex = dynamicObject._pointVisualizerIndex;
        var show = dynamicObject.isAvailable(time) && (typeof showProperty === 'undefined' || showProperty.getValue(time));

        if (!show) {
            //don't bother creating or updating anything else
            if (typeof pointVisualizerIndex !== 'undefined') {
                billboard = this._billboardCollection.get(pointVisualizerIndex);
                billboard.setShow(false);
                dynamicObject._pointVisualizerIndex = undefined;
                this._unusedIndexes.push(pointVisualizerIndex);
            }
            return;
        }

        var needRedraw = false;
        if (typeof pointVisualizerIndex === 'undefined') {
            var unusedIndexes = this._unusedIndexes;
            var length = unusedIndexes.length;
            if (length > 0) {
                pointVisualizerIndex = unusedIndexes.pop();
                billboard = this._billboardCollection.get(pointVisualizerIndex);
            } else {
                pointVisualizerIndex = this._billboardCollection.getLength();
                billboard = this._billboardCollection.add();
            }
            dynamicObject._pointVisualizerIndex = pointVisualizerIndex;
            billboard.dynamicObject = dynamicObject;

            // CZML_TODO Determine official defaults
            billboard._visualizerColor = Color.WHITE.clone(billboard._visualizerColor);
            billboard._visualizerOutlineColor = Color.BLACK.clone(billboard._visualizerOutlineColor);
            billboard._visualizerOutlineWidth = 2;
            billboard._visualizerPixelSize = 3;
            needRedraw = true;
        } else {
            billboard = this._billboardCollection.get(pointVisualizerIndex);
        }

        billboard.setShow(true);

        position = positionProperty.getValueCartesian(time, position);
        if (position !== 'undefined') {
            billboard.setPosition(position);
        }

        var property = dynamicPoint.color;
        if (typeof property !== 'undefined') {
            color = property.getValue(time, color);
            if (billboard._visualizerColor !== color) {
                billboard._visualizerColor = color;
                needRedraw = true;
            }
        }

        property = dynamicPoint.outlineColor;
        if (typeof property !== 'undefined') {
            outlineColor = property.getValue(time, outlineColor);
            if (billboard._visualizerOutlineColor !== outlineColor) {
                billboard._visualizerOutlineColor = outlineColor;
                needRedraw = true;
            }
        }

        property = dynamicPoint.outlineWidth;
        if (typeof property !== 'undefined') {
            var outlineWidth = property.getValue(time);
            if (billboard._visualizerOutlineWidth !== outlineWidth) {
                billboard._visualizerOutlineWidth = outlineWidth;
                needRedraw = true;
            }
        }

        property = dynamicPoint.pixelSize;
        if (typeof property !== 'undefined') {
            var pixelSize = property.getValue(time);
            if (billboard._visualizerPixelSize !== pixelSize) {
                billboard._visualizerPixelSize = pixelSize;
                needRedraw = true;
            }
        }

        if (needRedraw) {
            var cssColor = typeof billboard._visualizerColor !== 'undefined' ? billboard._visualizerColor.toCSSColor() : '#FFFFFF';
            var cssOutlineColor = typeof billboard._visualizerOutlineColor !== 'undefined' ? billboard._visualizerOutlineColor.toCSSColor() : '#000000';
            var cssPixelSize = typeof billboard._visualizerPixelSize !== 'undefined' ? billboard._visualizerPixelSize : 3;
            var cssOutlineWidth = typeof billboard._visualizerOutlineWidth !== 'undefined' ? billboard._visualizerOutlineWidth : 2;
            var textureId = JSON.stringify([cssColor, cssPixelSize, cssOutlineColor, cssOutlineWidth]);

            this._textureAtlasBuilder.addTextureFromFunction(textureId, function(id, loadedCallback) {
                var canvas = document.createElement('canvas');

                var length = cssPixelSize + (2 * cssOutlineWidth);
                canvas.height = canvas.width = length;

                var context2D = canvas.getContext('2d');
                context2D.clearRect(0, 0, length, length);

                if (cssOutlineWidth !== 0) {
                    context2D.beginPath();
                    context2D.arc(length / 2, length / 2, length / 2, 0, 2 * Math.PI, true);
                    context2D.closePath();
                    context2D.fillStyle = cssOutlineColor;
                    context2D.fill();
                }

                context2D.beginPath();
                context2D.arc(length / 2, length / 2, cssPixelSize / 2, 0, 2 * Math.PI, true);
                context2D.closePath();
                context2D.fillStyle = cssColor;
                context2D.fill();

                loadedCallback(canvas);
            }, function(imageIndex) {
                billboard.setImageIndex(imageIndex);
            });
        }
    };

    DynamicPointVisualizer.prototype._onObjectsRemoved = function(dynamicObjectCollection, dynamicObjects) {
        var thisBillboardCollection = this._billboardCollection;
        var thisUnusedIndexes = this._unusedIndexes;
        for ( var i = dynamicObjects.length - 1; i > -1; i--) {
            var dynamicObject = dynamicObjects[i];
            var pointVisualizerIndex = dynamicObject._pointVisualizerIndex;
            if (typeof pointVisualizerIndex !== 'undefined') {
                var billboard = thisBillboardCollection.get(pointVisualizerIndex);
                billboard.setShow(false);
                dynamicObject._pointVisualizerIndex = undefined;
                thisUnusedIndexes.push(pointVisualizerIndex);
            }
        }
    };

    return DynamicPointVisualizer;
});
/*global define*/
define('DynamicScene/CzmlDefaults',[
        './DynamicObject',
        './DynamicBillboard',
        './DynamicCone',
        './DynamicLabel',
        './DynamicPoint',
        './DynamicPolygon',
        './DynamicPolyline',
        './DynamicPyramid',
        './DynamicBillboardVisualizer',
        './DynamicConeVisualizerUsingCustomSensor', //CZML_TODO Replace with './DynamicConeVisualizer', once ComplexConicSensor works.
        './DynamicLabelVisualizer',
        './DynamicPointVisualizer',
        './DynamicPolygonVisualizer',
        './DynamicPolylineVisualizer',
        './DynamicPyramidVisualizer'
       ], function(
        DynamicObject,
        DynamicBillboard,
        DynamicCone,
        DynamicLabel,
        DynamicPoint,
        DynamicPolygon,
        DynamicPolyline,
        DynamicPyramid,
        DynamicBillboardVisualizer,
        DynamicConeVisualizer,
        DynamicLabelVisualizer,
        DynamicPointVisualizer,
        DynamicPolygonVisualizer,
        DynamicPolylineVisualizer,
        DynamicPyramidVisualizer) {
    

    /**
     * Helper class which provides the default set of CZML processing methods
     * needed to visualize the complete CZML standard.  There's no reason to
     * access this class directly, as it just holds the defaults used by
     * DynamicObjectCollection, CompositeDynamicObjectCollection, and VisualizerCollection.
     *
     * @exports CzmlDefaults
     *
     * @see DynamicObjectCollection
     * @see CompositeDynamicObjectCollection
     * @see VisualizerCollection#createCzmlDefaultsCollection
     */
    var CzmlDefaults = {
        //Any change to updaters needs to be reflected in the DynamicObject constructor,
        //which has the superset of all properties created by the various updaters.
        /**
         * The standard set of updaters for processing CZML.  This array is the default
         * set of updater methods used by DynamicObjectCollection.
         * @see DynamicObjectCollection
         */
        updaters : [DynamicBillboard.processCzmlPacket,
                    DynamicCone.processCzmlPacket,
                    DynamicLabel.processCzmlPacket,
                    DynamicPoint.processCzmlPacket,
                    DynamicPolygon.processCzmlPacket,
                    DynamicPolyline.processCzmlPacket,
                    DynamicPyramid.processCzmlPacket,
                    DynamicObject.processCzmlPacketPosition,
                    DynamicObject.processCzmlPacketOrientation,
                    DynamicObject.processCzmlPacketVertexPositions,
                    DynamicObject.processCzmlPacketAvailability],

        /**
         * The standard set of mergers for processing CZML.  This array is the default
         * set of updater methods used by CompositeDynamicObjectCollection.
         *
         * @see CompositeDynamicObjectCollection
         */
        mergers : [DynamicBillboard.mergeProperties,
                   DynamicCone.mergeProperties,
                   DynamicLabel.mergeProperties,
                   DynamicPoint.mergeProperties,
                   DynamicPolygon.mergeProperties,
                   DynamicPolyline.mergeProperties,
                   DynamicPyramid.mergeProperties,
                   DynamicObject.mergeProperties],

       /**
        * The standard set of cleaners for processing CZML.  This array is the default
        * set of updater methods used by CompositeDynamicObjectCollection.
        *
        * @see CompositeDynamicObjectCollection
        */
        cleaners : [DynamicBillboard.undefineProperties,
                    DynamicCone.undefineProperties,
                    DynamicLabel.undefineProperties,
                    DynamicPoint.undefineProperties,
                    DynamicPolygon.undefineProperties,
                    DynamicPolyline.undefineProperties,
                    DynamicPyramid.undefineProperties,
                    DynamicObject.undefineProperties],

        /**
         * Creates an array containing the standard CZML visualizers,
         * configured for the provided scene.
         *
         * @param scene The scene being used for visualization.
         * @returns {Array} The CZML standard visualizers.
         * @see VisualizerCollection#createCzmlDefaultsCollection
         */
        createVisualizers : function(scene) {
            return [new DynamicBillboardVisualizer(scene),
                    new DynamicConeVisualizer(scene),
                    new DynamicLabelVisualizer(scene),
                    new DynamicPointVisualizer(scene),
                    new DynamicPolygonVisualizer(scene),
                    new DynamicPolylineVisualizer(scene),
                    new DynamicPyramidVisualizer(scene)];
        }
    };

    return CzmlDefaults;
});
/*global define*/
define('DynamicScene/CompositeDynamicObjectCollection',[
        '../Core/Event',
        '../Core/Iso8601',
        '../Core/TimeInterval',
        '../Core/DeveloperError',
        './DynamicObject',
        './DynamicObjectCollection',
        './CzmlDefaults'
    ], function(
        Event,
        Iso8601,
        TimeInterval,
        DeveloperError,
        DynamicObject,
        DynamicObjectCollection,
        CzmlDefaults) {
    

    /**
     * Non-destructively composites multiple DynamicObjectCollection instances into a single collection.
     * If a DynamicObject with the same ID exists in multiple collections, it is non-destructively
     * merged into a single new object instance.  If an object has the same property in multiple
     * collections, the property of the DynamicObject in the last collection of the list it
     * belongs to is used.  CompositeDynamicObjectCollection can be used almost anywhere that a
     * DynamicObjectCollection is used.
     *
     * @alias CompositeDynamicObjectCollection
     * @constructor
     *
     * @param {Array} [collections] The initial list of DynamicObjectCollection instances to merge.
     * @param {Array} [mergeFunctions] The list of CZML merge functions.
     * @param {Array} [cleanFunctions] The list of CZML clean functions.
     *
     * @see DynamicObjectCollection
     * @see DynamicObject
     * @see CzmlDefaults
     */
    var CompositeDynamicObjectCollection = function(collections, mergeFunctions, cleanFunctions) {
        this._hash = {};
        this._array = [];
        this._collections = [];

        /**
         * The array of functions which merge DynamicObject instances together.
         */
        this.mergeFunctions = typeof mergeFunctions === 'undefined' ? CzmlDefaults.mergers : mergeFunctions;

        /**
         * The array of functions which remove data from a DynamicObject instance.
         */
        this.cleanFunctions = typeof cleanFunctions === 'undefined' ? CzmlDefaults.cleaners : cleanFunctions;

        /**
         * An {@link Event} that is fired whenever DynamicObjects in the collection have properties added.
         */
        this.objectPropertiesChanged = new Event();

        /**
         * An {@link Event} that is fired whenever DynamicObjects are removed from the collection.
         */
        this.objectsRemoved = new Event();

        this.setCollections(collections);
    };

    /**
     * Computes the maximum availability of the DynamicObjects in the collection.
     * If the collection contains a mix of infinitely available data and non-infinite data,
     * It will return the interval pertaining to the non-infinite data only.  If all
     * data is infinite, an infinite interval will be returned.
     * @memberof CompositeDynamicObjectCollection
     *
     * @returns {TimeInterval} The availability of DynamicObjects in the collection.
     */
    CompositeDynamicObjectCollection.prototype.computeAvailability = function() {
        var startTime = Iso8601.MAXIMUM_VALUE;
        var stopTime = Iso8601.MINIMUM_VALUE;
        var i;
        var len;
        var collection;
        var collections = this._collections;
        for (i = 0, len = collections.length; i < len; i++) {
            collection = collections[i];
            var availability = collection.computeAvailability();
            if (availability.start.lessThan(startTime)) {
                startTime = availability.start;
            }
            if (availability.stop.greaterThan(stopTime)) {
                stopTime = availability.stop;
            }
        }
        if (startTime !== Iso8601.MAXIMUM_VALUE && stopTime !== Iso8601.MINIMUM_VALUE) {
            return new TimeInterval(startTime, stopTime, true, true);
        }
        return new TimeInterval(Iso8601.MINIMUM_VALUE, Iso8601.MAXIMUM_VALUE, true, true);
    };

    /**
     * Returns a copy of the current array of collections being composited.  Changes to this
     * array will have no affect, to change which collections are being used, call setCollections.
     * @memberof CompositeDynamicObjectCollection
     *
     * @see CompositeDynamicObjectCollection#setCollections
     */
    CompositeDynamicObjectCollection.prototype.getCollections = function() {
        return this._collections.slice(0);
    };

    /**
     * Sets the array of collections to be composited.  Collections are composited
     * last to first, so higher indices into the array take precedence over lower indices.
     * @memberof CompositeDynamicObjectCollection
     *
     * @param {Array} collections The collections to be composited.
     */
    CompositeDynamicObjectCollection.prototype.setCollections = function(collections) {
        collections = typeof collections !== 'undefined' ? collections : [];

        var thisCollections = this._collections;
        if (collections !== thisCollections) {
            var collection;
            var iCollection;

            //Unsubscribe from old collections.
            for (iCollection = thisCollections.length - 1; iCollection > -1; iCollection--) {
                collection = thisCollections[iCollection];
                collection.compositeCollection = undefined;
                collection.objectPropertiesChanged.removeEventListener(CompositeDynamicObjectCollection.prototype._onObjectPropertiesChanged);
            }

            //Make a copy of the new collections.
            thisCollections = this._collections = collections;

            //Clear all existing objects and rebuild the colleciton.
            this._clearObjects();
            var thisMergeFunctions = this.mergeFunctions;
            for (iCollection = thisCollections.length - 1; iCollection > -1; iCollection--) {
                collection = thisCollections[iCollection];

                //Subscribe to the new collection.
                collection.compositeCollection = this;
                collection.objectPropertiesChanged.addEventListener(CompositeDynamicObjectCollection.prototype._onObjectPropertiesChanged, this);

                //Merge all of the existing objects.
                var objects = collection.getObjects();
                for ( var iObjects = objects.length - 1; iObjects > -1; iObjects--) {
                    var object = objects[iObjects];
                    var compositeObject = this._getOrCreateObject(object.id);
                    for ( var iMergeFuncs = thisMergeFunctions.length - 1; iMergeFuncs > -1; iMergeFuncs--) {
                        var mergeFunc = thisMergeFunctions[iMergeFuncs];
                        mergeFunc(compositeObject, object);
                    }
                }
            }
        }
    };

    /**
     * Gets an object with the specified id.
     * @memberof CompositeDynamicObjectCollection
     *
     * @param {Object} id The id of the object to retrieve.
     * @returns The DynamicObject with the provided id, or undefined if no such object exists.
     *
     * @exception {DeveloperError} id is required.
     */
    CompositeDynamicObjectCollection.prototype.getObject = function(id) {
        if (typeof id === 'undefined') {
            throw new DeveloperError('id is required.');
        }
        return this._hash[id];
    };

    /**
     * Gets the array of DynamicObject instances in this composite collection.
     * @memberof CompositeDynamicObjectCollection
     *
     * @returns {Array} the array of DynamicObject instances in this composite collection.
     */
    CompositeDynamicObjectCollection.prototype.getObjects = function() {
        return this._array;
    };

    /**
     * Clears all collections and DynamicObjects from this collection.
     * @memberof CompositeDynamicObjectCollection
     */
    CompositeDynamicObjectCollection.prototype.clear = function() {
        this.setCollections([]);
    };

    CompositeDynamicObjectCollection.prototype._getOrCreateObject = function(id) {
        var obj = this._hash[id];
        if (!obj) {
            obj = new DynamicObject(id);
            this._hash[id] = obj;
            this._array.push(obj);
        }
        return obj;
    };

    CompositeDynamicObjectCollection.prototype._clearObjects = function() {
        var removedObjects = this._array;
        this._hash = {};
        this._array = [];
        if (removedObjects.length > 0) {
            this.objectsRemoved.raiseEvent(this, removedObjects);
        }
    };

    CompositeDynamicObjectCollection.prototype._onObjectPropertiesChanged = function(dynamicObjectCollection, updatedObjects) {
        var thisMergeFunctions = this.mergeFunctions;
        var thisCleanFunctions = this.cleanFunctions;
        var thisCollections = this._collections;

        var updatedObject, compositeObject, compositeObjects = [];
        for ( var i = updatedObjects.length - 1; i > -1; i--) {
            updatedObject = updatedObjects[i];
            compositeObject = this.getObject(updatedObject.id);
            if (typeof compositeObject !== 'undefined') {
                for ( var iDeleteFuncs = thisCleanFunctions.length - 1; iDeleteFuncs > -1; iDeleteFuncs--) {
                    var deleteFunc = thisCleanFunctions[iDeleteFuncs];
                    deleteFunc(compositeObject);
                }
            } else {
                compositeObject = this._getOrCreateObject(updatedObject.id);
            }

            compositeObjects.push(compositeObject);
            for ( var iCollection = thisCollections.length - 1; iCollection > -1; iCollection--) {
                var currentCollection = thisCollections[iCollection];
                var objectToUpdate = currentCollection.getObject(updatedObject.id);
                if (typeof objectToUpdate !== 'undefined') {
                    for ( var iMergeFuncs = thisMergeFunctions.length - 1; iMergeFuncs > -1; iMergeFuncs--) {
                        var mergeFunc = thisMergeFunctions[iMergeFuncs];
                        mergeFunc(compositeObject, objectToUpdate);
                    }
                }
            }
        }
        if (compositeObjects.length > 0) {
            this.objectPropertiesChanged.raiseEvent(this, compositeObjects);
        }
    };

    return CompositeDynamicObjectCollection;
});
/*global define*/
define('DynamicScene/VisualizerCollection',[
        '../Core/DeveloperError',
        '../Core/destroyObject',
        './CzmlDefaults'
       ], function(
         DeveloperError,
         destroyObject,
         CzmlDefaults) {
    

    /**
     * A collection of visualizers which makes it easy to manage and
     * update them in unison.
     * @alias VisualizerCollection
     * @constructor
     *
     * @param {Object} The array of visualizers to use.
     * @param {DynamicObjectCollection} The objects to be visualized.
     *
     * @see CzmlDefaults#createVisualizers
     */
    var VisualizerCollection = function(visualizers, dynamicObjectCollection) {
        this._visualizers = visualizers || [];
        this._dynamicObjectCollection = undefined;
        this.setDynamicObjectCollection(dynamicObjectCollection);
    };

    /**
     * Creates a new VisualizerCollection which includes all standard visualizers.
     *
     * @memberof VisualizerCollection
     *
     * @param {Scene} The scene where visualization will take place.
     * @param {DynamicObjectCollection} The objects to be visualized.
     *
     * @exception {DeveloperError} scene is required.
     *
     * @see CzmlDefaults#createVisualizers
     */
    VisualizerCollection.createCzmlStandardCollection = function(scene, dynamicObjectCollection) {
        if (typeof scene === 'undefined') {
            throw new DeveloperError('scene is required.');
        }
        return new VisualizerCollection(CzmlDefaults.createVisualizers(scene), dynamicObjectCollection);
    };

    /**
     * Gets a copy of the array of visualizers in the collection.
     * @returns {Array} the array of visualizers in the collection.
     */
    VisualizerCollection.prototype.getVisualizers = function() {
        return this._visualizers.slice(0);
    };

    /**
     * Sets the array of visualizers in the collection.
     *
     * @param {Array} visualizers The new array of visualizers.  This array can partially overlap with visualizers currently in the collection.
     * @param {Boolean} destroyOldVisualizers If true, visualizers no longer in the collection will be destroyed.
     */
    VisualizerCollection.prototype.setVisualizers = function(visualizers, destroyOldVisualizers) {
        destroyOldVisualizers = (typeof destroyOldVisualizers !== 'undefined') ? destroyOldVisualizers : true;

        var i;
        var thisVisualizers = this._visualizers;
        if (destroyOldVisualizers) {
            for (i = thisVisualizers.length - 1; i > -1; i--) {
                var visualizer = thisVisualizers[i];
                if (visualizers.indexOf(visualizer) === -1) {
                    visualizer.destroy();
                }
            }
        }

        this._visualizers = visualizers || [];
        var dynamicObjectCollection = this._dynamicObjectCollection;
        for (i = visualizers.length - 1; i > -1; i--) {
            visualizers[i].setDynamicObjectCollection(dynamicObjectCollection);
        }
    };

    /**
     * Gets the DynamicObjectCollection being visualized.
     * @returns the DynamicObjectCollection being visualized
     */
    VisualizerCollection.prototype.getDynamicObjectCollection = function() {
        return this._dynamicObjectCollection;
    };

    /**
     * Sets the DynamicObjectCollection being visualized.
     * @param {DynamicObjectCollection} dynamicObjectCollection the DynamicObjectCollection being visualized.
     */
    VisualizerCollection.prototype.setDynamicObjectCollection = function(dynamicObjectCollection) {
        var oldCollection = this._dynamicObjectCollection;
        if (oldCollection !== dynamicObjectCollection) {
            this._dynamicObjectCollection = dynamicObjectCollection;
            var visualizers = this._visualizers;
            for ( var i = visualizers.length - 1; i > -1; i--) {
                visualizers[i].setDynamicObjectCollection(dynamicObjectCollection);
            }
        }
    };

    /**
     * Updates all visualizers to the provided time.
     * @param {JulianDate} time The time to updated to.
     */
    VisualizerCollection.prototype.update = function(time) {
        var visualizers = this._visualizers;
        for ( var i = visualizers.length - 1; i > -1; i--) {
            visualizers[i].update(time);
        }
    };

    /**
     * Removes all primitives from visualization.
     */
    VisualizerCollection.prototype.removeAllPrimitives = function() {
        var visualizers = this._visualizers;
        for ( var i = visualizers.length - 1; i > -1; i--) {
            visualizers[i].removeAllPrimitives();
        }
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @memberof VisualizerCollection
     *
     * @return {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see VisualizerCollection#destroy
     */
    VisualizerCollection.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @memberof VisualizerCollection
     *
     * @return {undefined}
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see VisualizerCollection#isDestroyed
     *
     * @example
     * visualizerCollection = visualizerCollection && visualizerCollection.destroy();
     */
    VisualizerCollection.prototype.destroy = function(destroyVisualizers) {
        destroyVisualizers = (typeof destroyVisualizers !== 'undefined') ? destroyVisualizers : true;
        this.removeAllPrimitives();
        if (destroyVisualizers) {
            var visualizers = this._visualizers;
            for ( var i = visualizers.length - 1; i > -1; i--) {
                visualizers[i].destroy();
            }
        }
        return destroyObject(this);
    };

    return VisualizerCollection;
});
/*global define*/
define('DynamicScene/processCzml',[
        '../Core/createGuid',
        '../Core/DeveloperError',
        './CzmlDefaults'
       ], function(
        createGuid,
        DeveloperError,
        CzmlDefaults) {
    

    function processCzmlPacket(packet, dynamicObjectCollection, updatedObjects, updatedObjectsHash, updaterFunctions, sourceUri) {
        var objectId = packet.id;
        if (typeof objectId === 'undefined') {
            objectId = createGuid();
        }

        var object = dynamicObjectCollection.getOrCreateObject(objectId);
        for ( var i = updaterFunctions.length - 1; i > -1; i--) {
            if (updaterFunctions[i](object, packet, dynamicObjectCollection, sourceUri) && typeof updatedObjectsHash[objectId] === 'undefined') {
                updatedObjectsHash[objectId] = true;
                updatedObjects.push(object);
            }
        }
    }

    /**
     * Processes the provided CZML, creating or updating DynamicObject instances for each
     * corresponding CZML identifier.
     * @exports processCzml
     *
     * @param {Object} czml The parsed CZML object to be processed.
     * @param {DynamicObjectCollection} dynamicObjectCollection The collection to create or updated objects within.
     * @param {String} [sourceUri] The uri of the file where the CZML originated from.  If provided, relative uri look-ups will use this as their base.
     * @param {Array} [updaterFunctions=CzmlDefaults.updaters] The array of updated functions to use for processing.  If left undefined, all standard CZML data is processed.
     *
     * @exception {DeveloperError} czml is required.
     * @exception {DeveloperError} dynamicObjectCollection is required.
     *
     * @returns An array containing all DynamicObject instances that were created or updated.
     *
     * @example
     * var url = 'http://someUrl.com/myCzmlFile.czml';
     * var dynamicObjectCollection = new DynamicObjectCollection();
     * getJson(url).then(function(czml) {
     *     processCzml(czml, dynamicObjectCollection, url);
     * });
     */
    var processCzml = function(czml, dynamicObjectCollection, sourceUri, updaterFunctions) {
        if (typeof czml === 'undefined') {
            throw new DeveloperError('czml is required.');
        }
        if (typeof dynamicObjectCollection === 'undefined') {
            throw new DeveloperError('dynamicObjectCollection is required.');
        }

        var updatedObjects = [];
        var updatedObjectsHash = {};
        updaterFunctions = typeof updaterFunctions !== 'undefined' ? updaterFunctions : CzmlDefaults.updaters;

        if (Array.isArray(czml)) {
            for ( var i = 0, len = czml.length; i < len; i++) {
                processCzmlPacket(czml[i], dynamicObjectCollection, updatedObjects, updatedObjectsHash, updaterFunctions, sourceUri);
            }
        } else {
            processCzmlPacket(czml, dynamicObjectCollection, updatedObjects, updatedObjectsHash, updaterFunctions, sourceUri);
        }

        if (updatedObjects.length > 0) {
            dynamicObjectCollection.objectPropertiesChanged.raiseEvent(dynamicObjectCollection, updatedObjects);
        }

        return updatedObjects;
    };

    return processCzml;
});
/*global define*/
define('Cesium',['Core/AnimationController', 'Core/AxisAlignedBoundingBox', 'Core/BoundingSphere', 'Core/BoxTessellator', 'Core/Cache', 'Core/CachePolicy', 'Core/Cartesian2', 'Core/Cartesian3', 'Core/Cartesian4', 'Core/Cartographic', 'Core/CatmullRomSpline', 'Core/Clock', 'Core/ClockRange', 'Core/ClockStep', 'Core/Color', 'Core/ComponentDatatype', 'Core/CubeMapEllipsoidTessellator', 'Core/DefaultProxy', 'Core/DeveloperError', 'Core/Ellipsoid', 'Core/EllipsoidTangentPlane', 'Core/Enumeration', 'Core/EquidistantCylindricalProjection', 'Core/Event', 'Core/EventHandler', 'Core/EventModifier', 'Core/Extent', 'Core/ExtentTessellator', 'Core/FAR', 'Core/FeatureDetection', 'Core/FullScreen', 'Core/HermitePolynomialApproximation', 'Core/HermiteSpline', 'Core/IndexDatatype', 'Core/Intersect', 'Core/IntersectionTests', 'Core/Iso8601', 'Core/JulianDate', 'Core/LagrangePolynomialApproximation', 'Core/LeapSecond', 'Core/LinearApproximation', 'Core/Math', 'Core/Matrix2', 'Core/Matrix3', 'Core/Matrix4', 'Core/MercatorProjection', 'Core/MeshFilters', 'Core/MouseEventType', 'Core/Occluder', 'Core/OrientationInterpolator', 'Core/PlaneTessellator', 'Core/PolygonPipeline', 'Core/PolylinePipeline', 'Core/PrimitiveType', 'Core/Quaternion', 'Core/Queue', 'Core/Ray', 'Core/Rectangle', 'Core/RuntimeError', 'Core/Shapes', 'Core/Spherical', 'Core/SunPosition', 'Core/TimeConstants', 'Core/TimeInterval', 'Core/TimeIntervalCollection', 'Core/TimeStandard', 'Core/Tipsify', 'Core/Transforms', 'Core/TridiagonalSystemSolver', 'Core/Visibility', 'Core/WindingOrder', 'Core/binarySearch', 'Core/clone', 'Core/combine', 'Core/createGuid', 'Core/defaultValue', 'Core/destroyObject', 'Core/isLeapYear', 'Core/jsonp', 'Core/loadImage', 'Core/pointInsideTriangle2D', 'Core/requestAnimationFrame', 'Core/shallowEquals', 'DynamicScene/CompositeDynamicObjectCollection', 'DynamicScene/CzmlBoolean', 'DynamicScene/CzmlCartesian2', 'DynamicScene/CzmlCartesian3', 'DynamicScene/CzmlCartographic', 'DynamicScene/CzmlColor', 'DynamicScene/CzmlDefaults', 'DynamicScene/CzmlHorizontalOrigin', 'DynamicScene/CzmlImage', 'DynamicScene/CzmlLabelStyle', 'DynamicScene/CzmlNumber', 'DynamicScene/CzmlString', 'DynamicScene/CzmlUnitCartesian3', 'DynamicScene/CzmlUnitQuaternion', 'DynamicScene/CzmlUnitSpherical', 'DynamicScene/CzmlVerticalOrigin', 'DynamicScene/DynamicBillboard', 'DynamicScene/DynamicBillboardVisualizer', 'DynamicScene/DynamicColorMaterial', 'DynamicScene/DynamicCone', 'DynamicScene/DynamicConeVisualizer', 'DynamicScene/DynamicConeVisualizerUsingCustomSensor', 'DynamicScene/DynamicDirectionsProperty', 'DynamicScene/DynamicImageMaterial', 'DynamicScene/DynamicLabel', 'DynamicScene/DynamicLabelVisualizer', 'DynamicScene/DynamicMaterialProperty', 'DynamicScene/DynamicObject', 'DynamicScene/DynamicObjectCollection', 'DynamicScene/DynamicPoint', 'DynamicScene/DynamicPointVisualizer', 'DynamicScene/DynamicPolygon', 'DynamicScene/DynamicPolygonVisualizer', 'DynamicScene/DynamicPolyline', 'DynamicScene/DynamicPolylineVisualizer', 'DynamicScene/DynamicPositionProperty', 'DynamicScene/DynamicProperty', 'DynamicScene/DynamicPyramid', 'DynamicScene/DynamicPyramidVisualizer', 'DynamicScene/DynamicVertexPositionsProperty', 'DynamicScene/ReferenceProperty', 'DynamicScene/VisualizerCollection', 'DynamicScene/processCzml', 'Renderer/BlendEquation', 'Renderer/BlendFunction', 'Renderer/BlendingState', 'Renderer/Buffer', 'Renderer/BufferUsage', 'Renderer/Context', 'Renderer/CubeMap', 'Renderer/CullFace', 'Renderer/DepthFunction', 'Renderer/Framebuffer', 'Renderer/MipmapHint', 'Renderer/PickFramebuffer', 'Renderer/PixelDatatype', 'Renderer/PixelFormat', 'Renderer/Renderbuffer', 'Renderer/RenderbufferFormat', 'Renderer/ShaderCache', 'Renderer/ShaderProgram', 'Renderer/StencilFunction', 'Renderer/StencilOperation', 'Renderer/Texture', 'Renderer/TextureAtlas', 'Renderer/TextureAtlasBuilder', 'Renderer/TextureMagnificationFilter', 'Renderer/TextureMinificationFilter', 'Renderer/TextureWrap', 'Renderer/UniformDatatype', 'Renderer/UniformState', 'Renderer/VertexArray', 'Renderer/VertexArrayFacade', 'Renderer/VertexLayout', 'Scene/AnimationCollection', 'Scene/ArcGISTileProvider', 'Scene/Billboard', 'Scene/BillboardCollection', 'Scene/BingMapsStyle', 'Scene/BingMapsTileProvider', 'Scene/BlobMaterial', 'Scene/Camera', 'Scene/Camera2DController', 'Scene/CameraCentralBodyController', 'Scene/CameraColumbusViewController', 'Scene/CameraControllerCollection', 'Scene/CameraEventHandler', 'Scene/CameraEventType', 'Scene/CameraFlightController', 'Scene/CameraFreeLookController', 'Scene/CameraHelpers', 'Scene/CameraSpindleController', 'Scene/CameraSpindleControllerMode', 'Scene/CentralBody', 'Scene/CheckerboardMaterial', 'Scene/ColorMaterial', 'Scene/ComplexConicSensorVolume', 'Scene/CompositePrimitive', 'Scene/CompositeTileProvider', 'Scene/CustomSensorVolume', 'Scene/DiffuseMapMaterial', 'Scene/DistanceIntervalMaterial', 'Scene/DotMaterial', 'Scene/EllipsoidPrimitive', 'Scene/FacetMaterial', 'Scene/HorizontalOrigin', 'Scene/HorizontalStripeMaterial', 'Scene/Label', 'Scene/LabelCollection', 'Scene/LabelStyle', 'Scene/OpenStreetMapTileProvider', 'Scene/OrthographicFrustum', 'Scene/PerformanceDisplay', 'Scene/PerspectiveFrustum', 'Scene/Polygon', 'Scene/Polyline', 'Scene/PolylineCollection', 'Scene/Projections', 'Scene/RectangularPyramidSensorVolume', 'Scene/Scene', 'Scene/SceneMode', 'Scene/SceneState', 'Scene/SceneTransitioner', 'Scene/SensorVolumeCollection', 'Scene/SingleTileProvider', 'Scene/SolidColorTileProvider', 'Scene/Texture2DPool', 'Scene/TieDyeMaterial', 'Scene/Tile', 'Scene/TileState', 'Scene/VerticalOrigin', 'Scene/VerticalStripeMaterial', 'Scene/ViewportQuad', 'Scene/combineMaterials', 'Shaders/BillboardCollectionFS', 'Shaders/BillboardCollectionVS', 'Shaders/BlobMaterial', 'Shaders/BuiltinFunctions', 'Shaders/CentralBodyFS', 'Shaders/CentralBodyFSCommon', 'Shaders/CentralBodyFSDepth', 'Shaders/CentralBodyFSFilter', 'Shaders/CentralBodyFSPole', 'Shaders/CentralBodyVS', 'Shaders/CentralBodyVSDepth', 'Shaders/CentralBodyVSFilter', 'Shaders/CentralBodyVSPole', 'Shaders/CheckerboardMaterial', 'Shaders/ColorMaterial', 'Shaders/ComplexConicSensorVolumeFS', 'Shaders/ComplexConicSensorVolumeVS', 'Shaders/ConstructiveSolidGeometry', 'Shaders/CustomSensorVolumeFS', 'Shaders/CustomSensorVolumeVS', 'Shaders/DiffuseMapMaterial', 'Shaders/DistanceIntervalMaterial', 'Shaders/DotMaterial', 'Shaders/FacetMaterial', 'Shaders/GroundAtmosphere', 'Shaders/HorizontalStripeMaterial', 'Shaders/Materials/AsphaltMaterial', 'Shaders/Materials/AsphaltMaterialComments', 'Shaders/Materials/BlobMaterial', 'Shaders/Materials/BlobMaterialComments', 'Shaders/Materials/BrickMaterial', 'Shaders/Materials/BrickMaterialComments', 'Shaders/Materials/BumpMapMaterial', 'Shaders/Materials/BumpMapMaterialComments', 'Shaders/Materials/CementMaterial', 'Shaders/Materials/CementMaterialComments', 'Shaders/Materials/CheckerboardMaterial', 'Shaders/Materials/CheckerboardMaterialComments', 'Shaders/Materials/DistanceIntervalMaterial', 'Shaders/Materials/DistanceIntervalMaterialComments', 'Shaders/Materials/DotMaterial', 'Shaders/Materials/DotMaterialComments', 'Shaders/Materials/FacetMaterial', 'Shaders/Materials/FacetMaterialComments', 'Shaders/Materials/FresnelMaterial', 'Shaders/Materials/FresnelMaterialComments', 'Shaders/Materials/GrassMaterial', 'Shaders/Materials/GrassMaterialComments', 'Shaders/Materials/NormalMapMaterial', 'Shaders/Materials/NormalMapMaterialComments', 'Shaders/Materials/ReflectionMaterial', 'Shaders/Materials/ReflectionMaterialComments', 'Shaders/Materials/RefractionMaterial', 'Shaders/Materials/RefractionMaterialComments', 'Shaders/Materials/StripeMaterial', 'Shaders/Materials/StripeMaterialComments', 'Shaders/Materials/TieDyeMaterial', 'Shaders/Materials/TieDyeMaterialComments', 'Shaders/Materials/WoodMaterial', 'Shaders/Materials/WoodMaterialComments', 'Shaders/Noise', 'Shaders/PolygonFS', 'Shaders/PolygonFSPick', 'Shaders/PolygonVS', 'Shaders/PolygonVSPick', 'Shaders/PolylineFS', 'Shaders/PolylineVS', 'Shaders/Ray', 'Shaders/SensorVolume', 'Shaders/SkyAtmosphereFS', 'Shaders/SkyAtmosphereVS', 'Shaders/TieDyeMaterial', 'Shaders/VerticalStripeMaterial', 'Shaders/ViewportQuadFS', 'Shaders/ViewportQuadVS', 'Shaders/glslComments', 'ThirdParty/Tween', 'ThirdParty/Uri', 'ThirdParty/measureText', 'ThirdParty/when'], function (Core_AnimationController, Core_AxisAlignedBoundingBox, Core_BoundingSphere, Core_BoxTessellator, Core_Cache, Core_CachePolicy, Core_Cartesian2, Core_Cartesian3, Core_Cartesian4, Core_Cartographic, Core_CatmullRomSpline, Core_Clock, Core_ClockRange, Core_ClockStep, Core_Color, Core_ComponentDatatype, Core_CubeMapEllipsoidTessellator, Core_DefaultProxy, Core_DeveloperError, Core_Ellipsoid, Core_EllipsoidTangentPlane, Core_Enumeration, Core_EquidistantCylindricalProjection, Core_Event, Core_EventHandler, Core_EventModifier, Core_Extent, Core_ExtentTessellator, Core_FAR, Core_FeatureDetection, Core_FullScreen, Core_HermitePolynomialApproximation, Core_HermiteSpline, Core_IndexDatatype, Core_Intersect, Core_IntersectionTests, Core_Iso8601, Core_JulianDate, Core_LagrangePolynomialApproximation, Core_LeapSecond, Core_LinearApproximation, Core_Math, Core_Matrix2, Core_Matrix3, Core_Matrix4, Core_MercatorProjection, Core_MeshFilters, Core_MouseEventType, Core_Occluder, Core_OrientationInterpolator, Core_PlaneTessellator, Core_PolygonPipeline, Core_PolylinePipeline, Core_PrimitiveType, Core_Quaternion, Core_Queue, Core_Ray, Core_Rectangle, Core_RuntimeError, Core_Shapes, Core_Spherical, Core_SunPosition, Core_TimeConstants, Core_TimeInterval, Core_TimeIntervalCollection, Core_TimeStandard, Core_Tipsify, Core_Transforms, Core_TridiagonalSystemSolver, Core_Visibility, Core_WindingOrder, Core_binarySearch, Core_clone, Core_combine, Core_createGuid, Core_defaultValue, Core_destroyObject, Core_isLeapYear, Core_jsonp, Core_loadImage, Core_pointInsideTriangle2D, Core_requestAnimationFrame, Core_shallowEquals, DynamicScene_CompositeDynamicObjectCollection, DynamicScene_CzmlBoolean, DynamicScene_CzmlCartesian2, DynamicScene_CzmlCartesian3, DynamicScene_CzmlCartographic, DynamicScene_CzmlColor, DynamicScene_CzmlDefaults, DynamicScene_CzmlHorizontalOrigin, DynamicScene_CzmlImage, DynamicScene_CzmlLabelStyle, DynamicScene_CzmlNumber, DynamicScene_CzmlString, DynamicScene_CzmlUnitCartesian3, DynamicScene_CzmlUnitQuaternion, DynamicScene_CzmlUnitSpherical, DynamicScene_CzmlVerticalOrigin, DynamicScene_DynamicBillboard, DynamicScene_DynamicBillboardVisualizer, DynamicScene_DynamicColorMaterial, DynamicScene_DynamicCone, DynamicScene_DynamicConeVisualizer, DynamicScene_DynamicConeVisualizerUsingCustomSensor, DynamicScene_DynamicDirectionsProperty, DynamicScene_DynamicImageMaterial, DynamicScene_DynamicLabel, DynamicScene_DynamicLabelVisualizer, DynamicScene_DynamicMaterialProperty, DynamicScene_DynamicObject, DynamicScene_DynamicObjectCollection, DynamicScene_DynamicPoint, DynamicScene_DynamicPointVisualizer, DynamicScene_DynamicPolygon, DynamicScene_DynamicPolygonVisualizer, DynamicScene_DynamicPolyline, DynamicScene_DynamicPolylineVisualizer, DynamicScene_DynamicPositionProperty, DynamicScene_DynamicProperty, DynamicScene_DynamicPyramid, DynamicScene_DynamicPyramidVisualizer, DynamicScene_DynamicVertexPositionsProperty, DynamicScene_ReferenceProperty, DynamicScene_VisualizerCollection, DynamicScene_processCzml, Renderer_BlendEquation, Renderer_BlendFunction, Renderer_BlendingState, Renderer_Buffer, Renderer_BufferUsage, Renderer_Context, Renderer_CubeMap, Renderer_CullFace, Renderer_DepthFunction, Renderer_Framebuffer, Renderer_MipmapHint, Renderer_PickFramebuffer, Renderer_PixelDatatype, Renderer_PixelFormat, Renderer_Renderbuffer, Renderer_RenderbufferFormat, Renderer_ShaderCache, Renderer_ShaderProgram, Renderer_StencilFunction, Renderer_StencilOperation, Renderer_Texture, Renderer_TextureAtlas, Renderer_TextureAtlasBuilder, Renderer_TextureMagnificationFilter, Renderer_TextureMinificationFilter, Renderer_TextureWrap, Renderer_UniformDatatype, Renderer_UniformState, Renderer_VertexArray, Renderer_VertexArrayFacade, Renderer_VertexLayout, Scene_AnimationCollection, Scene_ArcGISTileProvider, Scene_Billboard, Scene_BillboardCollection, Scene_BingMapsStyle, Scene_BingMapsTileProvider, Scene_BlobMaterial, Scene_Camera, Scene_Camera2DController, Scene_CameraCentralBodyController, Scene_CameraColumbusViewController, Scene_CameraControllerCollection, Scene_CameraEventHandler, Scene_CameraEventType, Scene_CameraFlightController, Scene_CameraFreeLookController, Scene_CameraHelpers, Scene_CameraSpindleController, Scene_CameraSpindleControllerMode, Scene_CentralBody, Scene_CheckerboardMaterial, Scene_ColorMaterial, Scene_ComplexConicSensorVolume, Scene_CompositePrimitive, Scene_CompositeTileProvider, Scene_CustomSensorVolume, Scene_DiffuseMapMaterial, Scene_DistanceIntervalMaterial, Scene_DotMaterial, Scene_EllipsoidPrimitive, Scene_FacetMaterial, Scene_HorizontalOrigin, Scene_HorizontalStripeMaterial, Scene_Label, Scene_LabelCollection, Scene_LabelStyle, Scene_OpenStreetMapTileProvider, Scene_OrthographicFrustum, Scene_PerformanceDisplay, Scene_PerspectiveFrustum, Scene_Polygon, Scene_Polyline, Scene_PolylineCollection, Scene_Projections, Scene_RectangularPyramidSensorVolume, Scene_Scene, Scene_SceneMode, Scene_SceneState, Scene_SceneTransitioner, Scene_SensorVolumeCollection, Scene_SingleTileProvider, Scene_SolidColorTileProvider, Scene_Texture2DPool, Scene_TieDyeMaterial, Scene_Tile, Scene_TileState, Scene_VerticalOrigin, Scene_VerticalStripeMaterial, Scene_ViewportQuad, Scene_combineMaterials, Shaders_BillboardCollectionFS, Shaders_BillboardCollectionVS, Shaders_BlobMaterial, Shaders_BuiltinFunctions, Shaders_CentralBodyFS, Shaders_CentralBodyFSCommon, Shaders_CentralBodyFSDepth, Shaders_CentralBodyFSFilter, Shaders_CentralBodyFSPole, Shaders_CentralBodyVS, Shaders_CentralBodyVSDepth, Shaders_CentralBodyVSFilter, Shaders_CentralBodyVSPole, Shaders_CheckerboardMaterial, Shaders_ColorMaterial, Shaders_ComplexConicSensorVolumeFS, Shaders_ComplexConicSensorVolumeVS, Shaders_ConstructiveSolidGeometry, Shaders_CustomSensorVolumeFS, Shaders_CustomSensorVolumeVS, Shaders_DiffuseMapMaterial, Shaders_DistanceIntervalMaterial, Shaders_DotMaterial, Shaders_FacetMaterial, Shaders_GroundAtmosphere, Shaders_HorizontalStripeMaterial, Shaders_Materials_AsphaltMaterial, Shaders_Materials_AsphaltMaterialComments, Shaders_Materials_BlobMaterial, Shaders_Materials_BlobMaterialComments, Shaders_Materials_BrickMaterial, Shaders_Materials_BrickMaterialComments, Shaders_Materials_BumpMapMaterial, Shaders_Materials_BumpMapMaterialComments, Shaders_Materials_CementMaterial, Shaders_Materials_CementMaterialComments, Shaders_Materials_CheckerboardMaterial, Shaders_Materials_CheckerboardMaterialComments, Shaders_Materials_DistanceIntervalMaterial, Shaders_Materials_DistanceIntervalMaterialComments, Shaders_Materials_DotMaterial, Shaders_Materials_DotMaterialComments, Shaders_Materials_FacetMaterial, Shaders_Materials_FacetMaterialComments, Shaders_Materials_FresnelMaterial, Shaders_Materials_FresnelMaterialComments, Shaders_Materials_GrassMaterial, Shaders_Materials_GrassMaterialComments, Shaders_Materials_NormalMapMaterial, Shaders_Materials_NormalMapMaterialComments, Shaders_Materials_ReflectionMaterial, Shaders_Materials_ReflectionMaterialComments, Shaders_Materials_RefractionMaterial, Shaders_Materials_RefractionMaterialComments, Shaders_Materials_StripeMaterial, Shaders_Materials_StripeMaterialComments, Shaders_Materials_TieDyeMaterial, Shaders_Materials_TieDyeMaterialComments, Shaders_Materials_WoodMaterial, Shaders_Materials_WoodMaterialComments, Shaders_Noise, Shaders_PolygonFS, Shaders_PolygonFSPick, Shaders_PolygonVS, Shaders_PolygonVSPick, Shaders_PolylineFS, Shaders_PolylineVS, Shaders_Ray, Shaders_SensorVolume, Shaders_SkyAtmosphereFS, Shaders_SkyAtmosphereVS, Shaders_TieDyeMaterial, Shaders_VerticalStripeMaterial, Shaders_ViewportQuadFS, Shaders_ViewportQuadVS, Shaders_glslComments, ThirdParty_Tween, ThirdParty_Uri, ThirdParty_measureText, ThirdParty_when) {
  
  var Cesium = { _shaders : {} };
  Cesium.AnimationController = Core_AnimationController;
  Cesium.AxisAlignedBoundingBox = Core_AxisAlignedBoundingBox;
  Cesium.BoundingSphere = Core_BoundingSphere;
  Cesium.BoxTessellator = Core_BoxTessellator;
  Cesium.Cache = Core_Cache;
  Cesium.CachePolicy = Core_CachePolicy;
  Cesium.Cartesian2 = Core_Cartesian2;
  Cesium.Cartesian3 = Core_Cartesian3;
  Cesium.Cartesian4 = Core_Cartesian4;
  Cesium.Cartographic = Core_Cartographic;
  Cesium.CatmullRomSpline = Core_CatmullRomSpline;
  Cesium.Clock = Core_Clock;
  Cesium.ClockRange = Core_ClockRange;
  Cesium.ClockStep = Core_ClockStep;
  Cesium.Color = Core_Color;
  Cesium.ComponentDatatype = Core_ComponentDatatype;
  Cesium.CubeMapEllipsoidTessellator = Core_CubeMapEllipsoidTessellator;
  Cesium.DefaultProxy = Core_DefaultProxy;
  Cesium.DeveloperError = Core_DeveloperError;
  Cesium.Ellipsoid = Core_Ellipsoid;
  Cesium.EllipsoidTangentPlane = Core_EllipsoidTangentPlane;
  Cesium.Enumeration = Core_Enumeration;
  Cesium.EquidistantCylindricalProjection = Core_EquidistantCylindricalProjection;
  Cesium.Event = Core_Event;
  Cesium.EventHandler = Core_EventHandler;
  Cesium.EventModifier = Core_EventModifier;
  Cesium.Extent = Core_Extent;
  Cesium.ExtentTessellator = Core_ExtentTessellator;
  Cesium.FAR = Core_FAR;
  Cesium.FeatureDetection = Core_FeatureDetection;
  Cesium.FullScreen = Core_FullScreen;
  Cesium.HermitePolynomialApproximation = Core_HermitePolynomialApproximation;
  Cesium.HermiteSpline = Core_HermiteSpline;
  Cesium.IndexDatatype = Core_IndexDatatype;
  Cesium.Intersect = Core_Intersect;
  Cesium.IntersectionTests = Core_IntersectionTests;
  Cesium.Iso8601 = Core_Iso8601;
  Cesium.JulianDate = Core_JulianDate;
  Cesium.LagrangePolynomialApproximation = Core_LagrangePolynomialApproximation;
  Cesium.LeapSecond = Core_LeapSecond;
  Cesium.LinearApproximation = Core_LinearApproximation;
  Cesium.Math = Core_Math;
  Cesium.Matrix2 = Core_Matrix2;
  Cesium.Matrix3 = Core_Matrix3;
  Cesium.Matrix4 = Core_Matrix4;
  Cesium.MercatorProjection = Core_MercatorProjection;
  Cesium.MeshFilters = Core_MeshFilters;
  Cesium.MouseEventType = Core_MouseEventType;
  Cesium.Occluder = Core_Occluder;
  Cesium.OrientationInterpolator = Core_OrientationInterpolator;
  Cesium.PlaneTessellator = Core_PlaneTessellator;
  Cesium.PolygonPipeline = Core_PolygonPipeline;
  Cesium.PolylinePipeline = Core_PolylinePipeline;
  Cesium.PrimitiveType = Core_PrimitiveType;
  Cesium.Quaternion = Core_Quaternion;
  Cesium.Queue = Core_Queue;
  Cesium.Ray = Core_Ray;
  Cesium.Rectangle = Core_Rectangle;
  Cesium.RuntimeError = Core_RuntimeError;
  Cesium.Shapes = Core_Shapes;
  Cesium.Spherical = Core_Spherical;
  Cesium.SunPosition = Core_SunPosition;
  Cesium.TimeConstants = Core_TimeConstants;
  Cesium.TimeInterval = Core_TimeInterval;
  Cesium.TimeIntervalCollection = Core_TimeIntervalCollection;
  Cesium.TimeStandard = Core_TimeStandard;
  Cesium.Tipsify = Core_Tipsify;
  Cesium.Transforms = Core_Transforms;
  Cesium.TridiagonalSystemSolver = Core_TridiagonalSystemSolver;
  Cesium.Visibility = Core_Visibility;
  Cesium.WindingOrder = Core_WindingOrder;
  Cesium.binarySearch = Core_binarySearch;
  Cesium.clone = Core_clone;
  Cesium.combine = Core_combine;
  Cesium.createGuid = Core_createGuid;
  Cesium.defaultValue = Core_defaultValue;
  Cesium.destroyObject = Core_destroyObject;
  Cesium.isLeapYear = Core_isLeapYear;
  Cesium.jsonp = Core_jsonp;
  Cesium.loadImage = Core_loadImage;
  Cesium.pointInsideTriangle2D = Core_pointInsideTriangle2D;
  Cesium.requestAnimationFrame = Core_requestAnimationFrame;
  Cesium.shallowEquals = Core_shallowEquals;
  Cesium.CompositeDynamicObjectCollection = DynamicScene_CompositeDynamicObjectCollection;
  Cesium.CzmlBoolean = DynamicScene_CzmlBoolean;
  Cesium.CzmlCartesian2 = DynamicScene_CzmlCartesian2;
  Cesium.CzmlCartesian3 = DynamicScene_CzmlCartesian3;
  Cesium.CzmlCartographic = DynamicScene_CzmlCartographic;
  Cesium.CzmlColor = DynamicScene_CzmlColor;
  Cesium.CzmlDefaults = DynamicScene_CzmlDefaults;
  Cesium.CzmlHorizontalOrigin = DynamicScene_CzmlHorizontalOrigin;
  Cesium.CzmlImage = DynamicScene_CzmlImage;
  Cesium.CzmlLabelStyle = DynamicScene_CzmlLabelStyle;
  Cesium.CzmlNumber = DynamicScene_CzmlNumber;
  Cesium.CzmlString = DynamicScene_CzmlString;
  Cesium.CzmlUnitCartesian3 = DynamicScene_CzmlUnitCartesian3;
  Cesium.CzmlUnitQuaternion = DynamicScene_CzmlUnitQuaternion;
  Cesium.CzmlUnitSpherical = DynamicScene_CzmlUnitSpherical;
  Cesium.CzmlVerticalOrigin = DynamicScene_CzmlVerticalOrigin;
  Cesium.DynamicBillboard = DynamicScene_DynamicBillboard;
  Cesium.DynamicBillboardVisualizer = DynamicScene_DynamicBillboardVisualizer;
  Cesium.DynamicColorMaterial = DynamicScene_DynamicColorMaterial;
  Cesium.DynamicCone = DynamicScene_DynamicCone;
  Cesium.DynamicConeVisualizer = DynamicScene_DynamicConeVisualizer;
  Cesium.DynamicConeVisualizerUsingCustomSensor = DynamicScene_DynamicConeVisualizerUsingCustomSensor;
  Cesium.DynamicDirectionsProperty = DynamicScene_DynamicDirectionsProperty;
  Cesium.DynamicImageMaterial = DynamicScene_DynamicImageMaterial;
  Cesium.DynamicLabel = DynamicScene_DynamicLabel;
  Cesium.DynamicLabelVisualizer = DynamicScene_DynamicLabelVisualizer;
  Cesium.DynamicMaterialProperty = DynamicScene_DynamicMaterialProperty;
  Cesium.DynamicObject = DynamicScene_DynamicObject;
  Cesium.DynamicObjectCollection = DynamicScene_DynamicObjectCollection;
  Cesium.DynamicPoint = DynamicScene_DynamicPoint;
  Cesium.DynamicPointVisualizer = DynamicScene_DynamicPointVisualizer;
  Cesium.DynamicPolygon = DynamicScene_DynamicPolygon;
  Cesium.DynamicPolygonVisualizer = DynamicScene_DynamicPolygonVisualizer;
  Cesium.DynamicPolyline = DynamicScene_DynamicPolyline;
  Cesium.DynamicPolylineVisualizer = DynamicScene_DynamicPolylineVisualizer;
  Cesium.DynamicPositionProperty = DynamicScene_DynamicPositionProperty;
  Cesium.DynamicProperty = DynamicScene_DynamicProperty;
  Cesium.DynamicPyramid = DynamicScene_DynamicPyramid;
  Cesium.DynamicPyramidVisualizer = DynamicScene_DynamicPyramidVisualizer;
  Cesium.DynamicVertexPositionsProperty = DynamicScene_DynamicVertexPositionsProperty;
  Cesium.ReferenceProperty = DynamicScene_ReferenceProperty;
  Cesium.VisualizerCollection = DynamicScene_VisualizerCollection;
  Cesium.processCzml = DynamicScene_processCzml;
  Cesium.BlendEquation = Renderer_BlendEquation;
  Cesium.BlendFunction = Renderer_BlendFunction;
  Cesium.BlendingState = Renderer_BlendingState;
  Cesium.Buffer = Renderer_Buffer;
  Cesium.BufferUsage = Renderer_BufferUsage;
  Cesium.Context = Renderer_Context;
  Cesium.CubeMap = Renderer_CubeMap;
  Cesium.CullFace = Renderer_CullFace;
  Cesium.DepthFunction = Renderer_DepthFunction;
  Cesium.Framebuffer = Renderer_Framebuffer;
  Cesium.MipmapHint = Renderer_MipmapHint;
  Cesium.PickFramebuffer = Renderer_PickFramebuffer;
  Cesium.PixelDatatype = Renderer_PixelDatatype;
  Cesium.PixelFormat = Renderer_PixelFormat;
  Cesium.Renderbuffer = Renderer_Renderbuffer;
  Cesium.RenderbufferFormat = Renderer_RenderbufferFormat;
  Cesium.ShaderCache = Renderer_ShaderCache;
  Cesium.ShaderProgram = Renderer_ShaderProgram;
  Cesium.StencilFunction = Renderer_StencilFunction;
  Cesium.StencilOperation = Renderer_StencilOperation;
  Cesium.Texture = Renderer_Texture;
  Cesium.TextureAtlas = Renderer_TextureAtlas;
  Cesium.TextureAtlasBuilder = Renderer_TextureAtlasBuilder;
  Cesium.TextureMagnificationFilter = Renderer_TextureMagnificationFilter;
  Cesium.TextureMinificationFilter = Renderer_TextureMinificationFilter;
  Cesium.TextureWrap = Renderer_TextureWrap;
  Cesium.UniformDatatype = Renderer_UniformDatatype;
  Cesium.UniformState = Renderer_UniformState;
  Cesium.VertexArray = Renderer_VertexArray;
  Cesium.VertexArrayFacade = Renderer_VertexArrayFacade;
  Cesium.VertexLayout = Renderer_VertexLayout;
  Cesium.AnimationCollection = Scene_AnimationCollection;
  Cesium.ArcGISTileProvider = Scene_ArcGISTileProvider;
  Cesium.Billboard = Scene_Billboard;
  Cesium.BillboardCollection = Scene_BillboardCollection;
  Cesium.BingMapsStyle = Scene_BingMapsStyle;
  Cesium.BingMapsTileProvider = Scene_BingMapsTileProvider;
  Cesium.BlobMaterial = Scene_BlobMaterial;
  Cesium.Camera = Scene_Camera;
  Cesium.Camera2DController = Scene_Camera2DController;
  Cesium.CameraCentralBodyController = Scene_CameraCentralBodyController;
  Cesium.CameraColumbusViewController = Scene_CameraColumbusViewController;
  Cesium.CameraControllerCollection = Scene_CameraControllerCollection;
  Cesium.CameraEventHandler = Scene_CameraEventHandler;
  Cesium.CameraEventType = Scene_CameraEventType;
  Cesium.CameraFlightController = Scene_CameraFlightController;
  Cesium.CameraFreeLookController = Scene_CameraFreeLookController;
  Cesium.CameraHelpers = Scene_CameraHelpers;
  Cesium.CameraSpindleController = Scene_CameraSpindleController;
  Cesium.CameraSpindleControllerMode = Scene_CameraSpindleControllerMode;
  Cesium.CentralBody = Scene_CentralBody;
  Cesium.CheckerboardMaterial = Scene_CheckerboardMaterial;
  Cesium.ColorMaterial = Scene_ColorMaterial;
  Cesium.ComplexConicSensorVolume = Scene_ComplexConicSensorVolume;
  Cesium.CompositePrimitive = Scene_CompositePrimitive;
  Cesium.CompositeTileProvider = Scene_CompositeTileProvider;
  Cesium.CustomSensorVolume = Scene_CustomSensorVolume;
  Cesium.DiffuseMapMaterial = Scene_DiffuseMapMaterial;
  Cesium.DistanceIntervalMaterial = Scene_DistanceIntervalMaterial;
  Cesium.DotMaterial = Scene_DotMaterial;
  Cesium.EllipsoidPrimitive = Scene_EllipsoidPrimitive;
  Cesium.FacetMaterial = Scene_FacetMaterial;
  Cesium.HorizontalOrigin = Scene_HorizontalOrigin;
  Cesium.HorizontalStripeMaterial = Scene_HorizontalStripeMaterial;
  Cesium.Label = Scene_Label;
  Cesium.LabelCollection = Scene_LabelCollection;
  Cesium.LabelStyle = Scene_LabelStyle;
  Cesium.OpenStreetMapTileProvider = Scene_OpenStreetMapTileProvider;
  Cesium.OrthographicFrustum = Scene_OrthographicFrustum;
  Cesium.PerformanceDisplay = Scene_PerformanceDisplay;
  Cesium.PerspectiveFrustum = Scene_PerspectiveFrustum;
  Cesium.Polygon = Scene_Polygon;
  Cesium.Polyline = Scene_Polyline;
  Cesium.PolylineCollection = Scene_PolylineCollection;
  Cesium.Projections = Scene_Projections;
  Cesium.RectangularPyramidSensorVolume = Scene_RectangularPyramidSensorVolume;
  Cesium.Scene = Scene_Scene;
  Cesium.SceneMode = Scene_SceneMode;
  Cesium.SceneState = Scene_SceneState;
  Cesium.SceneTransitioner = Scene_SceneTransitioner;
  Cesium.SensorVolumeCollection = Scene_SensorVolumeCollection;
  Cesium.SingleTileProvider = Scene_SingleTileProvider;
  Cesium.SolidColorTileProvider = Scene_SolidColorTileProvider;
  Cesium.Texture2DPool = Scene_Texture2DPool;
  Cesium.TieDyeMaterial = Scene_TieDyeMaterial;
  Cesium.Tile = Scene_Tile;
  Cesium.TileState = Scene_TileState;
  Cesium.VerticalOrigin = Scene_VerticalOrigin;
  Cesium.VerticalStripeMaterial = Scene_VerticalStripeMaterial;
  Cesium.ViewportQuad = Scene_ViewportQuad;
  Cesium.combineMaterials = Scene_combineMaterials;
  Cesium._shaders.BillboardCollectionFS = Shaders_BillboardCollectionFS;
  Cesium._shaders.BillboardCollectionVS = Shaders_BillboardCollectionVS;
  Cesium._shaders.BlobMaterial = Shaders_BlobMaterial;
  Cesium._shaders.BuiltinFunctions = Shaders_BuiltinFunctions;
  Cesium._shaders.CentralBodyFS = Shaders_CentralBodyFS;
  Cesium._shaders.CentralBodyFSCommon = Shaders_CentralBodyFSCommon;
  Cesium._shaders.CentralBodyFSDepth = Shaders_CentralBodyFSDepth;
  Cesium._shaders.CentralBodyFSFilter = Shaders_CentralBodyFSFilter;
  Cesium._shaders.CentralBodyFSPole = Shaders_CentralBodyFSPole;
  Cesium._shaders.CentralBodyVS = Shaders_CentralBodyVS;
  Cesium._shaders.CentralBodyVSDepth = Shaders_CentralBodyVSDepth;
  Cesium._shaders.CentralBodyVSFilter = Shaders_CentralBodyVSFilter;
  Cesium._shaders.CentralBodyVSPole = Shaders_CentralBodyVSPole;
  Cesium._shaders.CheckerboardMaterial = Shaders_CheckerboardMaterial;
  Cesium._shaders.ColorMaterial = Shaders_ColorMaterial;
  Cesium._shaders.ComplexConicSensorVolumeFS = Shaders_ComplexConicSensorVolumeFS;
  Cesium._shaders.ComplexConicSensorVolumeVS = Shaders_ComplexConicSensorVolumeVS;
  Cesium._shaders.ConstructiveSolidGeometry = Shaders_ConstructiveSolidGeometry;
  Cesium._shaders.CustomSensorVolumeFS = Shaders_CustomSensorVolumeFS;
  Cesium._shaders.CustomSensorVolumeVS = Shaders_CustomSensorVolumeVS;
  Cesium._shaders.DiffuseMapMaterial = Shaders_DiffuseMapMaterial;
  Cesium._shaders.DistanceIntervalMaterial = Shaders_DistanceIntervalMaterial;
  Cesium._shaders.DotMaterial = Shaders_DotMaterial;
  Cesium._shaders.FacetMaterial = Shaders_FacetMaterial;
  Cesium._shaders.GroundAtmosphere = Shaders_GroundAtmosphere;
  Cesium._shaders.HorizontalStripeMaterial = Shaders_HorizontalStripeMaterial;
  Cesium._shaders.AsphaltMaterial = Shaders_Materials_AsphaltMaterial;
  Cesium._shaders.AsphaltMaterialComments = Shaders_Materials_AsphaltMaterialComments;
  Cesium._shaders.BlobMaterial = Shaders_Materials_BlobMaterial;
  Cesium._shaders.BlobMaterialComments = Shaders_Materials_BlobMaterialComments;
  Cesium._shaders.BrickMaterial = Shaders_Materials_BrickMaterial;
  Cesium._shaders.BrickMaterialComments = Shaders_Materials_BrickMaterialComments;
  Cesium._shaders.BumpMapMaterial = Shaders_Materials_BumpMapMaterial;
  Cesium._shaders.BumpMapMaterialComments = Shaders_Materials_BumpMapMaterialComments;
  Cesium._shaders.CementMaterial = Shaders_Materials_CementMaterial;
  Cesium._shaders.CementMaterialComments = Shaders_Materials_CementMaterialComments;
  Cesium._shaders.CheckerboardMaterial = Shaders_Materials_CheckerboardMaterial;
  Cesium._shaders.CheckerboardMaterialComments = Shaders_Materials_CheckerboardMaterialComments;
  Cesium._shaders.DistanceIntervalMaterial = Shaders_Materials_DistanceIntervalMaterial;
  Cesium._shaders.DistanceIntervalMaterialComments = Shaders_Materials_DistanceIntervalMaterialComments;
  Cesium._shaders.DotMaterial = Shaders_Materials_DotMaterial;
  Cesium._shaders.DotMaterialComments = Shaders_Materials_DotMaterialComments;
  Cesium._shaders.FacetMaterial = Shaders_Materials_FacetMaterial;
  Cesium._shaders.FacetMaterialComments = Shaders_Materials_FacetMaterialComments;
  Cesium._shaders.FresnelMaterial = Shaders_Materials_FresnelMaterial;
  Cesium._shaders.FresnelMaterialComments = Shaders_Materials_FresnelMaterialComments;
  Cesium._shaders.GrassMaterial = Shaders_Materials_GrassMaterial;
  Cesium._shaders.GrassMaterialComments = Shaders_Materials_GrassMaterialComments;
  Cesium._shaders.NormalMapMaterial = Shaders_Materials_NormalMapMaterial;
  Cesium._shaders.NormalMapMaterialComments = Shaders_Materials_NormalMapMaterialComments;
  Cesium._shaders.ReflectionMaterial = Shaders_Materials_ReflectionMaterial;
  Cesium._shaders.ReflectionMaterialComments = Shaders_Materials_ReflectionMaterialComments;
  Cesium._shaders.RefractionMaterial = Shaders_Materials_RefractionMaterial;
  Cesium._shaders.RefractionMaterialComments = Shaders_Materials_RefractionMaterialComments;
  Cesium._shaders.StripeMaterial = Shaders_Materials_StripeMaterial;
  Cesium._shaders.StripeMaterialComments = Shaders_Materials_StripeMaterialComments;
  Cesium._shaders.TieDyeMaterial = Shaders_Materials_TieDyeMaterial;
  Cesium._shaders.TieDyeMaterialComments = Shaders_Materials_TieDyeMaterialComments;
  Cesium._shaders.WoodMaterial = Shaders_Materials_WoodMaterial;
  Cesium._shaders.WoodMaterialComments = Shaders_Materials_WoodMaterialComments;
  Cesium._shaders.Noise = Shaders_Noise;
  Cesium._shaders.PolygonFS = Shaders_PolygonFS;
  Cesium._shaders.PolygonFSPick = Shaders_PolygonFSPick;
  Cesium._shaders.PolygonVS = Shaders_PolygonVS;
  Cesium._shaders.PolygonVSPick = Shaders_PolygonVSPick;
  Cesium._shaders.PolylineFS = Shaders_PolylineFS;
  Cesium._shaders.PolylineVS = Shaders_PolylineVS;
  Cesium._shaders.Ray = Shaders_Ray;
  Cesium._shaders.SensorVolume = Shaders_SensorVolume;
  Cesium._shaders.SkyAtmosphereFS = Shaders_SkyAtmosphereFS;
  Cesium._shaders.SkyAtmosphereVS = Shaders_SkyAtmosphereVS;
  Cesium._shaders.TieDyeMaterial = Shaders_TieDyeMaterial;
  Cesium._shaders.VerticalStripeMaterial = Shaders_VerticalStripeMaterial;
  Cesium._shaders.ViewportQuadFS = Shaders_ViewportQuadFS;
  Cesium._shaders.ViewportQuadVS = Shaders_ViewportQuadVS;
  Cesium._shaders.glslComments = Shaders_glslComments;
  Cesium.Tween = ThirdParty_Tween;
  Cesium.Uri = ThirdParty_Uri;
  Cesium.measureText = ThirdParty_measureText;
  Cesium.when = ThirdParty_when;
  return Cesium;
});
/*global require*/
// require in the complete Cesium object and reassign it globally.
// This is meant for use with the Almond loader.
require(['Cesium'], function(Cesium) {
    
    window.Cesium = Cesium;
}, undefined, true);
define("main", function(){});
}());